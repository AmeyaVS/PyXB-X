# PyWXSB bindings for <not provided>
# Generated 2009-06-25 05:37:29.290547 by PyWXSB version UNSPECIFIED
import pyxb.binding
import pyxb.exceptions_
import pyxb.utils.domutils
import sys

# Import bindings for namespaces imported into schema


# Make sure there's a registered Namespace instance, and that it knows
# about this module.
Namespace = pyxb.namespace.NamespaceForURI(u'http://www.opengis.net/gml', create_if_missing=True)
Namespace._setModule(sys.modules[__name__])
Namespace.configureCategories(['typeBinding', 'elementBinding'])

def CreateFromDocument (xml_text):
    """Parse the given XML and use the document element to create a Python instance."""
    dom = pyxb.utils.domutils.StringToDOM(xml_text)
    return CreateFromDOM(dom.documentElement)

def CreateFromDOM (node):
    """Create a Python instance from the given DOM node.
    The node tag must correspond to an element declaration in this module."""
    return pyxb.binding.basis.element.AnyCreateFromDOM(node, Namespace)

# Atomic SimpleTypeDefinition
class _STD_ANON_1 (pyxb.binding.datatypes.string):
    """No information"""

    _ExpandedName = None
_STD_ANON_1._CF_pattern = pyxb.binding.facets.CF_pattern()
_STD_ANON_1._CF_pattern.addPattern(pattern=u'other:\\w{2,}')
_STD_ANON_1._InitializeFacetMap(_STD_ANON_1._CF_pattern)

# Atomic SimpleTypeDefinition
class _STD_ANON_2 (pyxb.binding.datatypes.string, pyxb.binding.basis.enumeration_mixin):
    """No information"""

    _ExpandedName = None
_STD_ANON_2._CF_enumeration = pyxb.binding.facets.CF_enumeration(value_datatype=_STD_ANON_2, enum_prefix=None)
_STD_ANON_2.sphere = _STD_ANON_2._CF_enumeration.addEnumeration(unicode_value=u'sphere')
_STD_ANON_2._InitializeFacetMap(_STD_ANON_2._CF_enumeration)

# Atomic SimpleTypeDefinition
class _STD_ANON_3 (pyxb.binding.datatypes.string, pyxb.binding.basis.enumeration_mixin):
    """No information"""

    _ExpandedName = None
_STD_ANON_3._CF_enumeration = pyxb.binding.facets.CF_enumeration(value_datatype=_STD_ANON_3, enum_prefix=None)
_STD_ANON_3.year = _STD_ANON_3._CF_enumeration.addEnumeration(unicode_value=u'year')
_STD_ANON_3.month = _STD_ANON_3._CF_enumeration.addEnumeration(unicode_value=u'month')
_STD_ANON_3.day = _STD_ANON_3._CF_enumeration.addEnumeration(unicode_value=u'day')
_STD_ANON_3.hour = _STD_ANON_3._CF_enumeration.addEnumeration(unicode_value=u'hour')
_STD_ANON_3.minute = _STD_ANON_3._CF_enumeration.addEnumeration(unicode_value=u'minute')
_STD_ANON_3.second = _STD_ANON_3._CF_enumeration.addEnumeration(unicode_value=u'second')
_STD_ANON_3._InitializeFacetMap(_STD_ANON_3._CF_enumeration)

# Atomic SimpleTypeDefinition
class _STD_ANON_4 (pyxb.binding.datatypes.string, pyxb.binding.basis.enumeration_mixin):
    """No information"""

    _ExpandedName = None
_STD_ANON_4._CF_enumeration = pyxb.binding.facets.CF_enumeration(value_datatype=_STD_ANON_4, enum_prefix=None)
_STD_ANON_4.N = _STD_ANON_4._CF_enumeration.addEnumeration(unicode_value=u'N')
_STD_ANON_4.E = _STD_ANON_4._CF_enumeration.addEnumeration(unicode_value=u'E')
_STD_ANON_4.S = _STD_ANON_4._CF_enumeration.addEnumeration(unicode_value=u'S')
_STD_ANON_4.W = _STD_ANON_4._CF_enumeration.addEnumeration(unicode_value=u'W')
_STD_ANON_4.emptyString = _STD_ANON_4._CF_enumeration.addEnumeration(unicode_value=u'+')
_STD_ANON_4.emptyString_ = _STD_ANON_4._CF_enumeration.addEnumeration(unicode_value=u'-')
_STD_ANON_4._InitializeFacetMap(_STD_ANON_4._CF_enumeration)

# Atomic SimpleTypeDefinition
class _STD_ANON_5 (pyxb.binding.datatypes.string, pyxb.binding.basis.enumeration_mixin):
    """No information"""

    _ExpandedName = None
_STD_ANON_5._CF_enumeration = pyxb.binding.facets.CF_enumeration(value_datatype=_STD_ANON_5, enum_prefix=None)
_STD_ANON_5.inapplicable = _STD_ANON_5._CF_enumeration.addEnumeration(unicode_value=u'inapplicable')
_STD_ANON_5.missing = _STD_ANON_5._CF_enumeration.addEnumeration(unicode_value=u'missing')
_STD_ANON_5.template = _STD_ANON_5._CF_enumeration.addEnumeration(unicode_value=u'template')
_STD_ANON_5.unknown = _STD_ANON_5._CF_enumeration.addEnumeration(unicode_value=u'unknown')
_STD_ANON_5.withheld = _STD_ANON_5._CF_enumeration.addEnumeration(unicode_value=u'withheld')
_STD_ANON_5._InitializeFacetMap(_STD_ANON_5._CF_enumeration)

# Atomic SimpleTypeDefinition
class _STD_ANON_6 (pyxb.binding.datatypes.string):
    """No information"""

    _ExpandedName = None
_STD_ANON_6._InitializeFacetMap()

# Atomic SimpleTypeDefinition
class _STD_ANON_7 (pyxb.binding.datatypes.string):
    """No information"""

    _ExpandedName = None
_STD_ANON_7._CF_pattern = pyxb.binding.facets.CF_pattern()
_STD_ANON_7._CF_pattern.addPattern(pattern=u'other:\\w{2,}')
_STD_ANON_7._InitializeFacetMap(_STD_ANON_7._CF_pattern)

# Atomic SimpleTypeDefinition
class _STD_ANON_8 (pyxb.binding.datatypes.string, pyxb.binding.basis.enumeration_mixin):
    """No information"""

    _ExpandedName = None
_STD_ANON_8._CF_enumeration = pyxb.binding.facets.CF_enumeration(value_datatype=_STD_ANON_8, enum_prefix=None)
_STD_ANON_8.inapplicable = _STD_ANON_8._CF_enumeration.addEnumeration(unicode_value=u'inapplicable')
_STD_ANON_8.missing = _STD_ANON_8._CF_enumeration.addEnumeration(unicode_value=u'missing')
_STD_ANON_8.template = _STD_ANON_8._CF_enumeration.addEnumeration(unicode_value=u'template')
_STD_ANON_8.unknown = _STD_ANON_8._CF_enumeration.addEnumeration(unicode_value=u'unknown')
_STD_ANON_8.withheld = _STD_ANON_8._CF_enumeration.addEnumeration(unicode_value=u'withheld')
_STD_ANON_8._InitializeFacetMap(_STD_ANON_8._CF_enumeration)

# Atomic SimpleTypeDefinition
class _STD_ANON_9 (pyxb.binding.datatypes.string):
    """No information"""

    _ExpandedName = None
_STD_ANON_9._CF_pattern = pyxb.binding.facets.CF_pattern()
_STD_ANON_9._CF_pattern.addPattern(pattern=u'other:\\w{2,}')
_STD_ANON_9._InitializeFacetMap(_STD_ANON_9._CF_pattern)

# Atomic SimpleTypeDefinition
class _STD_ANON_10 (pyxb.binding.datatypes.string):
    """No information"""

    _ExpandedName = None
_STD_ANON_10._CF_pattern = pyxb.binding.facets.CF_pattern()
_STD_ANON_10._CF_pattern.addPattern(pattern=u'other:\\w{2,}')
_STD_ANON_10._InitializeFacetMap(_STD_ANON_10._CF_pattern)

# Atomic SimpleTypeDefinition
class _STD_ANON_11 (pyxb.binding.datatypes.string, pyxb.binding.basis.enumeration_mixin):
    """No information"""

    _ExpandedName = None
_STD_ANON_11._CF_enumeration = pyxb.binding.facets.CF_enumeration(value_datatype=_STD_ANON_11, enum_prefix=None)
_STD_ANON_11.Before = _STD_ANON_11._CF_enumeration.addEnumeration(unicode_value=u'Before')
_STD_ANON_11.After = _STD_ANON_11._CF_enumeration.addEnumeration(unicode_value=u'After')
_STD_ANON_11.Begins = _STD_ANON_11._CF_enumeration.addEnumeration(unicode_value=u'Begins')
_STD_ANON_11.Ends = _STD_ANON_11._CF_enumeration.addEnumeration(unicode_value=u'Ends')
_STD_ANON_11.During = _STD_ANON_11._CF_enumeration.addEnumeration(unicode_value=u'During')
_STD_ANON_11.Equals = _STD_ANON_11._CF_enumeration.addEnumeration(unicode_value=u'Equals')
_STD_ANON_11.Contains = _STD_ANON_11._CF_enumeration.addEnumeration(unicode_value=u'Contains')
_STD_ANON_11.Overlaps = _STD_ANON_11._CF_enumeration.addEnumeration(unicode_value=u'Overlaps')
_STD_ANON_11.Meets = _STD_ANON_11._CF_enumeration.addEnumeration(unicode_value=u'Meets')
_STD_ANON_11.OverlappedBy = _STD_ANON_11._CF_enumeration.addEnumeration(unicode_value=u'OverlappedBy')
_STD_ANON_11.MetBy = _STD_ANON_11._CF_enumeration.addEnumeration(unicode_value=u'MetBy')
_STD_ANON_11.BegunBy = _STD_ANON_11._CF_enumeration.addEnumeration(unicode_value=u'BegunBy')
_STD_ANON_11.EndedBy = _STD_ANON_11._CF_enumeration.addEnumeration(unicode_value=u'EndedBy')
_STD_ANON_11._InitializeFacetMap(_STD_ANON_11._CF_enumeration)

# Atomic SimpleTypeDefinition
class _STD_ANON_12 (pyxb.binding.datatypes.string, pyxb.binding.basis.enumeration_mixin):
    """No information"""

    _ExpandedName = None
_STD_ANON_12._CF_enumeration = pyxb.binding.facets.CF_enumeration(value_datatype=_STD_ANON_12, enum_prefix=None)
_STD_ANON_12.year = _STD_ANON_12._CF_enumeration.addEnumeration(unicode_value=u'year')
_STD_ANON_12.month = _STD_ANON_12._CF_enumeration.addEnumeration(unicode_value=u'month')
_STD_ANON_12.day = _STD_ANON_12._CF_enumeration.addEnumeration(unicode_value=u'day')
_STD_ANON_12.hour = _STD_ANON_12._CF_enumeration.addEnumeration(unicode_value=u'hour')
_STD_ANON_12.minute = _STD_ANON_12._CF_enumeration.addEnumeration(unicode_value=u'minute')
_STD_ANON_12.second = _STD_ANON_12._CF_enumeration.addEnumeration(unicode_value=u'second')
_STD_ANON_12._InitializeFacetMap(_STD_ANON_12._CF_enumeration)

# Atomic SimpleTypeDefinition
class AggregationType (pyxb.binding.datatypes.string, pyxb.binding.basis.enumeration_mixin):
    """No information"""

    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'AggregationType')
AggregationType._CF_enumeration = pyxb.binding.facets.CF_enumeration(value_datatype=AggregationType, enum_prefix=None)
AggregationType.set = AggregationType._CF_enumeration.addEnumeration(unicode_value=u'set')
AggregationType.bag = AggregationType._CF_enumeration.addEnumeration(unicode_value=u'bag')
AggregationType.sequence = AggregationType._CF_enumeration.addEnumeration(unicode_value=u'sequence')
AggregationType.array = AggregationType._CF_enumeration.addEnumeration(unicode_value=u'array')
AggregationType.record = AggregationType._CF_enumeration.addEnumeration(unicode_value=u'record')
AggregationType.table = AggregationType._CF_enumeration.addEnumeration(unicode_value=u'table')
AggregationType._InitializeFacetMap(AggregationType._CF_enumeration)
Namespace.addCategoryObject('typeBinding', u'AggregationType', AggregationType)

# Atomic SimpleTypeDefinition
class ArcMinutesType (pyxb.binding.datatypes.nonNegativeInteger):
    """No information"""

    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'ArcMinutesType')
ArcMinutesType._CF_maxInclusive = pyxb.binding.facets.CF_maxInclusive(value_datatype=ArcMinutesType, value=pyxb.binding.datatypes.nonNegativeInteger(59L))
ArcMinutesType._InitializeFacetMap(ArcMinutesType._CF_maxInclusive)
Namespace.addCategoryObject('typeBinding', u'ArcMinutesType', ArcMinutesType)

# Atomic SimpleTypeDefinition
class ArcSecondsType (pyxb.binding.datatypes.decimal):
    """No information"""

    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'ArcSecondsType')
ArcSecondsType._CF_minInclusive = pyxb.binding.facets.CF_minInclusive(value_datatype=ArcSecondsType, value=pyxb.binding.datatypes.decimal(0.0))
ArcSecondsType._CF_maxExclusive = pyxb.binding.facets.CF_maxExclusive(value_datatype=pyxb.binding.datatypes.decimal, value=pyxb.binding.datatypes.anySimpleType(u'60.00'))
ArcSecondsType._InitializeFacetMap(ArcSecondsType._CF_minInclusive,
   ArcSecondsType._CF_maxExclusive)
Namespace.addCategoryObject('typeBinding', u'ArcSecondsType', ArcSecondsType)

# Atomic SimpleTypeDefinition
class AxisDirection (pyxb.binding.datatypes.string):
    """No information"""

    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'AxisDirection')
AxisDirection._CF_pattern = pyxb.binding.facets.CF_pattern()
AxisDirection._CF_pattern.addPattern(pattern=u'[\\+\\-][1-9][0-9]*')
AxisDirection._InitializeFacetMap(AxisDirection._CF_pattern)
Namespace.addCategoryObject('typeBinding', u'AxisDirection', AxisDirection)

# Union SimpleTypeDefinition
# superclasses pyxb.binding.datatypes.anySimpleType
class CalDate (pyxb.binding.basis.STD_union):
    """Simple type that is a union of pyxb.binding.datatypes.date, pyxb.binding.datatypes.gYearMonth, pyxb.binding.datatypes.gYear"""

    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'CalDate')
    _MemberTypes = ( pyxb.binding.datatypes.date, pyxb.binding.datatypes.gYearMonth, pyxb.binding.datatypes.gYear, )
CalDate._CF_pattern = pyxb.binding.facets.CF_pattern()
CalDate._CF_enumeration = pyxb.binding.facets.CF_enumeration(value_datatype=CalDate)
CalDate._InitializeFacetMap(CalDate._CF_pattern,
   CalDate._CF_enumeration)
Namespace.addCategoryObject('typeBinding', u'CalDate', CalDate)

# Atomic SimpleTypeDefinition
class CompassPointEnumeration (pyxb.binding.datatypes.string, pyxb.binding.basis.enumeration_mixin):
    """No information"""

    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'CompassPointEnumeration')
CompassPointEnumeration._CF_enumeration = pyxb.binding.facets.CF_enumeration(value_datatype=CompassPointEnumeration, enum_prefix=None)
CompassPointEnumeration.N = CompassPointEnumeration._CF_enumeration.addEnumeration(unicode_value=u'N')
CompassPointEnumeration.NNE = CompassPointEnumeration._CF_enumeration.addEnumeration(unicode_value=u'NNE')
CompassPointEnumeration.NE = CompassPointEnumeration._CF_enumeration.addEnumeration(unicode_value=u'NE')
CompassPointEnumeration.ENE = CompassPointEnumeration._CF_enumeration.addEnumeration(unicode_value=u'ENE')
CompassPointEnumeration.E = CompassPointEnumeration._CF_enumeration.addEnumeration(unicode_value=u'E')
CompassPointEnumeration.ESE = CompassPointEnumeration._CF_enumeration.addEnumeration(unicode_value=u'ESE')
CompassPointEnumeration.SE = CompassPointEnumeration._CF_enumeration.addEnumeration(unicode_value=u'SE')
CompassPointEnumeration.SSE = CompassPointEnumeration._CF_enumeration.addEnumeration(unicode_value=u'SSE')
CompassPointEnumeration.S = CompassPointEnumeration._CF_enumeration.addEnumeration(unicode_value=u'S')
CompassPointEnumeration.SSW = CompassPointEnumeration._CF_enumeration.addEnumeration(unicode_value=u'SSW')
CompassPointEnumeration.SW = CompassPointEnumeration._CF_enumeration.addEnumeration(unicode_value=u'SW')
CompassPointEnumeration.WSW = CompassPointEnumeration._CF_enumeration.addEnumeration(unicode_value=u'WSW')
CompassPointEnumeration.W = CompassPointEnumeration._CF_enumeration.addEnumeration(unicode_value=u'W')
CompassPointEnumeration.WNW = CompassPointEnumeration._CF_enumeration.addEnumeration(unicode_value=u'WNW')
CompassPointEnumeration.NW = CompassPointEnumeration._CF_enumeration.addEnumeration(unicode_value=u'NW')
CompassPointEnumeration.NNW = CompassPointEnumeration._CF_enumeration.addEnumeration(unicode_value=u'NNW')
CompassPointEnumeration._InitializeFacetMap(CompassPointEnumeration._CF_enumeration)
Namespace.addCategoryObject('typeBinding', u'CompassPointEnumeration', CompassPointEnumeration)

# Atomic SimpleTypeDefinition
class CurveInterpolationType (pyxb.binding.datatypes.string, pyxb.binding.basis.enumeration_mixin):
    """No information"""

    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'CurveInterpolationType')
CurveInterpolationType._CF_enumeration = pyxb.binding.facets.CF_enumeration(value_datatype=CurveInterpolationType, enum_prefix=None)
CurveInterpolationType.linear = CurveInterpolationType._CF_enumeration.addEnumeration(unicode_value=u'linear')
CurveInterpolationType.geodesic = CurveInterpolationType._CF_enumeration.addEnumeration(unicode_value=u'geodesic')
CurveInterpolationType.circularArc3Points = CurveInterpolationType._CF_enumeration.addEnumeration(unicode_value=u'circularArc3Points')
CurveInterpolationType.circularArc2PointWithBulge = CurveInterpolationType._CF_enumeration.addEnumeration(unicode_value=u'circularArc2PointWithBulge')
CurveInterpolationType.circularArcCenterPointWithRadius = CurveInterpolationType._CF_enumeration.addEnumeration(unicode_value=u'circularArcCenterPointWithRadius')
CurveInterpolationType.elliptical = CurveInterpolationType._CF_enumeration.addEnumeration(unicode_value=u'elliptical')
CurveInterpolationType.clothoid = CurveInterpolationType._CF_enumeration.addEnumeration(unicode_value=u'clothoid')
CurveInterpolationType.conic = CurveInterpolationType._CF_enumeration.addEnumeration(unicode_value=u'conic')
CurveInterpolationType.polynomialSpline = CurveInterpolationType._CF_enumeration.addEnumeration(unicode_value=u'polynomialSpline')
CurveInterpolationType.cubicSpline = CurveInterpolationType._CF_enumeration.addEnumeration(unicode_value=u'cubicSpline')
CurveInterpolationType.rationalSpline = CurveInterpolationType._CF_enumeration.addEnumeration(unicode_value=u'rationalSpline')
CurveInterpolationType._InitializeFacetMap(CurveInterpolationType._CF_enumeration)
Namespace.addCategoryObject('typeBinding', u'CurveInterpolationType', CurveInterpolationType)

# Atomic SimpleTypeDefinition
class DecimalMinutesType (pyxb.binding.datatypes.decimal):
    """No information"""

    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'DecimalMinutesType')
DecimalMinutesType._CF_minInclusive = pyxb.binding.facets.CF_minInclusive(value_datatype=DecimalMinutesType, value=pyxb.binding.datatypes.decimal(0.0))
DecimalMinutesType._CF_maxExclusive = pyxb.binding.facets.CF_maxExclusive(value_datatype=pyxb.binding.datatypes.decimal, value=pyxb.binding.datatypes.anySimpleType(u'60.00'))
DecimalMinutesType._InitializeFacetMap(DecimalMinutesType._CF_minInclusive,
   DecimalMinutesType._CF_maxExclusive)
Namespace.addCategoryObject('typeBinding', u'DecimalMinutesType', DecimalMinutesType)

# Atomic SimpleTypeDefinition
class DegreeValueType (pyxb.binding.datatypes.nonNegativeInteger):
    """No information"""

    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'DegreeValueType')
DegreeValueType._CF_maxInclusive = pyxb.binding.facets.CF_maxInclusive(value_datatype=DegreeValueType, value=pyxb.binding.datatypes.nonNegativeInteger(359L))
DegreeValueType._InitializeFacetMap(DegreeValueType._CF_maxInclusive)
Namespace.addCategoryObject('typeBinding', u'DegreeValueType', DegreeValueType)

# Atomic SimpleTypeDefinition
class FileValueModelType (pyxb.binding.datatypes.string, pyxb.binding.basis.enumeration_mixin):
    """No information"""

    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'FileValueModelType')
FileValueModelType._CF_enumeration = pyxb.binding.facets.CF_enumeration(value_datatype=FileValueModelType, enum_prefix=None)
FileValueModelType.Record_Interleaved = FileValueModelType._CF_enumeration.addEnumeration(unicode_value=u'Record Interleaved')
FileValueModelType._InitializeFacetMap(FileValueModelType._CF_enumeration)
Namespace.addCategoryObject('typeBinding', u'FileValueModelType', FileValueModelType)

# Atomic SimpleTypeDefinition
class IncrementOrder (pyxb.binding.datatypes.string, pyxb.binding.basis.enumeration_mixin):
    """No information"""

    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'IncrementOrder')
IncrementOrder._CF_enumeration = pyxb.binding.facets.CF_enumeration(value_datatype=IncrementOrder, enum_prefix=None)
IncrementOrder.xy = IncrementOrder._CF_enumeration.addEnumeration(unicode_value=u'+x+y')
IncrementOrder.yx = IncrementOrder._CF_enumeration.addEnumeration(unicode_value=u'+y+x')
IncrementOrder.x_y = IncrementOrder._CF_enumeration.addEnumeration(unicode_value=u'+x-y')
IncrementOrder.x_y_ = IncrementOrder._CF_enumeration.addEnumeration(unicode_value=u'-x-y')
IncrementOrder._InitializeFacetMap(IncrementOrder._CF_enumeration)
Namespace.addCategoryObject('typeBinding', u'IncrementOrder', IncrementOrder)

# Atomic SimpleTypeDefinition
class KnotTypesType (pyxb.binding.datatypes.string, pyxb.binding.basis.enumeration_mixin):
    """No information"""

    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'KnotTypesType')
KnotTypesType._CF_enumeration = pyxb.binding.facets.CF_enumeration(value_datatype=KnotTypesType, enum_prefix=None)
KnotTypesType.uniform = KnotTypesType._CF_enumeration.addEnumeration(unicode_value=u'uniform')
KnotTypesType.quasiUniform = KnotTypesType._CF_enumeration.addEnumeration(unicode_value=u'quasiUniform')
KnotTypesType.piecewiseBezier = KnotTypesType._CF_enumeration.addEnumeration(unicode_value=u'piecewiseBezier')
KnotTypesType._InitializeFacetMap(KnotTypesType._CF_enumeration)
Namespace.addCategoryObject('typeBinding', u'KnotTypesType', KnotTypesType)

# List SimpleTypeDefinition
# superclasses pyxb.binding.datatypes.anySimpleType
class NCNameList (pyxb.binding.basis.STD_list):
    """Simple type that is a list of pyxb.binding.datatypes.NCName"""

    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'NCNameList')
    _ItemType = pyxb.binding.datatypes.NCName
NCNameList._InitializeFacetMap()
Namespace.addCategoryObject('typeBinding', u'NCNameList', NCNameList)

# List SimpleTypeDefinition
# superclasses pyxb.binding.datatypes.anySimpleType
class NameList (pyxb.binding.basis.STD_list):
    """Simple type that is a list of pyxb.binding.datatypes.Name"""

    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'NameList')
    _ItemType = pyxb.binding.datatypes.Name
NameList._InitializeFacetMap()
Namespace.addCategoryObject('typeBinding', u'NameList', NameList)

# List SimpleTypeDefinition
# superclasses pyxb.binding.datatypes.anySimpleType
class QNameList (pyxb.binding.basis.STD_list):
    """Simple type that is a list of pyxb.binding.datatypes.QName"""

    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'QNameList')
    _ItemType = pyxb.binding.datatypes.QName
QNameList._InitializeFacetMap()
Namespace.addCategoryObject('typeBinding', u'QNameList', QNameList)

# Atomic SimpleTypeDefinition
class SequenceRuleEnumeration (pyxb.binding.datatypes.string, pyxb.binding.basis.enumeration_mixin):
    """No information"""

    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'SequenceRuleEnumeration')
SequenceRuleEnumeration._CF_enumeration = pyxb.binding.facets.CF_enumeration(value_datatype=SequenceRuleEnumeration, enum_prefix=None)
SequenceRuleEnumeration.Linear = SequenceRuleEnumeration._CF_enumeration.addEnumeration(unicode_value=u'Linear')
SequenceRuleEnumeration.Boustrophedonic = SequenceRuleEnumeration._CF_enumeration.addEnumeration(unicode_value=u'Boustrophedonic')
SequenceRuleEnumeration.Cantor_diagonal = SequenceRuleEnumeration._CF_enumeration.addEnumeration(unicode_value=u'Cantor-diagonal')
SequenceRuleEnumeration.Spiral = SequenceRuleEnumeration._CF_enumeration.addEnumeration(unicode_value=u'Spiral')
SequenceRuleEnumeration.Morton = SequenceRuleEnumeration._CF_enumeration.addEnumeration(unicode_value=u'Morton')
SequenceRuleEnumeration.Hilbert = SequenceRuleEnumeration._CF_enumeration.addEnumeration(unicode_value=u'Hilbert')
SequenceRuleEnumeration._InitializeFacetMap(SequenceRuleEnumeration._CF_enumeration)
Namespace.addCategoryObject('typeBinding', u'SequenceRuleEnumeration', SequenceRuleEnumeration)

# Atomic SimpleTypeDefinition
class SignType (pyxb.binding.datatypes.string, pyxb.binding.basis.enumeration_mixin):
    """No information"""

    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'SignType')
SignType._CF_enumeration = pyxb.binding.facets.CF_enumeration(value_datatype=SignType, enum_prefix=None)
SignType.emptyString = SignType._CF_enumeration.addEnumeration(unicode_value=u'-')
SignType.emptyString_ = SignType._CF_enumeration.addEnumeration(unicode_value=u'+')
SignType._InitializeFacetMap(SignType._CF_enumeration)
Namespace.addCategoryObject('typeBinding', u'SignType', SignType)

# Atomic SimpleTypeDefinition
class SuccessionType (pyxb.binding.datatypes.string, pyxb.binding.basis.enumeration_mixin):
    """No information"""

    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'SuccessionType')
SuccessionType._CF_enumeration = pyxb.binding.facets.CF_enumeration(value_datatype=SuccessionType, enum_prefix=None)
SuccessionType.substitution = SuccessionType._CF_enumeration.addEnumeration(unicode_value=u'substitution')
SuccessionType.division = SuccessionType._CF_enumeration.addEnumeration(unicode_value=u'division')
SuccessionType.fusion = SuccessionType._CF_enumeration.addEnumeration(unicode_value=u'fusion')
SuccessionType.initiation = SuccessionType._CF_enumeration.addEnumeration(unicode_value=u'initiation')
SuccessionType._InitializeFacetMap(SuccessionType._CF_enumeration)
Namespace.addCategoryObject('typeBinding', u'SuccessionType', SuccessionType)

# Atomic SimpleTypeDefinition
class SurfaceInterpolationType (pyxb.binding.datatypes.string, pyxb.binding.basis.enumeration_mixin):
    """No information"""

    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'SurfaceInterpolationType')
SurfaceInterpolationType._CF_enumeration = pyxb.binding.facets.CF_enumeration(value_datatype=SurfaceInterpolationType, enum_prefix=None)
SurfaceInterpolationType.none = SurfaceInterpolationType._CF_enumeration.addEnumeration(unicode_value=u'none')
SurfaceInterpolationType.planar = SurfaceInterpolationType._CF_enumeration.addEnumeration(unicode_value=u'planar')
SurfaceInterpolationType.spherical = SurfaceInterpolationType._CF_enumeration.addEnumeration(unicode_value=u'spherical')
SurfaceInterpolationType.elliptical = SurfaceInterpolationType._CF_enumeration.addEnumeration(unicode_value=u'elliptical')
SurfaceInterpolationType.conic = SurfaceInterpolationType._CF_enumeration.addEnumeration(unicode_value=u'conic')
SurfaceInterpolationType.tin = SurfaceInterpolationType._CF_enumeration.addEnumeration(unicode_value=u'tin')
SurfaceInterpolationType.parametricCurve = SurfaceInterpolationType._CF_enumeration.addEnumeration(unicode_value=u'parametricCurve')
SurfaceInterpolationType.polynomialSpline = SurfaceInterpolationType._CF_enumeration.addEnumeration(unicode_value=u'polynomialSpline')
SurfaceInterpolationType.rationalSpline = SurfaceInterpolationType._CF_enumeration.addEnumeration(unicode_value=u'rationalSpline')
SurfaceInterpolationType.triangulatedSpline = SurfaceInterpolationType._CF_enumeration.addEnumeration(unicode_value=u'triangulatedSpline')
SurfaceInterpolationType._InitializeFacetMap(SurfaceInterpolationType._CF_enumeration)
Namespace.addCategoryObject('typeBinding', u'SurfaceInterpolationType', SurfaceInterpolationType)

# Atomic SimpleTypeDefinition
class TimeIndeterminateValueType (pyxb.binding.datatypes.string, pyxb.binding.basis.enumeration_mixin):
    """No information"""

    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'TimeIndeterminateValueType')
TimeIndeterminateValueType._CF_enumeration = pyxb.binding.facets.CF_enumeration(value_datatype=TimeIndeterminateValueType, enum_prefix=None)
TimeIndeterminateValueType.after = TimeIndeterminateValueType._CF_enumeration.addEnumeration(unicode_value=u'after')
TimeIndeterminateValueType.before = TimeIndeterminateValueType._CF_enumeration.addEnumeration(unicode_value=u'before')
TimeIndeterminateValueType.now = TimeIndeterminateValueType._CF_enumeration.addEnumeration(unicode_value=u'now')
TimeIndeterminateValueType.unknown = TimeIndeterminateValueType._CF_enumeration.addEnumeration(unicode_value=u'unknown')
TimeIndeterminateValueType._InitializeFacetMap(TimeIndeterminateValueType._CF_enumeration)
Namespace.addCategoryObject('typeBinding', u'TimeIndeterminateValueType', TimeIndeterminateValueType)

# Union SimpleTypeDefinition
# superclasses pyxb.binding.datatypes.anySimpleType
class TimePositionUnion (pyxb.binding.basis.STD_union):
    """Simple type that is a union of pyxb.binding.datatypes.date, pyxb.binding.datatypes.gYearMonth, pyxb.binding.datatypes.gYear, pyxb.binding.datatypes.time, pyxb.binding.datatypes.dateTime, pyxb.binding.datatypes.anyURI, pyxb.binding.datatypes.decimal"""

    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'TimePositionUnion')
    _MemberTypes = ( pyxb.binding.datatypes.date, pyxb.binding.datatypes.gYearMonth, pyxb.binding.datatypes.gYear, pyxb.binding.datatypes.time, pyxb.binding.datatypes.dateTime, pyxb.binding.datatypes.anyURI, pyxb.binding.datatypes.decimal, )
TimePositionUnion._CF_pattern = pyxb.binding.facets.CF_pattern()
TimePositionUnion._CF_enumeration = pyxb.binding.facets.CF_enumeration(value_datatype=TimePositionUnion)
TimePositionUnion._InitializeFacetMap(TimePositionUnion._CF_pattern,
   TimePositionUnion._CF_enumeration)
Namespace.addCategoryObject('typeBinding', u'TimePositionUnion', TimePositionUnion)

# Atomic SimpleTypeDefinition
class UomSymbol (pyxb.binding.datatypes.string):
    """No information"""

    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'UomSymbol')
UomSymbol._CF_pattern = pyxb.binding.facets.CF_pattern()
UomSymbol._CF_pattern.addPattern(pattern=u'[^: \\n\\r\\t]+')
UomSymbol._InitializeFacetMap(UomSymbol._CF_pattern)
Namespace.addCategoryObject('typeBinding', u'UomSymbol', UomSymbol)

# Atomic SimpleTypeDefinition
class UomURI (pyxb.binding.datatypes.anyURI):
    """No information"""

    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'UomURI')
UomURI._CF_pattern = pyxb.binding.facets.CF_pattern()
UomURI._CF_pattern.addPattern(pattern=u'([a-zA-Z][a-zA-Z0-9\\-\\+\\.]*:|\\.\\./|\\./|#).*')
UomURI._InitializeFacetMap(UomURI._CF_pattern)
Namespace.addCategoryObject('typeBinding', u'UomURI', UomURI)

# List SimpleTypeDefinition
# superclasses pyxb.binding.datatypes.anySimpleType
class booleanList (pyxb.binding.basis.STD_list):
    """Simple type that is a list of pyxb.binding.datatypes.boolean"""

    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'booleanList')
    _ItemType = pyxb.binding.datatypes.boolean
booleanList._InitializeFacetMap()
Namespace.addCategoryObject('typeBinding', u'booleanList', booleanList)

# List SimpleTypeDefinition
# superclasses pyxb.binding.datatypes.anySimpleType
class doubleList (pyxb.binding.basis.STD_list):
    """Simple type that is a list of pyxb.binding.datatypes.double"""

    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'doubleList')
    _ItemType = pyxb.binding.datatypes.double
doubleList._InitializeFacetMap()
Namespace.addCategoryObject('typeBinding', u'doubleList', doubleList)

# List SimpleTypeDefinition
# superclasses pyxb.binding.datatypes.anySimpleType
class integerList (pyxb.binding.basis.STD_list):
    """Simple type that is a list of pyxb.binding.datatypes.integer"""

    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'integerList')
    _ItemType = pyxb.binding.datatypes.integer
integerList._InitializeFacetMap()
Namespace.addCategoryObject('typeBinding', u'integerList', integerList)

# List SimpleTypeDefinition
# superclasses doubleList
class _STD_ANON_13 (pyxb.binding.basis.STD_list):
    """Simple type that is a list of pyxb.binding.datatypes.double"""

    _ExpandedName = None
    _ItemType = pyxb.binding.datatypes.double
_STD_ANON_13._InitializeFacetMap()

# List SimpleTypeDefinition
# superclasses pyxb.binding.datatypes.anySimpleType
class AxisDirectionList (pyxb.binding.basis.STD_list):
    """Simple type that is a list of AxisDirection"""

    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'AxisDirectionList')
    _ItemType = AxisDirection
AxisDirectionList._InitializeFacetMap()
Namespace.addCategoryObject('typeBinding', u'AxisDirectionList', AxisDirectionList)

# Union SimpleTypeDefinition
# superclasses pyxb.binding.datatypes.anySimpleType
class NameOrNilReason (pyxb.binding.basis.STD_union):
    """Simple type that is a union of _STD_ANON_8, _STD_ANON_1, pyxb.binding.datatypes.Name, pyxb.binding.datatypes.anyURI"""

    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'NameOrNilReason')
    _MemberTypes = ( _STD_ANON_8, _STD_ANON_1, pyxb.binding.datatypes.Name, pyxb.binding.datatypes.anyURI, )
NameOrNilReason._CF_pattern = pyxb.binding.facets.CF_pattern()
NameOrNilReason._CF_enumeration = pyxb.binding.facets.CF_enumeration(value_datatype=NameOrNilReason)
NameOrNilReason._InitializeFacetMap(NameOrNilReason._CF_pattern,
   NameOrNilReason._CF_enumeration)
Namespace.addCategoryObject('typeBinding', u'NameOrNilReason', NameOrNilReason)

# Union SimpleTypeDefinition
# superclasses pyxb.binding.datatypes.anySimpleType
class NilReasonEnumeration (pyxb.binding.basis.STD_union):
    """Simple type that is a union of _STD_ANON_8, _STD_ANON_1"""

    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'NilReasonEnumeration')
    _MemberTypes = ( _STD_ANON_8, _STD_ANON_1, )
NilReasonEnumeration._CF_pattern = pyxb.binding.facets.CF_pattern()
NilReasonEnumeration._CF_enumeration = pyxb.binding.facets.CF_enumeration(value_datatype=NilReasonEnumeration)
NilReasonEnumeration._InitializeFacetMap(NilReasonEnumeration._CF_pattern,
   NilReasonEnumeration._CF_enumeration)
Namespace.addCategoryObject('typeBinding', u'NilReasonEnumeration', NilReasonEnumeration)

# Union SimpleTypeDefinition
# superclasses pyxb.binding.datatypes.anySimpleType
class NilReasonType (pyxb.binding.basis.STD_union):
    """Simple type that is a union of _STD_ANON_8, _STD_ANON_1, pyxb.binding.datatypes.anyURI"""

    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'NilReasonType')
    _MemberTypes = ( _STD_ANON_8, _STD_ANON_1, pyxb.binding.datatypes.anyURI, )
NilReasonType._CF_pattern = pyxb.binding.facets.CF_pattern()
NilReasonType._CF_enumeration = pyxb.binding.facets.CF_enumeration(value_datatype=NilReasonType)
NilReasonType._InitializeFacetMap(NilReasonType._CF_pattern,
   NilReasonType._CF_enumeration)
Namespace.addCategoryObject('typeBinding', u'NilReasonType', NilReasonType)

# Union SimpleTypeDefinition
# superclasses pyxb.binding.datatypes.anySimpleType
class TimeUnitType (pyxb.binding.basis.STD_union):
    """Simple type that is a union of _STD_ANON_3, _STD_ANON_7"""

    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'TimeUnitType')
    _MemberTypes = ( _STD_ANON_3, _STD_ANON_7, )
TimeUnitType._CF_pattern = pyxb.binding.facets.CF_pattern()
TimeUnitType._CF_enumeration = pyxb.binding.facets.CF_enumeration(value_datatype=TimeUnitType)
TimeUnitType._InitializeFacetMap(TimeUnitType._CF_pattern,
   TimeUnitType._CF_enumeration)
Namespace.addCategoryObject('typeBinding', u'TimeUnitType', TimeUnitType)

# Union SimpleTypeDefinition
# superclasses pyxb.binding.datatypes.anySimpleType
class UomIdentifier (pyxb.binding.basis.STD_union):
    """Simple type that is a union of UomSymbol, UomURI"""

    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'UomIdentifier')
    _MemberTypes = ( UomSymbol, UomURI, )
UomIdentifier._CF_pattern = pyxb.binding.facets.CF_pattern()
UomIdentifier._CF_enumeration = pyxb.binding.facets.CF_enumeration(value_datatype=UomIdentifier)
UomIdentifier._InitializeFacetMap(UomIdentifier._CF_pattern,
   UomIdentifier._CF_enumeration)
Namespace.addCategoryObject('typeBinding', u'UomIdentifier', UomIdentifier)

# Union SimpleTypeDefinition
# superclasses pyxb.binding.datatypes.anySimpleType
class booleanOrNilReason (pyxb.binding.basis.STD_union):
    """Simple type that is a union of _STD_ANON_8, _STD_ANON_1, pyxb.binding.datatypes.boolean, pyxb.binding.datatypes.anyURI"""

    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'booleanOrNilReason')
    _MemberTypes = ( _STD_ANON_8, _STD_ANON_1, pyxb.binding.datatypes.boolean, pyxb.binding.datatypes.anyURI, )
booleanOrNilReason._CF_pattern = pyxb.binding.facets.CF_pattern()
booleanOrNilReason._CF_enumeration = pyxb.binding.facets.CF_enumeration(value_datatype=booleanOrNilReason)
booleanOrNilReason._InitializeFacetMap(booleanOrNilReason._CF_pattern,
   booleanOrNilReason._CF_enumeration)
Namespace.addCategoryObject('typeBinding', u'booleanOrNilReason', booleanOrNilReason)

# Union SimpleTypeDefinition
# superclasses pyxb.binding.datatypes.anySimpleType
class doubleOrNilReason (pyxb.binding.basis.STD_union):
    """Simple type that is a union of _STD_ANON_8, _STD_ANON_1, pyxb.binding.datatypes.double, pyxb.binding.datatypes.anyURI"""

    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'doubleOrNilReason')
    _MemberTypes = ( _STD_ANON_8, _STD_ANON_1, pyxb.binding.datatypes.double, pyxb.binding.datatypes.anyURI, )
doubleOrNilReason._CF_pattern = pyxb.binding.facets.CF_pattern()
doubleOrNilReason._CF_enumeration = pyxb.binding.facets.CF_enumeration(value_datatype=doubleOrNilReason)
doubleOrNilReason._InitializeFacetMap(doubleOrNilReason._CF_pattern,
   doubleOrNilReason._CF_enumeration)
Namespace.addCategoryObject('typeBinding', u'doubleOrNilReason', doubleOrNilReason)

# Union SimpleTypeDefinition
# superclasses pyxb.binding.datatypes.anySimpleType
class integerOrNilReason (pyxb.binding.basis.STD_union):
    """Simple type that is a union of _STD_ANON_8, _STD_ANON_1, pyxb.binding.datatypes.integer, pyxb.binding.datatypes.anyURI"""

    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'integerOrNilReason')
    _MemberTypes = ( _STD_ANON_8, _STD_ANON_1, pyxb.binding.datatypes.integer, pyxb.binding.datatypes.anyURI, )
integerOrNilReason._CF_pattern = pyxb.binding.facets.CF_pattern()
integerOrNilReason._CF_enumeration = pyxb.binding.facets.CF_enumeration(value_datatype=integerOrNilReason)
integerOrNilReason._InitializeFacetMap(integerOrNilReason._CF_pattern,
   integerOrNilReason._CF_enumeration)
Namespace.addCategoryObject('typeBinding', u'integerOrNilReason', integerOrNilReason)

# Union SimpleTypeDefinition
# superclasses pyxb.binding.datatypes.anySimpleType
class stringOrNilReason (pyxb.binding.basis.STD_union):
    """Simple type that is a union of _STD_ANON_8, _STD_ANON_1, pyxb.binding.datatypes.string, pyxb.binding.datatypes.anyURI"""

    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'stringOrNilReason')
    _MemberTypes = ( _STD_ANON_8, _STD_ANON_1, pyxb.binding.datatypes.string, pyxb.binding.datatypes.anyURI, )
stringOrNilReason._CF_pattern = pyxb.binding.facets.CF_pattern()
stringOrNilReason._CF_enumeration = pyxb.binding.facets.CF_enumeration(value_datatype=stringOrNilReason)
stringOrNilReason._InitializeFacetMap(stringOrNilReason._CF_pattern,
   stringOrNilReason._CF_enumeration)
Namespace.addCategoryObject('typeBinding', u'stringOrNilReason', stringOrNilReason)

# List SimpleTypeDefinition
# superclasses pyxb.binding.datatypes.anySimpleType
class NameOrNilReasonList (pyxb.binding.basis.STD_list):
    """Simple type that is a list of NameOrNilReason"""

    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'NameOrNilReasonList')
    _ItemType = NameOrNilReason
NameOrNilReasonList._InitializeFacetMap()
Namespace.addCategoryObject('typeBinding', u'NameOrNilReasonList', NameOrNilReasonList)

# List SimpleTypeDefinition
# superclasses pyxb.binding.datatypes.anySimpleType
class booleanOrNilReasonList (pyxb.binding.basis.STD_list):
    """Simple type that is a list of booleanOrNilReason"""

    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'booleanOrNilReasonList')
    _ItemType = booleanOrNilReason
booleanOrNilReasonList._InitializeFacetMap()
Namespace.addCategoryObject('typeBinding', u'booleanOrNilReasonList', booleanOrNilReasonList)

# List SimpleTypeDefinition
# superclasses pyxb.binding.datatypes.anySimpleType
class doubleOrNilReasonList (pyxb.binding.basis.STD_list):
    """Simple type that is a list of doubleOrNilReason"""

    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'doubleOrNilReasonList')
    _ItemType = doubleOrNilReason
doubleOrNilReasonList._InitializeFacetMap()
Namespace.addCategoryObject('typeBinding', u'doubleOrNilReasonList', doubleOrNilReasonList)

# List SimpleTypeDefinition
# superclasses pyxb.binding.datatypes.anySimpleType
class integerOrNilReasonList (pyxb.binding.basis.STD_list):
    """Simple type that is a list of integerOrNilReason"""

    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'integerOrNilReasonList')
    _ItemType = integerOrNilReason
integerOrNilReasonList._InitializeFacetMap()
Namespace.addCategoryObject('typeBinding', u'integerOrNilReasonList', integerOrNilReasonList)

# List SimpleTypeDefinition
# superclasses NameOrNilReasonList
class _STD_ANON_14 (pyxb.binding.basis.STD_list):
    """Simple type that is a list of NameOrNilReason"""

    _ExpandedName = None
    _ItemType = NameOrNilReason
_STD_ANON_14._CF_length = pyxb.binding.facets.CF_length(value=pyxb.binding.datatypes.nonNegativeInteger(2L))
_STD_ANON_14._InitializeFacetMap(_STD_ANON_14._CF_length)

# List SimpleTypeDefinition
# superclasses doubleOrNilReasonList
class _STD_ANON_15 (pyxb.binding.basis.STD_list):
    """Simple type that is a list of doubleOrNilReason"""

    _ExpandedName = None
    _ItemType = doubleOrNilReason
_STD_ANON_15._CF_length = pyxb.binding.facets.CF_length(value=pyxb.binding.datatypes.nonNegativeInteger(2L))
_STD_ANON_15._InitializeFacetMap(_STD_ANON_15._CF_length)

# List SimpleTypeDefinition
# superclasses integerOrNilReasonList
class CountExtentType (pyxb.binding.basis.STD_list):
    """Simple type that is a list of integerOrNilReason"""

    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'CountExtentType')
    _ItemType = integerOrNilReason
CountExtentType._CF_length = pyxb.binding.facets.CF_length(value=pyxb.binding.datatypes.nonNegativeInteger(2L))
CountExtentType._InitializeFacetMap(CountExtentType._CF_length)
Namespace.addCategoryObject('typeBinding', u'CountExtentType', CountExtentType)

# Complex type _CTD_ANON_16 with content type ELEMENT_ONLY
class _CTD_ANON_16 (pyxb.binding.basis.complexTypeDefinition):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.opengis.net/gml}inverseFlattening uses Python identifier inverseFlattening
    __inverseFlattening = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'inverseFlattening'), 'inverseFlattening', '__CTD_ANON_16_httpwww_opengis_netgmlinverseFlattening', False)
    def inverseFlattening (self):
        """Get the value of the {http://www.opengis.net/gml}inverseFlattening element."""
        return self.__inverseFlattening.value(self)
    def setInverseFlattening (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}inverseFlattening element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__inverseFlattening.set(self, new_value)
    
    # Element {http://www.opengis.net/gml}semiMinorAxis uses Python identifier semiMinorAxis
    __semiMinorAxis = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'semiMinorAxis'), 'semiMinorAxis', '__CTD_ANON_16_httpwww_opengis_netgmlsemiMinorAxis', False)
    def semiMinorAxis (self):
        """Get the value of the {http://www.opengis.net/gml}semiMinorAxis element."""
        return self.__semiMinorAxis.value(self)
    def setSemiMinorAxis (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}semiMinorAxis element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__semiMinorAxis.set(self, new_value)
    
    # Element {http://www.opengis.net/gml}isSphere uses Python identifier isSphere
    __isSphere = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'isSphere'), 'isSphere', '__CTD_ANON_16_httpwww_opengis_netgmlisSphere', False)
    def isSphere (self):
        """Get the value of the {http://www.opengis.net/gml}isSphere element."""
        return self.__isSphere.value(self)
    def setIsSphere (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}isSphere element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__isSphere.set(self, new_value)

    _ElementMap = {
        __inverseFlattening.name() : __inverseFlattening,
        __semiMinorAxis.name() : __semiMinorAxis,
        __isSphere.name() : __isSphere
    }
    _AttributeMap = {
        
    }



# Complex type _CTD_ANON_17 with content type ELEMENT_ONLY
class _CTD_ANON_17 (pyxb.binding.basis.complexTypeDefinition):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.opengis.net/gml}Row uses Python identifier Row
    __Row = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'Row'), 'Row', '__CTD_ANON_17_httpwww_opengis_netgmlRow', True)
    def Row (self):
        """Get the value of the {http://www.opengis.net/gml}Row element."""
        return self.__Row.value(self)
    def setRow (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}Row element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__Row.set(self, new_value)
    
    def addRow (self, new_value):
        """Add the value as another occurrence of the {http://www.opengis.net/gml}Row element.  Raises
        BadValueTypeException if the new value is not consistent with the
        element's type."""
        return self.__Row.append(self, new_value)

    _ElementMap = {
        __Row.name() : __Row
    }
    _AttributeMap = {
        
    }



# Complex type _CTD_ANON_19 with content type ELEMENT_ONLY
class _CTD_ANON_19 (pyxb.binding.basis.complexTypeDefinition):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.opengis.net/gml}SecondDefiningParameter uses Python identifier SecondDefiningParameter
    __SecondDefiningParameter = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'SecondDefiningParameter'), 'SecondDefiningParameter', '__CTD_ANON_19_httpwww_opengis_netgmlSecondDefiningParameter', False)
    def SecondDefiningParameter (self):
        """Get the value of the {http://www.opengis.net/gml}SecondDefiningParameter element."""
        return self.__SecondDefiningParameter.value(self)
    def setSecondDefiningParameter (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}SecondDefiningParameter element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__SecondDefiningParameter.set(self, new_value)

    _ElementMap = {
        __SecondDefiningParameter.name() : __SecondDefiningParameter
    }
    _AttributeMap = {
        
    }



# Complex type _CTD_ANON_20 with content type SIMPLE
class _CTD_ANON_20 (pyxb.binding.basis.complexTypeDefinition):
    _TypeDefinition = pyxb.binding.datatypes.boolean
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_SIMPLE
    _Abstract = False
    _ExpandedName = None
    # Base type is pyxb.binding.datatypes.boolean
    
    # Attribute nilReason uses Python identifier nilReason
    __nilReason = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'nilReason'), 'nilReason', '__CTD_ANON_20_nilReason', NilReasonType)
    def nilReason (self):
        """Get the attribute value for nilReason."""
        return self.__nilReason.value(self)
    def setNilReason (self, new_value):
        """Set the attribute value for nilReason.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__nilReason.set(self, new_value)

    _ElementMap = {
        
    }
    _AttributeMap = {
        __nilReason.name() : __nilReason
    }



# Complex type _CTD_ANON_21 with content type ELEMENT_ONLY
class _CTD_ANON_21 (pyxb.binding.basis.complexTypeDefinition):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.opengis.net/gml}posList uses Python identifier posList
    __posList = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'posList'), 'posList', '__CTD_ANON_21_httpwww_opengis_netgmlposList', False)
    def posList (self):
        """Get the value of the {http://www.opengis.net/gml}posList element."""
        return self.__posList.value(self)
    def setPosList (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}posList element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__posList.set(self, new_value)
    
    # Element {http://www.opengis.net/gml}pos uses Python identifier pos
    __pos = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'pos'), 'pos', '__CTD_ANON_21_httpwww_opengis_netgmlpos', True)
    def pos (self):
        """Get the value of the {http://www.opengis.net/gml}pos element."""
        return self.__pos.value(self)
    def setPos (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}pos element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__pos.set(self, new_value)
    
    def addPos (self, new_value):
        """Add the value as another occurrence of the {http://www.opengis.net/gml}pos element.  Raises
        BadValueTypeException if the new value is not consistent with the
        element's type."""
        return self.__pos.append(self, new_value)
    
    # Element {http://www.opengis.net/gml}pointProperty uses Python identifier pointProperty
    __pointProperty = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'pointProperty'), 'pointProperty', '__CTD_ANON_21_httpwww_opengis_netgmlpointProperty', True)
    def pointProperty (self):
        """Get the value of the {http://www.opengis.net/gml}pointProperty element."""
        return self.__pointProperty.value(self)
    def setPointProperty (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}pointProperty element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__pointProperty.set(self, new_value)
    
    def addPointProperty (self, new_value):
        """Add the value as another occurrence of the {http://www.opengis.net/gml}pointProperty element.  Raises
        BadValueTypeException if the new value is not consistent with the
        element's type."""
        return self.__pointProperty.append(self, new_value)

    _ElementMap = {
        __posList.name() : __posList,
        __pos.name() : __pos,
        __pointProperty.name() : __pointProperty
    }
    _AttributeMap = {
        
    }



# Complex type _CTD_ANON_22 with content type ELEMENT_ONLY
class _CTD_ANON_22 (pyxb.binding.basis.complexTypeDefinition):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.isotc211.org/2005/gmd}EX_Extent uses Python identifier EX_Extent
    __EX_Extent = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(MODULEhttpwww_isotc211_org2005gmd.Namespace, u'EX_Extent'), 'EX_Extent', '__CTD_ANON_22_httpwww_isotc211_org2005gmdEX_Extent', False)
    def EX_Extent (self):
        """Get the value of the {http://www.isotc211.org/2005/gmd}EX_Extent element."""
        return self.__EX_Extent.value(self)
    def setEX_Extent (self, new_value):
        """Set the value of the {http://www.isotc211.org/2005/gmd}EX_Extent element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__EX_Extent.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}show uses Python identifier show
    __show = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'show'), 'show', '__CTD_ANON_22_httpwww_w3_org1999xlinkshow', MODULEhttpwww_w3_org1999xlink.UNBOUNDNone)
    def show (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}show."""
        return self.__show.value(self)
    def setShow (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}show.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__show.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}arcrole uses Python identifier arcrole
    __arcrole = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'arcrole'), 'arcrole', '__CTD_ANON_22_httpwww_w3_org1999xlinkarcrole', pyxb.binding.datatypes.anyURI)
    def arcrole (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}arcrole."""
        return self.__arcrole.value(self)
    def setArcrole (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}arcrole.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__arcrole.set(self, new_value)
    
    # Attribute {http://www.opengis.net/gml}remoteSchema uses Python identifier remoteSchema
    __remoteSchema = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(Namespace, u'remoteSchema'), 'remoteSchema', '__CTD_ANON_22_httpwww_opengis_netgmlremoteSchema', pyxb.binding.datatypes.anyURI)
    def remoteSchema (self):
        """Get the attribute value for {http://www.opengis.net/gml}remoteSchema."""
        return self.__remoteSchema.value(self)
    def setRemoteSchema (self, new_value):
        """Set the attribute value for {http://www.opengis.net/gml}remoteSchema.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__remoteSchema.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}actuate uses Python identifier actuate
    __actuate = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'actuate'), 'actuate', '__CTD_ANON_22_httpwww_w3_org1999xlinkactuate', MODULEhttpwww_w3_org1999xlink.UNBOUNDNone_)
    def actuate (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}actuate."""
        return self.__actuate.value(self)
    def setActuate (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}actuate.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__actuate.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}type uses Python identifier type
    __type = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'type'), 'type', '__CTD_ANON_22_httpwww_w3_org1999xlinktype', pyxb.binding.datatypes.string, fixed=True, unicode_default=u'simple')
    def type (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}type."""
        return self.__type.value(self)
    def setType (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}type.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__type.set(self, new_value)
    
    # Attribute nilReason uses Python identifier nilReason
    __nilReason = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'nilReason'), 'nilReason', '__CTD_ANON_22_nilReason', NilReasonType)
    def nilReason (self):
        """Get the attribute value for nilReason."""
        return self.__nilReason.value(self)
    def setNilReason (self, new_value):
        """Set the attribute value for nilReason.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__nilReason.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}role uses Python identifier role
    __role = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'role'), 'role', '__CTD_ANON_22_httpwww_w3_org1999xlinkrole', pyxb.binding.datatypes.anyURI)
    def role (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}role."""
        return self.__role.value(self)
    def setRole (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}role.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__role.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}title uses Python identifier title
    __title = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'title'), 'title', '__CTD_ANON_22_httpwww_w3_org1999xlinktitle', pyxb.binding.datatypes.string)
    def title (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}title."""
        return self.__title.value(self)
    def setTitle (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}title.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__title.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}href uses Python identifier href
    __href = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'href'), 'href', '__CTD_ANON_22_httpwww_w3_org1999xlinkhref', pyxb.binding.datatypes.anyURI)
    def href (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}href."""
        return self.__href.value(self)
    def setHref (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}href.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__href.set(self, new_value)

    _ElementMap = {
        __EX_Extent.name() : __EX_Extent
    }
    _AttributeMap = {
        __show.name() : __show,
        __arcrole.name() : __arcrole,
        __remoteSchema.name() : __remoteSchema,
        __actuate.name() : __actuate,
        __type.name() : __type,
        __nilReason.name() : __nilReason,
        __role.name() : __role,
        __title.name() : __title,
        __href.name() : __href
    }



# Complex type _CTD_ANON_18 with content type ELEMENT_ONLY
class _CTD_ANON_18 (pyxb.binding.basis.complexTypeDefinition):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.opengis.net/gml}posList uses Python identifier posList
    __posList = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'posList'), 'posList', '__CTD_ANON_18_httpwww_opengis_netgmlposList', False)
    def posList (self):
        """Get the value of the {http://www.opengis.net/gml}posList element."""
        return self.__posList.value(self)
    def setPosList (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}posList element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__posList.set(self, new_value)
    
    # Element {http://www.opengis.net/gml}pos uses Python identifier pos
    __pos = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'pos'), 'pos', '__CTD_ANON_18_httpwww_opengis_netgmlpos', True)
    def pos (self):
        """Get the value of the {http://www.opengis.net/gml}pos element."""
        return self.__pos.value(self)
    def setPos (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}pos element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__pos.set(self, new_value)
    
    def addPos (self, new_value):
        """Add the value as another occurrence of the {http://www.opengis.net/gml}pos element.  Raises
        BadValueTypeException if the new value is not consistent with the
        element's type."""
        return self.__pos.append(self, new_value)
    
    # Element {http://www.opengis.net/gml}pointProperty uses Python identifier pointProperty
    __pointProperty = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'pointProperty'), 'pointProperty', '__CTD_ANON_18_httpwww_opengis_netgmlpointProperty', True)
    def pointProperty (self):
        """Get the value of the {http://www.opengis.net/gml}pointProperty element."""
        return self.__pointProperty.value(self)
    def setPointProperty (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}pointProperty element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__pointProperty.set(self, new_value)
    
    def addPointProperty (self, new_value):
        """Add the value as another occurrence of the {http://www.opengis.net/gml}pointProperty element.  Raises
        BadValueTypeException if the new value is not consistent with the
        element's type."""
        return self.__pointProperty.append(self, new_value)

    _ElementMap = {
        __posList.name() : __posList,
        __pos.name() : __pos,
        __pointProperty.name() : __pointProperty
    }
    _AttributeMap = {
        
    }



# Complex type _CTD_ANON_23 with content type SIMPLE
class _CTD_ANON_23 (pyxb.binding.basis.complexTypeDefinition):
    _TypeDefinition = pyxb.binding.datatypes.integer
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_SIMPLE
    _Abstract = False
    _ExpandedName = None
    # Base type is pyxb.binding.datatypes.integer
    
    # Attribute nilReason uses Python identifier nilReason
    __nilReason = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'nilReason'), 'nilReason', '__CTD_ANON_23_nilReason', NilReasonType)
    def nilReason (self):
        """Get the attribute value for nilReason."""
        return self.__nilReason.value(self)
    def setNilReason (self, new_value):
        """Set the attribute value for nilReason.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__nilReason.set(self, new_value)

    _ElementMap = {
        
    }
    _AttributeMap = {
        __nilReason.name() : __nilReason
    }



# Complex type _CTD_ANON_24 with content type ELEMENT_ONLY
class _CTD_ANON_24 (pyxb.binding.basis.complexTypeDefinition):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.opengis.net/gml}AffinePlacement uses Python identifier AffinePlacement
    __AffinePlacement = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'AffinePlacement'), 'AffinePlacement', '__CTD_ANON_24_httpwww_opengis_netgmlAffinePlacement', False)
    def AffinePlacement (self):
        """Get the value of the {http://www.opengis.net/gml}AffinePlacement element."""
        return self.__AffinePlacement.value(self)
    def setAffinePlacement (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}AffinePlacement element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__AffinePlacement.set(self, new_value)

    _ElementMap = {
        __AffinePlacement.name() : __AffinePlacement
    }
    _AttributeMap = {
        
    }



# Complex type _CTD_ANON_25 with content type ELEMENT_ONLY
class _CTD_ANON_25 (pyxb.binding.basis.complexTypeDefinition):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.isotc211.org/2005/gmd}AbstractDQ_PositionalAccuracy uses Python identifier AbstractDQ_PositionalAccuracy
    __AbstractDQ_PositionalAccuracy = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(MODULEhttpwww_isotc211_org2005gmd.Namespace, u'AbstractDQ_PositionalAccuracy'), 'AbstractDQ_PositionalAccuracy', '__CTD_ANON_25_httpwww_isotc211_org2005gmdAbstractDQ_PositionalAccuracy', False)
    def AbstractDQ_PositionalAccuracy (self):
        """Get the value of the {http://www.isotc211.org/2005/gmd}AbstractDQ_PositionalAccuracy element."""
        return self.__AbstractDQ_PositionalAccuracy.value(self)
    def setAbstractDQ_PositionalAccuracy (self, new_value):
        """Set the value of the {http://www.isotc211.org/2005/gmd}AbstractDQ_PositionalAccuracy element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__AbstractDQ_PositionalAccuracy.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}show uses Python identifier show
    __show = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'show'), 'show', '__CTD_ANON_25_httpwww_w3_org1999xlinkshow', MODULEhttpwww_w3_org1999xlink.UNBOUNDNone_2)
    def show (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}show."""
        return self.__show.value(self)
    def setShow (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}show.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__show.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}role uses Python identifier role
    __role = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'role'), 'role', '__CTD_ANON_25_httpwww_w3_org1999xlinkrole', pyxb.binding.datatypes.anyURI)
    def role (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}role."""
        return self.__role.value(self)
    def setRole (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}role.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__role.set(self, new_value)
    
    # Attribute {http://www.opengis.net/gml}remoteSchema uses Python identifier remoteSchema
    __remoteSchema = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(Namespace, u'remoteSchema'), 'remoteSchema', '__CTD_ANON_25_httpwww_opengis_netgmlremoteSchema', pyxb.binding.datatypes.anyURI)
    def remoteSchema (self):
        """Get the attribute value for {http://www.opengis.net/gml}remoteSchema."""
        return self.__remoteSchema.value(self)
    def setRemoteSchema (self, new_value):
        """Set the attribute value for {http://www.opengis.net/gml}remoteSchema.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__remoteSchema.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}href uses Python identifier href
    __href = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'href'), 'href', '__CTD_ANON_25_httpwww_w3_org1999xlinkhref', pyxb.binding.datatypes.anyURI)
    def href (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}href."""
        return self.__href.value(self)
    def setHref (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}href.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__href.set(self, new_value)
    
    # Attribute nilReason uses Python identifier nilReason
    __nilReason = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'nilReason'), 'nilReason', '__CTD_ANON_25_nilReason', NilReasonType)
    def nilReason (self):
        """Get the attribute value for nilReason."""
        return self.__nilReason.value(self)
    def setNilReason (self, new_value):
        """Set the attribute value for nilReason.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__nilReason.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}type uses Python identifier type
    __type = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'type'), 'type', '__CTD_ANON_25_httpwww_w3_org1999xlinktype', pyxb.binding.datatypes.string, fixed=True, unicode_default=u'simple')
    def type (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}type."""
        return self.__type.value(self)
    def setType (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}type.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__type.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}actuate uses Python identifier actuate
    __actuate = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'actuate'), 'actuate', '__CTD_ANON_25_httpwww_w3_org1999xlinkactuate', MODULEhttpwww_w3_org1999xlink.UNBOUNDNone_3)
    def actuate (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}actuate."""
        return self.__actuate.value(self)
    def setActuate (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}actuate.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__actuate.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}arcrole uses Python identifier arcrole
    __arcrole = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'arcrole'), 'arcrole', '__CTD_ANON_25_httpwww_w3_org1999xlinkarcrole', pyxb.binding.datatypes.anyURI)
    def arcrole (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}arcrole."""
        return self.__arcrole.value(self)
    def setArcrole (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}arcrole.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__arcrole.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}title uses Python identifier title
    __title = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'title'), 'title', '__CTD_ANON_25_httpwww_w3_org1999xlinktitle', pyxb.binding.datatypes.string)
    def title (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}title."""
        return self.__title.value(self)
    def setTitle (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}title.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__title.set(self, new_value)

    _ElementMap = {
        __AbstractDQ_PositionalAccuracy.name() : __AbstractDQ_PositionalAccuracy
    }
    _AttributeMap = {
        __show.name() : __show,
        __role.name() : __role,
        __remoteSchema.name() : __remoteSchema,
        __href.name() : __href,
        __nilReason.name() : __nilReason,
        __type.name() : __type,
        __actuate.name() : __actuate,
        __arcrole.name() : __arcrole,
        __title.name() : __title
    }



# Complex type AbstractCurveSegmentType with content type EMPTY
class AbstractCurveSegmentType (pyxb.binding.basis.complexTypeDefinition):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_EMPTY
    _Abstract = True
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'AbstractCurveSegmentType')
    # Base type is pyxb.binding.datatypes.anyType
    
    # Attribute numDerivativesAtEnd uses Python identifier numDerivativesAtEnd
    __numDerivativesAtEnd = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'numDerivativesAtEnd'), 'numDerivativesAtEnd', '__AbstractCurveSegmentType_numDerivativesAtEnd', pyxb.binding.datatypes.integer, unicode_default=u'0')
    def numDerivativesAtEnd (self):
        """Get the attribute value for numDerivativesAtEnd."""
        return self.__numDerivativesAtEnd.value(self)
    def setNumDerivativesAtEnd (self, new_value):
        """Set the attribute value for numDerivativesAtEnd.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__numDerivativesAtEnd.set(self, new_value)
    
    # Attribute numDerivativeInterior uses Python identifier numDerivativeInterior
    __numDerivativeInterior = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'numDerivativeInterior'), 'numDerivativeInterior', '__AbstractCurveSegmentType_numDerivativeInterior', pyxb.binding.datatypes.integer, unicode_default=u'0')
    def numDerivativeInterior (self):
        """Get the attribute value for numDerivativeInterior."""
        return self.__numDerivativeInterior.value(self)
    def setNumDerivativeInterior (self, new_value):
        """Set the attribute value for numDerivativeInterior.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__numDerivativeInterior.set(self, new_value)
    
    # Attribute numDerivativesAtStart uses Python identifier numDerivativesAtStart
    __numDerivativesAtStart = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'numDerivativesAtStart'), 'numDerivativesAtStart', '__AbstractCurveSegmentType_numDerivativesAtStart', pyxb.binding.datatypes.integer, unicode_default=u'0')
    def numDerivativesAtStart (self):
        """Get the attribute value for numDerivativesAtStart."""
        return self.__numDerivativesAtStart.value(self)
    def setNumDerivativesAtStart (self, new_value):
        """Set the attribute value for numDerivativesAtStart.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__numDerivativesAtStart.set(self, new_value)

    _ElementMap = {
        
    }
    _AttributeMap = {
        __numDerivativesAtEnd.name() : __numDerivativesAtEnd,
        __numDerivativeInterior.name() : __numDerivativeInterior,
        __numDerivativesAtStart.name() : __numDerivativesAtStart
    }
Namespace.addCategoryObject('typeBinding', u'AbstractCurveSegmentType', AbstractCurveSegmentType)


# Complex type AbstractFeatureMemberType with content type EMPTY
class AbstractFeatureMemberType (pyxb.binding.basis.complexTypeDefinition):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_EMPTY
    _Abstract = True
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'AbstractFeatureMemberType')
    # Base type is pyxb.binding.datatypes.anyType
    
    # Attribute owns uses Python identifier owns
    __owns = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'owns'), 'owns', '__AbstractFeatureMemberType_owns', pyxb.binding.datatypes.boolean, unicode_default=u'false')
    def owns (self):
        """Get the attribute value for owns."""
        return self.__owns.value(self)
    def setOwns (self, new_value):
        """Set the attribute value for owns.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__owns.set(self, new_value)

    _ElementMap = {
        
    }
    _AttributeMap = {
        __owns.name() : __owns
    }
Namespace.addCategoryObject('typeBinding', u'AbstractFeatureMemberType', AbstractFeatureMemberType)


# Complex type AbstractGMLType with content type ELEMENT_ONLY
class AbstractGMLType (pyxb.binding.basis.complexTypeDefinition):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = True
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'AbstractGMLType')
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.opengis.net/gml}descriptionReference uses Python identifier descriptionReference
    __descriptionReference = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'descriptionReference'), 'descriptionReference', '__AbstractGMLType_httpwww_opengis_netgmldescriptionReference', False)
    def descriptionReference (self):
        """Get the value of the {http://www.opengis.net/gml}descriptionReference element."""
        return self.__descriptionReference.value(self)
    def setDescriptionReference (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}descriptionReference element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__descriptionReference.set(self, new_value)
    
    # Element {http://www.opengis.net/gml}name uses Python identifier name
    __name = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'name'), 'name', '__AbstractGMLType_httpwww_opengis_netgmlname', True)
    def name (self):
        """Get the value of the {http://www.opengis.net/gml}name element."""
        return self.__name.value(self)
    def setName (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}name element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__name.set(self, new_value)
    
    def addName (self, new_value):
        """Add the value as another occurrence of the {http://www.opengis.net/gml}name element.  Raises
        BadValueTypeException if the new value is not consistent with the
        element's type."""
        return self.__name.append(self, new_value)
    
    # Element {http://www.opengis.net/gml}identifier uses Python identifier identifier
    __identifier = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'identifier'), 'identifier', '__AbstractGMLType_httpwww_opengis_netgmlidentifier', False)
    def identifier (self):
        """Get the value of the {http://www.opengis.net/gml}identifier element."""
        return self.__identifier.value(self)
    def setIdentifier (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}identifier element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__identifier.set(self, new_value)
    
    # Element {http://www.opengis.net/gml}metaDataProperty uses Python identifier metaDataProperty
    __metaDataProperty = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'metaDataProperty'), 'metaDataProperty', '__AbstractGMLType_httpwww_opengis_netgmlmetaDataProperty', True)
    def metaDataProperty (self):
        """Get the value of the {http://www.opengis.net/gml}metaDataProperty element."""
        return self.__metaDataProperty.value(self)
    def setMetaDataProperty (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}metaDataProperty element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__metaDataProperty.set(self, new_value)
    
    def addMetaDataProperty (self, new_value):
        """Add the value as another occurrence of the {http://www.opengis.net/gml}metaDataProperty element.  Raises
        BadValueTypeException if the new value is not consistent with the
        element's type."""
        return self.__metaDataProperty.append(self, new_value)
    
    # Element {http://www.opengis.net/gml}description uses Python identifier description
    __description = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'description'), 'description', '__AbstractGMLType_httpwww_opengis_netgmldescription', False)
    def description (self):
        """Get the value of the {http://www.opengis.net/gml}description element."""
        return self.__description.value(self)
    def setDescription (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}description element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__description.set(self, new_value)
    
    # Attribute {http://www.opengis.net/gml}id uses Python identifier id
    __id = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(Namespace, u'id'), 'id', '__AbstractGMLType_httpwww_opengis_netgmlid', pyxb.binding.datatypes.ID, required=True)
    def id (self):
        """Get the attribute value for {http://www.opengis.net/gml}id."""
        return self.__id.value(self)
    def setId (self, new_value):
        """Set the attribute value for {http://www.opengis.net/gml}id.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__id.set(self, new_value)

    _ElementMap = {
        __descriptionReference.name() : __descriptionReference,
        __name.name() : __name,
        __identifier.name() : __identifier,
        __metaDataProperty.name() : __metaDataProperty,
        __description.name() : __description
    }
    _AttributeMap = {
        __id.name() : __id
    }
Namespace.addCategoryObject('typeBinding', u'AbstractGMLType', AbstractGMLType)


# Complex type AbstractGeneralOperationParameterPropertyType with content type ELEMENT_ONLY
class AbstractGeneralOperationParameterPropertyType (pyxb.binding.basis.complexTypeDefinition):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'AbstractGeneralOperationParameterPropertyType')
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.opengis.net/gml}AbstractGeneralOperationParameter uses Python identifier AbstractGeneralOperationParameter
    __AbstractGeneralOperationParameter = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'AbstractGeneralOperationParameter'), 'AbstractGeneralOperationParameter', '__AbstractGeneralOperationParameterPropertyType_httpwww_opengis_netgmlAbstractGeneralOperationParameter', False)
    def AbstractGeneralOperationParameter (self):
        """Get the value of the {http://www.opengis.net/gml}AbstractGeneralOperationParameter element."""
        return self.__AbstractGeneralOperationParameter.value(self)
    def setAbstractGeneralOperationParameter (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}AbstractGeneralOperationParameter element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__AbstractGeneralOperationParameter.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}show uses Python identifier show
    __show = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'show'), 'show', '__AbstractGeneralOperationParameterPropertyType_httpwww_w3_org1999xlinkshow', MODULEhttpwww_w3_org1999xlink.UNBOUNDNone_4)
    def show (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}show."""
        return self.__show.value(self)
    def setShow (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}show.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__show.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}arcrole uses Python identifier arcrole
    __arcrole = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'arcrole'), 'arcrole', '__AbstractGeneralOperationParameterPropertyType_httpwww_w3_org1999xlinkarcrole', pyxb.binding.datatypes.anyURI)
    def arcrole (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}arcrole."""
        return self.__arcrole.value(self)
    def setArcrole (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}arcrole.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__arcrole.set(self, new_value)
    
    # Attribute {http://www.opengis.net/gml}remoteSchema uses Python identifier remoteSchema
    __remoteSchema = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(Namespace, u'remoteSchema'), 'remoteSchema', '__AbstractGeneralOperationParameterPropertyType_httpwww_opengis_netgmlremoteSchema', pyxb.binding.datatypes.anyURI)
    def remoteSchema (self):
        """Get the attribute value for {http://www.opengis.net/gml}remoteSchema."""
        return self.__remoteSchema.value(self)
    def setRemoteSchema (self, new_value):
        """Set the attribute value for {http://www.opengis.net/gml}remoteSchema.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__remoteSchema.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}actuate uses Python identifier actuate
    __actuate = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'actuate'), 'actuate', '__AbstractGeneralOperationParameterPropertyType_httpwww_w3_org1999xlinkactuate', MODULEhttpwww_w3_org1999xlink.UNBOUNDNone_5)
    def actuate (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}actuate."""
        return self.__actuate.value(self)
    def setActuate (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}actuate.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__actuate.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}type uses Python identifier type
    __type = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'type'), 'type', '__AbstractGeneralOperationParameterPropertyType_httpwww_w3_org1999xlinktype', pyxb.binding.datatypes.string, fixed=True, unicode_default=u'simple')
    def type (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}type."""
        return self.__type.value(self)
    def setType (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}type.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__type.set(self, new_value)
    
    # Attribute nilReason uses Python identifier nilReason
    __nilReason = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'nilReason'), 'nilReason', '__AbstractGeneralOperationParameterPropertyType_nilReason', NilReasonType)
    def nilReason (self):
        """Get the attribute value for nilReason."""
        return self.__nilReason.value(self)
    def setNilReason (self, new_value):
        """Set the attribute value for nilReason.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__nilReason.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}title uses Python identifier title
    __title = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'title'), 'title', '__AbstractGeneralOperationParameterPropertyType_httpwww_w3_org1999xlinktitle', pyxb.binding.datatypes.string)
    def title (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}title."""
        return self.__title.value(self)
    def setTitle (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}title.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__title.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}role uses Python identifier role
    __role = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'role'), 'role', '__AbstractGeneralOperationParameterPropertyType_httpwww_w3_org1999xlinkrole', pyxb.binding.datatypes.anyURI)
    def role (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}role."""
        return self.__role.value(self)
    def setRole (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}role.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__role.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}href uses Python identifier href
    __href = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'href'), 'href', '__AbstractGeneralOperationParameterPropertyType_httpwww_w3_org1999xlinkhref', pyxb.binding.datatypes.anyURI)
    def href (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}href."""
        return self.__href.value(self)
    def setHref (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}href.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__href.set(self, new_value)

    _ElementMap = {
        __AbstractGeneralOperationParameter.name() : __AbstractGeneralOperationParameter
    }
    _AttributeMap = {
        __show.name() : __show,
        __arcrole.name() : __arcrole,
        __remoteSchema.name() : __remoteSchema,
        __actuate.name() : __actuate,
        __type.name() : __type,
        __nilReason.name() : __nilReason,
        __title.name() : __title,
        __role.name() : __role,
        __href.name() : __href
    }
Namespace.addCategoryObject('typeBinding', u'AbstractGeneralOperationParameterPropertyType', AbstractGeneralOperationParameterPropertyType)


# Complex type AbstractGeneralParameterValuePropertyType with content type ELEMENT_ONLY
class AbstractGeneralParameterValuePropertyType (pyxb.binding.basis.complexTypeDefinition):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'AbstractGeneralParameterValuePropertyType')
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.opengis.net/gml}AbstractGeneralParameterValue uses Python identifier AbstractGeneralParameterValue
    __AbstractGeneralParameterValue = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'AbstractGeneralParameterValue'), 'AbstractGeneralParameterValue', '__AbstractGeneralParameterValuePropertyType_httpwww_opengis_netgmlAbstractGeneralParameterValue', False)
    def AbstractGeneralParameterValue (self):
        """Get the value of the {http://www.opengis.net/gml}AbstractGeneralParameterValue element."""
        return self.__AbstractGeneralParameterValue.value(self)
    def setAbstractGeneralParameterValue (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}AbstractGeneralParameterValue element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__AbstractGeneralParameterValue.set(self, new_value)

    _ElementMap = {
        __AbstractGeneralParameterValue.name() : __AbstractGeneralParameterValue
    }
    _AttributeMap = {
        
    }
Namespace.addCategoryObject('typeBinding', u'AbstractGeneralParameterValuePropertyType', AbstractGeneralParameterValuePropertyType)


# Complex type AbstractGeneralParameterValueType with content type EMPTY
class AbstractGeneralParameterValueType (pyxb.binding.basis.complexTypeDefinition):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_EMPTY
    _Abstract = True
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'AbstractGeneralParameterValueType')
    # Base type is pyxb.binding.datatypes.anyType

    _ElementMap = {
        
    }
    _AttributeMap = {
        
    }
Namespace.addCategoryObject('typeBinding', u'AbstractGeneralParameterValueType', AbstractGeneralParameterValueType)


# Complex type AbstractMemberType with content type EMPTY
class AbstractMemberType (pyxb.binding.basis.complexTypeDefinition):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_EMPTY
    _Abstract = True
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'AbstractMemberType')
    # Base type is pyxb.binding.datatypes.anyType
    
    # Attribute owns uses Python identifier owns
    __owns = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'owns'), 'owns', '__AbstractMemberType_owns', pyxb.binding.datatypes.boolean, unicode_default=u'false')
    def owns (self):
        """Get the attribute value for owns."""
        return self.__owns.value(self)
    def setOwns (self, new_value):
        """Set the attribute value for owns.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__owns.set(self, new_value)

    _ElementMap = {
        
    }
    _AttributeMap = {
        __owns.name() : __owns
    }
Namespace.addCategoryObject('typeBinding', u'AbstractMemberType', AbstractMemberType)


# Complex type AbstractMetaDataType with content type MIXED
class AbstractMetaDataType (pyxb.binding.basis.complexTypeDefinition):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_MIXED
    _Abstract = True
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'AbstractMetaDataType')
    # Base type is pyxb.binding.datatypes.anyType
    
    # Attribute {http://www.opengis.net/gml}id uses Python identifier id
    __id = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(Namespace, u'id'), 'id', '__AbstractMetaDataType_httpwww_opengis_netgmlid', pyxb.binding.datatypes.ID)
    def id (self):
        """Get the attribute value for {http://www.opengis.net/gml}id."""
        return self.__id.value(self)
    def setId (self, new_value):
        """Set the attribute value for {http://www.opengis.net/gml}id.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__id.set(self, new_value)

    _ElementMap = {
        
    }
    _AttributeMap = {
        __id.name() : __id
    }
Namespace.addCategoryObject('typeBinding', u'AbstractMetaDataType', AbstractMetaDataType)


# Complex type AbstractMetadataPropertyType with content type EMPTY
class AbstractMetadataPropertyType (pyxb.binding.basis.complexTypeDefinition):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_EMPTY
    _Abstract = True
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'AbstractMetadataPropertyType')
    # Base type is pyxb.binding.datatypes.anyType
    
    # Attribute owns uses Python identifier owns
    __owns = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'owns'), 'owns', '__AbstractMetadataPropertyType_owns', pyxb.binding.datatypes.boolean, unicode_default=u'false')
    def owns (self):
        """Get the attribute value for owns."""
        return self.__owns.value(self)
    def setOwns (self, new_value):
        """Set the attribute value for owns.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__owns.set(self, new_value)

    _ElementMap = {
        
    }
    _AttributeMap = {
        __owns.name() : __owns
    }
Namespace.addCategoryObject('typeBinding', u'AbstractMetadataPropertyType', AbstractMetadataPropertyType)


# Complex type AbstractRingPropertyType with content type ELEMENT_ONLY
class AbstractRingPropertyType (pyxb.binding.basis.complexTypeDefinition):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'AbstractRingPropertyType')
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.opengis.net/gml}AbstractRing uses Python identifier AbstractRing
    __AbstractRing = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'AbstractRing'), 'AbstractRing', '__AbstractRingPropertyType_httpwww_opengis_netgmlAbstractRing', False)
    def AbstractRing (self):
        """Get the value of the {http://www.opengis.net/gml}AbstractRing element."""
        return self.__AbstractRing.value(self)
    def setAbstractRing (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}AbstractRing element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__AbstractRing.set(self, new_value)

    _ElementMap = {
        __AbstractRing.name() : __AbstractRing
    }
    _AttributeMap = {
        
    }
Namespace.addCategoryObject('typeBinding', u'AbstractRingPropertyType', AbstractRingPropertyType)


# Complex type AbstractRingType with content type EMPTY
class AbstractRingType (pyxb.binding.basis.complexTypeDefinition):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_EMPTY
    _Abstract = True
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'AbstractRingType')
    # Base type is pyxb.binding.datatypes.anyType

    _ElementMap = {
        
    }
    _AttributeMap = {
        
    }
Namespace.addCategoryObject('typeBinding', u'AbstractRingType', AbstractRingType)


# Complex type AbstractSurfacePatchType with content type EMPTY
class AbstractSurfacePatchType (pyxb.binding.basis.complexTypeDefinition):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_EMPTY
    _Abstract = True
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'AbstractSurfacePatchType')
    # Base type is pyxb.binding.datatypes.anyType

    _ElementMap = {
        
    }
    _AttributeMap = {
        
    }
Namespace.addCategoryObject('typeBinding', u'AbstractSurfacePatchType', AbstractSurfacePatchType)


# Complex type AffineCSPropertyType with content type ELEMENT_ONLY
class AffineCSPropertyType (pyxb.binding.basis.complexTypeDefinition):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'AffineCSPropertyType')
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.opengis.net/gml}AffineCS uses Python identifier AffineCS
    __AffineCS = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'AffineCS'), 'AffineCS', '__AffineCSPropertyType_httpwww_opengis_netgmlAffineCS', False)
    def AffineCS (self):
        """Get the value of the {http://www.opengis.net/gml}AffineCS element."""
        return self.__AffineCS.value(self)
    def setAffineCS (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}AffineCS element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__AffineCS.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}show uses Python identifier show
    __show = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'show'), 'show', '__AffineCSPropertyType_httpwww_w3_org1999xlinkshow', MODULEhttpwww_w3_org1999xlink.UNBOUNDNone_6)
    def show (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}show."""
        return self.__show.value(self)
    def setShow (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}show.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__show.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}role uses Python identifier role
    __role = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'role'), 'role', '__AffineCSPropertyType_httpwww_w3_org1999xlinkrole', pyxb.binding.datatypes.anyURI)
    def role (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}role."""
        return self.__role.value(self)
    def setRole (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}role.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__role.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}href uses Python identifier href
    __href = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'href'), 'href', '__AffineCSPropertyType_httpwww_w3_org1999xlinkhref', pyxb.binding.datatypes.anyURI)
    def href (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}href."""
        return self.__href.value(self)
    def setHref (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}href.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__href.set(self, new_value)
    
    # Attribute nilReason uses Python identifier nilReason
    __nilReason = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'nilReason'), 'nilReason', '__AffineCSPropertyType_nilReason', NilReasonType)
    def nilReason (self):
        """Get the attribute value for nilReason."""
        return self.__nilReason.value(self)
    def setNilReason (self, new_value):
        """Set the attribute value for nilReason.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__nilReason.set(self, new_value)
    
    # Attribute {http://www.opengis.net/gml}remoteSchema uses Python identifier remoteSchema
    __remoteSchema = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(Namespace, u'remoteSchema'), 'remoteSchema', '__AffineCSPropertyType_httpwww_opengis_netgmlremoteSchema', pyxb.binding.datatypes.anyURI)
    def remoteSchema (self):
        """Get the attribute value for {http://www.opengis.net/gml}remoteSchema."""
        return self.__remoteSchema.value(self)
    def setRemoteSchema (self, new_value):
        """Set the attribute value for {http://www.opengis.net/gml}remoteSchema.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__remoteSchema.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}actuate uses Python identifier actuate
    __actuate = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'actuate'), 'actuate', '__AffineCSPropertyType_httpwww_w3_org1999xlinkactuate', MODULEhttpwww_w3_org1999xlink.UNBOUNDNone_7)
    def actuate (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}actuate."""
        return self.__actuate.value(self)
    def setActuate (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}actuate.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__actuate.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}type uses Python identifier type
    __type = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'type'), 'type', '__AffineCSPropertyType_httpwww_w3_org1999xlinktype', pyxb.binding.datatypes.string, fixed=True, unicode_default=u'simple')
    def type (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}type."""
        return self.__type.value(self)
    def setType (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}type.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__type.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}arcrole uses Python identifier arcrole
    __arcrole = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'arcrole'), 'arcrole', '__AffineCSPropertyType_httpwww_w3_org1999xlinkarcrole', pyxb.binding.datatypes.anyURI)
    def arcrole (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}arcrole."""
        return self.__arcrole.value(self)
    def setArcrole (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}arcrole.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__arcrole.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}title uses Python identifier title
    __title = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'title'), 'title', '__AffineCSPropertyType_httpwww_w3_org1999xlinktitle', pyxb.binding.datatypes.string)
    def title (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}title."""
        return self.__title.value(self)
    def setTitle (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}title.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__title.set(self, new_value)

    _ElementMap = {
        __AffineCS.name() : __AffineCS
    }
    _AttributeMap = {
        __show.name() : __show,
        __role.name() : __role,
        __href.name() : __href,
        __nilReason.name() : __nilReason,
        __remoteSchema.name() : __remoteSchema,
        __actuate.name() : __actuate,
        __type.name() : __type,
        __arcrole.name() : __arcrole,
        __title.name() : __title
    }
Namespace.addCategoryObject('typeBinding', u'AffineCSPropertyType', AffineCSPropertyType)


# Complex type AffinePlacementType with content type ELEMENT_ONLY
class AffinePlacementType (pyxb.binding.basis.complexTypeDefinition):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'AffinePlacementType')
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.opengis.net/gml}inDimension uses Python identifier inDimension
    __inDimension = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'inDimension'), 'inDimension', '__AffinePlacementType_httpwww_opengis_netgmlinDimension', False)
    def inDimension (self):
        """Get the value of the {http://www.opengis.net/gml}inDimension element."""
        return self.__inDimension.value(self)
    def setInDimension (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}inDimension element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__inDimension.set(self, new_value)
    
    # Element {http://www.opengis.net/gml}location uses Python identifier location
    __location = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'location'), 'location', '__AffinePlacementType_httpwww_opengis_netgmllocation', False)
    def location (self):
        """Get the value of the {http://www.opengis.net/gml}location element."""
        return self.__location.value(self)
    def setLocation (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}location element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__location.set(self, new_value)
    
    # Element {http://www.opengis.net/gml}refDirection uses Python identifier refDirection
    __refDirection = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'refDirection'), 'refDirection', '__AffinePlacementType_httpwww_opengis_netgmlrefDirection', True)
    def refDirection (self):
        """Get the value of the {http://www.opengis.net/gml}refDirection element."""
        return self.__refDirection.value(self)
    def setRefDirection (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}refDirection element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__refDirection.set(self, new_value)
    
    def addRefDirection (self, new_value):
        """Add the value as another occurrence of the {http://www.opengis.net/gml}refDirection element.  Raises
        BadValueTypeException if the new value is not consistent with the
        element's type."""
        return self.__refDirection.append(self, new_value)
    
    # Element {http://www.opengis.net/gml}outDimension uses Python identifier outDimension
    __outDimension = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'outDimension'), 'outDimension', '__AffinePlacementType_httpwww_opengis_netgmloutDimension', False)
    def outDimension (self):
        """Get the value of the {http://www.opengis.net/gml}outDimension element."""
        return self.__outDimension.value(self)
    def setOutDimension (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}outDimension element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__outDimension.set(self, new_value)

    _ElementMap = {
        __inDimension.name() : __inDimension,
        __location.name() : __location,
        __refDirection.name() : __refDirection,
        __outDimension.name() : __outDimension
    }
    _AttributeMap = {
        
    }
Namespace.addCategoryObject('typeBinding', u'AffinePlacementType', AffinePlacementType)


# Complex type AngleChoiceType with content type ELEMENT_ONLY
class AngleChoiceType (pyxb.binding.basis.complexTypeDefinition):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'AngleChoiceType')
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.opengis.net/gml}dmsAngle uses Python identifier dmsAngle
    __dmsAngle = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'dmsAngle'), 'dmsAngle', '__AngleChoiceType_httpwww_opengis_netgmldmsAngle', False)
    def dmsAngle (self):
        """Get the value of the {http://www.opengis.net/gml}dmsAngle element."""
        return self.__dmsAngle.value(self)
    def setDmsAngle (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}dmsAngle element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__dmsAngle.set(self, new_value)
    
    # Element {http://www.opengis.net/gml}angle uses Python identifier angle
    __angle = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'angle'), 'angle', '__AngleChoiceType_httpwww_opengis_netgmlangle', False)
    def angle (self):
        """Get the value of the {http://www.opengis.net/gml}angle element."""
        return self.__angle.value(self)
    def setAngle (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}angle element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__angle.set(self, new_value)

    _ElementMap = {
        __dmsAngle.name() : __dmsAngle,
        __angle.name() : __angle
    }
    _AttributeMap = {
        
    }
Namespace.addCategoryObject('typeBinding', u'AngleChoiceType', AngleChoiceType)


# Complex type ArrayAssociationType with content type ELEMENT_ONLY
class ArrayAssociationType (pyxb.binding.basis.complexTypeDefinition):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'ArrayAssociationType')
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.opengis.net/gml}AbstractObject uses Python identifier AbstractObject
    __AbstractObject = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'AbstractObject'), 'AbstractObject', '__ArrayAssociationType_httpwww_opengis_netgmlAbstractObject', True)
    def AbstractObject (self):
        """Get the value of the {http://www.opengis.net/gml}AbstractObject element."""
        return self.__AbstractObject.value(self)
    def setAbstractObject (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}AbstractObject element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__AbstractObject.set(self, new_value)
    
    def addAbstractObject (self, new_value):
        """Add the value as another occurrence of the {http://www.opengis.net/gml}AbstractObject element.  Raises
        BadValueTypeException if the new value is not consistent with the
        element's type."""
        return self.__AbstractObject.append(self, new_value)
    
    # Attribute owns uses Python identifier owns
    __owns = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'owns'), 'owns', '__ArrayAssociationType_owns', pyxb.binding.datatypes.boolean, unicode_default=u'false')
    def owns (self):
        """Get the attribute value for owns."""
        return self.__owns.value(self)
    def setOwns (self, new_value):
        """Set the attribute value for owns.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__owns.set(self, new_value)

    _ElementMap = {
        __AbstractObject.name() : __AbstractObject
    }
    _AttributeMap = {
        __owns.name() : __owns
    }
Namespace.addCategoryObject('typeBinding', u'ArrayAssociationType', ArrayAssociationType)


# Complex type AssociationRoleType with content type ELEMENT_ONLY
class AssociationRoleType (pyxb.binding.basis.complexTypeDefinition):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'AssociationRoleType')
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.opengis.net/gml}AbstractObject uses Python identifier AbstractObject
    __AbstractObject = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'AbstractObject'), 'AbstractObject', '__AssociationRoleType_httpwww_opengis_netgmlAbstractObject', False)
    def AbstractObject (self):
        """Get the value of the {http://www.opengis.net/gml}AbstractObject element."""
        return self.__AbstractObject.value(self)
    def setAbstractObject (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}AbstractObject element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__AbstractObject.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}show uses Python identifier show
    __show = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'show'), 'show', '__AssociationRoleType_httpwww_w3_org1999xlinkshow', MODULEhttpwww_w3_org1999xlink.UNBOUNDNone_8)
    def show (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}show."""
        return self.__show.value(self)
    def setShow (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}show.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__show.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}actuate uses Python identifier actuate
    __actuate = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'actuate'), 'actuate', '__AssociationRoleType_httpwww_w3_org1999xlinkactuate', MODULEhttpwww_w3_org1999xlink.UNBOUNDNone_9)
    def actuate (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}actuate."""
        return self.__actuate.value(self)
    def setActuate (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}actuate.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__actuate.set(self, new_value)
    
    # Attribute owns uses Python identifier owns
    __owns = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'owns'), 'owns', '__AssociationRoleType_owns', pyxb.binding.datatypes.boolean, unicode_default=u'false')
    def owns (self):
        """Get the attribute value for owns."""
        return self.__owns.value(self)
    def setOwns (self, new_value):
        """Set the attribute value for owns.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__owns.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}href uses Python identifier href
    __href = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'href'), 'href', '__AssociationRoleType_httpwww_w3_org1999xlinkhref', pyxb.binding.datatypes.anyURI)
    def href (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}href."""
        return self.__href.value(self)
    def setHref (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}href.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__href.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}arcrole uses Python identifier arcrole
    __arcrole = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'arcrole'), 'arcrole', '__AssociationRoleType_httpwww_w3_org1999xlinkarcrole', pyxb.binding.datatypes.anyURI)
    def arcrole (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}arcrole."""
        return self.__arcrole.value(self)
    def setArcrole (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}arcrole.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__arcrole.set(self, new_value)
    
    # Attribute {http://www.opengis.net/gml}remoteSchema uses Python identifier remoteSchema
    __remoteSchema = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(Namespace, u'remoteSchema'), 'remoteSchema', '__AssociationRoleType_httpwww_opengis_netgmlremoteSchema', pyxb.binding.datatypes.anyURI)
    def remoteSchema (self):
        """Get the attribute value for {http://www.opengis.net/gml}remoteSchema."""
        return self.__remoteSchema.value(self)
    def setRemoteSchema (self, new_value):
        """Set the attribute value for {http://www.opengis.net/gml}remoteSchema.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__remoteSchema.set(self, new_value)
    
    # Attribute nilReason uses Python identifier nilReason
    __nilReason = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'nilReason'), 'nilReason', '__AssociationRoleType_nilReason', NilReasonType)
    def nilReason (self):
        """Get the attribute value for nilReason."""
        return self.__nilReason.value(self)
    def setNilReason (self, new_value):
        """Set the attribute value for nilReason.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__nilReason.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}type uses Python identifier type
    __type = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'type'), 'type', '__AssociationRoleType_httpwww_w3_org1999xlinktype', pyxb.binding.datatypes.string, fixed=True, unicode_default=u'simple')
    def type (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}type."""
        return self.__type.value(self)
    def setType (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}type.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__type.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}title uses Python identifier title
    __title = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'title'), 'title', '__AssociationRoleType_httpwww_w3_org1999xlinktitle', pyxb.binding.datatypes.string)
    def title (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}title."""
        return self.__title.value(self)
    def setTitle (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}title.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__title.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}role uses Python identifier role
    __role = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'role'), 'role', '__AssociationRoleType_httpwww_w3_org1999xlinkrole', pyxb.binding.datatypes.anyURI)
    def role (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}role."""
        return self.__role.value(self)
    def setRole (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}role.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__role.set(self, new_value)

    _ElementMap = {
        __AbstractObject.name() : __AbstractObject
    }
    _AttributeMap = {
        __show.name() : __show,
        __actuate.name() : __actuate,
        __owns.name() : __owns,
        __href.name() : __href,
        __arcrole.name() : __arcrole,
        __remoteSchema.name() : __remoteSchema,
        __nilReason.name() : __nilReason,
        __type.name() : __type,
        __title.name() : __title,
        __role.name() : __role
    }
Namespace.addCategoryObject('typeBinding', u'AssociationRoleType', AssociationRoleType)


# Complex type BooleanPropertyType with content type ELEMENT_ONLY
class BooleanPropertyType (pyxb.binding.basis.complexTypeDefinition):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'BooleanPropertyType')
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.opengis.net/gml}Boolean uses Python identifier Boolean
    __Boolean = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'Boolean'), 'Boolean', '__BooleanPropertyType_httpwww_opengis_netgmlBoolean', False)
    def Boolean (self):
        """Get the value of the {http://www.opengis.net/gml}Boolean element."""
        return self.__Boolean.value(self)
    def setBoolean (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}Boolean element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__Boolean.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}href uses Python identifier href
    __href = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'href'), 'href', '__BooleanPropertyType_httpwww_w3_org1999xlinkhref', pyxb.binding.datatypes.anyURI)
    def href (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}href."""
        return self.__href.value(self)
    def setHref (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}href.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__href.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}show uses Python identifier show
    __show = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'show'), 'show', '__BooleanPropertyType_httpwww_w3_org1999xlinkshow', MODULEhttpwww_w3_org1999xlink.UNBOUNDNone_10)
    def show (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}show."""
        return self.__show.value(self)
    def setShow (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}show.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__show.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}arcrole uses Python identifier arcrole
    __arcrole = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'arcrole'), 'arcrole', '__BooleanPropertyType_httpwww_w3_org1999xlinkarcrole', pyxb.binding.datatypes.anyURI)
    def arcrole (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}arcrole."""
        return self.__arcrole.value(self)
    def setArcrole (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}arcrole.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__arcrole.set(self, new_value)
    
    # Attribute {http://www.opengis.net/gml}remoteSchema uses Python identifier remoteSchema
    __remoteSchema = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(Namespace, u'remoteSchema'), 'remoteSchema', '__BooleanPropertyType_httpwww_opengis_netgmlremoteSchema', pyxb.binding.datatypes.anyURI)
    def remoteSchema (self):
        """Get the attribute value for {http://www.opengis.net/gml}remoteSchema."""
        return self.__remoteSchema.value(self)
    def setRemoteSchema (self, new_value):
        """Set the attribute value for {http://www.opengis.net/gml}remoteSchema.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__remoteSchema.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}actuate uses Python identifier actuate
    __actuate = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'actuate'), 'actuate', '__BooleanPropertyType_httpwww_w3_org1999xlinkactuate', MODULEhttpwww_w3_org1999xlink.UNBOUNDNone_11)
    def actuate (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}actuate."""
        return self.__actuate.value(self)
    def setActuate (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}actuate.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__actuate.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}type uses Python identifier type
    __type = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'type'), 'type', '__BooleanPropertyType_httpwww_w3_org1999xlinktype', pyxb.binding.datatypes.string, fixed=True, unicode_default=u'simple')
    def type (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}type."""
        return self.__type.value(self)
    def setType (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}type.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__type.set(self, new_value)
    
    # Attribute nilReason uses Python identifier nilReason
    __nilReason = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'nilReason'), 'nilReason', '__BooleanPropertyType_nilReason', NilReasonType)
    def nilReason (self):
        """Get the attribute value for nilReason."""
        return self.__nilReason.value(self)
    def setNilReason (self, new_value):
        """Set the attribute value for nilReason.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__nilReason.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}title uses Python identifier title
    __title = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'title'), 'title', '__BooleanPropertyType_httpwww_w3_org1999xlinktitle', pyxb.binding.datatypes.string)
    def title (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}title."""
        return self.__title.value(self)
    def setTitle (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}title.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__title.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}role uses Python identifier role
    __role = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'role'), 'role', '__BooleanPropertyType_httpwww_w3_org1999xlinkrole', pyxb.binding.datatypes.anyURI)
    def role (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}role."""
        return self.__role.value(self)
    def setRole (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}role.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__role.set(self, new_value)

    _ElementMap = {
        __Boolean.name() : __Boolean
    }
    _AttributeMap = {
        __href.name() : __href,
        __show.name() : __show,
        __arcrole.name() : __arcrole,
        __remoteSchema.name() : __remoteSchema,
        __actuate.name() : __actuate,
        __type.name() : __type,
        __nilReason.name() : __nilReason,
        __title.name() : __title,
        __role.name() : __role
    }
Namespace.addCategoryObject('typeBinding', u'BooleanPropertyType', BooleanPropertyType)


# Complex type BoundingShapeType with content type ELEMENT_ONLY
class BoundingShapeType (pyxb.binding.basis.complexTypeDefinition):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'BoundingShapeType')
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.opengis.net/gml}Null uses Python identifier Null
    __Null = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'Null'), 'Null', '__BoundingShapeType_httpwww_opengis_netgmlNull', False)
    def Null (self):
        """Get the value of the {http://www.opengis.net/gml}Null element."""
        return self.__Null.value(self)
    def setNull (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}Null element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__Null.set(self, new_value)
    
    # Element {http://www.opengis.net/gml}Envelope uses Python identifier Envelope
    __Envelope = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'Envelope'), 'Envelope', '__BoundingShapeType_httpwww_opengis_netgmlEnvelope', False)
    def Envelope (self):
        """Get the value of the {http://www.opengis.net/gml}Envelope element."""
        return self.__Envelope.value(self)
    def setEnvelope (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}Envelope element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__Envelope.set(self, new_value)
    
    # Attribute nilReason uses Python identifier nilReason
    __nilReason = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'nilReason'), 'nilReason', '__BoundingShapeType_nilReason', NilReasonType)
    def nilReason (self):
        """Get the attribute value for nilReason."""
        return self.__nilReason.value(self)
    def setNilReason (self, new_value):
        """Set the attribute value for nilReason.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__nilReason.set(self, new_value)

    _ElementMap = {
        __Null.name() : __Null,
        __Envelope.name() : __Envelope
    }
    _AttributeMap = {
        __nilReason.name() : __nilReason
    }
Namespace.addCategoryObject('typeBinding', u'BoundingShapeType', BoundingShapeType)


# Complex type CRSPropertyType with content type ELEMENT_ONLY
class CRSPropertyType (pyxb.binding.basis.complexTypeDefinition):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'CRSPropertyType')
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.opengis.net/gml}AbstractCRS uses Python identifier AbstractCRS
    __AbstractCRS = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'AbstractCRS'), 'AbstractCRS', '__CRSPropertyType_httpwww_opengis_netgmlAbstractCRS', False)
    def AbstractCRS (self):
        """Get the value of the {http://www.opengis.net/gml}AbstractCRS element."""
        return self.__AbstractCRS.value(self)
    def setAbstractCRS (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}AbstractCRS element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__AbstractCRS.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}show uses Python identifier show
    __show = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'show'), 'show', '__CRSPropertyType_httpwww_w3_org1999xlinkshow', MODULEhttpwww_w3_org1999xlink.UNBOUNDNone_12)
    def show (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}show."""
        return self.__show.value(self)
    def setShow (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}show.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__show.set(self, new_value)
    
    # Attribute {http://www.opengis.net/gml}remoteSchema uses Python identifier remoteSchema
    __remoteSchema = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(Namespace, u'remoteSchema'), 'remoteSchema', '__CRSPropertyType_httpwww_opengis_netgmlremoteSchema', pyxb.binding.datatypes.anyURI)
    def remoteSchema (self):
        """Get the attribute value for {http://www.opengis.net/gml}remoteSchema."""
        return self.__remoteSchema.value(self)
    def setRemoteSchema (self, new_value):
        """Set the attribute value for {http://www.opengis.net/gml}remoteSchema.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__remoteSchema.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}arcrole uses Python identifier arcrole
    __arcrole = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'arcrole'), 'arcrole', '__CRSPropertyType_httpwww_w3_org1999xlinkarcrole', pyxb.binding.datatypes.anyURI)
    def arcrole (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}arcrole."""
        return self.__arcrole.value(self)
    def setArcrole (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}arcrole.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__arcrole.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}actuate uses Python identifier actuate
    __actuate = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'actuate'), 'actuate', '__CRSPropertyType_httpwww_w3_org1999xlinkactuate', MODULEhttpwww_w3_org1999xlink.UNBOUNDNone_13)
    def actuate (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}actuate."""
        return self.__actuate.value(self)
    def setActuate (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}actuate.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__actuate.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}type uses Python identifier type
    __type = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'type'), 'type', '__CRSPropertyType_httpwww_w3_org1999xlinktype', pyxb.binding.datatypes.string, fixed=True, unicode_default=u'simple')
    def type (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}type."""
        return self.__type.value(self)
    def setType (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}type.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__type.set(self, new_value)
    
    # Attribute nilReason uses Python identifier nilReason
    __nilReason = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'nilReason'), 'nilReason', '__CRSPropertyType_nilReason', NilReasonType)
    def nilReason (self):
        """Get the attribute value for nilReason."""
        return self.__nilReason.value(self)
    def setNilReason (self, new_value):
        """Set the attribute value for nilReason.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__nilReason.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}title uses Python identifier title
    __title = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'title'), 'title', '__CRSPropertyType_httpwww_w3_org1999xlinktitle', pyxb.binding.datatypes.string)
    def title (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}title."""
        return self.__title.value(self)
    def setTitle (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}title.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__title.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}role uses Python identifier role
    __role = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'role'), 'role', '__CRSPropertyType_httpwww_w3_org1999xlinkrole', pyxb.binding.datatypes.anyURI)
    def role (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}role."""
        return self.__role.value(self)
    def setRole (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}role.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__role.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}href uses Python identifier href
    __href = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'href'), 'href', '__CRSPropertyType_httpwww_w3_org1999xlinkhref', pyxb.binding.datatypes.anyURI)
    def href (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}href."""
        return self.__href.value(self)
    def setHref (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}href.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__href.set(self, new_value)

    _ElementMap = {
        __AbstractCRS.name() : __AbstractCRS
    }
    _AttributeMap = {
        __show.name() : __show,
        __remoteSchema.name() : __remoteSchema,
        __arcrole.name() : __arcrole,
        __actuate.name() : __actuate,
        __type.name() : __type,
        __nilReason.name() : __nilReason,
        __title.name() : __title,
        __role.name() : __role,
        __href.name() : __href
    }
Namespace.addCategoryObject('typeBinding', u'CRSPropertyType', CRSPropertyType)


# Complex type CartesianCSPropertyType with content type ELEMENT_ONLY
class CartesianCSPropertyType (pyxb.binding.basis.complexTypeDefinition):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'CartesianCSPropertyType')
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.opengis.net/gml}CartesianCS uses Python identifier CartesianCS
    __CartesianCS = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'CartesianCS'), 'CartesianCS', '__CartesianCSPropertyType_httpwww_opengis_netgmlCartesianCS', False)
    def CartesianCS (self):
        """Get the value of the {http://www.opengis.net/gml}CartesianCS element."""
        return self.__CartesianCS.value(self)
    def setCartesianCS (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}CartesianCS element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__CartesianCS.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}show uses Python identifier show
    __show = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'show'), 'show', '__CartesianCSPropertyType_httpwww_w3_org1999xlinkshow', MODULEhttpwww_w3_org1999xlink.UNBOUNDNone_14)
    def show (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}show."""
        return self.__show.value(self)
    def setShow (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}show.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__show.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}href uses Python identifier href
    __href = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'href'), 'href', '__CartesianCSPropertyType_httpwww_w3_org1999xlinkhref', pyxb.binding.datatypes.anyURI)
    def href (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}href."""
        return self.__href.value(self)
    def setHref (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}href.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__href.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}arcrole uses Python identifier arcrole
    __arcrole = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'arcrole'), 'arcrole', '__CartesianCSPropertyType_httpwww_w3_org1999xlinkarcrole', pyxb.binding.datatypes.anyURI)
    def arcrole (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}arcrole."""
        return self.__arcrole.value(self)
    def setArcrole (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}arcrole.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__arcrole.set(self, new_value)
    
    # Attribute {http://www.opengis.net/gml}remoteSchema uses Python identifier remoteSchema
    __remoteSchema = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(Namespace, u'remoteSchema'), 'remoteSchema', '__CartesianCSPropertyType_httpwww_opengis_netgmlremoteSchema', pyxb.binding.datatypes.anyURI)
    def remoteSchema (self):
        """Get the attribute value for {http://www.opengis.net/gml}remoteSchema."""
        return self.__remoteSchema.value(self)
    def setRemoteSchema (self, new_value):
        """Set the attribute value for {http://www.opengis.net/gml}remoteSchema.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__remoteSchema.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}type uses Python identifier type
    __type = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'type'), 'type', '__CartesianCSPropertyType_httpwww_w3_org1999xlinktype', pyxb.binding.datatypes.string, fixed=True, unicode_default=u'simple')
    def type (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}type."""
        return self.__type.value(self)
    def setType (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}type.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__type.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}actuate uses Python identifier actuate
    __actuate = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'actuate'), 'actuate', '__CartesianCSPropertyType_httpwww_w3_org1999xlinkactuate', MODULEhttpwww_w3_org1999xlink.UNBOUNDNone_15)
    def actuate (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}actuate."""
        return self.__actuate.value(self)
    def setActuate (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}actuate.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__actuate.set(self, new_value)
    
    # Attribute nilReason uses Python identifier nilReason
    __nilReason = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'nilReason'), 'nilReason', '__CartesianCSPropertyType_nilReason', NilReasonType)
    def nilReason (self):
        """Get the attribute value for nilReason."""
        return self.__nilReason.value(self)
    def setNilReason (self, new_value):
        """Set the attribute value for nilReason.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__nilReason.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}title uses Python identifier title
    __title = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'title'), 'title', '__CartesianCSPropertyType_httpwww_w3_org1999xlinktitle', pyxb.binding.datatypes.string)
    def title (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}title."""
        return self.__title.value(self)
    def setTitle (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}title.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__title.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}role uses Python identifier role
    __role = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'role'), 'role', '__CartesianCSPropertyType_httpwww_w3_org1999xlinkrole', pyxb.binding.datatypes.anyURI)
    def role (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}role."""
        return self.__role.value(self)
    def setRole (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}role.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__role.set(self, new_value)

    _ElementMap = {
        __CartesianCS.name() : __CartesianCS
    }
    _AttributeMap = {
        __show.name() : __show,
        __href.name() : __href,
        __arcrole.name() : __arcrole,
        __remoteSchema.name() : __remoteSchema,
        __type.name() : __type,
        __actuate.name() : __actuate,
        __nilReason.name() : __nilReason,
        __title.name() : __title,
        __role.name() : __role
    }
Namespace.addCategoryObject('typeBinding', u'CartesianCSPropertyType', CartesianCSPropertyType)


# Complex type CategoryPropertyType with content type ELEMENT_ONLY
class CategoryPropertyType (pyxb.binding.basis.complexTypeDefinition):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'CategoryPropertyType')
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.opengis.net/gml}Category uses Python identifier Category
    __Category = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'Category'), 'Category', '__CategoryPropertyType_httpwww_opengis_netgmlCategory', False)
    def Category (self):
        """Get the value of the {http://www.opengis.net/gml}Category element."""
        return self.__Category.value(self)
    def setCategory (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}Category element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__Category.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}show uses Python identifier show
    __show = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'show'), 'show', '__CategoryPropertyType_httpwww_w3_org1999xlinkshow', MODULEhttpwww_w3_org1999xlink.UNBOUNDNone_16)
    def show (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}show."""
        return self.__show.value(self)
    def setShow (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}show.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__show.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}href uses Python identifier href
    __href = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'href'), 'href', '__CategoryPropertyType_httpwww_w3_org1999xlinkhref', pyxb.binding.datatypes.anyURI)
    def href (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}href."""
        return self.__href.value(self)
    def setHref (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}href.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__href.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}arcrole uses Python identifier arcrole
    __arcrole = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'arcrole'), 'arcrole', '__CategoryPropertyType_httpwww_w3_org1999xlinkarcrole', pyxb.binding.datatypes.anyURI)
    def arcrole (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}arcrole."""
        return self.__arcrole.value(self)
    def setArcrole (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}arcrole.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__arcrole.set(self, new_value)
    
    # Attribute {http://www.opengis.net/gml}remoteSchema uses Python identifier remoteSchema
    __remoteSchema = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(Namespace, u'remoteSchema'), 'remoteSchema', '__CategoryPropertyType_httpwww_opengis_netgmlremoteSchema', pyxb.binding.datatypes.anyURI)
    def remoteSchema (self):
        """Get the attribute value for {http://www.opengis.net/gml}remoteSchema."""
        return self.__remoteSchema.value(self)
    def setRemoteSchema (self, new_value):
        """Set the attribute value for {http://www.opengis.net/gml}remoteSchema.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__remoteSchema.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}actuate uses Python identifier actuate
    __actuate = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'actuate'), 'actuate', '__CategoryPropertyType_httpwww_w3_org1999xlinkactuate', MODULEhttpwww_w3_org1999xlink.UNBOUNDNone_17)
    def actuate (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}actuate."""
        return self.__actuate.value(self)
    def setActuate (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}actuate.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__actuate.set(self, new_value)
    
    # Attribute nilReason uses Python identifier nilReason
    __nilReason = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'nilReason'), 'nilReason', '__CategoryPropertyType_nilReason', NilReasonType)
    def nilReason (self):
        """Get the attribute value for nilReason."""
        return self.__nilReason.value(self)
    def setNilReason (self, new_value):
        """Set the attribute value for nilReason.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__nilReason.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}type uses Python identifier type
    __type = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'type'), 'type', '__CategoryPropertyType_httpwww_w3_org1999xlinktype', pyxb.binding.datatypes.string, fixed=True, unicode_default=u'simple')
    def type (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}type."""
        return self.__type.value(self)
    def setType (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}type.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__type.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}title uses Python identifier title
    __title = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'title'), 'title', '__CategoryPropertyType_httpwww_w3_org1999xlinktitle', pyxb.binding.datatypes.string)
    def title (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}title."""
        return self.__title.value(self)
    def setTitle (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}title.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__title.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}role uses Python identifier role
    __role = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'role'), 'role', '__CategoryPropertyType_httpwww_w3_org1999xlinkrole', pyxb.binding.datatypes.anyURI)
    def role (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}role."""
        return self.__role.value(self)
    def setRole (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}role.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__role.set(self, new_value)

    _ElementMap = {
        __Category.name() : __Category
    }
    _AttributeMap = {
        __show.name() : __show,
        __href.name() : __href,
        __arcrole.name() : __arcrole,
        __remoteSchema.name() : __remoteSchema,
        __actuate.name() : __actuate,
        __nilReason.name() : __nilReason,
        __type.name() : __type,
        __title.name() : __title,
        __role.name() : __role
    }
Namespace.addCategoryObject('typeBinding', u'CategoryPropertyType', CategoryPropertyType)


# Complex type CodeListType with content type SIMPLE
class CodeListType (pyxb.binding.basis.complexTypeDefinition):
    _TypeDefinition = NameList
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_SIMPLE
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'CodeListType')
    # Base type is NameList
    
    # Attribute codeSpace uses Python identifier codeSpace
    __codeSpace = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'codeSpace'), 'codeSpace', '__CodeListType_codeSpace', pyxb.binding.datatypes.anyURI)
    def codeSpace (self):
        """Get the attribute value for codeSpace."""
        return self.__codeSpace.value(self)
    def setCodeSpace (self, new_value):
        """Set the attribute value for codeSpace.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__codeSpace.set(self, new_value)

    _ElementMap = {
        
    }
    _AttributeMap = {
        __codeSpace.name() : __codeSpace
    }
Namespace.addCategoryObject('typeBinding', u'CodeListType', CodeListType)


# Complex type CodeOrNilReasonListType with content type SIMPLE
class CodeOrNilReasonListType (pyxb.binding.basis.complexTypeDefinition):
    _TypeDefinition = NameOrNilReasonList
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_SIMPLE
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'CodeOrNilReasonListType')
    # Base type is NameOrNilReasonList
    
    # Attribute codeSpace uses Python identifier codeSpace
    __codeSpace = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'codeSpace'), 'codeSpace', '__CodeOrNilReasonListType_codeSpace', pyxb.binding.datatypes.anyURI)
    def codeSpace (self):
        """Get the attribute value for codeSpace."""
        return self.__codeSpace.value(self)
    def setCodeSpace (self, new_value):
        """Set the attribute value for codeSpace.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__codeSpace.set(self, new_value)

    _ElementMap = {
        
    }
    _AttributeMap = {
        __codeSpace.name() : __codeSpace
    }
Namespace.addCategoryObject('typeBinding', u'CodeOrNilReasonListType', CodeOrNilReasonListType)


# Complex type CodeType with content type SIMPLE
class CodeType (pyxb.binding.basis.complexTypeDefinition):
    _TypeDefinition = pyxb.binding.datatypes.string
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_SIMPLE
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'CodeType')
    # Base type is pyxb.binding.datatypes.string
    
    # Attribute codeSpace uses Python identifier codeSpace
    __codeSpace = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'codeSpace'), 'codeSpace', '__CodeType_codeSpace', pyxb.binding.datatypes.anyURI)
    def codeSpace (self):
        """Get the attribute value for codeSpace."""
        return self.__codeSpace.value(self)
    def setCodeSpace (self, new_value):
        """Set the attribute value for codeSpace.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__codeSpace.set(self, new_value)

    _ElementMap = {
        
    }
    _AttributeMap = {
        __codeSpace.name() : __codeSpace
    }
Namespace.addCategoryObject('typeBinding', u'CodeType', CodeType)


# Complex type CompoundCRSPropertyType with content type ELEMENT_ONLY
class CompoundCRSPropertyType (pyxb.binding.basis.complexTypeDefinition):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'CompoundCRSPropertyType')
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.opengis.net/gml}CompoundCRS uses Python identifier CompoundCRS
    __CompoundCRS = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'CompoundCRS'), 'CompoundCRS', '__CompoundCRSPropertyType_httpwww_opengis_netgmlCompoundCRS', False)
    def CompoundCRS (self):
        """Get the value of the {http://www.opengis.net/gml}CompoundCRS element."""
        return self.__CompoundCRS.value(self)
    def setCompoundCRS (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}CompoundCRS element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__CompoundCRS.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}show uses Python identifier show
    __show = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'show'), 'show', '__CompoundCRSPropertyType_httpwww_w3_org1999xlinkshow', MODULEhttpwww_w3_org1999xlink.UNBOUNDNone_18)
    def show (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}show."""
        return self.__show.value(self)
    def setShow (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}show.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__show.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}href uses Python identifier href
    __href = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'href'), 'href', '__CompoundCRSPropertyType_httpwww_w3_org1999xlinkhref', pyxb.binding.datatypes.anyURI)
    def href (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}href."""
        return self.__href.value(self)
    def setHref (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}href.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__href.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}arcrole uses Python identifier arcrole
    __arcrole = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'arcrole'), 'arcrole', '__CompoundCRSPropertyType_httpwww_w3_org1999xlinkarcrole', pyxb.binding.datatypes.anyURI)
    def arcrole (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}arcrole."""
        return self.__arcrole.value(self)
    def setArcrole (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}arcrole.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__arcrole.set(self, new_value)
    
    # Attribute {http://www.opengis.net/gml}remoteSchema uses Python identifier remoteSchema
    __remoteSchema = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(Namespace, u'remoteSchema'), 'remoteSchema', '__CompoundCRSPropertyType_httpwww_opengis_netgmlremoteSchema', pyxb.binding.datatypes.anyURI)
    def remoteSchema (self):
        """Get the attribute value for {http://www.opengis.net/gml}remoteSchema."""
        return self.__remoteSchema.value(self)
    def setRemoteSchema (self, new_value):
        """Set the attribute value for {http://www.opengis.net/gml}remoteSchema.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__remoteSchema.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}actuate uses Python identifier actuate
    __actuate = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'actuate'), 'actuate', '__CompoundCRSPropertyType_httpwww_w3_org1999xlinkactuate', MODULEhttpwww_w3_org1999xlink.UNBOUNDNone_19)
    def actuate (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}actuate."""
        return self.__actuate.value(self)
    def setActuate (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}actuate.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__actuate.set(self, new_value)
    
    # Attribute nilReason uses Python identifier nilReason
    __nilReason = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'nilReason'), 'nilReason', '__CompoundCRSPropertyType_nilReason', NilReasonType)
    def nilReason (self):
        """Get the attribute value for nilReason."""
        return self.__nilReason.value(self)
    def setNilReason (self, new_value):
        """Set the attribute value for nilReason.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__nilReason.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}title uses Python identifier title
    __title = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'title'), 'title', '__CompoundCRSPropertyType_httpwww_w3_org1999xlinktitle', pyxb.binding.datatypes.string)
    def title (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}title."""
        return self.__title.value(self)
    def setTitle (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}title.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__title.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}role uses Python identifier role
    __role = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'role'), 'role', '__CompoundCRSPropertyType_httpwww_w3_org1999xlinkrole', pyxb.binding.datatypes.anyURI)
    def role (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}role."""
        return self.__role.value(self)
    def setRole (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}role.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__role.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}type uses Python identifier type
    __type = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'type'), 'type', '__CompoundCRSPropertyType_httpwww_w3_org1999xlinktype', pyxb.binding.datatypes.string, fixed=True, unicode_default=u'simple')
    def type (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}type."""
        return self.__type.value(self)
    def setType (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}type.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__type.set(self, new_value)

    _ElementMap = {
        __CompoundCRS.name() : __CompoundCRS
    }
    _AttributeMap = {
        __show.name() : __show,
        __href.name() : __href,
        __arcrole.name() : __arcrole,
        __remoteSchema.name() : __remoteSchema,
        __actuate.name() : __actuate,
        __nilReason.name() : __nilReason,
        __title.name() : __title,
        __role.name() : __role,
        __type.name() : __type
    }
Namespace.addCategoryObject('typeBinding', u'CompoundCRSPropertyType', CompoundCRSPropertyType)


# Complex type ConcatenatedOperationPropertyType with content type ELEMENT_ONLY
class ConcatenatedOperationPropertyType (pyxb.binding.basis.complexTypeDefinition):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'ConcatenatedOperationPropertyType')
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.opengis.net/gml}ConcatenatedOperation uses Python identifier ConcatenatedOperation
    __ConcatenatedOperation = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'ConcatenatedOperation'), 'ConcatenatedOperation', '__ConcatenatedOperationPropertyType_httpwww_opengis_netgmlConcatenatedOperation', False)
    def ConcatenatedOperation (self):
        """Get the value of the {http://www.opengis.net/gml}ConcatenatedOperation element."""
        return self.__ConcatenatedOperation.value(self)
    def setConcatenatedOperation (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}ConcatenatedOperation element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__ConcatenatedOperation.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}show uses Python identifier show
    __show = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'show'), 'show', '__ConcatenatedOperationPropertyType_httpwww_w3_org1999xlinkshow', MODULEhttpwww_w3_org1999xlink.UNBOUNDNone_20)
    def show (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}show."""
        return self.__show.value(self)
    def setShow (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}show.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__show.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}title uses Python identifier title
    __title = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'title'), 'title', '__ConcatenatedOperationPropertyType_httpwww_w3_org1999xlinktitle', pyxb.binding.datatypes.string)
    def title (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}title."""
        return self.__title.value(self)
    def setTitle (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}title.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__title.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}role uses Python identifier role
    __role = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'role'), 'role', '__ConcatenatedOperationPropertyType_httpwww_w3_org1999xlinkrole', pyxb.binding.datatypes.anyURI)
    def role (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}role."""
        return self.__role.value(self)
    def setRole (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}role.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__role.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}actuate uses Python identifier actuate
    __actuate = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'actuate'), 'actuate', '__ConcatenatedOperationPropertyType_httpwww_w3_org1999xlinkactuate', MODULEhttpwww_w3_org1999xlink.UNBOUNDNone_21)
    def actuate (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}actuate."""
        return self.__actuate.value(self)
    def setActuate (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}actuate.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__actuate.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}arcrole uses Python identifier arcrole
    __arcrole = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'arcrole'), 'arcrole', '__ConcatenatedOperationPropertyType_httpwww_w3_org1999xlinkarcrole', pyxb.binding.datatypes.anyURI)
    def arcrole (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}arcrole."""
        return self.__arcrole.value(self)
    def setArcrole (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}arcrole.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__arcrole.set(self, new_value)
    
    # Attribute nilReason uses Python identifier nilReason
    __nilReason = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'nilReason'), 'nilReason', '__ConcatenatedOperationPropertyType_nilReason', NilReasonType)
    def nilReason (self):
        """Get the attribute value for nilReason."""
        return self.__nilReason.value(self)
    def setNilReason (self, new_value):
        """Set the attribute value for nilReason.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__nilReason.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}href uses Python identifier href
    __href = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'href'), 'href', '__ConcatenatedOperationPropertyType_httpwww_w3_org1999xlinkhref', pyxb.binding.datatypes.anyURI)
    def href (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}href."""
        return self.__href.value(self)
    def setHref (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}href.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__href.set(self, new_value)
    
    # Attribute {http://www.opengis.net/gml}remoteSchema uses Python identifier remoteSchema
    __remoteSchema = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(Namespace, u'remoteSchema'), 'remoteSchema', '__ConcatenatedOperationPropertyType_httpwww_opengis_netgmlremoteSchema', pyxb.binding.datatypes.anyURI)
    def remoteSchema (self):
        """Get the attribute value for {http://www.opengis.net/gml}remoteSchema."""
        return self.__remoteSchema.value(self)
    def setRemoteSchema (self, new_value):
        """Set the attribute value for {http://www.opengis.net/gml}remoteSchema.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__remoteSchema.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}type uses Python identifier type
    __type = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'type'), 'type', '__ConcatenatedOperationPropertyType_httpwww_w3_org1999xlinktype', pyxb.binding.datatypes.string, fixed=True, unicode_default=u'simple')
    def type (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}type."""
        return self.__type.value(self)
    def setType (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}type.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__type.set(self, new_value)

    _ElementMap = {
        __ConcatenatedOperation.name() : __ConcatenatedOperation
    }
    _AttributeMap = {
        __show.name() : __show,
        __title.name() : __title,
        __role.name() : __role,
        __actuate.name() : __actuate,
        __arcrole.name() : __arcrole,
        __nilReason.name() : __nilReason,
        __href.name() : __href,
        __remoteSchema.name() : __remoteSchema,
        __type.name() : __type
    }
Namespace.addCategoryObject('typeBinding', u'ConcatenatedOperationPropertyType', ConcatenatedOperationPropertyType)


# Complex type ContainerPropertyType with content type ELEMENT_ONLY
class ContainerPropertyType (pyxb.binding.basis.complexTypeDefinition):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'ContainerPropertyType')
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.opengis.net/gml}TopoSolid uses Python identifier TopoSolid
    __TopoSolid = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'TopoSolid'), 'TopoSolid', '__ContainerPropertyType_httpwww_opengis_netgmlTopoSolid', False)
    def TopoSolid (self):
        """Get the value of the {http://www.opengis.net/gml}TopoSolid element."""
        return self.__TopoSolid.value(self)
    def setTopoSolid (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}TopoSolid element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__TopoSolid.set(self, new_value)
    
    # Element {http://www.opengis.net/gml}Face uses Python identifier Face
    __Face = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'Face'), 'Face', '__ContainerPropertyType_httpwww_opengis_netgmlFace', False)
    def Face (self):
        """Get the value of the {http://www.opengis.net/gml}Face element."""
        return self.__Face.value(self)
    def setFace (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}Face element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__Face.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}role uses Python identifier role
    __role = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'role'), 'role', '__ContainerPropertyType_httpwww_w3_org1999xlinkrole', pyxb.binding.datatypes.anyURI)
    def role (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}role."""
        return self.__role.value(self)
    def setRole (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}role.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__role.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}show uses Python identifier show
    __show = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'show'), 'show', '__ContainerPropertyType_httpwww_w3_org1999xlinkshow', MODULEhttpwww_w3_org1999xlink.UNBOUNDNone_22)
    def show (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}show."""
        return self.__show.value(self)
    def setShow (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}show.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__show.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}href uses Python identifier href
    __href = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'href'), 'href', '__ContainerPropertyType_httpwww_w3_org1999xlinkhref', pyxb.binding.datatypes.anyURI)
    def href (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}href."""
        return self.__href.value(self)
    def setHref (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}href.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__href.set(self, new_value)
    
    # Attribute owns uses Python identifier owns
    __owns = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'owns'), 'owns', '__ContainerPropertyType_owns', pyxb.binding.datatypes.boolean, unicode_default=u'false')
    def owns (self):
        """Get the attribute value for owns."""
        return self.__owns.value(self)
    def setOwns (self, new_value):
        """Set the attribute value for owns.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__owns.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}arcrole uses Python identifier arcrole
    __arcrole = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'arcrole'), 'arcrole', '__ContainerPropertyType_httpwww_w3_org1999xlinkarcrole', pyxb.binding.datatypes.anyURI)
    def arcrole (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}arcrole."""
        return self.__arcrole.value(self)
    def setArcrole (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}arcrole.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__arcrole.set(self, new_value)
    
    # Attribute {http://www.opengis.net/gml}remoteSchema uses Python identifier remoteSchema
    __remoteSchema = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(Namespace, u'remoteSchema'), 'remoteSchema', '__ContainerPropertyType_httpwww_opengis_netgmlremoteSchema', pyxb.binding.datatypes.anyURI)
    def remoteSchema (self):
        """Get the attribute value for {http://www.opengis.net/gml}remoteSchema."""
        return self.__remoteSchema.value(self)
    def setRemoteSchema (self, new_value):
        """Set the attribute value for {http://www.opengis.net/gml}remoteSchema.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__remoteSchema.set(self, new_value)
    
    # Attribute nilReason uses Python identifier nilReason
    __nilReason = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'nilReason'), 'nilReason', '__ContainerPropertyType_nilReason', NilReasonType)
    def nilReason (self):
        """Get the attribute value for nilReason."""
        return self.__nilReason.value(self)
    def setNilReason (self, new_value):
        """Set the attribute value for nilReason.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__nilReason.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}actuate uses Python identifier actuate
    __actuate = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'actuate'), 'actuate', '__ContainerPropertyType_httpwww_w3_org1999xlinkactuate', MODULEhttpwww_w3_org1999xlink.UNBOUNDNone_23)
    def actuate (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}actuate."""
        return self.__actuate.value(self)
    def setActuate (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}actuate.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__actuate.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}type uses Python identifier type
    __type = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'type'), 'type', '__ContainerPropertyType_httpwww_w3_org1999xlinktype', pyxb.binding.datatypes.string, fixed=True, unicode_default=u'simple')
    def type (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}type."""
        return self.__type.value(self)
    def setType (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}type.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__type.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}title uses Python identifier title
    __title = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'title'), 'title', '__ContainerPropertyType_httpwww_w3_org1999xlinktitle', pyxb.binding.datatypes.string)
    def title (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}title."""
        return self.__title.value(self)
    def setTitle (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}title.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__title.set(self, new_value)

    _ElementMap = {
        __TopoSolid.name() : __TopoSolid,
        __Face.name() : __Face
    }
    _AttributeMap = {
        __role.name() : __role,
        __show.name() : __show,
        __href.name() : __href,
        __owns.name() : __owns,
        __arcrole.name() : __arcrole,
        __remoteSchema.name() : __remoteSchema,
        __nilReason.name() : __nilReason,
        __actuate.name() : __actuate,
        __type.name() : __type,
        __title.name() : __title
    }
Namespace.addCategoryObject('typeBinding', u'ContainerPropertyType', ContainerPropertyType)


# Complex type ConversionPropertyType with content type ELEMENT_ONLY
class ConversionPropertyType (pyxb.binding.basis.complexTypeDefinition):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'ConversionPropertyType')
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.opengis.net/gml}Conversion uses Python identifier Conversion
    __Conversion = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'Conversion'), 'Conversion', '__ConversionPropertyType_httpwww_opengis_netgmlConversion', False)
    def Conversion (self):
        """Get the value of the {http://www.opengis.net/gml}Conversion element."""
        return self.__Conversion.value(self)
    def setConversion (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}Conversion element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__Conversion.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}show uses Python identifier show
    __show = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'show'), 'show', '__ConversionPropertyType_httpwww_w3_org1999xlinkshow', MODULEhttpwww_w3_org1999xlink.UNBOUNDNone_24)
    def show (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}show."""
        return self.__show.value(self)
    def setShow (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}show.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__show.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}title uses Python identifier title
    __title = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'title'), 'title', '__ConversionPropertyType_httpwww_w3_org1999xlinktitle', pyxb.binding.datatypes.string)
    def title (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}title."""
        return self.__title.value(self)
    def setTitle (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}title.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__title.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}actuate uses Python identifier actuate
    __actuate = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'actuate'), 'actuate', '__ConversionPropertyType_httpwww_w3_org1999xlinkactuate', MODULEhttpwww_w3_org1999xlink.UNBOUNDNone_25)
    def actuate (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}actuate."""
        return self.__actuate.value(self)
    def setActuate (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}actuate.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__actuate.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}role uses Python identifier role
    __role = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'role'), 'role', '__ConversionPropertyType_httpwww_w3_org1999xlinkrole', pyxb.binding.datatypes.anyURI)
    def role (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}role."""
        return self.__role.value(self)
    def setRole (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}role.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__role.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}arcrole uses Python identifier arcrole
    __arcrole = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'arcrole'), 'arcrole', '__ConversionPropertyType_httpwww_w3_org1999xlinkarcrole', pyxb.binding.datatypes.anyURI)
    def arcrole (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}arcrole."""
        return self.__arcrole.value(self)
    def setArcrole (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}arcrole.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__arcrole.set(self, new_value)
    
    # Attribute nilReason uses Python identifier nilReason
    __nilReason = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'nilReason'), 'nilReason', '__ConversionPropertyType_nilReason', NilReasonType)
    def nilReason (self):
        """Get the attribute value for nilReason."""
        return self.__nilReason.value(self)
    def setNilReason (self, new_value):
        """Set the attribute value for nilReason.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__nilReason.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}href uses Python identifier href
    __href = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'href'), 'href', '__ConversionPropertyType_httpwww_w3_org1999xlinkhref', pyxb.binding.datatypes.anyURI)
    def href (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}href."""
        return self.__href.value(self)
    def setHref (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}href.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__href.set(self, new_value)
    
    # Attribute {http://www.opengis.net/gml}remoteSchema uses Python identifier remoteSchema
    __remoteSchema = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(Namespace, u'remoteSchema'), 'remoteSchema', '__ConversionPropertyType_httpwww_opengis_netgmlremoteSchema', pyxb.binding.datatypes.anyURI)
    def remoteSchema (self):
        """Get the attribute value for {http://www.opengis.net/gml}remoteSchema."""
        return self.__remoteSchema.value(self)
    def setRemoteSchema (self, new_value):
        """Set the attribute value for {http://www.opengis.net/gml}remoteSchema.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__remoteSchema.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}type uses Python identifier type
    __type = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'type'), 'type', '__ConversionPropertyType_httpwww_w3_org1999xlinktype', pyxb.binding.datatypes.string, fixed=True, unicode_default=u'simple')
    def type (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}type."""
        return self.__type.value(self)
    def setType (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}type.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__type.set(self, new_value)

    _ElementMap = {
        __Conversion.name() : __Conversion
    }
    _AttributeMap = {
        __show.name() : __show,
        __title.name() : __title,
        __actuate.name() : __actuate,
        __role.name() : __role,
        __arcrole.name() : __arcrole,
        __nilReason.name() : __nilReason,
        __href.name() : __href,
        __remoteSchema.name() : __remoteSchema,
        __type.name() : __type
    }
Namespace.addCategoryObject('typeBinding', u'ConversionPropertyType', ConversionPropertyType)


# Complex type CoordinateOperationPropertyType with content type ELEMENT_ONLY
class CoordinateOperationPropertyType (pyxb.binding.basis.complexTypeDefinition):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'CoordinateOperationPropertyType')
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.opengis.net/gml}AbstractCoordinateOperation uses Python identifier AbstractCoordinateOperation
    __AbstractCoordinateOperation = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'AbstractCoordinateOperation'), 'AbstractCoordinateOperation', '__CoordinateOperationPropertyType_httpwww_opengis_netgmlAbstractCoordinateOperation', False)
    def AbstractCoordinateOperation (self):
        """Get the value of the {http://www.opengis.net/gml}AbstractCoordinateOperation element."""
        return self.__AbstractCoordinateOperation.value(self)
    def setAbstractCoordinateOperation (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}AbstractCoordinateOperation element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__AbstractCoordinateOperation.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}show uses Python identifier show
    __show = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'show'), 'show', '__CoordinateOperationPropertyType_httpwww_w3_org1999xlinkshow', MODULEhttpwww_w3_org1999xlink.UNBOUNDNone_26)
    def show (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}show."""
        return self.__show.value(self)
    def setShow (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}show.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__show.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}role uses Python identifier role
    __role = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'role'), 'role', '__CoordinateOperationPropertyType_httpwww_w3_org1999xlinkrole', pyxb.binding.datatypes.anyURI)
    def role (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}role."""
        return self.__role.value(self)
    def setRole (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}role.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__role.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}href uses Python identifier href
    __href = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'href'), 'href', '__CoordinateOperationPropertyType_httpwww_w3_org1999xlinkhref', pyxb.binding.datatypes.anyURI)
    def href (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}href."""
        return self.__href.value(self)
    def setHref (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}href.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__href.set(self, new_value)
    
    # Attribute nilReason uses Python identifier nilReason
    __nilReason = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'nilReason'), 'nilReason', '__CoordinateOperationPropertyType_nilReason', NilReasonType)
    def nilReason (self):
        """Get the attribute value for nilReason."""
        return self.__nilReason.value(self)
    def setNilReason (self, new_value):
        """Set the attribute value for nilReason.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__nilReason.set(self, new_value)
    
    # Attribute {http://www.opengis.net/gml}remoteSchema uses Python identifier remoteSchema
    __remoteSchema = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(Namespace, u'remoteSchema'), 'remoteSchema', '__CoordinateOperationPropertyType_httpwww_opengis_netgmlremoteSchema', pyxb.binding.datatypes.anyURI)
    def remoteSchema (self):
        """Get the attribute value for {http://www.opengis.net/gml}remoteSchema."""
        return self.__remoteSchema.value(self)
    def setRemoteSchema (self, new_value):
        """Set the attribute value for {http://www.opengis.net/gml}remoteSchema.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__remoteSchema.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}actuate uses Python identifier actuate
    __actuate = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'actuate'), 'actuate', '__CoordinateOperationPropertyType_httpwww_w3_org1999xlinkactuate', MODULEhttpwww_w3_org1999xlink.UNBOUNDNone_27)
    def actuate (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}actuate."""
        return self.__actuate.value(self)
    def setActuate (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}actuate.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__actuate.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}type uses Python identifier type
    __type = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'type'), 'type', '__CoordinateOperationPropertyType_httpwww_w3_org1999xlinktype', pyxb.binding.datatypes.string, fixed=True, unicode_default=u'simple')
    def type (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}type."""
        return self.__type.value(self)
    def setType (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}type.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__type.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}arcrole uses Python identifier arcrole
    __arcrole = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'arcrole'), 'arcrole', '__CoordinateOperationPropertyType_httpwww_w3_org1999xlinkarcrole', pyxb.binding.datatypes.anyURI)
    def arcrole (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}arcrole."""
        return self.__arcrole.value(self)
    def setArcrole (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}arcrole.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__arcrole.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}title uses Python identifier title
    __title = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'title'), 'title', '__CoordinateOperationPropertyType_httpwww_w3_org1999xlinktitle', pyxb.binding.datatypes.string)
    def title (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}title."""
        return self.__title.value(self)
    def setTitle (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}title.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__title.set(self, new_value)

    _ElementMap = {
        __AbstractCoordinateOperation.name() : __AbstractCoordinateOperation
    }
    _AttributeMap = {
        __show.name() : __show,
        __role.name() : __role,
        __href.name() : __href,
        __nilReason.name() : __nilReason,
        __remoteSchema.name() : __remoteSchema,
        __actuate.name() : __actuate,
        __type.name() : __type,
        __arcrole.name() : __arcrole,
        __title.name() : __title
    }
Namespace.addCategoryObject('typeBinding', u'CoordinateOperationPropertyType', CoordinateOperationPropertyType)


# Complex type CoordinateSystemAxisPropertyType with content type ELEMENT_ONLY
class CoordinateSystemAxisPropertyType (pyxb.binding.basis.complexTypeDefinition):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'CoordinateSystemAxisPropertyType')
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.opengis.net/gml}CoordinateSystemAxis uses Python identifier CoordinateSystemAxis
    __CoordinateSystemAxis = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'CoordinateSystemAxis'), 'CoordinateSystemAxis', '__CoordinateSystemAxisPropertyType_httpwww_opengis_netgmlCoordinateSystemAxis', False)
    def CoordinateSystemAxis (self):
        """Get the value of the {http://www.opengis.net/gml}CoordinateSystemAxis element."""
        return self.__CoordinateSystemAxis.value(self)
    def setCoordinateSystemAxis (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}CoordinateSystemAxis element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__CoordinateSystemAxis.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}show uses Python identifier show
    __show = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'show'), 'show', '__CoordinateSystemAxisPropertyType_httpwww_w3_org1999xlinkshow', MODULEhttpwww_w3_org1999xlink.UNBOUNDNone_28)
    def show (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}show."""
        return self.__show.value(self)
    def setShow (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}show.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__show.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}arcrole uses Python identifier arcrole
    __arcrole = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'arcrole'), 'arcrole', '__CoordinateSystemAxisPropertyType_httpwww_w3_org1999xlinkarcrole', pyxb.binding.datatypes.anyURI)
    def arcrole (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}arcrole."""
        return self.__arcrole.value(self)
    def setArcrole (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}arcrole.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__arcrole.set(self, new_value)
    
    # Attribute {http://www.opengis.net/gml}remoteSchema uses Python identifier remoteSchema
    __remoteSchema = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(Namespace, u'remoteSchema'), 'remoteSchema', '__CoordinateSystemAxisPropertyType_httpwww_opengis_netgmlremoteSchema', pyxb.binding.datatypes.anyURI)
    def remoteSchema (self):
        """Get the attribute value for {http://www.opengis.net/gml}remoteSchema."""
        return self.__remoteSchema.value(self)
    def setRemoteSchema (self, new_value):
        """Set the attribute value for {http://www.opengis.net/gml}remoteSchema.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__remoteSchema.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}actuate uses Python identifier actuate
    __actuate = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'actuate'), 'actuate', '__CoordinateSystemAxisPropertyType_httpwww_w3_org1999xlinkactuate', MODULEhttpwww_w3_org1999xlink.UNBOUNDNone_29)
    def actuate (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}actuate."""
        return self.__actuate.value(self)
    def setActuate (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}actuate.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__actuate.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}type uses Python identifier type
    __type = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'type'), 'type', '__CoordinateSystemAxisPropertyType_httpwww_w3_org1999xlinktype', pyxb.binding.datatypes.string, fixed=True, unicode_default=u'simple')
    def type (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}type."""
        return self.__type.value(self)
    def setType (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}type.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__type.set(self, new_value)
    
    # Attribute nilReason uses Python identifier nilReason
    __nilReason = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'nilReason'), 'nilReason', '__CoordinateSystemAxisPropertyType_nilReason', NilReasonType)
    def nilReason (self):
        """Get the attribute value for nilReason."""
        return self.__nilReason.value(self)
    def setNilReason (self, new_value):
        """Set the attribute value for nilReason.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__nilReason.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}title uses Python identifier title
    __title = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'title'), 'title', '__CoordinateSystemAxisPropertyType_httpwww_w3_org1999xlinktitle', pyxb.binding.datatypes.string)
    def title (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}title."""
        return self.__title.value(self)
    def setTitle (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}title.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__title.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}role uses Python identifier role
    __role = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'role'), 'role', '__CoordinateSystemAxisPropertyType_httpwww_w3_org1999xlinkrole', pyxb.binding.datatypes.anyURI)
    def role (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}role."""
        return self.__role.value(self)
    def setRole (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}role.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__role.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}href uses Python identifier href
    __href = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'href'), 'href', '__CoordinateSystemAxisPropertyType_httpwww_w3_org1999xlinkhref', pyxb.binding.datatypes.anyURI)
    def href (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}href."""
        return self.__href.value(self)
    def setHref (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}href.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__href.set(self, new_value)

    _ElementMap = {
        __CoordinateSystemAxis.name() : __CoordinateSystemAxis
    }
    _AttributeMap = {
        __show.name() : __show,
        __arcrole.name() : __arcrole,
        __remoteSchema.name() : __remoteSchema,
        __actuate.name() : __actuate,
        __type.name() : __type,
        __nilReason.name() : __nilReason,
        __title.name() : __title,
        __role.name() : __role,
        __href.name() : __href
    }
Namespace.addCategoryObject('typeBinding', u'CoordinateSystemAxisPropertyType', CoordinateSystemAxisPropertyType)


# Complex type CoordinateSystemPropertyType with content type ELEMENT_ONLY
class CoordinateSystemPropertyType (pyxb.binding.basis.complexTypeDefinition):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'CoordinateSystemPropertyType')
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.opengis.net/gml}AbstractCoordinateSystem uses Python identifier AbstractCoordinateSystem
    __AbstractCoordinateSystem = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'AbstractCoordinateSystem'), 'AbstractCoordinateSystem', '__CoordinateSystemPropertyType_httpwww_opengis_netgmlAbstractCoordinateSystem', False)
    def AbstractCoordinateSystem (self):
        """Get the value of the {http://www.opengis.net/gml}AbstractCoordinateSystem element."""
        return self.__AbstractCoordinateSystem.value(self)
    def setAbstractCoordinateSystem (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}AbstractCoordinateSystem element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__AbstractCoordinateSystem.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}href uses Python identifier href
    __href = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'href'), 'href', '__CoordinateSystemPropertyType_httpwww_w3_org1999xlinkhref', pyxb.binding.datatypes.anyURI)
    def href (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}href."""
        return self.__href.value(self)
    def setHref (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}href.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__href.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}show uses Python identifier show
    __show = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'show'), 'show', '__CoordinateSystemPropertyType_httpwww_w3_org1999xlinkshow', MODULEhttpwww_w3_org1999xlink.UNBOUNDNone_30)
    def show (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}show."""
        return self.__show.value(self)
    def setShow (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}show.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__show.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}arcrole uses Python identifier arcrole
    __arcrole = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'arcrole'), 'arcrole', '__CoordinateSystemPropertyType_httpwww_w3_org1999xlinkarcrole', pyxb.binding.datatypes.anyURI)
    def arcrole (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}arcrole."""
        return self.__arcrole.value(self)
    def setArcrole (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}arcrole.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__arcrole.set(self, new_value)
    
    # Attribute {http://www.opengis.net/gml}remoteSchema uses Python identifier remoteSchema
    __remoteSchema = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(Namespace, u'remoteSchema'), 'remoteSchema', '__CoordinateSystemPropertyType_httpwww_opengis_netgmlremoteSchema', pyxb.binding.datatypes.anyURI)
    def remoteSchema (self):
        """Get the attribute value for {http://www.opengis.net/gml}remoteSchema."""
        return self.__remoteSchema.value(self)
    def setRemoteSchema (self, new_value):
        """Set the attribute value for {http://www.opengis.net/gml}remoteSchema.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__remoteSchema.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}actuate uses Python identifier actuate
    __actuate = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'actuate'), 'actuate', '__CoordinateSystemPropertyType_httpwww_w3_org1999xlinkactuate', MODULEhttpwww_w3_org1999xlink.UNBOUNDNone_31)
    def actuate (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}actuate."""
        return self.__actuate.value(self)
    def setActuate (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}actuate.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__actuate.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}type uses Python identifier type
    __type = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'type'), 'type', '__CoordinateSystemPropertyType_httpwww_w3_org1999xlinktype', pyxb.binding.datatypes.string, fixed=True, unicode_default=u'simple')
    def type (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}type."""
        return self.__type.value(self)
    def setType (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}type.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__type.set(self, new_value)
    
    # Attribute nilReason uses Python identifier nilReason
    __nilReason = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'nilReason'), 'nilReason', '__CoordinateSystemPropertyType_nilReason', NilReasonType)
    def nilReason (self):
        """Get the attribute value for nilReason."""
        return self.__nilReason.value(self)
    def setNilReason (self, new_value):
        """Set the attribute value for nilReason.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__nilReason.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}title uses Python identifier title
    __title = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'title'), 'title', '__CoordinateSystemPropertyType_httpwww_w3_org1999xlinktitle', pyxb.binding.datatypes.string)
    def title (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}title."""
        return self.__title.value(self)
    def setTitle (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}title.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__title.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}role uses Python identifier role
    __role = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'role'), 'role', '__CoordinateSystemPropertyType_httpwww_w3_org1999xlinkrole', pyxb.binding.datatypes.anyURI)
    def role (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}role."""
        return self.__role.value(self)
    def setRole (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}role.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__role.set(self, new_value)

    _ElementMap = {
        __AbstractCoordinateSystem.name() : __AbstractCoordinateSystem
    }
    _AttributeMap = {
        __href.name() : __href,
        __show.name() : __show,
        __arcrole.name() : __arcrole,
        __remoteSchema.name() : __remoteSchema,
        __actuate.name() : __actuate,
        __type.name() : __type,
        __nilReason.name() : __nilReason,
        __title.name() : __title,
        __role.name() : __role
    }
Namespace.addCategoryObject('typeBinding', u'CoordinateSystemPropertyType', CoordinateSystemPropertyType)


# Complex type CoordinatesType with content type SIMPLE
class CoordinatesType (pyxb.binding.basis.complexTypeDefinition):
    _TypeDefinition = pyxb.binding.datatypes.string
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_SIMPLE
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'CoordinatesType')
    # Base type is pyxb.binding.datatypes.string
    
    # Attribute cs uses Python identifier cs
    __cs = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'cs'), 'cs', '__CoordinatesType_cs', pyxb.binding.datatypes.string, unicode_default=u',')
    def cs (self):
        """Get the attribute value for cs."""
        return self.__cs.value(self)
    def setCs (self, new_value):
        """Set the attribute value for cs.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__cs.set(self, new_value)
    
    # Attribute decimal uses Python identifier decimal
    __decimal = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'decimal'), 'decimal', '__CoordinatesType_decimal', pyxb.binding.datatypes.string, unicode_default=u'.')
    def decimal (self):
        """Get the attribute value for decimal."""
        return self.__decimal.value(self)
    def setDecimal (self, new_value):
        """Set the attribute value for decimal.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__decimal.set(self, new_value)
    
    # Attribute ts uses Python identifier ts
    __ts = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'ts'), 'ts', '__CoordinatesType_ts', pyxb.binding.datatypes.string, unicode_default=u' ')
    def ts (self):
        """Get the attribute value for ts."""
        return self.__ts.value(self)
    def setTs (self, new_value):
        """Set the attribute value for ts.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__ts.set(self, new_value)

    _ElementMap = {
        
    }
    _AttributeMap = {
        __cs.name() : __cs,
        __decimal.name() : __decimal,
        __ts.name() : __ts
    }
Namespace.addCategoryObject('typeBinding', u'CoordinatesType', CoordinatesType)


# Complex type CountPropertyType with content type ELEMENT_ONLY
class CountPropertyType (pyxb.binding.basis.complexTypeDefinition):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'CountPropertyType')
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.opengis.net/gml}Count uses Python identifier Count
    __Count = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'Count'), 'Count', '__CountPropertyType_httpwww_opengis_netgmlCount', False)
    def Count (self):
        """Get the value of the {http://www.opengis.net/gml}Count element."""
        return self.__Count.value(self)
    def setCount (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}Count element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__Count.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}show uses Python identifier show
    __show = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'show'), 'show', '__CountPropertyType_httpwww_w3_org1999xlinkshow', MODULEhttpwww_w3_org1999xlink.UNBOUNDNone_32)
    def show (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}show."""
        return self.__show.value(self)
    def setShow (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}show.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__show.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}href uses Python identifier href
    __href = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'href'), 'href', '__CountPropertyType_httpwww_w3_org1999xlinkhref', pyxb.binding.datatypes.anyURI)
    def href (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}href."""
        return self.__href.value(self)
    def setHref (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}href.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__href.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}actuate uses Python identifier actuate
    __actuate = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'actuate'), 'actuate', '__CountPropertyType_httpwww_w3_org1999xlinkactuate', MODULEhttpwww_w3_org1999xlink.UNBOUNDNone_33)
    def actuate (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}actuate."""
        return self.__actuate.value(self)
    def setActuate (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}actuate.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__actuate.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}arcrole uses Python identifier arcrole
    __arcrole = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'arcrole'), 'arcrole', '__CountPropertyType_httpwww_w3_org1999xlinkarcrole', pyxb.binding.datatypes.anyURI)
    def arcrole (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}arcrole."""
        return self.__arcrole.value(self)
    def setArcrole (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}arcrole.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__arcrole.set(self, new_value)
    
    # Attribute {http://www.opengis.net/gml}remoteSchema uses Python identifier remoteSchema
    __remoteSchema = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(Namespace, u'remoteSchema'), 'remoteSchema', '__CountPropertyType_httpwww_opengis_netgmlremoteSchema', pyxb.binding.datatypes.anyURI)
    def remoteSchema (self):
        """Get the attribute value for {http://www.opengis.net/gml}remoteSchema."""
        return self.__remoteSchema.value(self)
    def setRemoteSchema (self, new_value):
        """Set the attribute value for {http://www.opengis.net/gml}remoteSchema.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__remoteSchema.set(self, new_value)
    
    # Attribute nilReason uses Python identifier nilReason
    __nilReason = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'nilReason'), 'nilReason', '__CountPropertyType_nilReason', NilReasonType)
    def nilReason (self):
        """Get the attribute value for nilReason."""
        return self.__nilReason.value(self)
    def setNilReason (self, new_value):
        """Set the attribute value for nilReason.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__nilReason.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}type uses Python identifier type
    __type = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'type'), 'type', '__CountPropertyType_httpwww_w3_org1999xlinktype', pyxb.binding.datatypes.string, fixed=True, unicode_default=u'simple')
    def type (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}type."""
        return self.__type.value(self)
    def setType (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}type.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__type.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}title uses Python identifier title
    __title = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'title'), 'title', '__CountPropertyType_httpwww_w3_org1999xlinktitle', pyxb.binding.datatypes.string)
    def title (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}title."""
        return self.__title.value(self)
    def setTitle (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}title.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__title.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}role uses Python identifier role
    __role = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'role'), 'role', '__CountPropertyType_httpwww_w3_org1999xlinkrole', pyxb.binding.datatypes.anyURI)
    def role (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}role."""
        return self.__role.value(self)
    def setRole (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}role.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__role.set(self, new_value)

    _ElementMap = {
        __Count.name() : __Count
    }
    _AttributeMap = {
        __show.name() : __show,
        __href.name() : __href,
        __actuate.name() : __actuate,
        __arcrole.name() : __arcrole,
        __remoteSchema.name() : __remoteSchema,
        __nilReason.name() : __nilReason,
        __type.name() : __type,
        __title.name() : __title,
        __role.name() : __role
    }
Namespace.addCategoryObject('typeBinding', u'CountPropertyType', CountPropertyType)


# Complex type CoverageFunctionType with content type ELEMENT_ONLY
class CoverageFunctionType (pyxb.binding.basis.complexTypeDefinition):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'CoverageFunctionType')
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.opengis.net/gml}MappingRule uses Python identifier MappingRule
    __MappingRule = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'MappingRule'), 'MappingRule', '__CoverageFunctionType_httpwww_opengis_netgmlMappingRule', False)
    def MappingRule (self):
        """Get the value of the {http://www.opengis.net/gml}MappingRule element."""
        return self.__MappingRule.value(self)
    def setMappingRule (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}MappingRule element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__MappingRule.set(self, new_value)
    
    # Element {http://www.opengis.net/gml}CoverageMappingRule uses Python identifier CoverageMappingRule
    __CoverageMappingRule = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'CoverageMappingRule'), 'CoverageMappingRule', '__CoverageFunctionType_httpwww_opengis_netgmlCoverageMappingRule', False)
    def CoverageMappingRule (self):
        """Get the value of the {http://www.opengis.net/gml}CoverageMappingRule element."""
        return self.__CoverageMappingRule.value(self)
    def setCoverageMappingRule (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}CoverageMappingRule element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__CoverageMappingRule.set(self, new_value)
    
    # Element {http://www.opengis.net/gml}GridFunction uses Python identifier GridFunction
    __GridFunction = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'GridFunction'), 'GridFunction', '__CoverageFunctionType_httpwww_opengis_netgmlGridFunction', False)
    def GridFunction (self):
        """Get the value of the {http://www.opengis.net/gml}GridFunction element."""
        return self.__GridFunction.value(self)
    def setGridFunction (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}GridFunction element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__GridFunction.set(self, new_value)

    _ElementMap = {
        __MappingRule.name() : __MappingRule,
        __CoverageMappingRule.name() : __CoverageMappingRule,
        __GridFunction.name() : __GridFunction
    }
    _AttributeMap = {
        
    }
Namespace.addCategoryObject('typeBinding', u'CoverageFunctionType', CoverageFunctionType)


# Complex type CurveArrayPropertyType with content type ELEMENT_ONLY
class CurveArrayPropertyType (pyxb.binding.basis.complexTypeDefinition):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'CurveArrayPropertyType')
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.opengis.net/gml}AbstractCurve uses Python identifier AbstractCurve
    __AbstractCurve = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'AbstractCurve'), 'AbstractCurve', '__CurveArrayPropertyType_httpwww_opengis_netgmlAbstractCurve', True)
    def AbstractCurve (self):
        """Get the value of the {http://www.opengis.net/gml}AbstractCurve element."""
        return self.__AbstractCurve.value(self)
    def setAbstractCurve (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}AbstractCurve element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__AbstractCurve.set(self, new_value)
    
    def addAbstractCurve (self, new_value):
        """Add the value as another occurrence of the {http://www.opengis.net/gml}AbstractCurve element.  Raises
        BadValueTypeException if the new value is not consistent with the
        element's type."""
        return self.__AbstractCurve.append(self, new_value)
    
    # Attribute owns uses Python identifier owns
    __owns = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'owns'), 'owns', '__CurveArrayPropertyType_owns', pyxb.binding.datatypes.boolean, unicode_default=u'false')
    def owns (self):
        """Get the attribute value for owns."""
        return self.__owns.value(self)
    def setOwns (self, new_value):
        """Set the attribute value for owns.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__owns.set(self, new_value)

    _ElementMap = {
        __AbstractCurve.name() : __AbstractCurve
    }
    _AttributeMap = {
        __owns.name() : __owns
    }
Namespace.addCategoryObject('typeBinding', u'CurveArrayPropertyType', CurveArrayPropertyType)


# Complex type CurvePropertyType with content type ELEMENT_ONLY
class CurvePropertyType (pyxb.binding.basis.complexTypeDefinition):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'CurvePropertyType')
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.opengis.net/gml}AbstractCurve uses Python identifier AbstractCurve
    __AbstractCurve = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'AbstractCurve'), 'AbstractCurve', '__CurvePropertyType_httpwww_opengis_netgmlAbstractCurve', False)
    def AbstractCurve (self):
        """Get the value of the {http://www.opengis.net/gml}AbstractCurve element."""
        return self.__AbstractCurve.value(self)
    def setAbstractCurve (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}AbstractCurve element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__AbstractCurve.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}show uses Python identifier show
    __show = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'show'), 'show', '__CurvePropertyType_httpwww_w3_org1999xlinkshow', MODULEhttpwww_w3_org1999xlink.UNBOUNDNone_34)
    def show (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}show."""
        return self.__show.value(self)
    def setShow (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}show.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__show.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}role uses Python identifier role
    __role = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'role'), 'role', '__CurvePropertyType_httpwww_w3_org1999xlinkrole', pyxb.binding.datatypes.anyURI)
    def role (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}role."""
        return self.__role.value(self)
    def setRole (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}role.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__role.set(self, new_value)
    
    # Attribute owns uses Python identifier owns
    __owns = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'owns'), 'owns', '__CurvePropertyType_owns', pyxb.binding.datatypes.boolean, unicode_default=u'false')
    def owns (self):
        """Get the attribute value for owns."""
        return self.__owns.value(self)
    def setOwns (self, new_value):
        """Set the attribute value for owns.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__owns.set(self, new_value)
    
    # Attribute nilReason uses Python identifier nilReason
    __nilReason = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'nilReason'), 'nilReason', '__CurvePropertyType_nilReason', NilReasonType)
    def nilReason (self):
        """Get the attribute value for nilReason."""
        return self.__nilReason.value(self)
    def setNilReason (self, new_value):
        """Set the attribute value for nilReason.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__nilReason.set(self, new_value)
    
    # Attribute {http://www.opengis.net/gml}remoteSchema uses Python identifier remoteSchema
    __remoteSchema = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(Namespace, u'remoteSchema'), 'remoteSchema', '__CurvePropertyType_httpwww_opengis_netgmlremoteSchema', pyxb.binding.datatypes.anyURI)
    def remoteSchema (self):
        """Get the attribute value for {http://www.opengis.net/gml}remoteSchema."""
        return self.__remoteSchema.value(self)
    def setRemoteSchema (self, new_value):
        """Set the attribute value for {http://www.opengis.net/gml}remoteSchema.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__remoteSchema.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}actuate uses Python identifier actuate
    __actuate = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'actuate'), 'actuate', '__CurvePropertyType_httpwww_w3_org1999xlinkactuate', MODULEhttpwww_w3_org1999xlink.UNBOUNDNone_35)
    def actuate (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}actuate."""
        return self.__actuate.value(self)
    def setActuate (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}actuate.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__actuate.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}arcrole uses Python identifier arcrole
    __arcrole = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'arcrole'), 'arcrole', '__CurvePropertyType_httpwww_w3_org1999xlinkarcrole', pyxb.binding.datatypes.anyURI)
    def arcrole (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}arcrole."""
        return self.__arcrole.value(self)
    def setArcrole (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}arcrole.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__arcrole.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}type uses Python identifier type
    __type = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'type'), 'type', '__CurvePropertyType_httpwww_w3_org1999xlinktype', pyxb.binding.datatypes.string, fixed=True, unicode_default=u'simple')
    def type (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}type."""
        return self.__type.value(self)
    def setType (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}type.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__type.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}href uses Python identifier href
    __href = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'href'), 'href', '__CurvePropertyType_httpwww_w3_org1999xlinkhref', pyxb.binding.datatypes.anyURI)
    def href (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}href."""
        return self.__href.value(self)
    def setHref (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}href.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__href.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}title uses Python identifier title
    __title = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'title'), 'title', '__CurvePropertyType_httpwww_w3_org1999xlinktitle', pyxb.binding.datatypes.string)
    def title (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}title."""
        return self.__title.value(self)
    def setTitle (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}title.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__title.set(self, new_value)

    _ElementMap = {
        __AbstractCurve.name() : __AbstractCurve
    }
    _AttributeMap = {
        __show.name() : __show,
        __role.name() : __role,
        __owns.name() : __owns,
        __nilReason.name() : __nilReason,
        __remoteSchema.name() : __remoteSchema,
        __actuate.name() : __actuate,
        __arcrole.name() : __arcrole,
        __type.name() : __type,
        __href.name() : __href,
        __title.name() : __title
    }
Namespace.addCategoryObject('typeBinding', u'CurvePropertyType', CurvePropertyType)


# Complex type CurveSegmentArrayPropertyType with content type ELEMENT_ONLY
class CurveSegmentArrayPropertyType (pyxb.binding.basis.complexTypeDefinition):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'CurveSegmentArrayPropertyType')
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.opengis.net/gml}AbstractCurveSegment uses Python identifier AbstractCurveSegment
    __AbstractCurveSegment = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'AbstractCurveSegment'), 'AbstractCurveSegment', '__CurveSegmentArrayPropertyType_httpwww_opengis_netgmlAbstractCurveSegment', True)
    def AbstractCurveSegment (self):
        """Get the value of the {http://www.opengis.net/gml}AbstractCurveSegment element."""
        return self.__AbstractCurveSegment.value(self)
    def setAbstractCurveSegment (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}AbstractCurveSegment element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__AbstractCurveSegment.set(self, new_value)
    
    def addAbstractCurveSegment (self, new_value):
        """Add the value as another occurrence of the {http://www.opengis.net/gml}AbstractCurveSegment element.  Raises
        BadValueTypeException if the new value is not consistent with the
        element's type."""
        return self.__AbstractCurveSegment.append(self, new_value)

    _ElementMap = {
        __AbstractCurveSegment.name() : __AbstractCurveSegment
    }
    _AttributeMap = {
        
    }
Namespace.addCategoryObject('typeBinding', u'CurveSegmentArrayPropertyType', CurveSegmentArrayPropertyType)


# Complex type CylindricalCSPropertyType with content type ELEMENT_ONLY
class CylindricalCSPropertyType (pyxb.binding.basis.complexTypeDefinition):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'CylindricalCSPropertyType')
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.opengis.net/gml}CylindricalCS uses Python identifier CylindricalCS
    __CylindricalCS = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'CylindricalCS'), 'CylindricalCS', '__CylindricalCSPropertyType_httpwww_opengis_netgmlCylindricalCS', False)
    def CylindricalCS (self):
        """Get the value of the {http://www.opengis.net/gml}CylindricalCS element."""
        return self.__CylindricalCS.value(self)
    def setCylindricalCS (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}CylindricalCS element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__CylindricalCS.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}show uses Python identifier show
    __show = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'show'), 'show', '__CylindricalCSPropertyType_httpwww_w3_org1999xlinkshow', MODULEhttpwww_w3_org1999xlink.UNBOUNDNone_36)
    def show (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}show."""
        return self.__show.value(self)
    def setShow (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}show.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__show.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}role uses Python identifier role
    __role = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'role'), 'role', '__CylindricalCSPropertyType_httpwww_w3_org1999xlinkrole', pyxb.binding.datatypes.anyURI)
    def role (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}role."""
        return self.__role.value(self)
    def setRole (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}role.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__role.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}href uses Python identifier href
    __href = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'href'), 'href', '__CylindricalCSPropertyType_httpwww_w3_org1999xlinkhref', pyxb.binding.datatypes.anyURI)
    def href (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}href."""
        return self.__href.value(self)
    def setHref (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}href.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__href.set(self, new_value)
    
    # Attribute nilReason uses Python identifier nilReason
    __nilReason = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'nilReason'), 'nilReason', '__CylindricalCSPropertyType_nilReason', NilReasonType)
    def nilReason (self):
        """Get the attribute value for nilReason."""
        return self.__nilReason.value(self)
    def setNilReason (self, new_value):
        """Set the attribute value for nilReason.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__nilReason.set(self, new_value)
    
    # Attribute {http://www.opengis.net/gml}remoteSchema uses Python identifier remoteSchema
    __remoteSchema = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(Namespace, u'remoteSchema'), 'remoteSchema', '__CylindricalCSPropertyType_httpwww_opengis_netgmlremoteSchema', pyxb.binding.datatypes.anyURI)
    def remoteSchema (self):
        """Get the attribute value for {http://www.opengis.net/gml}remoteSchema."""
        return self.__remoteSchema.value(self)
    def setRemoteSchema (self, new_value):
        """Set the attribute value for {http://www.opengis.net/gml}remoteSchema.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__remoteSchema.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}actuate uses Python identifier actuate
    __actuate = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'actuate'), 'actuate', '__CylindricalCSPropertyType_httpwww_w3_org1999xlinkactuate', MODULEhttpwww_w3_org1999xlink.UNBOUNDNone_37)
    def actuate (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}actuate."""
        return self.__actuate.value(self)
    def setActuate (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}actuate.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__actuate.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}type uses Python identifier type
    __type = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'type'), 'type', '__CylindricalCSPropertyType_httpwww_w3_org1999xlinktype', pyxb.binding.datatypes.string, fixed=True, unicode_default=u'simple')
    def type (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}type."""
        return self.__type.value(self)
    def setType (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}type.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__type.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}arcrole uses Python identifier arcrole
    __arcrole = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'arcrole'), 'arcrole', '__CylindricalCSPropertyType_httpwww_w3_org1999xlinkarcrole', pyxb.binding.datatypes.anyURI)
    def arcrole (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}arcrole."""
        return self.__arcrole.value(self)
    def setArcrole (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}arcrole.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__arcrole.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}title uses Python identifier title
    __title = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'title'), 'title', '__CylindricalCSPropertyType_httpwww_w3_org1999xlinktitle', pyxb.binding.datatypes.string)
    def title (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}title."""
        return self.__title.value(self)
    def setTitle (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}title.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__title.set(self, new_value)

    _ElementMap = {
        __CylindricalCS.name() : __CylindricalCS
    }
    _AttributeMap = {
        __show.name() : __show,
        __role.name() : __role,
        __href.name() : __href,
        __nilReason.name() : __nilReason,
        __remoteSchema.name() : __remoteSchema,
        __actuate.name() : __actuate,
        __type.name() : __type,
        __arcrole.name() : __arcrole,
        __title.name() : __title
    }
Namespace.addCategoryObject('typeBinding', u'CylindricalCSPropertyType', CylindricalCSPropertyType)


# Complex type DMSAngleType with content type ELEMENT_ONLY
class DMSAngleType (pyxb.binding.basis.complexTypeDefinition):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'DMSAngleType')
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.opengis.net/gml}degrees uses Python identifier degrees
    __degrees = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'degrees'), 'degrees', '__DMSAngleType_httpwww_opengis_netgmldegrees', True)
    def degrees (self):
        """Get the value of the {http://www.opengis.net/gml}degrees element."""
        return self.__degrees.value(self)
    def setDegrees (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}degrees element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__degrees.set(self, new_value)
    
    def addDegrees (self, new_value):
        """Add the value as another occurrence of the {http://www.opengis.net/gml}degrees element.  Raises
        BadValueTypeException if the new value is not consistent with the
        element's type."""
        return self.__degrees.append(self, new_value)
    
    # Element {http://www.opengis.net/gml}seconds uses Python identifier seconds
    __seconds = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'seconds'), 'seconds', '__DMSAngleType_httpwww_opengis_netgmlseconds', False)
    def seconds (self):
        """Get the value of the {http://www.opengis.net/gml}seconds element."""
        return self.__seconds.value(self)
    def setSeconds (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}seconds element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__seconds.set(self, new_value)
    
    # Element {http://www.opengis.net/gml}decimalMinutes uses Python identifier decimalMinutes
    __decimalMinutes = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'decimalMinutes'), 'decimalMinutes', '__DMSAngleType_httpwww_opengis_netgmldecimalMinutes', False)
    def decimalMinutes (self):
        """Get the value of the {http://www.opengis.net/gml}decimalMinutes element."""
        return self.__decimalMinutes.value(self)
    def setDecimalMinutes (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}decimalMinutes element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__decimalMinutes.set(self, new_value)
    
    # Element {http://www.opengis.net/gml}minutes uses Python identifier minutes
    __minutes = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'minutes'), 'minutes', '__DMSAngleType_httpwww_opengis_netgmlminutes', False)
    def minutes (self):
        """Get the value of the {http://www.opengis.net/gml}minutes element."""
        return self.__minutes.value(self)
    def setMinutes (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}minutes element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__minutes.set(self, new_value)

    _ElementMap = {
        __degrees.name() : __degrees,
        __seconds.name() : __seconds,
        __decimalMinutes.name() : __decimalMinutes,
        __minutes.name() : __minutes
    }
    _AttributeMap = {
        
    }
Namespace.addCategoryObject('typeBinding', u'DMSAngleType', DMSAngleType)


# Complex type DataBlockType with content type ELEMENT_ONLY
class DataBlockType (pyxb.binding.basis.complexTypeDefinition):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'DataBlockType')
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.opengis.net/gml}tupleList uses Python identifier tupleList
    __tupleList = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'tupleList'), 'tupleList', '__DataBlockType_httpwww_opengis_netgmltupleList', False)
    def tupleList (self):
        """Get the value of the {http://www.opengis.net/gml}tupleList element."""
        return self.__tupleList.value(self)
    def setTupleList (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}tupleList element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__tupleList.set(self, new_value)
    
    # Element {http://www.opengis.net/gml}doubleOrNilReasonTupleList uses Python identifier doubleOrNilReasonTupleList
    __doubleOrNilReasonTupleList = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'doubleOrNilReasonTupleList'), 'doubleOrNilReasonTupleList', '__DataBlockType_httpwww_opengis_netgmldoubleOrNilReasonTupleList', False)
    def doubleOrNilReasonTupleList (self):
        """Get the value of the {http://www.opengis.net/gml}doubleOrNilReasonTupleList element."""
        return self.__doubleOrNilReasonTupleList.value(self)
    def setDoubleOrNilReasonTupleList (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}doubleOrNilReasonTupleList element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__doubleOrNilReasonTupleList.set(self, new_value)
    
    # Element {http://www.opengis.net/gml}rangeParameters uses Python identifier rangeParameters
    __rangeParameters = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'rangeParameters'), 'rangeParameters', '__DataBlockType_httpwww_opengis_netgmlrangeParameters', True)
    def rangeParameters (self):
        """Get the value of the {http://www.opengis.net/gml}rangeParameters element."""
        return self.__rangeParameters.value(self)
    def setRangeParameters (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}rangeParameters element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__rangeParameters.set(self, new_value)
    
    def addRangeParameters (self, new_value):
        """Add the value as another occurrence of the {http://www.opengis.net/gml}rangeParameters element.  Raises
        BadValueTypeException if the new value is not consistent with the
        element's type."""
        return self.__rangeParameters.append(self, new_value)

    _ElementMap = {
        __tupleList.name() : __tupleList,
        __doubleOrNilReasonTupleList.name() : __doubleOrNilReasonTupleList,
        __rangeParameters.name() : __rangeParameters
    }
    _AttributeMap = {
        
    }
Namespace.addCategoryObject('typeBinding', u'DataBlockType', DataBlockType)


# Complex type DatumPropertyType with content type ELEMENT_ONLY
class DatumPropertyType (pyxb.binding.basis.complexTypeDefinition):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'DatumPropertyType')
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.opengis.net/gml}AbstractDatum uses Python identifier AbstractDatum
    __AbstractDatum = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'AbstractDatum'), 'AbstractDatum', '__DatumPropertyType_httpwww_opengis_netgmlAbstractDatum', False)
    def AbstractDatum (self):
        """Get the value of the {http://www.opengis.net/gml}AbstractDatum element."""
        return self.__AbstractDatum.value(self)
    def setAbstractDatum (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}AbstractDatum element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__AbstractDatum.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}title uses Python identifier title
    __title = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'title'), 'title', '__DatumPropertyType_httpwww_w3_org1999xlinktitle', pyxb.binding.datatypes.string)
    def title (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}title."""
        return self.__title.value(self)
    def setTitle (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}title.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__title.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}show uses Python identifier show
    __show = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'show'), 'show', '__DatumPropertyType_httpwww_w3_org1999xlinkshow', MODULEhttpwww_w3_org1999xlink.UNBOUNDNone_38)
    def show (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}show."""
        return self.__show.value(self)
    def setShow (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}show.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__show.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}role uses Python identifier role
    __role = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'role'), 'role', '__DatumPropertyType_httpwww_w3_org1999xlinkrole', pyxb.binding.datatypes.anyURI)
    def role (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}role."""
        return self.__role.value(self)
    def setRole (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}role.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__role.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}href uses Python identifier href
    __href = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'href'), 'href', '__DatumPropertyType_httpwww_w3_org1999xlinkhref', pyxb.binding.datatypes.anyURI)
    def href (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}href."""
        return self.__href.value(self)
    def setHref (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}href.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__href.set(self, new_value)
    
    # Attribute nilReason uses Python identifier nilReason
    __nilReason = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'nilReason'), 'nilReason', '__DatumPropertyType_nilReason', NilReasonType)
    def nilReason (self):
        """Get the attribute value for nilReason."""
        return self.__nilReason.value(self)
    def setNilReason (self, new_value):
        """Set the attribute value for nilReason.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__nilReason.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}arcrole uses Python identifier arcrole
    __arcrole = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'arcrole'), 'arcrole', '__DatumPropertyType_httpwww_w3_org1999xlinkarcrole', pyxb.binding.datatypes.anyURI)
    def arcrole (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}arcrole."""
        return self.__arcrole.value(self)
    def setArcrole (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}arcrole.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__arcrole.set(self, new_value)
    
    # Attribute {http://www.opengis.net/gml}remoteSchema uses Python identifier remoteSchema
    __remoteSchema = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(Namespace, u'remoteSchema'), 'remoteSchema', '__DatumPropertyType_httpwww_opengis_netgmlremoteSchema', pyxb.binding.datatypes.anyURI)
    def remoteSchema (self):
        """Get the attribute value for {http://www.opengis.net/gml}remoteSchema."""
        return self.__remoteSchema.value(self)
    def setRemoteSchema (self, new_value):
        """Set the attribute value for {http://www.opengis.net/gml}remoteSchema.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__remoteSchema.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}actuate uses Python identifier actuate
    __actuate = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'actuate'), 'actuate', '__DatumPropertyType_httpwww_w3_org1999xlinkactuate', MODULEhttpwww_w3_org1999xlink.UNBOUNDNone_39)
    def actuate (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}actuate."""
        return self.__actuate.value(self)
    def setActuate (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}actuate.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__actuate.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}type uses Python identifier type
    __type = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'type'), 'type', '__DatumPropertyType_httpwww_w3_org1999xlinktype', pyxb.binding.datatypes.string, fixed=True, unicode_default=u'simple')
    def type (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}type."""
        return self.__type.value(self)
    def setType (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}type.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__type.set(self, new_value)

    _ElementMap = {
        __AbstractDatum.name() : __AbstractDatum
    }
    _AttributeMap = {
        __title.name() : __title,
        __show.name() : __show,
        __role.name() : __role,
        __href.name() : __href,
        __nilReason.name() : __nilReason,
        __arcrole.name() : __arcrole,
        __remoteSchema.name() : __remoteSchema,
        __actuate.name() : __actuate,
        __type.name() : __type
    }
Namespace.addCategoryObject('typeBinding', u'DatumPropertyType', DatumPropertyType)


# Complex type DegreesType with content type SIMPLE
class DegreesType (pyxb.binding.basis.complexTypeDefinition):
    _TypeDefinition = DegreeValueType
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_SIMPLE
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'DegreesType')
    # Base type is DegreeValueType
    
    # Attribute direction uses Python identifier direction
    __direction = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'direction'), 'direction', '__DegreesType_direction', _STD_ANON_4)
    def direction (self):
        """Get the attribute value for direction."""
        return self.__direction.value(self)
    def setDirection (self, new_value):
        """Set the attribute value for direction.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__direction.set(self, new_value)

    _ElementMap = {
        
    }
    _AttributeMap = {
        __direction.name() : __direction
    }
Namespace.addCategoryObject('typeBinding', u'DegreesType', DegreesType)


# Complex type DerivedCRSPropertyType with content type ELEMENT_ONLY
class DerivedCRSPropertyType (pyxb.binding.basis.complexTypeDefinition):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'DerivedCRSPropertyType')
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.opengis.net/gml}DerivedCRS uses Python identifier DerivedCRS
    __DerivedCRS = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'DerivedCRS'), 'DerivedCRS', '__DerivedCRSPropertyType_httpwww_opengis_netgmlDerivedCRS', False)
    def DerivedCRS (self):
        """Get the value of the {http://www.opengis.net/gml}DerivedCRS element."""
        return self.__DerivedCRS.value(self)
    def setDerivedCRS (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}DerivedCRS element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__DerivedCRS.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}role uses Python identifier role
    __role = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'role'), 'role', '__DerivedCRSPropertyType_httpwww_w3_org1999xlinkrole', pyxb.binding.datatypes.anyURI)
    def role (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}role."""
        return self.__role.value(self)
    def setRole (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}role.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__role.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}show uses Python identifier show
    __show = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'show'), 'show', '__DerivedCRSPropertyType_httpwww_w3_org1999xlinkshow', MODULEhttpwww_w3_org1999xlink.UNBOUNDNone_40)
    def show (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}show."""
        return self.__show.value(self)
    def setShow (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}show.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__show.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}href uses Python identifier href
    __href = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'href'), 'href', '__DerivedCRSPropertyType_httpwww_w3_org1999xlinkhref', pyxb.binding.datatypes.anyURI)
    def href (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}href."""
        return self.__href.value(self)
    def setHref (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}href.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__href.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}arcrole uses Python identifier arcrole
    __arcrole = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'arcrole'), 'arcrole', '__DerivedCRSPropertyType_httpwww_w3_org1999xlinkarcrole', pyxb.binding.datatypes.anyURI)
    def arcrole (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}arcrole."""
        return self.__arcrole.value(self)
    def setArcrole (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}arcrole.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__arcrole.set(self, new_value)
    
    # Attribute {http://www.opengis.net/gml}remoteSchema uses Python identifier remoteSchema
    __remoteSchema = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(Namespace, u'remoteSchema'), 'remoteSchema', '__DerivedCRSPropertyType_httpwww_opengis_netgmlremoteSchema', pyxb.binding.datatypes.anyURI)
    def remoteSchema (self):
        """Get the attribute value for {http://www.opengis.net/gml}remoteSchema."""
        return self.__remoteSchema.value(self)
    def setRemoteSchema (self, new_value):
        """Set the attribute value for {http://www.opengis.net/gml}remoteSchema.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__remoteSchema.set(self, new_value)
    
    # Attribute nilReason uses Python identifier nilReason
    __nilReason = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'nilReason'), 'nilReason', '__DerivedCRSPropertyType_nilReason', NilReasonType)
    def nilReason (self):
        """Get the attribute value for nilReason."""
        return self.__nilReason.value(self)
    def setNilReason (self, new_value):
        """Set the attribute value for nilReason.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__nilReason.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}actuate uses Python identifier actuate
    __actuate = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'actuate'), 'actuate', '__DerivedCRSPropertyType_httpwww_w3_org1999xlinkactuate', MODULEhttpwww_w3_org1999xlink.UNBOUNDNone_41)
    def actuate (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}actuate."""
        return self.__actuate.value(self)
    def setActuate (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}actuate.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__actuate.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}type uses Python identifier type
    __type = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'type'), 'type', '__DerivedCRSPropertyType_httpwww_w3_org1999xlinktype', pyxb.binding.datatypes.string, fixed=True, unicode_default=u'simple')
    def type (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}type."""
        return self.__type.value(self)
    def setType (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}type.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__type.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}title uses Python identifier title
    __title = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'title'), 'title', '__DerivedCRSPropertyType_httpwww_w3_org1999xlinktitle', pyxb.binding.datatypes.string)
    def title (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}title."""
        return self.__title.value(self)
    def setTitle (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}title.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__title.set(self, new_value)

    _ElementMap = {
        __DerivedCRS.name() : __DerivedCRS
    }
    _AttributeMap = {
        __role.name() : __role,
        __show.name() : __show,
        __href.name() : __href,
        __arcrole.name() : __arcrole,
        __remoteSchema.name() : __remoteSchema,
        __nilReason.name() : __nilReason,
        __actuate.name() : __actuate,
        __type.name() : __type,
        __title.name() : __title
    }
Namespace.addCategoryObject('typeBinding', u'DerivedCRSPropertyType', DerivedCRSPropertyType)


# Complex type DirectPositionListType with content type SIMPLE
class DirectPositionListType (pyxb.binding.basis.complexTypeDefinition):
    _TypeDefinition = doubleList
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_SIMPLE
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'DirectPositionListType')
    # Base type is doubleList
    
    # Attribute count uses Python identifier count
    __count = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'count'), 'count', '__DirectPositionListType_count', pyxb.binding.datatypes.positiveInteger)
    def count (self):
        """Get the attribute value for count."""
        return self.__count.value(self)
    def setCount (self, new_value):
        """Set the attribute value for count.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__count.set(self, new_value)
    
    # Attribute srsName uses Python identifier srsName
    __srsName = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'srsName'), 'srsName', '__DirectPositionListType_srsName', pyxb.binding.datatypes.anyURI)
    def srsName (self):
        """Get the attribute value for srsName."""
        return self.__srsName.value(self)
    def setSrsName (self, new_value):
        """Set the attribute value for srsName.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__srsName.set(self, new_value)
    
    # Attribute axisLabels uses Python identifier axisLabels
    __axisLabels = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'axisLabels'), 'axisLabels', '__DirectPositionListType_axisLabels', NCNameList)
    def axisLabels (self):
        """Get the attribute value for axisLabels."""
        return self.__axisLabels.value(self)
    def setAxisLabels (self, new_value):
        """Set the attribute value for axisLabels.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__axisLabels.set(self, new_value)
    
    # Attribute uomLabels uses Python identifier uomLabels
    __uomLabels = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'uomLabels'), 'uomLabels', '__DirectPositionListType_uomLabels', NCNameList)
    def uomLabels (self):
        """Get the attribute value for uomLabels."""
        return self.__uomLabels.value(self)
    def setUomLabels (self, new_value):
        """Set the attribute value for uomLabels.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__uomLabels.set(self, new_value)
    
    # Attribute srsDimension uses Python identifier srsDimension
    __srsDimension = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'srsDimension'), 'srsDimension', '__DirectPositionListType_srsDimension', pyxb.binding.datatypes.positiveInteger)
    def srsDimension (self):
        """Get the attribute value for srsDimension."""
        return self.__srsDimension.value(self)
    def setSrsDimension (self, new_value):
        """Set the attribute value for srsDimension.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__srsDimension.set(self, new_value)

    _ElementMap = {
        
    }
    _AttributeMap = {
        __count.name() : __count,
        __srsName.name() : __srsName,
        __axisLabels.name() : __axisLabels,
        __uomLabels.name() : __uomLabels,
        __srsDimension.name() : __srsDimension
    }
Namespace.addCategoryObject('typeBinding', u'DirectPositionListType', DirectPositionListType)


# Complex type DirectPositionType with content type SIMPLE
class DirectPositionType (pyxb.binding.basis.complexTypeDefinition):
    _TypeDefinition = doubleList
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_SIMPLE
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'DirectPositionType')
    # Base type is doubleList
    
    # Attribute srsName uses Python identifier srsName
    __srsName = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'srsName'), 'srsName', '__DirectPositionType_srsName', pyxb.binding.datatypes.anyURI)
    def srsName (self):
        """Get the attribute value for srsName."""
        return self.__srsName.value(self)
    def setSrsName (self, new_value):
        """Set the attribute value for srsName.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__srsName.set(self, new_value)
    
    # Attribute axisLabels uses Python identifier axisLabels
    __axisLabels = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'axisLabels'), 'axisLabels', '__DirectPositionType_axisLabels', NCNameList)
    def axisLabels (self):
        """Get the attribute value for axisLabels."""
        return self.__axisLabels.value(self)
    def setAxisLabels (self, new_value):
        """Set the attribute value for axisLabels.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__axisLabels.set(self, new_value)
    
    # Attribute uomLabels uses Python identifier uomLabels
    __uomLabels = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'uomLabels'), 'uomLabels', '__DirectPositionType_uomLabels', NCNameList)
    def uomLabels (self):
        """Get the attribute value for uomLabels."""
        return self.__uomLabels.value(self)
    def setUomLabels (self, new_value):
        """Set the attribute value for uomLabels.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__uomLabels.set(self, new_value)
    
    # Attribute srsDimension uses Python identifier srsDimension
    __srsDimension = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'srsDimension'), 'srsDimension', '__DirectPositionType_srsDimension', pyxb.binding.datatypes.positiveInteger)
    def srsDimension (self):
        """Get the attribute value for srsDimension."""
        return self.__srsDimension.value(self)
    def setSrsDimension (self, new_value):
        """Set the attribute value for srsDimension.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__srsDimension.set(self, new_value)

    _ElementMap = {
        
    }
    _AttributeMap = {
        __srsName.name() : __srsName,
        __axisLabels.name() : __axisLabels,
        __uomLabels.name() : __uomLabels,
        __srsDimension.name() : __srsDimension
    }
Namespace.addCategoryObject('typeBinding', u'DirectPositionType', DirectPositionType)


# Complex type DirectedEdgePropertyType with content type ELEMENT_ONLY
class DirectedEdgePropertyType (pyxb.binding.basis.complexTypeDefinition):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'DirectedEdgePropertyType')
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.opengis.net/gml}Edge uses Python identifier Edge
    __Edge = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'Edge'), 'Edge', '__DirectedEdgePropertyType_httpwww_opengis_netgmlEdge', False)
    def Edge (self):
        """Get the value of the {http://www.opengis.net/gml}Edge element."""
        return self.__Edge.value(self)
    def setEdge (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}Edge element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__Edge.set(self, new_value)
    
    # Attribute orientation uses Python identifier orientation
    __orientation = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'orientation'), 'orientation', '__DirectedEdgePropertyType_orientation', SignType, unicode_default=u'+')
    def orientation (self):
        """Get the attribute value for orientation."""
        return self.__orientation.value(self)
    def setOrientation (self, new_value):
        """Set the attribute value for orientation.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__orientation.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}show uses Python identifier show
    __show = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'show'), 'show', '__DirectedEdgePropertyType_httpwww_w3_org1999xlinkshow', MODULEhttpwww_w3_org1999xlink.UNBOUNDNone_42)
    def show (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}show."""
        return self.__show.value(self)
    def setShow (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}show.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__show.set(self, new_value)
    
    # Attribute {http://www.opengis.net/gml}remoteSchema uses Python identifier remoteSchema
    __remoteSchema = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(Namespace, u'remoteSchema'), 'remoteSchema', '__DirectedEdgePropertyType_httpwww_opengis_netgmlremoteSchema', pyxb.binding.datatypes.anyURI)
    def remoteSchema (self):
        """Get the attribute value for {http://www.opengis.net/gml}remoteSchema."""
        return self.__remoteSchema.value(self)
    def setRemoteSchema (self, new_value):
        """Set the attribute value for {http://www.opengis.net/gml}remoteSchema.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__remoteSchema.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}actuate uses Python identifier actuate
    __actuate = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'actuate'), 'actuate', '__DirectedEdgePropertyType_httpwww_w3_org1999xlinkactuate', MODULEhttpwww_w3_org1999xlink.UNBOUNDNone_43)
    def actuate (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}actuate."""
        return self.__actuate.value(self)
    def setActuate (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}actuate.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__actuate.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}type uses Python identifier type
    __type = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'type'), 'type', '__DirectedEdgePropertyType_httpwww_w3_org1999xlinktype', pyxb.binding.datatypes.string, fixed=True, unicode_default=u'simple')
    def type (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}type."""
        return self.__type.value(self)
    def setType (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}type.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__type.set(self, new_value)
    
    # Attribute nilReason uses Python identifier nilReason
    __nilReason = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'nilReason'), 'nilReason', '__DirectedEdgePropertyType_nilReason', NilReasonType)
    def nilReason (self):
        """Get the attribute value for nilReason."""
        return self.__nilReason.value(self)
    def setNilReason (self, new_value):
        """Set the attribute value for nilReason.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__nilReason.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}arcrole uses Python identifier arcrole
    __arcrole = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'arcrole'), 'arcrole', '__DirectedEdgePropertyType_httpwww_w3_org1999xlinkarcrole', pyxb.binding.datatypes.anyURI)
    def arcrole (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}arcrole."""
        return self.__arcrole.value(self)
    def setArcrole (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}arcrole.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__arcrole.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}title uses Python identifier title
    __title = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'title'), 'title', '__DirectedEdgePropertyType_httpwww_w3_org1999xlinktitle', pyxb.binding.datatypes.string)
    def title (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}title."""
        return self.__title.value(self)
    def setTitle (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}title.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__title.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}href uses Python identifier href
    __href = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'href'), 'href', '__DirectedEdgePropertyType_httpwww_w3_org1999xlinkhref', pyxb.binding.datatypes.anyURI)
    def href (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}href."""
        return self.__href.value(self)
    def setHref (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}href.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__href.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}role uses Python identifier role
    __role = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'role'), 'role', '__DirectedEdgePropertyType_httpwww_w3_org1999xlinkrole', pyxb.binding.datatypes.anyURI)
    def role (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}role."""
        return self.__role.value(self)
    def setRole (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}role.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__role.set(self, new_value)
    
    # Attribute owns uses Python identifier owns
    __owns = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'owns'), 'owns', '__DirectedEdgePropertyType_owns', pyxb.binding.datatypes.boolean, unicode_default=u'false')
    def owns (self):
        """Get the attribute value for owns."""
        return self.__owns.value(self)
    def setOwns (self, new_value):
        """Set the attribute value for owns.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__owns.set(self, new_value)

    _ElementMap = {
        __Edge.name() : __Edge
    }
    _AttributeMap = {
        __orientation.name() : __orientation,
        __show.name() : __show,
        __remoteSchema.name() : __remoteSchema,
        __actuate.name() : __actuate,
        __type.name() : __type,
        __nilReason.name() : __nilReason,
        __arcrole.name() : __arcrole,
        __title.name() : __title,
        __href.name() : __href,
        __role.name() : __role,
        __owns.name() : __owns
    }
Namespace.addCategoryObject('typeBinding', u'DirectedEdgePropertyType', DirectedEdgePropertyType)


# Complex type DirectedFacePropertyType with content type ELEMENT_ONLY
class DirectedFacePropertyType (pyxb.binding.basis.complexTypeDefinition):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'DirectedFacePropertyType')
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.opengis.net/gml}Face uses Python identifier Face
    __Face = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'Face'), 'Face', '__DirectedFacePropertyType_httpwww_opengis_netgmlFace', False)
    def Face (self):
        """Get the value of the {http://www.opengis.net/gml}Face element."""
        return self.__Face.value(self)
    def setFace (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}Face element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__Face.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}role uses Python identifier role
    __role = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'role'), 'role', '__DirectedFacePropertyType_httpwww_w3_org1999xlinkrole', pyxb.binding.datatypes.anyURI)
    def role (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}role."""
        return self.__role.value(self)
    def setRole (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}role.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__role.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}show uses Python identifier show
    __show = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'show'), 'show', '__DirectedFacePropertyType_httpwww_w3_org1999xlinkshow', MODULEhttpwww_w3_org1999xlink.UNBOUNDNone_44)
    def show (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}show."""
        return self.__show.value(self)
    def setShow (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}show.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__show.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}href uses Python identifier href
    __href = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'href'), 'href', '__DirectedFacePropertyType_httpwww_w3_org1999xlinkhref', pyxb.binding.datatypes.anyURI)
    def href (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}href."""
        return self.__href.value(self)
    def setHref (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}href.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__href.set(self, new_value)
    
    # Attribute owns uses Python identifier owns
    __owns = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'owns'), 'owns', '__DirectedFacePropertyType_owns', pyxb.binding.datatypes.boolean, unicode_default=u'false')
    def owns (self):
        """Get the attribute value for owns."""
        return self.__owns.value(self)
    def setOwns (self, new_value):
        """Set the attribute value for owns.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__owns.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}arcrole uses Python identifier arcrole
    __arcrole = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'arcrole'), 'arcrole', '__DirectedFacePropertyType_httpwww_w3_org1999xlinkarcrole', pyxb.binding.datatypes.anyURI)
    def arcrole (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}arcrole."""
        return self.__arcrole.value(self)
    def setArcrole (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}arcrole.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__arcrole.set(self, new_value)
    
    # Attribute {http://www.opengis.net/gml}remoteSchema uses Python identifier remoteSchema
    __remoteSchema = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(Namespace, u'remoteSchema'), 'remoteSchema', '__DirectedFacePropertyType_httpwww_opengis_netgmlremoteSchema', pyxb.binding.datatypes.anyURI)
    def remoteSchema (self):
        """Get the attribute value for {http://www.opengis.net/gml}remoteSchema."""
        return self.__remoteSchema.value(self)
    def setRemoteSchema (self, new_value):
        """Set the attribute value for {http://www.opengis.net/gml}remoteSchema.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__remoteSchema.set(self, new_value)
    
    # Attribute nilReason uses Python identifier nilReason
    __nilReason = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'nilReason'), 'nilReason', '__DirectedFacePropertyType_nilReason', NilReasonType)
    def nilReason (self):
        """Get the attribute value for nilReason."""
        return self.__nilReason.value(self)
    def setNilReason (self, new_value):
        """Set the attribute value for nilReason.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__nilReason.set(self, new_value)
    
    # Attribute orientation uses Python identifier orientation
    __orientation = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'orientation'), 'orientation', '__DirectedFacePropertyType_orientation', SignType, unicode_default=u'+')
    def orientation (self):
        """Get the attribute value for orientation."""
        return self.__orientation.value(self)
    def setOrientation (self, new_value):
        """Set the attribute value for orientation.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__orientation.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}type uses Python identifier type
    __type = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'type'), 'type', '__DirectedFacePropertyType_httpwww_w3_org1999xlinktype', pyxb.binding.datatypes.string, fixed=True, unicode_default=u'simple')
    def type (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}type."""
        return self.__type.value(self)
    def setType (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}type.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__type.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}actuate uses Python identifier actuate
    __actuate = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'actuate'), 'actuate', '__DirectedFacePropertyType_httpwww_w3_org1999xlinkactuate', MODULEhttpwww_w3_org1999xlink.UNBOUNDNone_45)
    def actuate (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}actuate."""
        return self.__actuate.value(self)
    def setActuate (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}actuate.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__actuate.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}title uses Python identifier title
    __title = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'title'), 'title', '__DirectedFacePropertyType_httpwww_w3_org1999xlinktitle', pyxb.binding.datatypes.string)
    def title (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}title."""
        return self.__title.value(self)
    def setTitle (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}title.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__title.set(self, new_value)

    _ElementMap = {
        __Face.name() : __Face
    }
    _AttributeMap = {
        __role.name() : __role,
        __show.name() : __show,
        __href.name() : __href,
        __owns.name() : __owns,
        __arcrole.name() : __arcrole,
        __remoteSchema.name() : __remoteSchema,
        __nilReason.name() : __nilReason,
        __orientation.name() : __orientation,
        __type.name() : __type,
        __actuate.name() : __actuate,
        __title.name() : __title
    }
Namespace.addCategoryObject('typeBinding', u'DirectedFacePropertyType', DirectedFacePropertyType)


# Complex type DirectedNodePropertyType with content type ELEMENT_ONLY
class DirectedNodePropertyType (pyxb.binding.basis.complexTypeDefinition):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'DirectedNodePropertyType')
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.opengis.net/gml}Node uses Python identifier Node
    __Node = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'Node'), 'Node', '__DirectedNodePropertyType_httpwww_opengis_netgmlNode', False)
    def Node (self):
        """Get the value of the {http://www.opengis.net/gml}Node element."""
        return self.__Node.value(self)
    def setNode (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}Node element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__Node.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}actuate uses Python identifier actuate
    __actuate = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'actuate'), 'actuate', '__DirectedNodePropertyType_httpwww_w3_org1999xlinkactuate', MODULEhttpwww_w3_org1999xlink.UNBOUNDNone_46)
    def actuate (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}actuate."""
        return self.__actuate.value(self)
    def setActuate (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}actuate.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__actuate.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}show uses Python identifier show
    __show = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'show'), 'show', '__DirectedNodePropertyType_httpwww_w3_org1999xlinkshow', MODULEhttpwww_w3_org1999xlink.UNBOUNDNone_47)
    def show (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}show."""
        return self.__show.value(self)
    def setShow (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}show.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__show.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}type uses Python identifier type
    __type = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'type'), 'type', '__DirectedNodePropertyType_httpwww_w3_org1999xlinktype', pyxb.binding.datatypes.string, fixed=True, unicode_default=u'simple')
    def type (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}type."""
        return self.__type.value(self)
    def setType (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}type.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__type.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}title uses Python identifier title
    __title = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'title'), 'title', '__DirectedNodePropertyType_httpwww_w3_org1999xlinktitle', pyxb.binding.datatypes.string)
    def title (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}title."""
        return self.__title.value(self)
    def setTitle (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}title.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__title.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}role uses Python identifier role
    __role = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'role'), 'role', '__DirectedNodePropertyType_httpwww_w3_org1999xlinkrole', pyxb.binding.datatypes.anyURI)
    def role (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}role."""
        return self.__role.value(self)
    def setRole (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}role.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__role.set(self, new_value)
    
    # Attribute nilReason uses Python identifier nilReason
    __nilReason = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'nilReason'), 'nilReason', '__DirectedNodePropertyType_nilReason', NilReasonType)
    def nilReason (self):
        """Get the attribute value for nilReason."""
        return self.__nilReason.value(self)
    def setNilReason (self, new_value):
        """Set the attribute value for nilReason.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__nilReason.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}href uses Python identifier href
    __href = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'href'), 'href', '__DirectedNodePropertyType_httpwww_w3_org1999xlinkhref', pyxb.binding.datatypes.anyURI)
    def href (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}href."""
        return self.__href.value(self)
    def setHref (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}href.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__href.set(self, new_value)
    
    # Attribute owns uses Python identifier owns
    __owns = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'owns'), 'owns', '__DirectedNodePropertyType_owns', pyxb.binding.datatypes.boolean, unicode_default=u'false')
    def owns (self):
        """Get the attribute value for owns."""
        return self.__owns.value(self)
    def setOwns (self, new_value):
        """Set the attribute value for owns.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__owns.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}arcrole uses Python identifier arcrole
    __arcrole = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'arcrole'), 'arcrole', '__DirectedNodePropertyType_httpwww_w3_org1999xlinkarcrole', pyxb.binding.datatypes.anyURI)
    def arcrole (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}arcrole."""
        return self.__arcrole.value(self)
    def setArcrole (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}arcrole.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__arcrole.set(self, new_value)
    
    # Attribute {http://www.opengis.net/gml}remoteSchema uses Python identifier remoteSchema
    __remoteSchema = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(Namespace, u'remoteSchema'), 'remoteSchema', '__DirectedNodePropertyType_httpwww_opengis_netgmlremoteSchema', pyxb.binding.datatypes.anyURI)
    def remoteSchema (self):
        """Get the attribute value for {http://www.opengis.net/gml}remoteSchema."""
        return self.__remoteSchema.value(self)
    def setRemoteSchema (self, new_value):
        """Set the attribute value for {http://www.opengis.net/gml}remoteSchema.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__remoteSchema.set(self, new_value)
    
    # Attribute orientation uses Python identifier orientation
    __orientation = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'orientation'), 'orientation', '__DirectedNodePropertyType_orientation', SignType, unicode_default=u'+')
    def orientation (self):
        """Get the attribute value for orientation."""
        return self.__orientation.value(self)
    def setOrientation (self, new_value):
        """Set the attribute value for orientation.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__orientation.set(self, new_value)

    _ElementMap = {
        __Node.name() : __Node
    }
    _AttributeMap = {
        __actuate.name() : __actuate,
        __show.name() : __show,
        __type.name() : __type,
        __title.name() : __title,
        __role.name() : __role,
        __nilReason.name() : __nilReason,
        __href.name() : __href,
        __owns.name() : __owns,
        __arcrole.name() : __arcrole,
        __remoteSchema.name() : __remoteSchema,
        __orientation.name() : __orientation
    }
Namespace.addCategoryObject('typeBinding', u'DirectedNodePropertyType', DirectedNodePropertyType)


# Complex type DirectedTopoSolidPropertyType with content type ELEMENT_ONLY
class DirectedTopoSolidPropertyType (pyxb.binding.basis.complexTypeDefinition):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'DirectedTopoSolidPropertyType')
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.opengis.net/gml}TopoSolid uses Python identifier TopoSolid
    __TopoSolid = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'TopoSolid'), 'TopoSolid', '__DirectedTopoSolidPropertyType_httpwww_opengis_netgmlTopoSolid', False)
    def TopoSolid (self):
        """Get the value of the {http://www.opengis.net/gml}TopoSolid element."""
        return self.__TopoSolid.value(self)
    def setTopoSolid (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}TopoSolid element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__TopoSolid.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}title uses Python identifier title
    __title = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'title'), 'title', '__DirectedTopoSolidPropertyType_httpwww_w3_org1999xlinktitle', pyxb.binding.datatypes.string)
    def title (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}title."""
        return self.__title.value(self)
    def setTitle (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}title.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__title.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}show uses Python identifier show
    __show = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'show'), 'show', '__DirectedTopoSolidPropertyType_httpwww_w3_org1999xlinkshow', MODULEhttpwww_w3_org1999xlink.UNBOUNDNone_48)
    def show (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}show."""
        return self.__show.value(self)
    def setShow (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}show.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__show.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}href uses Python identifier href
    __href = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'href'), 'href', '__DirectedTopoSolidPropertyType_httpwww_w3_org1999xlinkhref', pyxb.binding.datatypes.anyURI)
    def href (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}href."""
        return self.__href.value(self)
    def setHref (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}href.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__href.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}arcrole uses Python identifier arcrole
    __arcrole = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'arcrole'), 'arcrole', '__DirectedTopoSolidPropertyType_httpwww_w3_org1999xlinkarcrole', pyxb.binding.datatypes.anyURI)
    def arcrole (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}arcrole."""
        return self.__arcrole.value(self)
    def setArcrole (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}arcrole.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__arcrole.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}role uses Python identifier role
    __role = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'role'), 'role', '__DirectedTopoSolidPropertyType_httpwww_w3_org1999xlinkrole', pyxb.binding.datatypes.anyURI)
    def role (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}role."""
        return self.__role.value(self)
    def setRole (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}role.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__role.set(self, new_value)
    
    # Attribute nilReason uses Python identifier nilReason
    __nilReason = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'nilReason'), 'nilReason', '__DirectedTopoSolidPropertyType_nilReason', NilReasonType)
    def nilReason (self):
        """Get the attribute value for nilReason."""
        return self.__nilReason.value(self)
    def setNilReason (self, new_value):
        """Set the attribute value for nilReason.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__nilReason.set(self, new_value)
    
    # Attribute owns uses Python identifier owns
    __owns = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'owns'), 'owns', '__DirectedTopoSolidPropertyType_owns', pyxb.binding.datatypes.boolean, unicode_default=u'false')
    def owns (self):
        """Get the attribute value for owns."""
        return self.__owns.value(self)
    def setOwns (self, new_value):
        """Set the attribute value for owns.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__owns.set(self, new_value)
    
    # Attribute orientation uses Python identifier orientation
    __orientation = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'orientation'), 'orientation', '__DirectedTopoSolidPropertyType_orientation', SignType, unicode_default=u'+')
    def orientation (self):
        """Get the attribute value for orientation."""
        return self.__orientation.value(self)
    def setOrientation (self, new_value):
        """Set the attribute value for orientation.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__orientation.set(self, new_value)
    
    # Attribute {http://www.opengis.net/gml}remoteSchema uses Python identifier remoteSchema
    __remoteSchema = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(Namespace, u'remoteSchema'), 'remoteSchema', '__DirectedTopoSolidPropertyType_httpwww_opengis_netgmlremoteSchema', pyxb.binding.datatypes.anyURI)
    def remoteSchema (self):
        """Get the attribute value for {http://www.opengis.net/gml}remoteSchema."""
        return self.__remoteSchema.value(self)
    def setRemoteSchema (self, new_value):
        """Set the attribute value for {http://www.opengis.net/gml}remoteSchema.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__remoteSchema.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}actuate uses Python identifier actuate
    __actuate = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'actuate'), 'actuate', '__DirectedTopoSolidPropertyType_httpwww_w3_org1999xlinkactuate', MODULEhttpwww_w3_org1999xlink.UNBOUNDNone_49)
    def actuate (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}actuate."""
        return self.__actuate.value(self)
    def setActuate (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}actuate.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__actuate.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}type uses Python identifier type
    __type = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'type'), 'type', '__DirectedTopoSolidPropertyType_httpwww_w3_org1999xlinktype', pyxb.binding.datatypes.string, fixed=True, unicode_default=u'simple')
    def type (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}type."""
        return self.__type.value(self)
    def setType (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}type.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__type.set(self, new_value)

    _ElementMap = {
        __TopoSolid.name() : __TopoSolid
    }
    _AttributeMap = {
        __title.name() : __title,
        __show.name() : __show,
        __href.name() : __href,
        __arcrole.name() : __arcrole,
        __role.name() : __role,
        __nilReason.name() : __nilReason,
        __owns.name() : __owns,
        __orientation.name() : __orientation,
        __remoteSchema.name() : __remoteSchema,
        __actuate.name() : __actuate,
        __type.name() : __type
    }
Namespace.addCategoryObject('typeBinding', u'DirectedTopoSolidPropertyType', DirectedTopoSolidPropertyType)


# Complex type DirectionDescriptionType with content type ELEMENT_ONLY
class DirectionDescriptionType (pyxb.binding.basis.complexTypeDefinition):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'DirectionDescriptionType')
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.opengis.net/gml}compassPoint uses Python identifier compassPoint
    __compassPoint = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'compassPoint'), 'compassPoint', '__DirectionDescriptionType_httpwww_opengis_netgmlcompassPoint', False)
    def compassPoint (self):
        """Get the value of the {http://www.opengis.net/gml}compassPoint element."""
        return self.__compassPoint.value(self)
    def setCompassPoint (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}compassPoint element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__compassPoint.set(self, new_value)
    
    # Element {http://www.opengis.net/gml}keyword uses Python identifier keyword
    __keyword = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'keyword'), 'keyword', '__DirectionDescriptionType_httpwww_opengis_netgmlkeyword', False)
    def keyword (self):
        """Get the value of the {http://www.opengis.net/gml}keyword element."""
        return self.__keyword.value(self)
    def setKeyword (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}keyword element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__keyword.set(self, new_value)
    
    # Element {http://www.opengis.net/gml}description uses Python identifier description
    __description = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'description'), 'description', '__DirectionDescriptionType_httpwww_opengis_netgmldescription', False)
    def description (self):
        """Get the value of the {http://www.opengis.net/gml}description element."""
        return self.__description.value(self)
    def setDescription (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}description element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__description.set(self, new_value)
    
    # Element {http://www.opengis.net/gml}reference uses Python identifier reference
    __reference = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'reference'), 'reference', '__DirectionDescriptionType_httpwww_opengis_netgmlreference', False)
    def reference (self):
        """Get the value of the {http://www.opengis.net/gml}reference element."""
        return self.__reference.value(self)
    def setReference (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}reference element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__reference.set(self, new_value)

    _ElementMap = {
        __compassPoint.name() : __compassPoint,
        __keyword.name() : __keyword,
        __description.name() : __description,
        __reference.name() : __reference
    }
    _AttributeMap = {
        
    }
Namespace.addCategoryObject('typeBinding', u'DirectionDescriptionType', DirectionDescriptionType)


# Complex type DirectionPropertyType with content type ELEMENT_ONLY
class DirectionPropertyType (pyxb.binding.basis.complexTypeDefinition):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'DirectionPropertyType')
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.opengis.net/gml}CompassPoint uses Python identifier CompassPoint
    __CompassPoint = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'CompassPoint'), 'CompassPoint', '__DirectionPropertyType_httpwww_opengis_netgmlCompassPoint', False)
    def CompassPoint (self):
        """Get the value of the {http://www.opengis.net/gml}CompassPoint element."""
        return self.__CompassPoint.value(self)
    def setCompassPoint (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}CompassPoint element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__CompassPoint.set(self, new_value)
    
    # Element {http://www.opengis.net/gml}DirectionDescription uses Python identifier DirectionDescription
    __DirectionDescription = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'DirectionDescription'), 'DirectionDescription', '__DirectionPropertyType_httpwww_opengis_netgmlDirectionDescription', False)
    def DirectionDescription (self):
        """Get the value of the {http://www.opengis.net/gml}DirectionDescription element."""
        return self.__DirectionDescription.value(self)
    def setDirectionDescription (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}DirectionDescription element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__DirectionDescription.set(self, new_value)
    
    # Element {http://www.opengis.net/gml}DirectionKeyword uses Python identifier DirectionKeyword
    __DirectionKeyword = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'DirectionKeyword'), 'DirectionKeyword', '__DirectionPropertyType_httpwww_opengis_netgmlDirectionKeyword', False)
    def DirectionKeyword (self):
        """Get the value of the {http://www.opengis.net/gml}DirectionKeyword element."""
        return self.__DirectionKeyword.value(self)
    def setDirectionKeyword (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}DirectionKeyword element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__DirectionKeyword.set(self, new_value)
    
    # Element {http://www.opengis.net/gml}DirectionVector uses Python identifier DirectionVector
    __DirectionVector = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'DirectionVector'), 'DirectionVector', '__DirectionPropertyType_httpwww_opengis_netgmlDirectionVector', False)
    def DirectionVector (self):
        """Get the value of the {http://www.opengis.net/gml}DirectionVector element."""
        return self.__DirectionVector.value(self)
    def setDirectionVector (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}DirectionVector element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__DirectionVector.set(self, new_value)
    
    # Element {http://www.opengis.net/gml}DirectionString uses Python identifier DirectionString
    __DirectionString = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'DirectionString'), 'DirectionString', '__DirectionPropertyType_httpwww_opengis_netgmlDirectionString', False)
    def DirectionString (self):
        """Get the value of the {http://www.opengis.net/gml}DirectionString element."""
        return self.__DirectionString.value(self)
    def setDirectionString (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}DirectionString element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__DirectionString.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}show uses Python identifier show
    __show = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'show'), 'show', '__DirectionPropertyType_httpwww_w3_org1999xlinkshow', MODULEhttpwww_w3_org1999xlink.UNBOUNDNone_50)
    def show (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}show."""
        return self.__show.value(self)
    def setShow (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}show.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__show.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}arcrole uses Python identifier arcrole
    __arcrole = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'arcrole'), 'arcrole', '__DirectionPropertyType_httpwww_w3_org1999xlinkarcrole', pyxb.binding.datatypes.anyURI)
    def arcrole (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}arcrole."""
        return self.__arcrole.value(self)
    def setArcrole (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}arcrole.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__arcrole.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}type uses Python identifier type
    __type = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'type'), 'type', '__DirectionPropertyType_httpwww_w3_org1999xlinktype', pyxb.binding.datatypes.string, fixed=True, unicode_default=u'simple')
    def type (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}type."""
        return self.__type.value(self)
    def setType (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}type.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__type.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}href uses Python identifier href
    __href = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'href'), 'href', '__DirectionPropertyType_httpwww_w3_org1999xlinkhref', pyxb.binding.datatypes.anyURI)
    def href (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}href."""
        return self.__href.value(self)
    def setHref (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}href.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__href.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}title uses Python identifier title
    __title = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'title'), 'title', '__DirectionPropertyType_httpwww_w3_org1999xlinktitle', pyxb.binding.datatypes.string)
    def title (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}title."""
        return self.__title.value(self)
    def setTitle (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}title.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__title.set(self, new_value)
    
    # Attribute nilReason uses Python identifier nilReason
    __nilReason = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'nilReason'), 'nilReason', '__DirectionPropertyType_nilReason', NilReasonType)
    def nilReason (self):
        """Get the attribute value for nilReason."""
        return self.__nilReason.value(self)
    def setNilReason (self, new_value):
        """Set the attribute value for nilReason.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__nilReason.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}role uses Python identifier role
    __role = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'role'), 'role', '__DirectionPropertyType_httpwww_w3_org1999xlinkrole', pyxb.binding.datatypes.anyURI)
    def role (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}role."""
        return self.__role.value(self)
    def setRole (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}role.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__role.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}actuate uses Python identifier actuate
    __actuate = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'actuate'), 'actuate', '__DirectionPropertyType_httpwww_w3_org1999xlinkactuate', MODULEhttpwww_w3_org1999xlink.UNBOUNDNone_51)
    def actuate (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}actuate."""
        return self.__actuate.value(self)
    def setActuate (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}actuate.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__actuate.set(self, new_value)
    
    # Attribute owns uses Python identifier owns
    __owns = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'owns'), 'owns', '__DirectionPropertyType_owns', pyxb.binding.datatypes.boolean, unicode_default=u'false')
    def owns (self):
        """Get the attribute value for owns."""
        return self.__owns.value(self)
    def setOwns (self, new_value):
        """Set the attribute value for owns.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__owns.set(self, new_value)
    
    # Attribute {http://www.opengis.net/gml}remoteSchema uses Python identifier remoteSchema
    __remoteSchema = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(Namespace, u'remoteSchema'), 'remoteSchema', '__DirectionPropertyType_httpwww_opengis_netgmlremoteSchema', pyxb.binding.datatypes.anyURI)
    def remoteSchema (self):
        """Get the attribute value for {http://www.opengis.net/gml}remoteSchema."""
        return self.__remoteSchema.value(self)
    def setRemoteSchema (self, new_value):
        """Set the attribute value for {http://www.opengis.net/gml}remoteSchema.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__remoteSchema.set(self, new_value)

    _ElementMap = {
        __CompassPoint.name() : __CompassPoint,
        __DirectionDescription.name() : __DirectionDescription,
        __DirectionKeyword.name() : __DirectionKeyword,
        __DirectionVector.name() : __DirectionVector,
        __DirectionString.name() : __DirectionString
    }
    _AttributeMap = {
        __show.name() : __show,
        __arcrole.name() : __arcrole,
        __type.name() : __type,
        __href.name() : __href,
        __title.name() : __title,
        __nilReason.name() : __nilReason,
        __role.name() : __role,
        __actuate.name() : __actuate,
        __owns.name() : __owns,
        __remoteSchema.name() : __remoteSchema
    }
Namespace.addCategoryObject('typeBinding', u'DirectionPropertyType', DirectionPropertyType)


# Complex type DirectionVectorType with content type ELEMENT_ONLY
class DirectionVectorType (pyxb.binding.basis.complexTypeDefinition):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'DirectionVectorType')
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.opengis.net/gml}verticalAngle uses Python identifier verticalAngle
    __verticalAngle = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'verticalAngle'), 'verticalAngle', '__DirectionVectorType_httpwww_opengis_netgmlverticalAngle', False)
    def verticalAngle (self):
        """Get the value of the {http://www.opengis.net/gml}verticalAngle element."""
        return self.__verticalAngle.value(self)
    def setVerticalAngle (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}verticalAngle element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__verticalAngle.set(self, new_value)
    
    # Element {http://www.opengis.net/gml}vector uses Python identifier vector
    __vector = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'vector'), 'vector', '__DirectionVectorType_httpwww_opengis_netgmlvector', False)
    def vector (self):
        """Get the value of the {http://www.opengis.net/gml}vector element."""
        return self.__vector.value(self)
    def setVector (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}vector element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__vector.set(self, new_value)
    
    # Element {http://www.opengis.net/gml}horizontalAngle uses Python identifier horizontalAngle
    __horizontalAngle = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'horizontalAngle'), 'horizontalAngle', '__DirectionVectorType_httpwww_opengis_netgmlhorizontalAngle', False)
    def horizontalAngle (self):
        """Get the value of the {http://www.opengis.net/gml}horizontalAngle element."""
        return self.__horizontalAngle.value(self)
    def setHorizontalAngle (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}horizontalAngle element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__horizontalAngle.set(self, new_value)

    _ElementMap = {
        __verticalAngle.name() : __verticalAngle,
        __vector.name() : __vector,
        __horizontalAngle.name() : __horizontalAngle
    }
    _AttributeMap = {
        
    }
Namespace.addCategoryObject('typeBinding', u'DirectionVectorType', DirectionVectorType)


# Complex type DomainSetType with content type ELEMENT_ONLY
class DomainSetType (pyxb.binding.basis.complexTypeDefinition):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'DomainSetType')
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.opengis.net/gml}AbstractGeometry uses Python identifier AbstractGeometry
    __AbstractGeometry = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'AbstractGeometry'), 'AbstractGeometry', '__DomainSetType_httpwww_opengis_netgmlAbstractGeometry', False)
    def AbstractGeometry (self):
        """Get the value of the {http://www.opengis.net/gml}AbstractGeometry element."""
        return self.__AbstractGeometry.value(self)
    def setAbstractGeometry (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}AbstractGeometry element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__AbstractGeometry.set(self, new_value)
    
    # Element {http://www.opengis.net/gml}AbstractTimeObject uses Python identifier AbstractTimeObject
    __AbstractTimeObject = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'AbstractTimeObject'), 'AbstractTimeObject', '__DomainSetType_httpwww_opengis_netgmlAbstractTimeObject', False)
    def AbstractTimeObject (self):
        """Get the value of the {http://www.opengis.net/gml}AbstractTimeObject element."""
        return self.__AbstractTimeObject.value(self)
    def setAbstractTimeObject (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}AbstractTimeObject element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__AbstractTimeObject.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}show uses Python identifier show
    __show = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'show'), 'show', '__DomainSetType_httpwww_w3_org1999xlinkshow', MODULEhttpwww_w3_org1999xlink.UNBOUNDNone_52)
    def show (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}show."""
        return self.__show.value(self)
    def setShow (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}show.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__show.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}href uses Python identifier href
    __href = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'href'), 'href', '__DomainSetType_httpwww_w3_org1999xlinkhref', pyxb.binding.datatypes.anyURI)
    def href (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}href."""
        return self.__href.value(self)
    def setHref (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}href.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__href.set(self, new_value)
    
    # Attribute owns uses Python identifier owns
    __owns = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'owns'), 'owns', '__DomainSetType_owns', pyxb.binding.datatypes.boolean, unicode_default=u'false')
    def owns (self):
        """Get the attribute value for owns."""
        return self.__owns.value(self)
    def setOwns (self, new_value):
        """Set the attribute value for owns.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__owns.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}type uses Python identifier type
    __type = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'type'), 'type', '__DomainSetType_httpwww_w3_org1999xlinktype', pyxb.binding.datatypes.string, fixed=True, unicode_default=u'simple')
    def type (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}type."""
        return self.__type.value(self)
    def setType (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}type.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__type.set(self, new_value)
    
    # Attribute {http://www.opengis.net/gml}remoteSchema uses Python identifier remoteSchema
    __remoteSchema = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(Namespace, u'remoteSchema'), 'remoteSchema', '__DomainSetType_httpwww_opengis_netgmlremoteSchema', pyxb.binding.datatypes.anyURI)
    def remoteSchema (self):
        """Get the attribute value for {http://www.opengis.net/gml}remoteSchema."""
        return self.__remoteSchema.value(self)
    def setRemoteSchema (self, new_value):
        """Set the attribute value for {http://www.opengis.net/gml}remoteSchema.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__remoteSchema.set(self, new_value)
    
    # Attribute nilReason uses Python identifier nilReason
    __nilReason = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'nilReason'), 'nilReason', '__DomainSetType_nilReason', NilReasonType)
    def nilReason (self):
        """Get the attribute value for nilReason."""
        return self.__nilReason.value(self)
    def setNilReason (self, new_value):
        """Set the attribute value for nilReason.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__nilReason.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}title uses Python identifier title
    __title = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'title'), 'title', '__DomainSetType_httpwww_w3_org1999xlinktitle', pyxb.binding.datatypes.string)
    def title (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}title."""
        return self.__title.value(self)
    def setTitle (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}title.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__title.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}actuate uses Python identifier actuate
    __actuate = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'actuate'), 'actuate', '__DomainSetType_httpwww_w3_org1999xlinkactuate', MODULEhttpwww_w3_org1999xlink.UNBOUNDNone_53)
    def actuate (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}actuate."""
        return self.__actuate.value(self)
    def setActuate (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}actuate.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__actuate.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}arcrole uses Python identifier arcrole
    __arcrole = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'arcrole'), 'arcrole', '__DomainSetType_httpwww_w3_org1999xlinkarcrole', pyxb.binding.datatypes.anyURI)
    def arcrole (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}arcrole."""
        return self.__arcrole.value(self)
    def setArcrole (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}arcrole.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__arcrole.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}role uses Python identifier role
    __role = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'role'), 'role', '__DomainSetType_httpwww_w3_org1999xlinkrole', pyxb.binding.datatypes.anyURI)
    def role (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}role."""
        return self.__role.value(self)
    def setRole (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}role.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__role.set(self, new_value)

    _ElementMap = {
        __AbstractGeometry.name() : __AbstractGeometry,
        __AbstractTimeObject.name() : __AbstractTimeObject
    }
    _AttributeMap = {
        __show.name() : __show,
        __href.name() : __href,
        __owns.name() : __owns,
        __type.name() : __type,
        __remoteSchema.name() : __remoteSchema,
        __nilReason.name() : __nilReason,
        __title.name() : __title,
        __actuate.name() : __actuate,
        __arcrole.name() : __arcrole,
        __role.name() : __role
    }
Namespace.addCategoryObject('typeBinding', u'DomainSetType', DomainSetType)


# Complex type EllipsoidPropertyType with content type ELEMENT_ONLY
class EllipsoidPropertyType (pyxb.binding.basis.complexTypeDefinition):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'EllipsoidPropertyType')
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.opengis.net/gml}Ellipsoid uses Python identifier Ellipsoid
    __Ellipsoid = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'Ellipsoid'), 'Ellipsoid', '__EllipsoidPropertyType_httpwww_opengis_netgmlEllipsoid', False)
    def Ellipsoid (self):
        """Get the value of the {http://www.opengis.net/gml}Ellipsoid element."""
        return self.__Ellipsoid.value(self)
    def setEllipsoid (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}Ellipsoid element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__Ellipsoid.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}show uses Python identifier show
    __show = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'show'), 'show', '__EllipsoidPropertyType_httpwww_w3_org1999xlinkshow', MODULEhttpwww_w3_org1999xlink.UNBOUNDNone_54)
    def show (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}show."""
        return self.__show.value(self)
    def setShow (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}show.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__show.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}href uses Python identifier href
    __href = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'href'), 'href', '__EllipsoidPropertyType_httpwww_w3_org1999xlinkhref', pyxb.binding.datatypes.anyURI)
    def href (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}href."""
        return self.__href.value(self)
    def setHref (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}href.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__href.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}type uses Python identifier type
    __type = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'type'), 'type', '__EllipsoidPropertyType_httpwww_w3_org1999xlinktype', pyxb.binding.datatypes.string, fixed=True, unicode_default=u'simple')
    def type (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}type."""
        return self.__type.value(self)
    def setType (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}type.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__type.set(self, new_value)
    
    # Attribute {http://www.opengis.net/gml}remoteSchema uses Python identifier remoteSchema
    __remoteSchema = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(Namespace, u'remoteSchema'), 'remoteSchema', '__EllipsoidPropertyType_httpwww_opengis_netgmlremoteSchema', pyxb.binding.datatypes.anyURI)
    def remoteSchema (self):
        """Get the attribute value for {http://www.opengis.net/gml}remoteSchema."""
        return self.__remoteSchema.value(self)
    def setRemoteSchema (self, new_value):
        """Set the attribute value for {http://www.opengis.net/gml}remoteSchema.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__remoteSchema.set(self, new_value)
    
    # Attribute nilReason uses Python identifier nilReason
    __nilReason = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'nilReason'), 'nilReason', '__EllipsoidPropertyType_nilReason', NilReasonType)
    def nilReason (self):
        """Get the attribute value for nilReason."""
        return self.__nilReason.value(self)
    def setNilReason (self, new_value):
        """Set the attribute value for nilReason.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__nilReason.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}title uses Python identifier title
    __title = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'title'), 'title', '__EllipsoidPropertyType_httpwww_w3_org1999xlinktitle', pyxb.binding.datatypes.string)
    def title (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}title."""
        return self.__title.value(self)
    def setTitle (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}title.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__title.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}role uses Python identifier role
    __role = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'role'), 'role', '__EllipsoidPropertyType_httpwww_w3_org1999xlinkrole', pyxb.binding.datatypes.anyURI)
    def role (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}role."""
        return self.__role.value(self)
    def setRole (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}role.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__role.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}actuate uses Python identifier actuate
    __actuate = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'actuate'), 'actuate', '__EllipsoidPropertyType_httpwww_w3_org1999xlinkactuate', MODULEhttpwww_w3_org1999xlink.UNBOUNDNone_55)
    def actuate (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}actuate."""
        return self.__actuate.value(self)
    def setActuate (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}actuate.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__actuate.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}arcrole uses Python identifier arcrole
    __arcrole = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'arcrole'), 'arcrole', '__EllipsoidPropertyType_httpwww_w3_org1999xlinkarcrole', pyxb.binding.datatypes.anyURI)
    def arcrole (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}arcrole."""
        return self.__arcrole.value(self)
    def setArcrole (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}arcrole.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__arcrole.set(self, new_value)

    _ElementMap = {
        __Ellipsoid.name() : __Ellipsoid
    }
    _AttributeMap = {
        __show.name() : __show,
        __href.name() : __href,
        __type.name() : __type,
        __remoteSchema.name() : __remoteSchema,
        __nilReason.name() : __nilReason,
        __title.name() : __title,
        __role.name() : __role,
        __actuate.name() : __actuate,
        __arcrole.name() : __arcrole
    }
Namespace.addCategoryObject('typeBinding', u'EllipsoidPropertyType', EllipsoidPropertyType)


# Complex type EllipsoidalCSPropertyType with content type ELEMENT_ONLY
class EllipsoidalCSPropertyType (pyxb.binding.basis.complexTypeDefinition):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'EllipsoidalCSPropertyType')
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.opengis.net/gml}EllipsoidalCS uses Python identifier EllipsoidalCS
    __EllipsoidalCS = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'EllipsoidalCS'), 'EllipsoidalCS', '__EllipsoidalCSPropertyType_httpwww_opengis_netgmlEllipsoidalCS', False)
    def EllipsoidalCS (self):
        """Get the value of the {http://www.opengis.net/gml}EllipsoidalCS element."""
        return self.__EllipsoidalCS.value(self)
    def setEllipsoidalCS (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}EllipsoidalCS element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__EllipsoidalCS.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}href uses Python identifier href
    __href = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'href'), 'href', '__EllipsoidalCSPropertyType_httpwww_w3_org1999xlinkhref', pyxb.binding.datatypes.anyURI)
    def href (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}href."""
        return self.__href.value(self)
    def setHref (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}href.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__href.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}show uses Python identifier show
    __show = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'show'), 'show', '__EllipsoidalCSPropertyType_httpwww_w3_org1999xlinkshow', MODULEhttpwww_w3_org1999xlink.UNBOUNDNone_56)
    def show (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}show."""
        return self.__show.value(self)
    def setShow (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}show.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__show.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}arcrole uses Python identifier arcrole
    __arcrole = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'arcrole'), 'arcrole', '__EllipsoidalCSPropertyType_httpwww_w3_org1999xlinkarcrole', pyxb.binding.datatypes.anyURI)
    def arcrole (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}arcrole."""
        return self.__arcrole.value(self)
    def setArcrole (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}arcrole.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__arcrole.set(self, new_value)
    
    # Attribute {http://www.opengis.net/gml}remoteSchema uses Python identifier remoteSchema
    __remoteSchema = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(Namespace, u'remoteSchema'), 'remoteSchema', '__EllipsoidalCSPropertyType_httpwww_opengis_netgmlremoteSchema', pyxb.binding.datatypes.anyURI)
    def remoteSchema (self):
        """Get the attribute value for {http://www.opengis.net/gml}remoteSchema."""
        return self.__remoteSchema.value(self)
    def setRemoteSchema (self, new_value):
        """Set the attribute value for {http://www.opengis.net/gml}remoteSchema.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__remoteSchema.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}actuate uses Python identifier actuate
    __actuate = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'actuate'), 'actuate', '__EllipsoidalCSPropertyType_httpwww_w3_org1999xlinkactuate', MODULEhttpwww_w3_org1999xlink.UNBOUNDNone_57)
    def actuate (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}actuate."""
        return self.__actuate.value(self)
    def setActuate (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}actuate.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__actuate.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}type uses Python identifier type
    __type = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'type'), 'type', '__EllipsoidalCSPropertyType_httpwww_w3_org1999xlinktype', pyxb.binding.datatypes.string, fixed=True, unicode_default=u'simple')
    def type (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}type."""
        return self.__type.value(self)
    def setType (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}type.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__type.set(self, new_value)
    
    # Attribute nilReason uses Python identifier nilReason
    __nilReason = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'nilReason'), 'nilReason', '__EllipsoidalCSPropertyType_nilReason', NilReasonType)
    def nilReason (self):
        """Get the attribute value for nilReason."""
        return self.__nilReason.value(self)
    def setNilReason (self, new_value):
        """Set the attribute value for nilReason.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__nilReason.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}title uses Python identifier title
    __title = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'title'), 'title', '__EllipsoidalCSPropertyType_httpwww_w3_org1999xlinktitle', pyxb.binding.datatypes.string)
    def title (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}title."""
        return self.__title.value(self)
    def setTitle (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}title.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__title.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}role uses Python identifier role
    __role = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'role'), 'role', '__EllipsoidalCSPropertyType_httpwww_w3_org1999xlinkrole', pyxb.binding.datatypes.anyURI)
    def role (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}role."""
        return self.__role.value(self)
    def setRole (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}role.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__role.set(self, new_value)

    _ElementMap = {
        __EllipsoidalCS.name() : __EllipsoidalCS
    }
    _AttributeMap = {
        __href.name() : __href,
        __show.name() : __show,
        __arcrole.name() : __arcrole,
        __remoteSchema.name() : __remoteSchema,
        __actuate.name() : __actuate,
        __type.name() : __type,
        __nilReason.name() : __nilReason,
        __title.name() : __title,
        __role.name() : __role
    }
Namespace.addCategoryObject('typeBinding', u'EllipsoidalCSPropertyType', EllipsoidalCSPropertyType)


# Complex type EngineeringCRSPropertyType with content type ELEMENT_ONLY
class EngineeringCRSPropertyType (pyxb.binding.basis.complexTypeDefinition):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'EngineeringCRSPropertyType')
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.opengis.net/gml}EngineeringCRS uses Python identifier EngineeringCRS
    __EngineeringCRS = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'EngineeringCRS'), 'EngineeringCRS', '__EngineeringCRSPropertyType_httpwww_opengis_netgmlEngineeringCRS', False)
    def EngineeringCRS (self):
        """Get the value of the {http://www.opengis.net/gml}EngineeringCRS element."""
        return self.__EngineeringCRS.value(self)
    def setEngineeringCRS (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}EngineeringCRS element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__EngineeringCRS.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}show uses Python identifier show
    __show = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'show'), 'show', '__EngineeringCRSPropertyType_httpwww_w3_org1999xlinkshow', MODULEhttpwww_w3_org1999xlink.UNBOUNDNone_58)
    def show (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}show."""
        return self.__show.value(self)
    def setShow (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}show.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__show.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}role uses Python identifier role
    __role = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'role'), 'role', '__EngineeringCRSPropertyType_httpwww_w3_org1999xlinkrole', pyxb.binding.datatypes.anyURI)
    def role (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}role."""
        return self.__role.value(self)
    def setRole (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}role.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__role.set(self, new_value)
    
    # Attribute {http://www.opengis.net/gml}remoteSchema uses Python identifier remoteSchema
    __remoteSchema = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(Namespace, u'remoteSchema'), 'remoteSchema', '__EngineeringCRSPropertyType_httpwww_opengis_netgmlremoteSchema', pyxb.binding.datatypes.anyURI)
    def remoteSchema (self):
        """Get the attribute value for {http://www.opengis.net/gml}remoteSchema."""
        return self.__remoteSchema.value(self)
    def setRemoteSchema (self, new_value):
        """Set the attribute value for {http://www.opengis.net/gml}remoteSchema.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__remoteSchema.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}href uses Python identifier href
    __href = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'href'), 'href', '__EngineeringCRSPropertyType_httpwww_w3_org1999xlinkhref', pyxb.binding.datatypes.anyURI)
    def href (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}href."""
        return self.__href.value(self)
    def setHref (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}href.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__href.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}arcrole uses Python identifier arcrole
    __arcrole = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'arcrole'), 'arcrole', '__EngineeringCRSPropertyType_httpwww_w3_org1999xlinkarcrole', pyxb.binding.datatypes.anyURI)
    def arcrole (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}arcrole."""
        return self.__arcrole.value(self)
    def setArcrole (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}arcrole.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__arcrole.set(self, new_value)
    
    # Attribute nilReason uses Python identifier nilReason
    __nilReason = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'nilReason'), 'nilReason', '__EngineeringCRSPropertyType_nilReason', NilReasonType)
    def nilReason (self):
        """Get the attribute value for nilReason."""
        return self.__nilReason.value(self)
    def setNilReason (self, new_value):
        """Set the attribute value for nilReason.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__nilReason.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}actuate uses Python identifier actuate
    __actuate = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'actuate'), 'actuate', '__EngineeringCRSPropertyType_httpwww_w3_org1999xlinkactuate', MODULEhttpwww_w3_org1999xlink.UNBOUNDNone_59)
    def actuate (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}actuate."""
        return self.__actuate.value(self)
    def setActuate (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}actuate.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__actuate.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}type uses Python identifier type
    __type = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'type'), 'type', '__EngineeringCRSPropertyType_httpwww_w3_org1999xlinktype', pyxb.binding.datatypes.string, fixed=True, unicode_default=u'simple')
    def type (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}type."""
        return self.__type.value(self)
    def setType (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}type.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__type.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}title uses Python identifier title
    __title = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'title'), 'title', '__EngineeringCRSPropertyType_httpwww_w3_org1999xlinktitle', pyxb.binding.datatypes.string)
    def title (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}title."""
        return self.__title.value(self)
    def setTitle (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}title.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__title.set(self, new_value)

    _ElementMap = {
        __EngineeringCRS.name() : __EngineeringCRS
    }
    _AttributeMap = {
        __show.name() : __show,
        __role.name() : __role,
        __remoteSchema.name() : __remoteSchema,
        __href.name() : __href,
        __arcrole.name() : __arcrole,
        __nilReason.name() : __nilReason,
        __actuate.name() : __actuate,
        __type.name() : __type,
        __title.name() : __title
    }
Namespace.addCategoryObject('typeBinding', u'EngineeringCRSPropertyType', EngineeringCRSPropertyType)


# Complex type EngineeringDatumPropertyType with content type ELEMENT_ONLY
class EngineeringDatumPropertyType (pyxb.binding.basis.complexTypeDefinition):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'EngineeringDatumPropertyType')
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.opengis.net/gml}EngineeringDatum uses Python identifier EngineeringDatum
    __EngineeringDatum = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'EngineeringDatum'), 'EngineeringDatum', '__EngineeringDatumPropertyType_httpwww_opengis_netgmlEngineeringDatum', False)
    def EngineeringDatum (self):
        """Get the value of the {http://www.opengis.net/gml}EngineeringDatum element."""
        return self.__EngineeringDatum.value(self)
    def setEngineeringDatum (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}EngineeringDatum element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__EngineeringDatum.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}show uses Python identifier show
    __show = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'show'), 'show', '__EngineeringDatumPropertyType_httpwww_w3_org1999xlinkshow', MODULEhttpwww_w3_org1999xlink.UNBOUNDNone_60)
    def show (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}show."""
        return self.__show.value(self)
    def setShow (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}show.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__show.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}href uses Python identifier href
    __href = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'href'), 'href', '__EngineeringDatumPropertyType_httpwww_w3_org1999xlinkhref', pyxb.binding.datatypes.anyURI)
    def href (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}href."""
        return self.__href.value(self)
    def setHref (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}href.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__href.set(self, new_value)
    
    # Attribute {http://www.opengis.net/gml}remoteSchema uses Python identifier remoteSchema
    __remoteSchema = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(Namespace, u'remoteSchema'), 'remoteSchema', '__EngineeringDatumPropertyType_httpwww_opengis_netgmlremoteSchema', pyxb.binding.datatypes.anyURI)
    def remoteSchema (self):
        """Get the attribute value for {http://www.opengis.net/gml}remoteSchema."""
        return self.__remoteSchema.value(self)
    def setRemoteSchema (self, new_value):
        """Set the attribute value for {http://www.opengis.net/gml}remoteSchema.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__remoteSchema.set(self, new_value)
    
    # Attribute nilReason uses Python identifier nilReason
    __nilReason = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'nilReason'), 'nilReason', '__EngineeringDatumPropertyType_nilReason', NilReasonType)
    def nilReason (self):
        """Get the attribute value for nilReason."""
        return self.__nilReason.value(self)
    def setNilReason (self, new_value):
        """Set the attribute value for nilReason.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__nilReason.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}type uses Python identifier type
    __type = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'type'), 'type', '__EngineeringDatumPropertyType_httpwww_w3_org1999xlinktype', pyxb.binding.datatypes.string, fixed=True, unicode_default=u'simple')
    def type (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}type."""
        return self.__type.value(self)
    def setType (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}type.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__type.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}title uses Python identifier title
    __title = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'title'), 'title', '__EngineeringDatumPropertyType_httpwww_w3_org1999xlinktitle', pyxb.binding.datatypes.string)
    def title (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}title."""
        return self.__title.value(self)
    def setTitle (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}title.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__title.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}actuate uses Python identifier actuate
    __actuate = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'actuate'), 'actuate', '__EngineeringDatumPropertyType_httpwww_w3_org1999xlinkactuate', MODULEhttpwww_w3_org1999xlink.UNBOUNDNone_61)
    def actuate (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}actuate."""
        return self.__actuate.value(self)
    def setActuate (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}actuate.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__actuate.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}arcrole uses Python identifier arcrole
    __arcrole = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'arcrole'), 'arcrole', '__EngineeringDatumPropertyType_httpwww_w3_org1999xlinkarcrole', pyxb.binding.datatypes.anyURI)
    def arcrole (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}arcrole."""
        return self.__arcrole.value(self)
    def setArcrole (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}arcrole.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__arcrole.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}role uses Python identifier role
    __role = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'role'), 'role', '__EngineeringDatumPropertyType_httpwww_w3_org1999xlinkrole', pyxb.binding.datatypes.anyURI)
    def role (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}role."""
        return self.__role.value(self)
    def setRole (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}role.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__role.set(self, new_value)

    _ElementMap = {
        __EngineeringDatum.name() : __EngineeringDatum
    }
    _AttributeMap = {
        __show.name() : __show,
        __href.name() : __href,
        __remoteSchema.name() : __remoteSchema,
        __nilReason.name() : __nilReason,
        __type.name() : __type,
        __title.name() : __title,
        __actuate.name() : __actuate,
        __arcrole.name() : __arcrole,
        __role.name() : __role
    }
Namespace.addCategoryObject('typeBinding', u'EngineeringDatumPropertyType', EngineeringDatumPropertyType)


# Complex type EnvelopeType with content type ELEMENT_ONLY
class EnvelopeType (pyxb.binding.basis.complexTypeDefinition):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'EnvelopeType')
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.opengis.net/gml}coordinates uses Python identifier coordinates
    __coordinates = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'coordinates'), 'coordinates', '__EnvelopeType_httpwww_opengis_netgmlcoordinates', False)
    def coordinates (self):
        """Get the value of the {http://www.opengis.net/gml}coordinates element."""
        return self.__coordinates.value(self)
    def setCoordinates (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}coordinates element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__coordinates.set(self, new_value)
    
    # Element {http://www.opengis.net/gml}lowerCorner uses Python identifier lowerCorner
    __lowerCorner = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'lowerCorner'), 'lowerCorner', '__EnvelopeType_httpwww_opengis_netgmllowerCorner', False)
    def lowerCorner (self):
        """Get the value of the {http://www.opengis.net/gml}lowerCorner element."""
        return self.__lowerCorner.value(self)
    def setLowerCorner (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}lowerCorner element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__lowerCorner.set(self, new_value)
    
    # Element {http://www.opengis.net/gml}upperCorner uses Python identifier upperCorner
    __upperCorner = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'upperCorner'), 'upperCorner', '__EnvelopeType_httpwww_opengis_netgmlupperCorner', False)
    def upperCorner (self):
        """Get the value of the {http://www.opengis.net/gml}upperCorner element."""
        return self.__upperCorner.value(self)
    def setUpperCorner (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}upperCorner element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__upperCorner.set(self, new_value)
    
    # Element {http://www.opengis.net/gml}pos uses Python identifier pos
    __pos = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'pos'), 'pos', '__EnvelopeType_httpwww_opengis_netgmlpos', True)
    def pos (self):
        """Get the value of the {http://www.opengis.net/gml}pos element."""
        return self.__pos.value(self)
    def setPos (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}pos element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__pos.set(self, new_value)
    
    def addPos (self, new_value):
        """Add the value as another occurrence of the {http://www.opengis.net/gml}pos element.  Raises
        BadValueTypeException if the new value is not consistent with the
        element's type."""
        return self.__pos.append(self, new_value)
    
    # Attribute srsName uses Python identifier srsName
    __srsName = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'srsName'), 'srsName', '__EnvelopeType_srsName', pyxb.binding.datatypes.anyURI)
    def srsName (self):
        """Get the attribute value for srsName."""
        return self.__srsName.value(self)
    def setSrsName (self, new_value):
        """Set the attribute value for srsName.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__srsName.set(self, new_value)
    
    # Attribute axisLabels uses Python identifier axisLabels
    __axisLabels = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'axisLabels'), 'axisLabels', '__EnvelopeType_axisLabels', NCNameList)
    def axisLabels (self):
        """Get the attribute value for axisLabels."""
        return self.__axisLabels.value(self)
    def setAxisLabels (self, new_value):
        """Set the attribute value for axisLabels.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__axisLabels.set(self, new_value)
    
    # Attribute srsDimension uses Python identifier srsDimension
    __srsDimension = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'srsDimension'), 'srsDimension', '__EnvelopeType_srsDimension', pyxb.binding.datatypes.positiveInteger)
    def srsDimension (self):
        """Get the attribute value for srsDimension."""
        return self.__srsDimension.value(self)
    def setSrsDimension (self, new_value):
        """Set the attribute value for srsDimension.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__srsDimension.set(self, new_value)
    
    # Attribute uomLabels uses Python identifier uomLabels
    __uomLabels = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'uomLabels'), 'uomLabels', '__EnvelopeType_uomLabels', NCNameList)
    def uomLabels (self):
        """Get the attribute value for uomLabels."""
        return self.__uomLabels.value(self)
    def setUomLabels (self, new_value):
        """Set the attribute value for uomLabels.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__uomLabels.set(self, new_value)

    _ElementMap = {
        __coordinates.name() : __coordinates,
        __lowerCorner.name() : __lowerCorner,
        __upperCorner.name() : __upperCorner,
        __pos.name() : __pos
    }
    _AttributeMap = {
        __srsName.name() : __srsName,
        __axisLabels.name() : __axisLabels,
        __srsDimension.name() : __srsDimension,
        __uomLabels.name() : __uomLabels
    }
Namespace.addCategoryObject('typeBinding', u'EnvelopeType', EnvelopeType)


# Complex type FeatureArrayPropertyType with content type ELEMENT_ONLY
class FeatureArrayPropertyType (pyxb.binding.basis.complexTypeDefinition):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'FeatureArrayPropertyType')
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.opengis.net/gml}AbstractFeature uses Python identifier AbstractFeature
    __AbstractFeature = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'AbstractFeature'), 'AbstractFeature', '__FeatureArrayPropertyType_httpwww_opengis_netgmlAbstractFeature', True)
    def AbstractFeature (self):
        """Get the value of the {http://www.opengis.net/gml}AbstractFeature element."""
        return self.__AbstractFeature.value(self)
    def setAbstractFeature (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}AbstractFeature element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__AbstractFeature.set(self, new_value)
    
    def addAbstractFeature (self, new_value):
        """Add the value as another occurrence of the {http://www.opengis.net/gml}AbstractFeature element.  Raises
        BadValueTypeException if the new value is not consistent with the
        element's type."""
        return self.__AbstractFeature.append(self, new_value)

    _ElementMap = {
        __AbstractFeature.name() : __AbstractFeature
    }
    _AttributeMap = {
        
    }
Namespace.addCategoryObject('typeBinding', u'FeatureArrayPropertyType', FeatureArrayPropertyType)


# Complex type FeaturePropertyType with content type ELEMENT_ONLY
class FeaturePropertyType (pyxb.binding.basis.complexTypeDefinition):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'FeaturePropertyType')
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.opengis.net/gml}AbstractFeature uses Python identifier AbstractFeature
    __AbstractFeature = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'AbstractFeature'), 'AbstractFeature', '__FeaturePropertyType_httpwww_opengis_netgmlAbstractFeature', False)
    def AbstractFeature (self):
        """Get the value of the {http://www.opengis.net/gml}AbstractFeature element."""
        return self.__AbstractFeature.value(self)
    def setAbstractFeature (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}AbstractFeature element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__AbstractFeature.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}show uses Python identifier show
    __show = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'show'), 'show', '__FeaturePropertyType_httpwww_w3_org1999xlinkshow', MODULEhttpwww_w3_org1999xlink.UNBOUNDNone_62)
    def show (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}show."""
        return self.__show.value(self)
    def setShow (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}show.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__show.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}arcrole uses Python identifier arcrole
    __arcrole = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'arcrole'), 'arcrole', '__FeaturePropertyType_httpwww_w3_org1999xlinkarcrole', pyxb.binding.datatypes.anyURI)
    def arcrole (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}arcrole."""
        return self.__arcrole.value(self)
    def setArcrole (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}arcrole.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__arcrole.set(self, new_value)
    
    # Attribute {http://www.opengis.net/gml}remoteSchema uses Python identifier remoteSchema
    __remoteSchema = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(Namespace, u'remoteSchema'), 'remoteSchema', '__FeaturePropertyType_httpwww_opengis_netgmlremoteSchema', pyxb.binding.datatypes.anyURI)
    def remoteSchema (self):
        """Get the attribute value for {http://www.opengis.net/gml}remoteSchema."""
        return self.__remoteSchema.value(self)
    def setRemoteSchema (self, new_value):
        """Set the attribute value for {http://www.opengis.net/gml}remoteSchema.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__remoteSchema.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}actuate uses Python identifier actuate
    __actuate = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'actuate'), 'actuate', '__FeaturePropertyType_httpwww_w3_org1999xlinkactuate', MODULEhttpwww_w3_org1999xlink.UNBOUNDNone_63)
    def actuate (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}actuate."""
        return self.__actuate.value(self)
    def setActuate (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}actuate.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__actuate.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}type uses Python identifier type
    __type = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'type'), 'type', '__FeaturePropertyType_httpwww_w3_org1999xlinktype', pyxb.binding.datatypes.string, fixed=True, unicode_default=u'simple')
    def type (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}type."""
        return self.__type.value(self)
    def setType (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}type.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__type.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}title uses Python identifier title
    __title = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'title'), 'title', '__FeaturePropertyType_httpwww_w3_org1999xlinktitle', pyxb.binding.datatypes.string)
    def title (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}title."""
        return self.__title.value(self)
    def setTitle (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}title.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__title.set(self, new_value)
    
    # Attribute nilReason uses Python identifier nilReason
    __nilReason = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'nilReason'), 'nilReason', '__FeaturePropertyType_nilReason', NilReasonType)
    def nilReason (self):
        """Get the attribute value for nilReason."""
        return self.__nilReason.value(self)
    def setNilReason (self, new_value):
        """Set the attribute value for nilReason.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__nilReason.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}role uses Python identifier role
    __role = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'role'), 'role', '__FeaturePropertyType_httpwww_w3_org1999xlinkrole', pyxb.binding.datatypes.anyURI)
    def role (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}role."""
        return self.__role.value(self)
    def setRole (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}role.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__role.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}href uses Python identifier href
    __href = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'href'), 'href', '__FeaturePropertyType_httpwww_w3_org1999xlinkhref', pyxb.binding.datatypes.anyURI)
    def href (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}href."""
        return self.__href.value(self)
    def setHref (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}href.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__href.set(self, new_value)
    
    # Attribute owns uses Python identifier owns
    __owns = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'owns'), 'owns', '__FeaturePropertyType_owns', pyxb.binding.datatypes.boolean, unicode_default=u'false')
    def owns (self):
        """Get the attribute value for owns."""
        return self.__owns.value(self)
    def setOwns (self, new_value):
        """Set the attribute value for owns.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__owns.set(self, new_value)

    _ElementMap = {
        __AbstractFeature.name() : __AbstractFeature
    }
    _AttributeMap = {
        __show.name() : __show,
        __arcrole.name() : __arcrole,
        __remoteSchema.name() : __remoteSchema,
        __actuate.name() : __actuate,
        __type.name() : __type,
        __title.name() : __title,
        __nilReason.name() : __nilReason,
        __role.name() : __role,
        __href.name() : __href,
        __owns.name() : __owns
    }
Namespace.addCategoryObject('typeBinding', u'FeaturePropertyType', FeaturePropertyType)


# Complex type FileType with content type ELEMENT_ONLY
class FileType (pyxb.binding.basis.complexTypeDefinition):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'FileType')
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.opengis.net/gml}compression uses Python identifier compression
    __compression = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'compression'), 'compression', '__FileType_httpwww_opengis_netgmlcompression', True)
    def compression (self):
        """Get the value of the {http://www.opengis.net/gml}compression element."""
        return self.__compression.value(self)
    def setCompression (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}compression element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__compression.set(self, new_value)
    
    def addCompression (self, new_value):
        """Add the value as another occurrence of the {http://www.opengis.net/gml}compression element.  Raises
        BadValueTypeException if the new value is not consistent with the
        element's type."""
        return self.__compression.append(self, new_value)
    
    # Element {http://www.opengis.net/gml}fileStructure uses Python identifier fileStructure
    __fileStructure = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'fileStructure'), 'fileStructure', '__FileType_httpwww_opengis_netgmlfileStructure', True)
    def fileStructure (self):
        """Get the value of the {http://www.opengis.net/gml}fileStructure element."""
        return self.__fileStructure.value(self)
    def setFileStructure (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}fileStructure element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__fileStructure.set(self, new_value)
    
    def addFileStructure (self, new_value):
        """Add the value as another occurrence of the {http://www.opengis.net/gml}fileStructure element.  Raises
        BadValueTypeException if the new value is not consistent with the
        element's type."""
        return self.__fileStructure.append(self, new_value)
    
    # Element {http://www.opengis.net/gml}fileReference uses Python identifier fileReference
    __fileReference = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'fileReference'), 'fileReference', '__FileType_httpwww_opengis_netgmlfileReference', False)
    def fileReference (self):
        """Get the value of the {http://www.opengis.net/gml}fileReference element."""
        return self.__fileReference.value(self)
    def setFileReference (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}fileReference element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__fileReference.set(self, new_value)
    
    # Element {http://www.opengis.net/gml}mimeType uses Python identifier mimeType
    __mimeType = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'mimeType'), 'mimeType', '__FileType_httpwww_opengis_netgmlmimeType', True)
    def mimeType (self):
        """Get the value of the {http://www.opengis.net/gml}mimeType element."""
        return self.__mimeType.value(self)
    def setMimeType (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}mimeType element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__mimeType.set(self, new_value)
    
    def addMimeType (self, new_value):
        """Add the value as another occurrence of the {http://www.opengis.net/gml}mimeType element.  Raises
        BadValueTypeException if the new value is not consistent with the
        element's type."""
        return self.__mimeType.append(self, new_value)
    
    # Element {http://www.opengis.net/gml}fileName uses Python identifier fileName
    __fileName = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'fileName'), 'fileName', '__FileType_httpwww_opengis_netgmlfileName', False)
    def fileName (self):
        """Get the value of the {http://www.opengis.net/gml}fileName element."""
        return self.__fileName.value(self)
    def setFileName (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}fileName element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__fileName.set(self, new_value)
    
    # Element {http://www.opengis.net/gml}rangeParameters uses Python identifier rangeParameters
    __rangeParameters = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'rangeParameters'), 'rangeParameters', '__FileType_httpwww_opengis_netgmlrangeParameters', True)
    def rangeParameters (self):
        """Get the value of the {http://www.opengis.net/gml}rangeParameters element."""
        return self.__rangeParameters.value(self)
    def setRangeParameters (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}rangeParameters element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__rangeParameters.set(self, new_value)
    
    def addRangeParameters (self, new_value):
        """Add the value as another occurrence of the {http://www.opengis.net/gml}rangeParameters element.  Raises
        BadValueTypeException if the new value is not consistent with the
        element's type."""
        return self.__rangeParameters.append(self, new_value)

    _ElementMap = {
        __compression.name() : __compression,
        __fileStructure.name() : __fileStructure,
        __fileReference.name() : __fileReference,
        __mimeType.name() : __mimeType,
        __fileName.name() : __fileName,
        __rangeParameters.name() : __rangeParameters
    }
    _AttributeMap = {
        
    }
Namespace.addCategoryObject('typeBinding', u'FileType', FileType)


# Complex type FormulaType with content type ELEMENT_ONLY
class FormulaType (pyxb.binding.basis.complexTypeDefinition):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'FormulaType')
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.opengis.net/gml}b uses Python identifier b
    __b = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'b'), 'b', '__FormulaType_httpwww_opengis_netgmlb', False)
    def b (self):
        """Get the value of the {http://www.opengis.net/gml}b element."""
        return self.__b.value(self)
    def setB (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}b element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__b.set(self, new_value)
    
    # Element {http://www.opengis.net/gml}a uses Python identifier a
    __a = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'a'), 'a', '__FormulaType_httpwww_opengis_netgmla', False)
    def a (self):
        """Get the value of the {http://www.opengis.net/gml}a element."""
        return self.__a.value(self)
    def setA (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}a element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__a.set(self, new_value)
    
    # Element {http://www.opengis.net/gml}d uses Python identifier d
    __d = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'd'), 'd', '__FormulaType_httpwww_opengis_netgmld', False)
    def d (self):
        """Get the value of the {http://www.opengis.net/gml}d element."""
        return self.__d.value(self)
    def setD (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}d element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__d.set(self, new_value)
    
    # Element {http://www.opengis.net/gml}c uses Python identifier c
    __c = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'c'), 'c', '__FormulaType_httpwww_opengis_netgmlc', False)
    def c (self):
        """Get the value of the {http://www.opengis.net/gml}c element."""
        return self.__c.value(self)
    def setC (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}c element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__c.set(self, new_value)

    _ElementMap = {
        __b.name() : __b,
        __a.name() : __a,
        __d.name() : __d,
        __c.name() : __c
    }
    _AttributeMap = {
        
    }
Namespace.addCategoryObject('typeBinding', u'FormulaType', FormulaType)


# Complex type GeneralConversionPropertyType with content type ELEMENT_ONLY
class GeneralConversionPropertyType (pyxb.binding.basis.complexTypeDefinition):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'GeneralConversionPropertyType')
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.opengis.net/gml}AbstractGeneralConversion uses Python identifier AbstractGeneralConversion
    __AbstractGeneralConversion = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'AbstractGeneralConversion'), 'AbstractGeneralConversion', '__GeneralConversionPropertyType_httpwww_opengis_netgmlAbstractGeneralConversion', False)
    def AbstractGeneralConversion (self):
        """Get the value of the {http://www.opengis.net/gml}AbstractGeneralConversion element."""
        return self.__AbstractGeneralConversion.value(self)
    def setAbstractGeneralConversion (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}AbstractGeneralConversion element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__AbstractGeneralConversion.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}title uses Python identifier title
    __title = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'title'), 'title', '__GeneralConversionPropertyType_httpwww_w3_org1999xlinktitle', pyxb.binding.datatypes.string)
    def title (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}title."""
        return self.__title.value(self)
    def setTitle (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}title.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__title.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}show uses Python identifier show
    __show = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'show'), 'show', '__GeneralConversionPropertyType_httpwww_w3_org1999xlinkshow', MODULEhttpwww_w3_org1999xlink.UNBOUNDNone_64)
    def show (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}show."""
        return self.__show.value(self)
    def setShow (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}show.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__show.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}role uses Python identifier role
    __role = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'role'), 'role', '__GeneralConversionPropertyType_httpwww_w3_org1999xlinkrole', pyxb.binding.datatypes.anyURI)
    def role (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}role."""
        return self.__role.value(self)
    def setRole (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}role.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__role.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}href uses Python identifier href
    __href = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'href'), 'href', '__GeneralConversionPropertyType_httpwww_w3_org1999xlinkhref', pyxb.binding.datatypes.anyURI)
    def href (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}href."""
        return self.__href.value(self)
    def setHref (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}href.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__href.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}actuate uses Python identifier actuate
    __actuate = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'actuate'), 'actuate', '__GeneralConversionPropertyType_httpwww_w3_org1999xlinkactuate', MODULEhttpwww_w3_org1999xlink.UNBOUNDNone_65)
    def actuate (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}actuate."""
        return self.__actuate.value(self)
    def setActuate (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}actuate.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__actuate.set(self, new_value)
    
    # Attribute nilReason uses Python identifier nilReason
    __nilReason = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'nilReason'), 'nilReason', '__GeneralConversionPropertyType_nilReason', NilReasonType)
    def nilReason (self):
        """Get the attribute value for nilReason."""
        return self.__nilReason.value(self)
    def setNilReason (self, new_value):
        """Set the attribute value for nilReason.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__nilReason.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}arcrole uses Python identifier arcrole
    __arcrole = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'arcrole'), 'arcrole', '__GeneralConversionPropertyType_httpwww_w3_org1999xlinkarcrole', pyxb.binding.datatypes.anyURI)
    def arcrole (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}arcrole."""
        return self.__arcrole.value(self)
    def setArcrole (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}arcrole.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__arcrole.set(self, new_value)
    
    # Attribute {http://www.opengis.net/gml}remoteSchema uses Python identifier remoteSchema
    __remoteSchema = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(Namespace, u'remoteSchema'), 'remoteSchema', '__GeneralConversionPropertyType_httpwww_opengis_netgmlremoteSchema', pyxb.binding.datatypes.anyURI)
    def remoteSchema (self):
        """Get the attribute value for {http://www.opengis.net/gml}remoteSchema."""
        return self.__remoteSchema.value(self)
    def setRemoteSchema (self, new_value):
        """Set the attribute value for {http://www.opengis.net/gml}remoteSchema.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__remoteSchema.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}type uses Python identifier type
    __type = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'type'), 'type', '__GeneralConversionPropertyType_httpwww_w3_org1999xlinktype', pyxb.binding.datatypes.string, fixed=True, unicode_default=u'simple')
    def type (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}type."""
        return self.__type.value(self)
    def setType (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}type.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__type.set(self, new_value)

    _ElementMap = {
        __AbstractGeneralConversion.name() : __AbstractGeneralConversion
    }
    _AttributeMap = {
        __title.name() : __title,
        __show.name() : __show,
        __role.name() : __role,
        __href.name() : __href,
        __actuate.name() : __actuate,
        __nilReason.name() : __nilReason,
        __arcrole.name() : __arcrole,
        __remoteSchema.name() : __remoteSchema,
        __type.name() : __type
    }
Namespace.addCategoryObject('typeBinding', u'GeneralConversionPropertyType', GeneralConversionPropertyType)


# Complex type GeneralTransformationPropertyType with content type ELEMENT_ONLY
class GeneralTransformationPropertyType (pyxb.binding.basis.complexTypeDefinition):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'GeneralTransformationPropertyType')
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.opengis.net/gml}AbstractGeneralTransformation uses Python identifier AbstractGeneralTransformation
    __AbstractGeneralTransformation = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'AbstractGeneralTransformation'), 'AbstractGeneralTransformation', '__GeneralTransformationPropertyType_httpwww_opengis_netgmlAbstractGeneralTransformation', False)
    def AbstractGeneralTransformation (self):
        """Get the value of the {http://www.opengis.net/gml}AbstractGeneralTransformation element."""
        return self.__AbstractGeneralTransformation.value(self)
    def setAbstractGeneralTransformation (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}AbstractGeneralTransformation element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__AbstractGeneralTransformation.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}show uses Python identifier show
    __show = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'show'), 'show', '__GeneralTransformationPropertyType_httpwww_w3_org1999xlinkshow', MODULEhttpwww_w3_org1999xlink.UNBOUNDNone_66)
    def show (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}show."""
        return self.__show.value(self)
    def setShow (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}show.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__show.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}title uses Python identifier title
    __title = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'title'), 'title', '__GeneralTransformationPropertyType_httpwww_w3_org1999xlinktitle', pyxb.binding.datatypes.string)
    def title (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}title."""
        return self.__title.value(self)
    def setTitle (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}title.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__title.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}role uses Python identifier role
    __role = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'role'), 'role', '__GeneralTransformationPropertyType_httpwww_w3_org1999xlinkrole', pyxb.binding.datatypes.anyURI)
    def role (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}role."""
        return self.__role.value(self)
    def setRole (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}role.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__role.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}href uses Python identifier href
    __href = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'href'), 'href', '__GeneralTransformationPropertyType_httpwww_w3_org1999xlinkhref', pyxb.binding.datatypes.anyURI)
    def href (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}href."""
        return self.__href.value(self)
    def setHref (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}href.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__href.set(self, new_value)
    
    # Attribute nilReason uses Python identifier nilReason
    __nilReason = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'nilReason'), 'nilReason', '__GeneralTransformationPropertyType_nilReason', NilReasonType)
    def nilReason (self):
        """Get the attribute value for nilReason."""
        return self.__nilReason.value(self)
    def setNilReason (self, new_value):
        """Set the attribute value for nilReason.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__nilReason.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}arcrole uses Python identifier arcrole
    __arcrole = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'arcrole'), 'arcrole', '__GeneralTransformationPropertyType_httpwww_w3_org1999xlinkarcrole', pyxb.binding.datatypes.anyURI)
    def arcrole (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}arcrole."""
        return self.__arcrole.value(self)
    def setArcrole (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}arcrole.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__arcrole.set(self, new_value)
    
    # Attribute {http://www.opengis.net/gml}remoteSchema uses Python identifier remoteSchema
    __remoteSchema = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(Namespace, u'remoteSchema'), 'remoteSchema', '__GeneralTransformationPropertyType_httpwww_opengis_netgmlremoteSchema', pyxb.binding.datatypes.anyURI)
    def remoteSchema (self):
        """Get the attribute value for {http://www.opengis.net/gml}remoteSchema."""
        return self.__remoteSchema.value(self)
    def setRemoteSchema (self, new_value):
        """Set the attribute value for {http://www.opengis.net/gml}remoteSchema.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__remoteSchema.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}actuate uses Python identifier actuate
    __actuate = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'actuate'), 'actuate', '__GeneralTransformationPropertyType_httpwww_w3_org1999xlinkactuate', MODULEhttpwww_w3_org1999xlink.UNBOUNDNone_67)
    def actuate (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}actuate."""
        return self.__actuate.value(self)
    def setActuate (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}actuate.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__actuate.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}type uses Python identifier type
    __type = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'type'), 'type', '__GeneralTransformationPropertyType_httpwww_w3_org1999xlinktype', pyxb.binding.datatypes.string, fixed=True, unicode_default=u'simple')
    def type (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}type."""
        return self.__type.value(self)
    def setType (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}type.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__type.set(self, new_value)

    _ElementMap = {
        __AbstractGeneralTransformation.name() : __AbstractGeneralTransformation
    }
    _AttributeMap = {
        __show.name() : __show,
        __title.name() : __title,
        __role.name() : __role,
        __href.name() : __href,
        __nilReason.name() : __nilReason,
        __arcrole.name() : __arcrole,
        __remoteSchema.name() : __remoteSchema,
        __actuate.name() : __actuate,
        __type.name() : __type
    }
Namespace.addCategoryObject('typeBinding', u'GeneralTransformationPropertyType', GeneralTransformationPropertyType)


# Complex type GeocentricCRSPropertyType with content type ELEMENT_ONLY
class GeocentricCRSPropertyType (pyxb.binding.basis.complexTypeDefinition):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'GeocentricCRSPropertyType')
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.opengis.net/gml}GeocentricCRS uses Python identifier GeocentricCRS
    __GeocentricCRS = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'GeocentricCRS'), 'GeocentricCRS', '__GeocentricCRSPropertyType_httpwww_opengis_netgmlGeocentricCRS', False)
    def GeocentricCRS (self):
        """Get the value of the {http://www.opengis.net/gml}GeocentricCRS element."""
        return self.__GeocentricCRS.value(self)
    def setGeocentricCRS (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}GeocentricCRS element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__GeocentricCRS.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}title uses Python identifier title
    __title = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'title'), 'title', '__GeocentricCRSPropertyType_httpwww_w3_org1999xlinktitle', pyxb.binding.datatypes.string)
    def title (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}title."""
        return self.__title.value(self)
    def setTitle (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}title.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__title.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}show uses Python identifier show
    __show = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'show'), 'show', '__GeocentricCRSPropertyType_httpwww_w3_org1999xlinkshow', MODULEhttpwww_w3_org1999xlink.UNBOUNDNone_68)
    def show (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}show."""
        return self.__show.value(self)
    def setShow (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}show.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__show.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}role uses Python identifier role
    __role = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'role'), 'role', '__GeocentricCRSPropertyType_httpwww_w3_org1999xlinkrole', pyxb.binding.datatypes.anyURI)
    def role (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}role."""
        return self.__role.value(self)
    def setRole (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}role.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__role.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}href uses Python identifier href
    __href = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'href'), 'href', '__GeocentricCRSPropertyType_httpwww_w3_org1999xlinkhref', pyxb.binding.datatypes.anyURI)
    def href (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}href."""
        return self.__href.value(self)
    def setHref (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}href.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__href.set(self, new_value)
    
    # Attribute nilReason uses Python identifier nilReason
    __nilReason = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'nilReason'), 'nilReason', '__GeocentricCRSPropertyType_nilReason', NilReasonType)
    def nilReason (self):
        """Get the attribute value for nilReason."""
        return self.__nilReason.value(self)
    def setNilReason (self, new_value):
        """Set the attribute value for nilReason.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__nilReason.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}arcrole uses Python identifier arcrole
    __arcrole = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'arcrole'), 'arcrole', '__GeocentricCRSPropertyType_httpwww_w3_org1999xlinkarcrole', pyxb.binding.datatypes.anyURI)
    def arcrole (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}arcrole."""
        return self.__arcrole.value(self)
    def setArcrole (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}arcrole.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__arcrole.set(self, new_value)
    
    # Attribute {http://www.opengis.net/gml}remoteSchema uses Python identifier remoteSchema
    __remoteSchema = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(Namespace, u'remoteSchema'), 'remoteSchema', '__GeocentricCRSPropertyType_httpwww_opengis_netgmlremoteSchema', pyxb.binding.datatypes.anyURI)
    def remoteSchema (self):
        """Get the attribute value for {http://www.opengis.net/gml}remoteSchema."""
        return self.__remoteSchema.value(self)
    def setRemoteSchema (self, new_value):
        """Set the attribute value for {http://www.opengis.net/gml}remoteSchema.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__remoteSchema.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}actuate uses Python identifier actuate
    __actuate = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'actuate'), 'actuate', '__GeocentricCRSPropertyType_httpwww_w3_org1999xlinkactuate', MODULEhttpwww_w3_org1999xlink.UNBOUNDNone_69)
    def actuate (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}actuate."""
        return self.__actuate.value(self)
    def setActuate (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}actuate.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__actuate.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}type uses Python identifier type
    __type = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'type'), 'type', '__GeocentricCRSPropertyType_httpwww_w3_org1999xlinktype', pyxb.binding.datatypes.string, fixed=True, unicode_default=u'simple')
    def type (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}type."""
        return self.__type.value(self)
    def setType (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}type.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__type.set(self, new_value)

    _ElementMap = {
        __GeocentricCRS.name() : __GeocentricCRS
    }
    _AttributeMap = {
        __title.name() : __title,
        __show.name() : __show,
        __role.name() : __role,
        __href.name() : __href,
        __nilReason.name() : __nilReason,
        __arcrole.name() : __arcrole,
        __remoteSchema.name() : __remoteSchema,
        __actuate.name() : __actuate,
        __type.name() : __type
    }
Namespace.addCategoryObject('typeBinding', u'GeocentricCRSPropertyType', GeocentricCRSPropertyType)


# Complex type GeodeticCRSPropertyType with content type ELEMENT_ONLY
class GeodeticCRSPropertyType (pyxb.binding.basis.complexTypeDefinition):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'GeodeticCRSPropertyType')
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.opengis.net/gml}GeodeticCRS uses Python identifier GeodeticCRS
    __GeodeticCRS = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'GeodeticCRS'), 'GeodeticCRS', '__GeodeticCRSPropertyType_httpwww_opengis_netgmlGeodeticCRS', False)
    def GeodeticCRS (self):
        """Get the value of the {http://www.opengis.net/gml}GeodeticCRS element."""
        return self.__GeodeticCRS.value(self)
    def setGeodeticCRS (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}GeodeticCRS element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__GeodeticCRS.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}show uses Python identifier show
    __show = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'show'), 'show', '__GeodeticCRSPropertyType_httpwww_w3_org1999xlinkshow', MODULEhttpwww_w3_org1999xlink.UNBOUNDNone_70)
    def show (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}show."""
        return self.__show.value(self)
    def setShow (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}show.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__show.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}href uses Python identifier href
    __href = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'href'), 'href', '__GeodeticCRSPropertyType_httpwww_w3_org1999xlinkhref', pyxb.binding.datatypes.anyURI)
    def href (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}href."""
        return self.__href.value(self)
    def setHref (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}href.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__href.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}arcrole uses Python identifier arcrole
    __arcrole = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'arcrole'), 'arcrole', '__GeodeticCRSPropertyType_httpwww_w3_org1999xlinkarcrole', pyxb.binding.datatypes.anyURI)
    def arcrole (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}arcrole."""
        return self.__arcrole.value(self)
    def setArcrole (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}arcrole.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__arcrole.set(self, new_value)
    
    # Attribute {http://www.opengis.net/gml}remoteSchema uses Python identifier remoteSchema
    __remoteSchema = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(Namespace, u'remoteSchema'), 'remoteSchema', '__GeodeticCRSPropertyType_httpwww_opengis_netgmlremoteSchema', pyxb.binding.datatypes.anyURI)
    def remoteSchema (self):
        """Get the attribute value for {http://www.opengis.net/gml}remoteSchema."""
        return self.__remoteSchema.value(self)
    def setRemoteSchema (self, new_value):
        """Set the attribute value for {http://www.opengis.net/gml}remoteSchema.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__remoteSchema.set(self, new_value)
    
    # Attribute nilReason uses Python identifier nilReason
    __nilReason = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'nilReason'), 'nilReason', '__GeodeticCRSPropertyType_nilReason', NilReasonType)
    def nilReason (self):
        """Get the attribute value for nilReason."""
        return self.__nilReason.value(self)
    def setNilReason (self, new_value):
        """Set the attribute value for nilReason.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__nilReason.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}type uses Python identifier type
    __type = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'type'), 'type', '__GeodeticCRSPropertyType_httpwww_w3_org1999xlinktype', pyxb.binding.datatypes.string, fixed=True, unicode_default=u'simple')
    def type (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}type."""
        return self.__type.value(self)
    def setType (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}type.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__type.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}title uses Python identifier title
    __title = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'title'), 'title', '__GeodeticCRSPropertyType_httpwww_w3_org1999xlinktitle', pyxb.binding.datatypes.string)
    def title (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}title."""
        return self.__title.value(self)
    def setTitle (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}title.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__title.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}actuate uses Python identifier actuate
    __actuate = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'actuate'), 'actuate', '__GeodeticCRSPropertyType_httpwww_w3_org1999xlinkactuate', MODULEhttpwww_w3_org1999xlink.UNBOUNDNone_71)
    def actuate (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}actuate."""
        return self.__actuate.value(self)
    def setActuate (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}actuate.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__actuate.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}role uses Python identifier role
    __role = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'role'), 'role', '__GeodeticCRSPropertyType_httpwww_w3_org1999xlinkrole', pyxb.binding.datatypes.anyURI)
    def role (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}role."""
        return self.__role.value(self)
    def setRole (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}role.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__role.set(self, new_value)

    _ElementMap = {
        __GeodeticCRS.name() : __GeodeticCRS
    }
    _AttributeMap = {
        __show.name() : __show,
        __href.name() : __href,
        __arcrole.name() : __arcrole,
        __remoteSchema.name() : __remoteSchema,
        __nilReason.name() : __nilReason,
        __type.name() : __type,
        __title.name() : __title,
        __actuate.name() : __actuate,
        __role.name() : __role
    }
Namespace.addCategoryObject('typeBinding', u'GeodeticCRSPropertyType', GeodeticCRSPropertyType)


# Complex type GeodeticDatumPropertyType with content type ELEMENT_ONLY
class GeodeticDatumPropertyType (pyxb.binding.basis.complexTypeDefinition):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'GeodeticDatumPropertyType')
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.opengis.net/gml}GeodeticDatum uses Python identifier GeodeticDatum
    __GeodeticDatum = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'GeodeticDatum'), 'GeodeticDatum', '__GeodeticDatumPropertyType_httpwww_opengis_netgmlGeodeticDatum', False)
    def GeodeticDatum (self):
        """Get the value of the {http://www.opengis.net/gml}GeodeticDatum element."""
        return self.__GeodeticDatum.value(self)
    def setGeodeticDatum (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}GeodeticDatum element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__GeodeticDatum.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}show uses Python identifier show
    __show = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'show'), 'show', '__GeodeticDatumPropertyType_httpwww_w3_org1999xlinkshow', MODULEhttpwww_w3_org1999xlink.UNBOUNDNone_72)
    def show (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}show."""
        return self.__show.value(self)
    def setShow (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}show.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__show.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}title uses Python identifier title
    __title = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'title'), 'title', '__GeodeticDatumPropertyType_httpwww_w3_org1999xlinktitle', pyxb.binding.datatypes.string)
    def title (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}title."""
        return self.__title.value(self)
    def setTitle (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}title.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__title.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}role uses Python identifier role
    __role = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'role'), 'role', '__GeodeticDatumPropertyType_httpwww_w3_org1999xlinkrole', pyxb.binding.datatypes.anyURI)
    def role (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}role."""
        return self.__role.value(self)
    def setRole (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}role.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__role.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}href uses Python identifier href
    __href = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'href'), 'href', '__GeodeticDatumPropertyType_httpwww_w3_org1999xlinkhref', pyxb.binding.datatypes.anyURI)
    def href (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}href."""
        return self.__href.value(self)
    def setHref (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}href.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__href.set(self, new_value)
    
    # Attribute nilReason uses Python identifier nilReason
    __nilReason = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'nilReason'), 'nilReason', '__GeodeticDatumPropertyType_nilReason', NilReasonType)
    def nilReason (self):
        """Get the attribute value for nilReason."""
        return self.__nilReason.value(self)
    def setNilReason (self, new_value):
        """Set the attribute value for nilReason.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__nilReason.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}arcrole uses Python identifier arcrole
    __arcrole = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'arcrole'), 'arcrole', '__GeodeticDatumPropertyType_httpwww_w3_org1999xlinkarcrole', pyxb.binding.datatypes.anyURI)
    def arcrole (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}arcrole."""
        return self.__arcrole.value(self)
    def setArcrole (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}arcrole.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__arcrole.set(self, new_value)
    
    # Attribute {http://www.opengis.net/gml}remoteSchema uses Python identifier remoteSchema
    __remoteSchema = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(Namespace, u'remoteSchema'), 'remoteSchema', '__GeodeticDatumPropertyType_httpwww_opengis_netgmlremoteSchema', pyxb.binding.datatypes.anyURI)
    def remoteSchema (self):
        """Get the attribute value for {http://www.opengis.net/gml}remoteSchema."""
        return self.__remoteSchema.value(self)
    def setRemoteSchema (self, new_value):
        """Set the attribute value for {http://www.opengis.net/gml}remoteSchema.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__remoteSchema.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}actuate uses Python identifier actuate
    __actuate = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'actuate'), 'actuate', '__GeodeticDatumPropertyType_httpwww_w3_org1999xlinkactuate', MODULEhttpwww_w3_org1999xlink.UNBOUNDNone_73)
    def actuate (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}actuate."""
        return self.__actuate.value(self)
    def setActuate (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}actuate.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__actuate.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}type uses Python identifier type
    __type = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'type'), 'type', '__GeodeticDatumPropertyType_httpwww_w3_org1999xlinktype', pyxb.binding.datatypes.string, fixed=True, unicode_default=u'simple')
    def type (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}type."""
        return self.__type.value(self)
    def setType (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}type.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__type.set(self, new_value)

    _ElementMap = {
        __GeodeticDatum.name() : __GeodeticDatum
    }
    _AttributeMap = {
        __show.name() : __show,
        __title.name() : __title,
        __role.name() : __role,
        __href.name() : __href,
        __nilReason.name() : __nilReason,
        __arcrole.name() : __arcrole,
        __remoteSchema.name() : __remoteSchema,
        __actuate.name() : __actuate,
        __type.name() : __type
    }
Namespace.addCategoryObject('typeBinding', u'GeodeticDatumPropertyType', GeodeticDatumPropertyType)


# Complex type GeographicCRSPropertyType with content type ELEMENT_ONLY
class GeographicCRSPropertyType (pyxb.binding.basis.complexTypeDefinition):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'GeographicCRSPropertyType')
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.opengis.net/gml}GeographicCRS uses Python identifier GeographicCRS
    __GeographicCRS = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'GeographicCRS'), 'GeographicCRS', '__GeographicCRSPropertyType_httpwww_opengis_netgmlGeographicCRS', False)
    def GeographicCRS (self):
        """Get the value of the {http://www.opengis.net/gml}GeographicCRS element."""
        return self.__GeographicCRS.value(self)
    def setGeographicCRS (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}GeographicCRS element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__GeographicCRS.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}show uses Python identifier show
    __show = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'show'), 'show', '__GeographicCRSPropertyType_httpwww_w3_org1999xlinkshow', MODULEhttpwww_w3_org1999xlink.UNBOUNDNone_74)
    def show (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}show."""
        return self.__show.value(self)
    def setShow (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}show.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__show.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}role uses Python identifier role
    __role = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'role'), 'role', '__GeographicCRSPropertyType_httpwww_w3_org1999xlinkrole', pyxb.binding.datatypes.anyURI)
    def role (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}role."""
        return self.__role.value(self)
    def setRole (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}role.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__role.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}href uses Python identifier href
    __href = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'href'), 'href', '__GeographicCRSPropertyType_httpwww_w3_org1999xlinkhref', pyxb.binding.datatypes.anyURI)
    def href (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}href."""
        return self.__href.value(self)
    def setHref (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}href.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__href.set(self, new_value)
    
    # Attribute nilReason uses Python identifier nilReason
    __nilReason = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'nilReason'), 'nilReason', '__GeographicCRSPropertyType_nilReason', NilReasonType)
    def nilReason (self):
        """Get the attribute value for nilReason."""
        return self.__nilReason.value(self)
    def setNilReason (self, new_value):
        """Set the attribute value for nilReason.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__nilReason.set(self, new_value)
    
    # Attribute {http://www.opengis.net/gml}remoteSchema uses Python identifier remoteSchema
    __remoteSchema = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(Namespace, u'remoteSchema'), 'remoteSchema', '__GeographicCRSPropertyType_httpwww_opengis_netgmlremoteSchema', pyxb.binding.datatypes.anyURI)
    def remoteSchema (self):
        """Get the attribute value for {http://www.opengis.net/gml}remoteSchema."""
        return self.__remoteSchema.value(self)
    def setRemoteSchema (self, new_value):
        """Set the attribute value for {http://www.opengis.net/gml}remoteSchema.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__remoteSchema.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}actuate uses Python identifier actuate
    __actuate = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'actuate'), 'actuate', '__GeographicCRSPropertyType_httpwww_w3_org1999xlinkactuate', MODULEhttpwww_w3_org1999xlink.UNBOUNDNone_75)
    def actuate (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}actuate."""
        return self.__actuate.value(self)
    def setActuate (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}actuate.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__actuate.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}type uses Python identifier type
    __type = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'type'), 'type', '__GeographicCRSPropertyType_httpwww_w3_org1999xlinktype', pyxb.binding.datatypes.string, fixed=True, unicode_default=u'simple')
    def type (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}type."""
        return self.__type.value(self)
    def setType (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}type.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__type.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}arcrole uses Python identifier arcrole
    __arcrole = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'arcrole'), 'arcrole', '__GeographicCRSPropertyType_httpwww_w3_org1999xlinkarcrole', pyxb.binding.datatypes.anyURI)
    def arcrole (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}arcrole."""
        return self.__arcrole.value(self)
    def setArcrole (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}arcrole.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__arcrole.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}title uses Python identifier title
    __title = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'title'), 'title', '__GeographicCRSPropertyType_httpwww_w3_org1999xlinktitle', pyxb.binding.datatypes.string)
    def title (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}title."""
        return self.__title.value(self)
    def setTitle (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}title.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__title.set(self, new_value)

    _ElementMap = {
        __GeographicCRS.name() : __GeographicCRS
    }
    _AttributeMap = {
        __show.name() : __show,
        __role.name() : __role,
        __href.name() : __href,
        __nilReason.name() : __nilReason,
        __remoteSchema.name() : __remoteSchema,
        __actuate.name() : __actuate,
        __type.name() : __type,
        __arcrole.name() : __arcrole,
        __title.name() : __title
    }
Namespace.addCategoryObject('typeBinding', u'GeographicCRSPropertyType', GeographicCRSPropertyType)


# Complex type GeometricComplexPropertyType with content type ELEMENT_ONLY
class GeometricComplexPropertyType (pyxb.binding.basis.complexTypeDefinition):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'GeometricComplexPropertyType')
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.opengis.net/gml}GeometricComplex uses Python identifier GeometricComplex
    __GeometricComplex = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'GeometricComplex'), 'GeometricComplex', '__GeometricComplexPropertyType_httpwww_opengis_netgmlGeometricComplex', False)
    def GeometricComplex (self):
        """Get the value of the {http://www.opengis.net/gml}GeometricComplex element."""
        return self.__GeometricComplex.value(self)
    def setGeometricComplex (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}GeometricComplex element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__GeometricComplex.set(self, new_value)
    
    # Element {http://www.opengis.net/gml}CompositeCurve uses Python identifier CompositeCurve
    __CompositeCurve = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'CompositeCurve'), 'CompositeCurve', '__GeometricComplexPropertyType_httpwww_opengis_netgmlCompositeCurve', False)
    def CompositeCurve (self):
        """Get the value of the {http://www.opengis.net/gml}CompositeCurve element."""
        return self.__CompositeCurve.value(self)
    def setCompositeCurve (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}CompositeCurve element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__CompositeCurve.set(self, new_value)
    
    # Element {http://www.opengis.net/gml}CompositeSurface uses Python identifier CompositeSurface
    __CompositeSurface = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'CompositeSurface'), 'CompositeSurface', '__GeometricComplexPropertyType_httpwww_opengis_netgmlCompositeSurface', False)
    def CompositeSurface (self):
        """Get the value of the {http://www.opengis.net/gml}CompositeSurface element."""
        return self.__CompositeSurface.value(self)
    def setCompositeSurface (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}CompositeSurface element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__CompositeSurface.set(self, new_value)
    
    # Element {http://www.opengis.net/gml}CompositeSolid uses Python identifier CompositeSolid
    __CompositeSolid = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'CompositeSolid'), 'CompositeSolid', '__GeometricComplexPropertyType_httpwww_opengis_netgmlCompositeSolid', False)
    def CompositeSolid (self):
        """Get the value of the {http://www.opengis.net/gml}CompositeSolid element."""
        return self.__CompositeSolid.value(self)
    def setCompositeSolid (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}CompositeSolid element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__CompositeSolid.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}show uses Python identifier show
    __show = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'show'), 'show', '__GeometricComplexPropertyType_httpwww_w3_org1999xlinkshow', MODULEhttpwww_w3_org1999xlink.UNBOUNDNone_76)
    def show (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}show."""
        return self.__show.value(self)
    def setShow (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}show.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__show.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}title uses Python identifier title
    __title = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'title'), 'title', '__GeometricComplexPropertyType_httpwww_w3_org1999xlinktitle', pyxb.binding.datatypes.string)
    def title (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}title."""
        return self.__title.value(self)
    def setTitle (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}title.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__title.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}role uses Python identifier role
    __role = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'role'), 'role', '__GeometricComplexPropertyType_httpwww_w3_org1999xlinkrole', pyxb.binding.datatypes.anyURI)
    def role (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}role."""
        return self.__role.value(self)
    def setRole (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}role.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__role.set(self, new_value)
    
    # Attribute nilReason uses Python identifier nilReason
    __nilReason = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'nilReason'), 'nilReason', '__GeometricComplexPropertyType_nilReason', NilReasonType)
    def nilReason (self):
        """Get the attribute value for nilReason."""
        return self.__nilReason.value(self)
    def setNilReason (self, new_value):
        """Set the attribute value for nilReason.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__nilReason.set(self, new_value)
    
    # Attribute owns uses Python identifier owns
    __owns = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'owns'), 'owns', '__GeometricComplexPropertyType_owns', pyxb.binding.datatypes.boolean, unicode_default=u'false')
    def owns (self):
        """Get the attribute value for owns."""
        return self.__owns.value(self)
    def setOwns (self, new_value):
        """Set the attribute value for owns.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__owns.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}href uses Python identifier href
    __href = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'href'), 'href', '__GeometricComplexPropertyType_httpwww_w3_org1999xlinkhref', pyxb.binding.datatypes.anyURI)
    def href (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}href."""
        return self.__href.value(self)
    def setHref (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}href.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__href.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}arcrole uses Python identifier arcrole
    __arcrole = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'arcrole'), 'arcrole', '__GeometricComplexPropertyType_httpwww_w3_org1999xlinkarcrole', pyxb.binding.datatypes.anyURI)
    def arcrole (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}arcrole."""
        return self.__arcrole.value(self)
    def setArcrole (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}arcrole.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__arcrole.set(self, new_value)
    
    # Attribute {http://www.opengis.net/gml}remoteSchema uses Python identifier remoteSchema
    __remoteSchema = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(Namespace, u'remoteSchema'), 'remoteSchema', '__GeometricComplexPropertyType_httpwww_opengis_netgmlremoteSchema', pyxb.binding.datatypes.anyURI)
    def remoteSchema (self):
        """Get the attribute value for {http://www.opengis.net/gml}remoteSchema."""
        return self.__remoteSchema.value(self)
    def setRemoteSchema (self, new_value):
        """Set the attribute value for {http://www.opengis.net/gml}remoteSchema.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__remoteSchema.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}actuate uses Python identifier actuate
    __actuate = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'actuate'), 'actuate', '__GeometricComplexPropertyType_httpwww_w3_org1999xlinkactuate', MODULEhttpwww_w3_org1999xlink.UNBOUNDNone_77)
    def actuate (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}actuate."""
        return self.__actuate.value(self)
    def setActuate (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}actuate.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__actuate.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}type uses Python identifier type
    __type = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'type'), 'type', '__GeometricComplexPropertyType_httpwww_w3_org1999xlinktype', pyxb.binding.datatypes.string, fixed=True, unicode_default=u'simple')
    def type (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}type."""
        return self.__type.value(self)
    def setType (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}type.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__type.set(self, new_value)

    _ElementMap = {
        __GeometricComplex.name() : __GeometricComplex,
        __CompositeCurve.name() : __CompositeCurve,
        __CompositeSurface.name() : __CompositeSurface,
        __CompositeSolid.name() : __CompositeSolid
    }
    _AttributeMap = {
        __show.name() : __show,
        __title.name() : __title,
        __role.name() : __role,
        __nilReason.name() : __nilReason,
        __owns.name() : __owns,
        __href.name() : __href,
        __arcrole.name() : __arcrole,
        __remoteSchema.name() : __remoteSchema,
        __actuate.name() : __actuate,
        __type.name() : __type
    }
Namespace.addCategoryObject('typeBinding', u'GeometricComplexPropertyType', GeometricComplexPropertyType)


# Complex type GeometricPrimitivePropertyType with content type ELEMENT_ONLY
class GeometricPrimitivePropertyType (pyxb.binding.basis.complexTypeDefinition):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'GeometricPrimitivePropertyType')
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.opengis.net/gml}AbstractGeometricPrimitive uses Python identifier AbstractGeometricPrimitive
    __AbstractGeometricPrimitive = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'AbstractGeometricPrimitive'), 'AbstractGeometricPrimitive', '__GeometricPrimitivePropertyType_httpwww_opengis_netgmlAbstractGeometricPrimitive', False)
    def AbstractGeometricPrimitive (self):
        """Get the value of the {http://www.opengis.net/gml}AbstractGeometricPrimitive element."""
        return self.__AbstractGeometricPrimitive.value(self)
    def setAbstractGeometricPrimitive (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}AbstractGeometricPrimitive element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__AbstractGeometricPrimitive.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}title uses Python identifier title
    __title = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'title'), 'title', '__GeometricPrimitivePropertyType_httpwww_w3_org1999xlinktitle', pyxb.binding.datatypes.string)
    def title (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}title."""
        return self.__title.value(self)
    def setTitle (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}title.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__title.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}show uses Python identifier show
    __show = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'show'), 'show', '__GeometricPrimitivePropertyType_httpwww_w3_org1999xlinkshow', MODULEhttpwww_w3_org1999xlink.UNBOUNDNone_78)
    def show (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}show."""
        return self.__show.value(self)
    def setShow (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}show.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__show.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}role uses Python identifier role
    __role = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'role'), 'role', '__GeometricPrimitivePropertyType_httpwww_w3_org1999xlinkrole', pyxb.binding.datatypes.anyURI)
    def role (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}role."""
        return self.__role.value(self)
    def setRole (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}role.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__role.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}href uses Python identifier href
    __href = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'href'), 'href', '__GeometricPrimitivePropertyType_httpwww_w3_org1999xlinkhref', pyxb.binding.datatypes.anyURI)
    def href (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}href."""
        return self.__href.value(self)
    def setHref (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}href.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__href.set(self, new_value)
    
    # Attribute owns uses Python identifier owns
    __owns = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'owns'), 'owns', '__GeometricPrimitivePropertyType_owns', pyxb.binding.datatypes.boolean, unicode_default=u'false')
    def owns (self):
        """Get the attribute value for owns."""
        return self.__owns.value(self)
    def setOwns (self, new_value):
        """Set the attribute value for owns.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__owns.set(self, new_value)
    
    # Attribute nilReason uses Python identifier nilReason
    __nilReason = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'nilReason'), 'nilReason', '__GeometricPrimitivePropertyType_nilReason', NilReasonType)
    def nilReason (self):
        """Get the attribute value for nilReason."""
        return self.__nilReason.value(self)
    def setNilReason (self, new_value):
        """Set the attribute value for nilReason.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__nilReason.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}arcrole uses Python identifier arcrole
    __arcrole = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'arcrole'), 'arcrole', '__GeometricPrimitivePropertyType_httpwww_w3_org1999xlinkarcrole', pyxb.binding.datatypes.anyURI)
    def arcrole (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}arcrole."""
        return self.__arcrole.value(self)
    def setArcrole (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}arcrole.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__arcrole.set(self, new_value)
    
    # Attribute {http://www.opengis.net/gml}remoteSchema uses Python identifier remoteSchema
    __remoteSchema = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(Namespace, u'remoteSchema'), 'remoteSchema', '__GeometricPrimitivePropertyType_httpwww_opengis_netgmlremoteSchema', pyxb.binding.datatypes.anyURI)
    def remoteSchema (self):
        """Get the attribute value for {http://www.opengis.net/gml}remoteSchema."""
        return self.__remoteSchema.value(self)
    def setRemoteSchema (self, new_value):
        """Set the attribute value for {http://www.opengis.net/gml}remoteSchema.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__remoteSchema.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}actuate uses Python identifier actuate
    __actuate = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'actuate'), 'actuate', '__GeometricPrimitivePropertyType_httpwww_w3_org1999xlinkactuate', MODULEhttpwww_w3_org1999xlink.UNBOUNDNone_79)
    def actuate (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}actuate."""
        return self.__actuate.value(self)
    def setActuate (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}actuate.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__actuate.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}type uses Python identifier type
    __type = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'type'), 'type', '__GeometricPrimitivePropertyType_httpwww_w3_org1999xlinktype', pyxb.binding.datatypes.string, fixed=True, unicode_default=u'simple')
    def type (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}type."""
        return self.__type.value(self)
    def setType (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}type.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__type.set(self, new_value)

    _ElementMap = {
        __AbstractGeometricPrimitive.name() : __AbstractGeometricPrimitive
    }
    _AttributeMap = {
        __title.name() : __title,
        __show.name() : __show,
        __role.name() : __role,
        __href.name() : __href,
        __owns.name() : __owns,
        __nilReason.name() : __nilReason,
        __arcrole.name() : __arcrole,
        __remoteSchema.name() : __remoteSchema,
        __actuate.name() : __actuate,
        __type.name() : __type
    }
Namespace.addCategoryObject('typeBinding', u'GeometricPrimitivePropertyType', GeometricPrimitivePropertyType)


# Complex type GeometryArrayPropertyType with content type ELEMENT_ONLY
class GeometryArrayPropertyType (pyxb.binding.basis.complexTypeDefinition):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'GeometryArrayPropertyType')
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.opengis.net/gml}AbstractGeometry uses Python identifier AbstractGeometry
    __AbstractGeometry = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'AbstractGeometry'), 'AbstractGeometry', '__GeometryArrayPropertyType_httpwww_opengis_netgmlAbstractGeometry', True)
    def AbstractGeometry (self):
        """Get the value of the {http://www.opengis.net/gml}AbstractGeometry element."""
        return self.__AbstractGeometry.value(self)
    def setAbstractGeometry (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}AbstractGeometry element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__AbstractGeometry.set(self, new_value)
    
    def addAbstractGeometry (self, new_value):
        """Add the value as another occurrence of the {http://www.opengis.net/gml}AbstractGeometry element.  Raises
        BadValueTypeException if the new value is not consistent with the
        element's type."""
        return self.__AbstractGeometry.append(self, new_value)
    
    # Attribute owns uses Python identifier owns
    __owns = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'owns'), 'owns', '__GeometryArrayPropertyType_owns', pyxb.binding.datatypes.boolean, unicode_default=u'false')
    def owns (self):
        """Get the attribute value for owns."""
        return self.__owns.value(self)
    def setOwns (self, new_value):
        """Set the attribute value for owns.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__owns.set(self, new_value)

    _ElementMap = {
        __AbstractGeometry.name() : __AbstractGeometry
    }
    _AttributeMap = {
        __owns.name() : __owns
    }
Namespace.addCategoryObject('typeBinding', u'GeometryArrayPropertyType', GeometryArrayPropertyType)


# Complex type GeometryPropertyType with content type ELEMENT_ONLY
class GeometryPropertyType (pyxb.binding.basis.complexTypeDefinition):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'GeometryPropertyType')
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.opengis.net/gml}AbstractGeometry uses Python identifier AbstractGeometry
    __AbstractGeometry = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'AbstractGeometry'), 'AbstractGeometry', '__GeometryPropertyType_httpwww_opengis_netgmlAbstractGeometry', False)
    def AbstractGeometry (self):
        """Get the value of the {http://www.opengis.net/gml}AbstractGeometry element."""
        return self.__AbstractGeometry.value(self)
    def setAbstractGeometry (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}AbstractGeometry element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__AbstractGeometry.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}show uses Python identifier show
    __show = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'show'), 'show', '__GeometryPropertyType_httpwww_w3_org1999xlinkshow', MODULEhttpwww_w3_org1999xlink.UNBOUNDNone_80)
    def show (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}show."""
        return self.__show.value(self)
    def setShow (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}show.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__show.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}role uses Python identifier role
    __role = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'role'), 'role', '__GeometryPropertyType_httpwww_w3_org1999xlinkrole', pyxb.binding.datatypes.anyURI)
    def role (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}role."""
        return self.__role.value(self)
    def setRole (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}role.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__role.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}href uses Python identifier href
    __href = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'href'), 'href', '__GeometryPropertyType_httpwww_w3_org1999xlinkhref', pyxb.binding.datatypes.anyURI)
    def href (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}href."""
        return self.__href.value(self)
    def setHref (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}href.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__href.set(self, new_value)
    
    # Attribute owns uses Python identifier owns
    __owns = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'owns'), 'owns', '__GeometryPropertyType_owns', pyxb.binding.datatypes.boolean, unicode_default=u'false')
    def owns (self):
        """Get the attribute value for owns."""
        return self.__owns.value(self)
    def setOwns (self, new_value):
        """Set the attribute value for owns.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__owns.set(self, new_value)
    
    # Attribute nilReason uses Python identifier nilReason
    __nilReason = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'nilReason'), 'nilReason', '__GeometryPropertyType_nilReason', NilReasonType)
    def nilReason (self):
        """Get the attribute value for nilReason."""
        return self.__nilReason.value(self)
    def setNilReason (self, new_value):
        """Set the attribute value for nilReason.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__nilReason.set(self, new_value)
    
    # Attribute {http://www.opengis.net/gml}remoteSchema uses Python identifier remoteSchema
    __remoteSchema = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(Namespace, u'remoteSchema'), 'remoteSchema', '__GeometryPropertyType_httpwww_opengis_netgmlremoteSchema', pyxb.binding.datatypes.anyURI)
    def remoteSchema (self):
        """Get the attribute value for {http://www.opengis.net/gml}remoteSchema."""
        return self.__remoteSchema.value(self)
    def setRemoteSchema (self, new_value):
        """Set the attribute value for {http://www.opengis.net/gml}remoteSchema.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__remoteSchema.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}arcrole uses Python identifier arcrole
    __arcrole = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'arcrole'), 'arcrole', '__GeometryPropertyType_httpwww_w3_org1999xlinkarcrole', pyxb.binding.datatypes.anyURI)
    def arcrole (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}arcrole."""
        return self.__arcrole.value(self)
    def setArcrole (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}arcrole.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__arcrole.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}actuate uses Python identifier actuate
    __actuate = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'actuate'), 'actuate', '__GeometryPropertyType_httpwww_w3_org1999xlinkactuate', MODULEhttpwww_w3_org1999xlink.UNBOUNDNone_81)
    def actuate (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}actuate."""
        return self.__actuate.value(self)
    def setActuate (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}actuate.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__actuate.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}type uses Python identifier type
    __type = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'type'), 'type', '__GeometryPropertyType_httpwww_w3_org1999xlinktype', pyxb.binding.datatypes.string, fixed=True, unicode_default=u'simple')
    def type (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}type."""
        return self.__type.value(self)
    def setType (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}type.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__type.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}title uses Python identifier title
    __title = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'title'), 'title', '__GeometryPropertyType_httpwww_w3_org1999xlinktitle', pyxb.binding.datatypes.string)
    def title (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}title."""
        return self.__title.value(self)
    def setTitle (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}title.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__title.set(self, new_value)

    _ElementMap = {
        __AbstractGeometry.name() : __AbstractGeometry
    }
    _AttributeMap = {
        __show.name() : __show,
        __role.name() : __role,
        __href.name() : __href,
        __owns.name() : __owns,
        __nilReason.name() : __nilReason,
        __remoteSchema.name() : __remoteSchema,
        __arcrole.name() : __arcrole,
        __actuate.name() : __actuate,
        __type.name() : __type,
        __title.name() : __title
    }
Namespace.addCategoryObject('typeBinding', u'GeometryPropertyType', GeometryPropertyType)


# Complex type GridEnvelopeType with content type ELEMENT_ONLY
class GridEnvelopeType (pyxb.binding.basis.complexTypeDefinition):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'GridEnvelopeType')
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.opengis.net/gml}high uses Python identifier high
    __high = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'high'), 'high', '__GridEnvelopeType_httpwww_opengis_netgmlhigh', False)
    def high (self):
        """Get the value of the {http://www.opengis.net/gml}high element."""
        return self.__high.value(self)
    def setHigh (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}high element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__high.set(self, new_value)
    
    # Element {http://www.opengis.net/gml}low uses Python identifier low
    __low = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'low'), 'low', '__GridEnvelopeType_httpwww_opengis_netgmllow', False)
    def low (self):
        """Get the value of the {http://www.opengis.net/gml}low element."""
        return self.__low.value(self)
    def setLow (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}low element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__low.set(self, new_value)

    _ElementMap = {
        __high.name() : __high,
        __low.name() : __low
    }
    _AttributeMap = {
        
    }
Namespace.addCategoryObject('typeBinding', u'GridEnvelopeType', GridEnvelopeType)


# Complex type GridFunctionType with content type ELEMENT_ONLY
class GridFunctionType (pyxb.binding.basis.complexTypeDefinition):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'GridFunctionType')
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.opengis.net/gml}sequenceRule uses Python identifier sequenceRule
    __sequenceRule = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'sequenceRule'), 'sequenceRule', '__GridFunctionType_httpwww_opengis_netgmlsequenceRule', False)
    def sequenceRule (self):
        """Get the value of the {http://www.opengis.net/gml}sequenceRule element."""
        return self.__sequenceRule.value(self)
    def setSequenceRule (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}sequenceRule element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__sequenceRule.set(self, new_value)
    
    # Element {http://www.opengis.net/gml}startPoint uses Python identifier startPoint
    __startPoint = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'startPoint'), 'startPoint', '__GridFunctionType_httpwww_opengis_netgmlstartPoint', False)
    def startPoint (self):
        """Get the value of the {http://www.opengis.net/gml}startPoint element."""
        return self.__startPoint.value(self)
    def setStartPoint (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}startPoint element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__startPoint.set(self, new_value)

    _ElementMap = {
        __sequenceRule.name() : __sequenceRule,
        __startPoint.name() : __startPoint
    }
    _AttributeMap = {
        
    }
Namespace.addCategoryObject('typeBinding', u'GridFunctionType', GridFunctionType)


# Complex type GridLimitsType with content type ELEMENT_ONLY
class GridLimitsType (pyxb.binding.basis.complexTypeDefinition):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'GridLimitsType')
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.opengis.net/gml}GridEnvelope uses Python identifier GridEnvelope
    __GridEnvelope = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'GridEnvelope'), 'GridEnvelope', '__GridLimitsType_httpwww_opengis_netgmlGridEnvelope', False)
    def GridEnvelope (self):
        """Get the value of the {http://www.opengis.net/gml}GridEnvelope element."""
        return self.__GridEnvelope.value(self)
    def setGridEnvelope (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}GridEnvelope element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__GridEnvelope.set(self, new_value)

    _ElementMap = {
        __GridEnvelope.name() : __GridEnvelope
    }
    _AttributeMap = {
        
    }
Namespace.addCategoryObject('typeBinding', u'GridLimitsType', GridLimitsType)


# Complex type HistoryPropertyType with content type ELEMENT_ONLY
class HistoryPropertyType (pyxb.binding.basis.complexTypeDefinition):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'HistoryPropertyType')
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.opengis.net/gml}AbstractTimeSlice uses Python identifier AbstractTimeSlice
    __AbstractTimeSlice = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'AbstractTimeSlice'), 'AbstractTimeSlice', '__HistoryPropertyType_httpwww_opengis_netgmlAbstractTimeSlice', True)
    def AbstractTimeSlice (self):
        """Get the value of the {http://www.opengis.net/gml}AbstractTimeSlice element."""
        return self.__AbstractTimeSlice.value(self)
    def setAbstractTimeSlice (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}AbstractTimeSlice element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__AbstractTimeSlice.set(self, new_value)
    
    def addAbstractTimeSlice (self, new_value):
        """Add the value as another occurrence of the {http://www.opengis.net/gml}AbstractTimeSlice element.  Raises
        BadValueTypeException if the new value is not consistent with the
        element's type."""
        return self.__AbstractTimeSlice.append(self, new_value)
    
    # Attribute owns uses Python identifier owns
    __owns = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'owns'), 'owns', '__HistoryPropertyType_owns', pyxb.binding.datatypes.boolean, unicode_default=u'false')
    def owns (self):
        """Get the attribute value for owns."""
        return self.__owns.value(self)
    def setOwns (self, new_value):
        """Set the attribute value for owns.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__owns.set(self, new_value)

    _ElementMap = {
        __AbstractTimeSlice.name() : __AbstractTimeSlice
    }
    _AttributeMap = {
        __owns.name() : __owns
    }
Namespace.addCategoryObject('typeBinding', u'HistoryPropertyType', HistoryPropertyType)


# Complex type ImageCRSPropertyType with content type ELEMENT_ONLY
class ImageCRSPropertyType (pyxb.binding.basis.complexTypeDefinition):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'ImageCRSPropertyType')
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.opengis.net/gml}ImageCRS uses Python identifier ImageCRS
    __ImageCRS = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'ImageCRS'), 'ImageCRS', '__ImageCRSPropertyType_httpwww_opengis_netgmlImageCRS', False)
    def ImageCRS (self):
        """Get the value of the {http://www.opengis.net/gml}ImageCRS element."""
        return self.__ImageCRS.value(self)
    def setImageCRS (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}ImageCRS element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__ImageCRS.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}show uses Python identifier show
    __show = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'show'), 'show', '__ImageCRSPropertyType_httpwww_w3_org1999xlinkshow', MODULEhttpwww_w3_org1999xlink.UNBOUNDNone_82)
    def show (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}show."""
        return self.__show.value(self)
    def setShow (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}show.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__show.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}role uses Python identifier role
    __role = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'role'), 'role', '__ImageCRSPropertyType_httpwww_w3_org1999xlinkrole', pyxb.binding.datatypes.anyURI)
    def role (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}role."""
        return self.__role.value(self)
    def setRole (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}role.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__role.set(self, new_value)
    
    # Attribute {http://www.opengis.net/gml}remoteSchema uses Python identifier remoteSchema
    __remoteSchema = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(Namespace, u'remoteSchema'), 'remoteSchema', '__ImageCRSPropertyType_httpwww_opengis_netgmlremoteSchema', pyxb.binding.datatypes.anyURI)
    def remoteSchema (self):
        """Get the attribute value for {http://www.opengis.net/gml}remoteSchema."""
        return self.__remoteSchema.value(self)
    def setRemoteSchema (self, new_value):
        """Set the attribute value for {http://www.opengis.net/gml}remoteSchema.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__remoteSchema.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}href uses Python identifier href
    __href = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'href'), 'href', '__ImageCRSPropertyType_httpwww_w3_org1999xlinkhref', pyxb.binding.datatypes.anyURI)
    def href (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}href."""
        return self.__href.value(self)
    def setHref (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}href.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__href.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}arcrole uses Python identifier arcrole
    __arcrole = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'arcrole'), 'arcrole', '__ImageCRSPropertyType_httpwww_w3_org1999xlinkarcrole', pyxb.binding.datatypes.anyURI)
    def arcrole (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}arcrole."""
        return self.__arcrole.value(self)
    def setArcrole (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}arcrole.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__arcrole.set(self, new_value)
    
    # Attribute nilReason uses Python identifier nilReason
    __nilReason = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'nilReason'), 'nilReason', '__ImageCRSPropertyType_nilReason', NilReasonType)
    def nilReason (self):
        """Get the attribute value for nilReason."""
        return self.__nilReason.value(self)
    def setNilReason (self, new_value):
        """Set the attribute value for nilReason.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__nilReason.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}actuate uses Python identifier actuate
    __actuate = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'actuate'), 'actuate', '__ImageCRSPropertyType_httpwww_w3_org1999xlinkactuate', MODULEhttpwww_w3_org1999xlink.UNBOUNDNone_83)
    def actuate (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}actuate."""
        return self.__actuate.value(self)
    def setActuate (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}actuate.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__actuate.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}type uses Python identifier type
    __type = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'type'), 'type', '__ImageCRSPropertyType_httpwww_w3_org1999xlinktype', pyxb.binding.datatypes.string, fixed=True, unicode_default=u'simple')
    def type (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}type."""
        return self.__type.value(self)
    def setType (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}type.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__type.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}title uses Python identifier title
    __title = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'title'), 'title', '__ImageCRSPropertyType_httpwww_w3_org1999xlinktitle', pyxb.binding.datatypes.string)
    def title (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}title."""
        return self.__title.value(self)
    def setTitle (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}title.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__title.set(self, new_value)

    _ElementMap = {
        __ImageCRS.name() : __ImageCRS
    }
    _AttributeMap = {
        __show.name() : __show,
        __role.name() : __role,
        __remoteSchema.name() : __remoteSchema,
        __href.name() : __href,
        __arcrole.name() : __arcrole,
        __nilReason.name() : __nilReason,
        __actuate.name() : __actuate,
        __type.name() : __type,
        __title.name() : __title
    }
Namespace.addCategoryObject('typeBinding', u'ImageCRSPropertyType', ImageCRSPropertyType)


# Complex type ImageDatumPropertyType with content type ELEMENT_ONLY
class ImageDatumPropertyType (pyxb.binding.basis.complexTypeDefinition):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'ImageDatumPropertyType')
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.opengis.net/gml}ImageDatum uses Python identifier ImageDatum
    __ImageDatum = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'ImageDatum'), 'ImageDatum', '__ImageDatumPropertyType_httpwww_opengis_netgmlImageDatum', False)
    def ImageDatum (self):
        """Get the value of the {http://www.opengis.net/gml}ImageDatum element."""
        return self.__ImageDatum.value(self)
    def setImageDatum (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}ImageDatum element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__ImageDatum.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}role uses Python identifier role
    __role = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'role'), 'role', '__ImageDatumPropertyType_httpwww_w3_org1999xlinkrole', pyxb.binding.datatypes.anyURI)
    def role (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}role."""
        return self.__role.value(self)
    def setRole (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}role.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__role.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}show uses Python identifier show
    __show = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'show'), 'show', '__ImageDatumPropertyType_httpwww_w3_org1999xlinkshow', MODULEhttpwww_w3_org1999xlink.UNBOUNDNone_84)
    def show (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}show."""
        return self.__show.value(self)
    def setShow (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}show.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__show.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}href uses Python identifier href
    __href = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'href'), 'href', '__ImageDatumPropertyType_httpwww_w3_org1999xlinkhref', pyxb.binding.datatypes.anyURI)
    def href (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}href."""
        return self.__href.value(self)
    def setHref (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}href.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__href.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}arcrole uses Python identifier arcrole
    __arcrole = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'arcrole'), 'arcrole', '__ImageDatumPropertyType_httpwww_w3_org1999xlinkarcrole', pyxb.binding.datatypes.anyURI)
    def arcrole (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}arcrole."""
        return self.__arcrole.value(self)
    def setArcrole (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}arcrole.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__arcrole.set(self, new_value)
    
    # Attribute {http://www.opengis.net/gml}remoteSchema uses Python identifier remoteSchema
    __remoteSchema = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(Namespace, u'remoteSchema'), 'remoteSchema', '__ImageDatumPropertyType_httpwww_opengis_netgmlremoteSchema', pyxb.binding.datatypes.anyURI)
    def remoteSchema (self):
        """Get the attribute value for {http://www.opengis.net/gml}remoteSchema."""
        return self.__remoteSchema.value(self)
    def setRemoteSchema (self, new_value):
        """Set the attribute value for {http://www.opengis.net/gml}remoteSchema.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__remoteSchema.set(self, new_value)
    
    # Attribute nilReason uses Python identifier nilReason
    __nilReason = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'nilReason'), 'nilReason', '__ImageDatumPropertyType_nilReason', NilReasonType)
    def nilReason (self):
        """Get the attribute value for nilReason."""
        return self.__nilReason.value(self)
    def setNilReason (self, new_value):
        """Set the attribute value for nilReason.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__nilReason.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}actuate uses Python identifier actuate
    __actuate = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'actuate'), 'actuate', '__ImageDatumPropertyType_httpwww_w3_org1999xlinkactuate', MODULEhttpwww_w3_org1999xlink.UNBOUNDNone_85)
    def actuate (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}actuate."""
        return self.__actuate.value(self)
    def setActuate (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}actuate.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__actuate.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}type uses Python identifier type
    __type = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'type'), 'type', '__ImageDatumPropertyType_httpwww_w3_org1999xlinktype', pyxb.binding.datatypes.string, fixed=True, unicode_default=u'simple')
    def type (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}type."""
        return self.__type.value(self)
    def setType (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}type.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__type.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}title uses Python identifier title
    __title = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'title'), 'title', '__ImageDatumPropertyType_httpwww_w3_org1999xlinktitle', pyxb.binding.datatypes.string)
    def title (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}title."""
        return self.__title.value(self)
    def setTitle (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}title.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__title.set(self, new_value)

    _ElementMap = {
        __ImageDatum.name() : __ImageDatum
    }
    _AttributeMap = {
        __role.name() : __role,
        __show.name() : __show,
        __href.name() : __href,
        __arcrole.name() : __arcrole,
        __remoteSchema.name() : __remoteSchema,
        __nilReason.name() : __nilReason,
        __actuate.name() : __actuate,
        __type.name() : __type,
        __title.name() : __title
    }
Namespace.addCategoryObject('typeBinding', u'ImageDatumPropertyType', ImageDatumPropertyType)


# Complex type IndirectEntryType with content type ELEMENT_ONLY
class IndirectEntryType (pyxb.binding.basis.complexTypeDefinition):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'IndirectEntryType')
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.opengis.net/gml}DefinitionProxy uses Python identifier DefinitionProxy
    __DefinitionProxy = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'DefinitionProxy'), 'DefinitionProxy', '__IndirectEntryType_httpwww_opengis_netgmlDefinitionProxy', False)
    def DefinitionProxy (self):
        """Get the value of the {http://www.opengis.net/gml}DefinitionProxy element."""
        return self.__DefinitionProxy.value(self)
    def setDefinitionProxy (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}DefinitionProxy element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__DefinitionProxy.set(self, new_value)

    _ElementMap = {
        __DefinitionProxy.name() : __DefinitionProxy
    }
    _AttributeMap = {
        
    }
Namespace.addCategoryObject('typeBinding', u'IndirectEntryType', IndirectEntryType)


# Complex type InlinePropertyType with content type ELEMENT_ONLY
class InlinePropertyType (pyxb.binding.basis.complexTypeDefinition):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'InlinePropertyType')
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.opengis.net/gml}AbstractObject uses Python identifier AbstractObject
    __AbstractObject = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'AbstractObject'), 'AbstractObject', '__InlinePropertyType_httpwww_opengis_netgmlAbstractObject', False)
    def AbstractObject (self):
        """Get the value of the {http://www.opengis.net/gml}AbstractObject element."""
        return self.__AbstractObject.value(self)
    def setAbstractObject (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}AbstractObject element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__AbstractObject.set(self, new_value)
    
    # Attribute owns uses Python identifier owns
    __owns = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'owns'), 'owns', '__InlinePropertyType_owns', pyxb.binding.datatypes.boolean, unicode_default=u'false')
    def owns (self):
        """Get the attribute value for owns."""
        return self.__owns.value(self)
    def setOwns (self, new_value):
        """Set the attribute value for owns.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__owns.set(self, new_value)

    _ElementMap = {
        __AbstractObject.name() : __AbstractObject
    }
    _AttributeMap = {
        __owns.name() : __owns
    }
Namespace.addCategoryObject('typeBinding', u'InlinePropertyType', InlinePropertyType)


# Complex type IsolatedPropertyType with content type ELEMENT_ONLY
class IsolatedPropertyType (pyxb.binding.basis.complexTypeDefinition):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'IsolatedPropertyType')
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.opengis.net/gml}Edge uses Python identifier Edge
    __Edge = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'Edge'), 'Edge', '__IsolatedPropertyType_httpwww_opengis_netgmlEdge', False)
    def Edge (self):
        """Get the value of the {http://www.opengis.net/gml}Edge element."""
        return self.__Edge.value(self)
    def setEdge (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}Edge element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__Edge.set(self, new_value)
    
    # Element {http://www.opengis.net/gml}Node uses Python identifier Node
    __Node = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'Node'), 'Node', '__IsolatedPropertyType_httpwww_opengis_netgmlNode', False)
    def Node (self):
        """Get the value of the {http://www.opengis.net/gml}Node element."""
        return self.__Node.value(self)
    def setNode (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}Node element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__Node.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}actuate uses Python identifier actuate
    __actuate = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'actuate'), 'actuate', '__IsolatedPropertyType_httpwww_w3_org1999xlinkactuate', MODULEhttpwww_w3_org1999xlink.UNBOUNDNone_86)
    def actuate (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}actuate."""
        return self.__actuate.value(self)
    def setActuate (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}actuate.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__actuate.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}show uses Python identifier show
    __show = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'show'), 'show', '__IsolatedPropertyType_httpwww_w3_org1999xlinkshow', MODULEhttpwww_w3_org1999xlink.UNBOUNDNone_87)
    def show (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}show."""
        return self.__show.value(self)
    def setShow (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}show.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__show.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}type uses Python identifier type
    __type = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'type'), 'type', '__IsolatedPropertyType_httpwww_w3_org1999xlinktype', pyxb.binding.datatypes.string, fixed=True, unicode_default=u'simple')
    def type (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}type."""
        return self.__type.value(self)
    def setType (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}type.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__type.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}title uses Python identifier title
    __title = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'title'), 'title', '__IsolatedPropertyType_httpwww_w3_org1999xlinktitle', pyxb.binding.datatypes.string)
    def title (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}title."""
        return self.__title.value(self)
    def setTitle (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}title.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__title.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}role uses Python identifier role
    __role = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'role'), 'role', '__IsolatedPropertyType_httpwww_w3_org1999xlinkrole', pyxb.binding.datatypes.anyURI)
    def role (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}role."""
        return self.__role.value(self)
    def setRole (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}role.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__role.set(self, new_value)
    
    # Attribute nilReason uses Python identifier nilReason
    __nilReason = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'nilReason'), 'nilReason', '__IsolatedPropertyType_nilReason', NilReasonType)
    def nilReason (self):
        """Get the attribute value for nilReason."""
        return self.__nilReason.value(self)
    def setNilReason (self, new_value):
        """Set the attribute value for nilReason.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__nilReason.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}href uses Python identifier href
    __href = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'href'), 'href', '__IsolatedPropertyType_httpwww_w3_org1999xlinkhref', pyxb.binding.datatypes.anyURI)
    def href (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}href."""
        return self.__href.value(self)
    def setHref (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}href.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__href.set(self, new_value)
    
    # Attribute owns uses Python identifier owns
    __owns = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'owns'), 'owns', '__IsolatedPropertyType_owns', pyxb.binding.datatypes.boolean, unicode_default=u'false')
    def owns (self):
        """Get the attribute value for owns."""
        return self.__owns.value(self)
    def setOwns (self, new_value):
        """Set the attribute value for owns.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__owns.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}arcrole uses Python identifier arcrole
    __arcrole = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'arcrole'), 'arcrole', '__IsolatedPropertyType_httpwww_w3_org1999xlinkarcrole', pyxb.binding.datatypes.anyURI)
    def arcrole (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}arcrole."""
        return self.__arcrole.value(self)
    def setArcrole (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}arcrole.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__arcrole.set(self, new_value)
    
    # Attribute {http://www.opengis.net/gml}remoteSchema uses Python identifier remoteSchema
    __remoteSchema = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(Namespace, u'remoteSchema'), 'remoteSchema', '__IsolatedPropertyType_httpwww_opengis_netgmlremoteSchema', pyxb.binding.datatypes.anyURI)
    def remoteSchema (self):
        """Get the attribute value for {http://www.opengis.net/gml}remoteSchema."""
        return self.__remoteSchema.value(self)
    def setRemoteSchema (self, new_value):
        """Set the attribute value for {http://www.opengis.net/gml}remoteSchema.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__remoteSchema.set(self, new_value)

    _ElementMap = {
        __Edge.name() : __Edge,
        __Node.name() : __Node
    }
    _AttributeMap = {
        __actuate.name() : __actuate,
        __show.name() : __show,
        __type.name() : __type,
        __title.name() : __title,
        __role.name() : __role,
        __nilReason.name() : __nilReason,
        __href.name() : __href,
        __owns.name() : __owns,
        __arcrole.name() : __arcrole,
        __remoteSchema.name() : __remoteSchema
    }
Namespace.addCategoryObject('typeBinding', u'IsolatedPropertyType', IsolatedPropertyType)


# Complex type KnotPropertyType with content type ELEMENT_ONLY
class KnotPropertyType (pyxb.binding.basis.complexTypeDefinition):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'KnotPropertyType')
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.opengis.net/gml}Knot uses Python identifier Knot
    __Knot = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'Knot'), 'Knot', '__KnotPropertyType_httpwww_opengis_netgmlKnot', False)
    def Knot (self):
        """Get the value of the {http://www.opengis.net/gml}Knot element."""
        return self.__Knot.value(self)
    def setKnot (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}Knot element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__Knot.set(self, new_value)

    _ElementMap = {
        __Knot.name() : __Knot
    }
    _AttributeMap = {
        
    }
Namespace.addCategoryObject('typeBinding', u'KnotPropertyType', KnotPropertyType)


# Complex type KnotType with content type ELEMENT_ONLY
class KnotType (pyxb.binding.basis.complexTypeDefinition):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'KnotType')
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.opengis.net/gml}multiplicity uses Python identifier multiplicity
    __multiplicity = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'multiplicity'), 'multiplicity', '__KnotType_httpwww_opengis_netgmlmultiplicity', False)
    def multiplicity (self):
        """Get the value of the {http://www.opengis.net/gml}multiplicity element."""
        return self.__multiplicity.value(self)
    def setMultiplicity (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}multiplicity element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__multiplicity.set(self, new_value)
    
    # Element {http://www.opengis.net/gml}weight uses Python identifier weight
    __weight = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'weight'), 'weight', '__KnotType_httpwww_opengis_netgmlweight', False)
    def weight (self):
        """Get the value of the {http://www.opengis.net/gml}weight element."""
        return self.__weight.value(self)
    def setWeight (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}weight element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__weight.set(self, new_value)
    
    # Element {http://www.opengis.net/gml}value uses Python identifier value
    __value = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'value'), 'value', '__KnotType_httpwww_opengis_netgmlvalue', False)
    def value (self):
        """Get the value of the {http://www.opengis.net/gml}value element."""
        return self.__value.value(self)
    def setValue (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}value element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__value.set(self, new_value)

    _ElementMap = {
        __multiplicity.name() : __multiplicity,
        __weight.name() : __weight,
        __value.name() : __value
    }
    _AttributeMap = {
        
    }
Namespace.addCategoryObject('typeBinding', u'KnotType', KnotType)


# Complex type LineStringSegmentArrayPropertyType with content type ELEMENT_ONLY
class LineStringSegmentArrayPropertyType (pyxb.binding.basis.complexTypeDefinition):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'LineStringSegmentArrayPropertyType')
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.opengis.net/gml}LineStringSegment uses Python identifier LineStringSegment
    __LineStringSegment = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'LineStringSegment'), 'LineStringSegment', '__LineStringSegmentArrayPropertyType_httpwww_opengis_netgmlLineStringSegment', True)
    def LineStringSegment (self):
        """Get the value of the {http://www.opengis.net/gml}LineStringSegment element."""
        return self.__LineStringSegment.value(self)
    def setLineStringSegment (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}LineStringSegment element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__LineStringSegment.set(self, new_value)
    
    def addLineStringSegment (self, new_value):
        """Add the value as another occurrence of the {http://www.opengis.net/gml}LineStringSegment element.  Raises
        BadValueTypeException if the new value is not consistent with the
        element's type."""
        return self.__LineStringSegment.append(self, new_value)

    _ElementMap = {
        __LineStringSegment.name() : __LineStringSegment
    }
    _AttributeMap = {
        
    }
Namespace.addCategoryObject('typeBinding', u'LineStringSegmentArrayPropertyType', LineStringSegmentArrayPropertyType)


# Complex type LinearCSPropertyType with content type ELEMENT_ONLY
class LinearCSPropertyType (pyxb.binding.basis.complexTypeDefinition):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'LinearCSPropertyType')
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.opengis.net/gml}LinearCS uses Python identifier LinearCS
    __LinearCS = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'LinearCS'), 'LinearCS', '__LinearCSPropertyType_httpwww_opengis_netgmlLinearCS', False)
    def LinearCS (self):
        """Get the value of the {http://www.opengis.net/gml}LinearCS element."""
        return self.__LinearCS.value(self)
    def setLinearCS (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}LinearCS element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__LinearCS.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}role uses Python identifier role
    __role = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'role'), 'role', '__LinearCSPropertyType_httpwww_w3_org1999xlinkrole', pyxb.binding.datatypes.anyURI)
    def role (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}role."""
        return self.__role.value(self)
    def setRole (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}role.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__role.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}show uses Python identifier show
    __show = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'show'), 'show', '__LinearCSPropertyType_httpwww_w3_org1999xlinkshow', MODULEhttpwww_w3_org1999xlink.UNBOUNDNone_88)
    def show (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}show."""
        return self.__show.value(self)
    def setShow (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}show.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__show.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}href uses Python identifier href
    __href = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'href'), 'href', '__LinearCSPropertyType_httpwww_w3_org1999xlinkhref', pyxb.binding.datatypes.anyURI)
    def href (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}href."""
        return self.__href.value(self)
    def setHref (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}href.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__href.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}arcrole uses Python identifier arcrole
    __arcrole = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'arcrole'), 'arcrole', '__LinearCSPropertyType_httpwww_w3_org1999xlinkarcrole', pyxb.binding.datatypes.anyURI)
    def arcrole (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}arcrole."""
        return self.__arcrole.value(self)
    def setArcrole (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}arcrole.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__arcrole.set(self, new_value)
    
    # Attribute {http://www.opengis.net/gml}remoteSchema uses Python identifier remoteSchema
    __remoteSchema = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(Namespace, u'remoteSchema'), 'remoteSchema', '__LinearCSPropertyType_httpwww_opengis_netgmlremoteSchema', pyxb.binding.datatypes.anyURI)
    def remoteSchema (self):
        """Get the attribute value for {http://www.opengis.net/gml}remoteSchema."""
        return self.__remoteSchema.value(self)
    def setRemoteSchema (self, new_value):
        """Set the attribute value for {http://www.opengis.net/gml}remoteSchema.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__remoteSchema.set(self, new_value)
    
    # Attribute nilReason uses Python identifier nilReason
    __nilReason = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'nilReason'), 'nilReason', '__LinearCSPropertyType_nilReason', NilReasonType)
    def nilReason (self):
        """Get the attribute value for nilReason."""
        return self.__nilReason.value(self)
    def setNilReason (self, new_value):
        """Set the attribute value for nilReason.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__nilReason.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}actuate uses Python identifier actuate
    __actuate = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'actuate'), 'actuate', '__LinearCSPropertyType_httpwww_w3_org1999xlinkactuate', MODULEhttpwww_w3_org1999xlink.UNBOUNDNone_89)
    def actuate (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}actuate."""
        return self.__actuate.value(self)
    def setActuate (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}actuate.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__actuate.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}type uses Python identifier type
    __type = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'type'), 'type', '__LinearCSPropertyType_httpwww_w3_org1999xlinktype', pyxb.binding.datatypes.string, fixed=True, unicode_default=u'simple')
    def type (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}type."""
        return self.__type.value(self)
    def setType (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}type.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__type.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}title uses Python identifier title
    __title = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'title'), 'title', '__LinearCSPropertyType_httpwww_w3_org1999xlinktitle', pyxb.binding.datatypes.string)
    def title (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}title."""
        return self.__title.value(self)
    def setTitle (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}title.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__title.set(self, new_value)

    _ElementMap = {
        __LinearCS.name() : __LinearCS
    }
    _AttributeMap = {
        __role.name() : __role,
        __show.name() : __show,
        __href.name() : __href,
        __arcrole.name() : __arcrole,
        __remoteSchema.name() : __remoteSchema,
        __nilReason.name() : __nilReason,
        __actuate.name() : __actuate,
        __type.name() : __type,
        __title.name() : __title
    }
Namespace.addCategoryObject('typeBinding', u'LinearCSPropertyType', LinearCSPropertyType)


# Complex type LinearRingPropertyType with content type ELEMENT_ONLY
class LinearRingPropertyType (pyxb.binding.basis.complexTypeDefinition):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'LinearRingPropertyType')
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.opengis.net/gml}LinearRing uses Python identifier LinearRing
    __LinearRing = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'LinearRing'), 'LinearRing', '__LinearRingPropertyType_httpwww_opengis_netgmlLinearRing', False)
    def LinearRing (self):
        """Get the value of the {http://www.opengis.net/gml}LinearRing element."""
        return self.__LinearRing.value(self)
    def setLinearRing (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}LinearRing element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__LinearRing.set(self, new_value)

    _ElementMap = {
        __LinearRing.name() : __LinearRing
    }
    _AttributeMap = {
        
    }
Namespace.addCategoryObject('typeBinding', u'LinearRingPropertyType', LinearRingPropertyType)


# Complex type LocationPropertyType with content type ELEMENT_ONLY
class LocationPropertyType (pyxb.binding.basis.complexTypeDefinition):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'LocationPropertyType')
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.opengis.net/gml}LocationKeyWord uses Python identifier LocationKeyWord
    __LocationKeyWord = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'LocationKeyWord'), 'LocationKeyWord', '__LocationPropertyType_httpwww_opengis_netgmlLocationKeyWord', False)
    def LocationKeyWord (self):
        """Get the value of the {http://www.opengis.net/gml}LocationKeyWord element."""
        return self.__LocationKeyWord.value(self)
    def setLocationKeyWord (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}LocationKeyWord element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__LocationKeyWord.set(self, new_value)
    
    # Element {http://www.opengis.net/gml}AbstractGeometry uses Python identifier AbstractGeometry
    __AbstractGeometry = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'AbstractGeometry'), 'AbstractGeometry', '__LocationPropertyType_httpwww_opengis_netgmlAbstractGeometry', False)
    def AbstractGeometry (self):
        """Get the value of the {http://www.opengis.net/gml}AbstractGeometry element."""
        return self.__AbstractGeometry.value(self)
    def setAbstractGeometry (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}AbstractGeometry element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__AbstractGeometry.set(self, new_value)
    
    # Element {http://www.opengis.net/gml}Null uses Python identifier Null
    __Null = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'Null'), 'Null', '__LocationPropertyType_httpwww_opengis_netgmlNull', False)
    def Null (self):
        """Get the value of the {http://www.opengis.net/gml}Null element."""
        return self.__Null.value(self)
    def setNull (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}Null element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__Null.set(self, new_value)
    
    # Element {http://www.opengis.net/gml}LocationString uses Python identifier LocationString
    __LocationString = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'LocationString'), 'LocationString', '__LocationPropertyType_httpwww_opengis_netgmlLocationString', False)
    def LocationString (self):
        """Get the value of the {http://www.opengis.net/gml}LocationString element."""
        return self.__LocationString.value(self)
    def setLocationString (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}LocationString element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__LocationString.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}title uses Python identifier title
    __title = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'title'), 'title', '__LocationPropertyType_httpwww_w3_org1999xlinktitle', pyxb.binding.datatypes.string)
    def title (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}title."""
        return self.__title.value(self)
    def setTitle (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}title.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__title.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}show uses Python identifier show
    __show = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'show'), 'show', '__LocationPropertyType_httpwww_w3_org1999xlinkshow', MODULEhttpwww_w3_org1999xlink.UNBOUNDNone_90)
    def show (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}show."""
        return self.__show.value(self)
    def setShow (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}show.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__show.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}role uses Python identifier role
    __role = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'role'), 'role', '__LocationPropertyType_httpwww_w3_org1999xlinkrole', pyxb.binding.datatypes.anyURI)
    def role (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}role."""
        return self.__role.value(self)
    def setRole (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}role.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__role.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}href uses Python identifier href
    __href = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'href'), 'href', '__LocationPropertyType_httpwww_w3_org1999xlinkhref', pyxb.binding.datatypes.anyURI)
    def href (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}href."""
        return self.__href.value(self)
    def setHref (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}href.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__href.set(self, new_value)
    
    # Attribute nilReason uses Python identifier nilReason
    __nilReason = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'nilReason'), 'nilReason', '__LocationPropertyType_nilReason', NilReasonType)
    def nilReason (self):
        """Get the attribute value for nilReason."""
        return self.__nilReason.value(self)
    def setNilReason (self, new_value):
        """Set the attribute value for nilReason.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__nilReason.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}arcrole uses Python identifier arcrole
    __arcrole = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'arcrole'), 'arcrole', '__LocationPropertyType_httpwww_w3_org1999xlinkarcrole', pyxb.binding.datatypes.anyURI)
    def arcrole (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}arcrole."""
        return self.__arcrole.value(self)
    def setArcrole (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}arcrole.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__arcrole.set(self, new_value)
    
    # Attribute {http://www.opengis.net/gml}remoteSchema uses Python identifier remoteSchema
    __remoteSchema = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(Namespace, u'remoteSchema'), 'remoteSchema', '__LocationPropertyType_httpwww_opengis_netgmlremoteSchema', pyxb.binding.datatypes.anyURI)
    def remoteSchema (self):
        """Get the attribute value for {http://www.opengis.net/gml}remoteSchema."""
        return self.__remoteSchema.value(self)
    def setRemoteSchema (self, new_value):
        """Set the attribute value for {http://www.opengis.net/gml}remoteSchema.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__remoteSchema.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}actuate uses Python identifier actuate
    __actuate = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'actuate'), 'actuate', '__LocationPropertyType_httpwww_w3_org1999xlinkactuate', MODULEhttpwww_w3_org1999xlink.UNBOUNDNone_91)
    def actuate (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}actuate."""
        return self.__actuate.value(self)
    def setActuate (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}actuate.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__actuate.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}type uses Python identifier type
    __type = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'type'), 'type', '__LocationPropertyType_httpwww_w3_org1999xlinktype', pyxb.binding.datatypes.string, fixed=True, unicode_default=u'simple')
    def type (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}type."""
        return self.__type.value(self)
    def setType (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}type.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__type.set(self, new_value)

    _ElementMap = {
        __LocationKeyWord.name() : __LocationKeyWord,
        __AbstractGeometry.name() : __AbstractGeometry,
        __Null.name() : __Null,
        __LocationString.name() : __LocationString
    }
    _AttributeMap = {
        __title.name() : __title,
        __show.name() : __show,
        __role.name() : __role,
        __href.name() : __href,
        __nilReason.name() : __nilReason,
        __arcrole.name() : __arcrole,
        __remoteSchema.name() : __remoteSchema,
        __actuate.name() : __actuate,
        __type.name() : __type
    }
Namespace.addCategoryObject('typeBinding', u'LocationPropertyType', LocationPropertyType)


# Complex type MappingRuleType with content type ELEMENT_ONLY
class MappingRuleType (pyxb.binding.basis.complexTypeDefinition):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'MappingRuleType')
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.opengis.net/gml}ruleDefinition uses Python identifier ruleDefinition
    __ruleDefinition = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'ruleDefinition'), 'ruleDefinition', '__MappingRuleType_httpwww_opengis_netgmlruleDefinition', False)
    def ruleDefinition (self):
        """Get the value of the {http://www.opengis.net/gml}ruleDefinition element."""
        return self.__ruleDefinition.value(self)
    def setRuleDefinition (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}ruleDefinition element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__ruleDefinition.set(self, new_value)
    
    # Element {http://www.opengis.net/gml}ruleReference uses Python identifier ruleReference
    __ruleReference = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'ruleReference'), 'ruleReference', '__MappingRuleType_httpwww_opengis_netgmlruleReference', False)
    def ruleReference (self):
        """Get the value of the {http://www.opengis.net/gml}ruleReference element."""
        return self.__ruleReference.value(self)
    def setRuleReference (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}ruleReference element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__ruleReference.set(self, new_value)

    _ElementMap = {
        __ruleDefinition.name() : __ruleDefinition,
        __ruleReference.name() : __ruleReference
    }
    _AttributeMap = {
        
    }
Namespace.addCategoryObject('typeBinding', u'MappingRuleType', MappingRuleType)


# Complex type MeasureListType with content type SIMPLE
class MeasureListType (pyxb.binding.basis.complexTypeDefinition):
    _TypeDefinition = doubleList
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_SIMPLE
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'MeasureListType')
    # Base type is doubleList
    
    # Attribute uom uses Python identifier uom
    __uom = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'uom'), 'uom', '__MeasureListType_uom', UomIdentifier, required=True)
    def uom (self):
        """Get the attribute value for uom."""
        return self.__uom.value(self)
    def setUom (self, new_value):
        """Set the attribute value for uom.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__uom.set(self, new_value)

    _ElementMap = {
        
    }
    _AttributeMap = {
        __uom.name() : __uom
    }
Namespace.addCategoryObject('typeBinding', u'MeasureListType', MeasureListType)


# Complex type MeasureOrNilReasonListType with content type SIMPLE
class MeasureOrNilReasonListType (pyxb.binding.basis.complexTypeDefinition):
    _TypeDefinition = doubleOrNilReasonList
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_SIMPLE
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'MeasureOrNilReasonListType')
    # Base type is doubleOrNilReasonList
    
    # Attribute uom uses Python identifier uom
    __uom = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'uom'), 'uom', '__MeasureOrNilReasonListType_uom', UomIdentifier, required=True)
    def uom (self):
        """Get the attribute value for uom."""
        return self.__uom.value(self)
    def setUom (self, new_value):
        """Set the attribute value for uom.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__uom.set(self, new_value)

    _ElementMap = {
        
    }
    _AttributeMap = {
        __uom.name() : __uom
    }
Namespace.addCategoryObject('typeBinding', u'MeasureOrNilReasonListType', MeasureOrNilReasonListType)


# Complex type MeasureType with content type SIMPLE
class MeasureType (pyxb.binding.basis.complexTypeDefinition):
    _TypeDefinition = pyxb.binding.datatypes.double
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_SIMPLE
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'MeasureType')
    # Base type is pyxb.binding.datatypes.double
    
    # Attribute uom uses Python identifier uom
    __uom = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'uom'), 'uom', '__MeasureType_uom', UomIdentifier, required=True)
    def uom (self):
        """Get the attribute value for uom."""
        return self.__uom.value(self)
    def setUom (self, new_value):
        """Set the attribute value for uom.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__uom.set(self, new_value)

    _ElementMap = {
        
    }
    _AttributeMap = {
        __uom.name() : __uom
    }
Namespace.addCategoryObject('typeBinding', u'MeasureType', MeasureType)


# Complex type MetaDataPropertyType with content type ELEMENT_ONLY
class MetaDataPropertyType (pyxb.binding.basis.complexTypeDefinition):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'MetaDataPropertyType')
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.opengis.net/gml}AbstractMetaData uses Python identifier AbstractMetaData
    __AbstractMetaData = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'AbstractMetaData'), 'AbstractMetaData', '__MetaDataPropertyType_httpwww_opengis_netgmlAbstractMetaData', False)
    def AbstractMetaData (self):
        """Get the value of the {http://www.opengis.net/gml}AbstractMetaData element."""
        return self.__AbstractMetaData.value(self)
    def setAbstractMetaData (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}AbstractMetaData element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__AbstractMetaData.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}show uses Python identifier show
    __show = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'show'), 'show', '__MetaDataPropertyType_httpwww_w3_org1999xlinkshow', MODULEhttpwww_w3_org1999xlink.UNBOUNDNone_92)
    def show (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}show."""
        return self.__show.value(self)
    def setShow (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}show.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__show.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}title uses Python identifier title
    __title = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'title'), 'title', '__MetaDataPropertyType_httpwww_w3_org1999xlinktitle', pyxb.binding.datatypes.string)
    def title (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}title."""
        return self.__title.value(self)
    def setTitle (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}title.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__title.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}role uses Python identifier role
    __role = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'role'), 'role', '__MetaDataPropertyType_httpwww_w3_org1999xlinkrole', pyxb.binding.datatypes.anyURI)
    def role (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}role."""
        return self.__role.value(self)
    def setRole (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}role.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__role.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}href uses Python identifier href
    __href = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'href'), 'href', '__MetaDataPropertyType_httpwww_w3_org1999xlinkhref', pyxb.binding.datatypes.anyURI)
    def href (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}href."""
        return self.__href.value(self)
    def setHref (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}href.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__href.set(self, new_value)
    
    # Attribute nilReason uses Python identifier nilReason
    __nilReason = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'nilReason'), 'nilReason', '__MetaDataPropertyType_nilReason', NilReasonType)
    def nilReason (self):
        """Get the attribute value for nilReason."""
        return self.__nilReason.value(self)
    def setNilReason (self, new_value):
        """Set the attribute value for nilReason.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__nilReason.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}arcrole uses Python identifier arcrole
    __arcrole = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'arcrole'), 'arcrole', '__MetaDataPropertyType_httpwww_w3_org1999xlinkarcrole', pyxb.binding.datatypes.anyURI)
    def arcrole (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}arcrole."""
        return self.__arcrole.value(self)
    def setArcrole (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}arcrole.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__arcrole.set(self, new_value)
    
    # Attribute {http://www.opengis.net/gml}remoteSchema uses Python identifier remoteSchema
    __remoteSchema = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(Namespace, u'remoteSchema'), 'remoteSchema', '__MetaDataPropertyType_httpwww_opengis_netgmlremoteSchema', pyxb.binding.datatypes.anyURI)
    def remoteSchema (self):
        """Get the attribute value for {http://www.opengis.net/gml}remoteSchema."""
        return self.__remoteSchema.value(self)
    def setRemoteSchema (self, new_value):
        """Set the attribute value for {http://www.opengis.net/gml}remoteSchema.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__remoteSchema.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}actuate uses Python identifier actuate
    __actuate = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'actuate'), 'actuate', '__MetaDataPropertyType_httpwww_w3_org1999xlinkactuate', MODULEhttpwww_w3_org1999xlink.UNBOUNDNone_93)
    def actuate (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}actuate."""
        return self.__actuate.value(self)
    def setActuate (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}actuate.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__actuate.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}type uses Python identifier type
    __type = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'type'), 'type', '__MetaDataPropertyType_httpwww_w3_org1999xlinktype', pyxb.binding.datatypes.string, fixed=True, unicode_default=u'simple')
    def type (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}type."""
        return self.__type.value(self)
    def setType (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}type.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__type.set(self, new_value)
    
    # Attribute about uses Python identifier about
    __about = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'about'), 'about', '__MetaDataPropertyType_about', pyxb.binding.datatypes.anyURI)
    def about (self):
        """Get the attribute value for about."""
        return self.__about.value(self)
    def setAbout (self, new_value):
        """Set the attribute value for about.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__about.set(self, new_value)

    _ElementMap = {
        __AbstractMetaData.name() : __AbstractMetaData
    }
    _AttributeMap = {
        __show.name() : __show,
        __title.name() : __title,
        __role.name() : __role,
        __href.name() : __href,
        __nilReason.name() : __nilReason,
        __arcrole.name() : __arcrole,
        __remoteSchema.name() : __remoteSchema,
        __actuate.name() : __actuate,
        __type.name() : __type,
        __about.name() : __about
    }
Namespace.addCategoryObject('typeBinding', u'MetaDataPropertyType', MetaDataPropertyType)


# Complex type MultiCurvePropertyType with content type ELEMENT_ONLY
class MultiCurvePropertyType (pyxb.binding.basis.complexTypeDefinition):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'MultiCurvePropertyType')
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.opengis.net/gml}MultiCurve uses Python identifier MultiCurve
    __MultiCurve = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'MultiCurve'), 'MultiCurve', '__MultiCurvePropertyType_httpwww_opengis_netgmlMultiCurve', False)
    def MultiCurve (self):
        """Get the value of the {http://www.opengis.net/gml}MultiCurve element."""
        return self.__MultiCurve.value(self)
    def setMultiCurve (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}MultiCurve element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__MultiCurve.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}show uses Python identifier show
    __show = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'show'), 'show', '__MultiCurvePropertyType_httpwww_w3_org1999xlinkshow', MODULEhttpwww_w3_org1999xlink.UNBOUNDNone_94)
    def show (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}show."""
        return self.__show.value(self)
    def setShow (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}show.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__show.set(self, new_value)
    
    # Attribute {http://www.opengis.net/gml}remoteSchema uses Python identifier remoteSchema
    __remoteSchema = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(Namespace, u'remoteSchema'), 'remoteSchema', '__MultiCurvePropertyType_httpwww_opengis_netgmlremoteSchema', pyxb.binding.datatypes.anyURI)
    def remoteSchema (self):
        """Get the attribute value for {http://www.opengis.net/gml}remoteSchema."""
        return self.__remoteSchema.value(self)
    def setRemoteSchema (self, new_value):
        """Set the attribute value for {http://www.opengis.net/gml}remoteSchema.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__remoteSchema.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}actuate uses Python identifier actuate
    __actuate = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'actuate'), 'actuate', '__MultiCurvePropertyType_httpwww_w3_org1999xlinkactuate', MODULEhttpwww_w3_org1999xlink.UNBOUNDNone_95)
    def actuate (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}actuate."""
        return self.__actuate.value(self)
    def setActuate (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}actuate.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__actuate.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}type uses Python identifier type
    __type = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'type'), 'type', '__MultiCurvePropertyType_httpwww_w3_org1999xlinktype', pyxb.binding.datatypes.string, fixed=True, unicode_default=u'simple')
    def type (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}type."""
        return self.__type.value(self)
    def setType (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}type.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__type.set(self, new_value)
    
    # Attribute nilReason uses Python identifier nilReason
    __nilReason = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'nilReason'), 'nilReason', '__MultiCurvePropertyType_nilReason', NilReasonType)
    def nilReason (self):
        """Get the attribute value for nilReason."""
        return self.__nilReason.value(self)
    def setNilReason (self, new_value):
        """Set the attribute value for nilReason.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__nilReason.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}title uses Python identifier title
    __title = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'title'), 'title', '__MultiCurvePropertyType_httpwww_w3_org1999xlinktitle', pyxb.binding.datatypes.string)
    def title (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}title."""
        return self.__title.value(self)
    def setTitle (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}title.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__title.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}role uses Python identifier role
    __role = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'role'), 'role', '__MultiCurvePropertyType_httpwww_w3_org1999xlinkrole', pyxb.binding.datatypes.anyURI)
    def role (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}role."""
        return self.__role.value(self)
    def setRole (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}role.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__role.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}arcrole uses Python identifier arcrole
    __arcrole = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'arcrole'), 'arcrole', '__MultiCurvePropertyType_httpwww_w3_org1999xlinkarcrole', pyxb.binding.datatypes.anyURI)
    def arcrole (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}arcrole."""
        return self.__arcrole.value(self)
    def setArcrole (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}arcrole.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__arcrole.set(self, new_value)
    
    # Attribute owns uses Python identifier owns
    __owns = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'owns'), 'owns', '__MultiCurvePropertyType_owns', pyxb.binding.datatypes.boolean, unicode_default=u'false')
    def owns (self):
        """Get the attribute value for owns."""
        return self.__owns.value(self)
    def setOwns (self, new_value):
        """Set the attribute value for owns.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__owns.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}href uses Python identifier href
    __href = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'href'), 'href', '__MultiCurvePropertyType_httpwww_w3_org1999xlinkhref', pyxb.binding.datatypes.anyURI)
    def href (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}href."""
        return self.__href.value(self)
    def setHref (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}href.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__href.set(self, new_value)

    _ElementMap = {
        __MultiCurve.name() : __MultiCurve
    }
    _AttributeMap = {
        __show.name() : __show,
        __remoteSchema.name() : __remoteSchema,
        __actuate.name() : __actuate,
        __type.name() : __type,
        __nilReason.name() : __nilReason,
        __title.name() : __title,
        __role.name() : __role,
        __arcrole.name() : __arcrole,
        __owns.name() : __owns,
        __href.name() : __href
    }
Namespace.addCategoryObject('typeBinding', u'MultiCurvePropertyType', MultiCurvePropertyType)


# Complex type MultiGeometryPropertyType with content type ELEMENT_ONLY
class MultiGeometryPropertyType (pyxb.binding.basis.complexTypeDefinition):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'MultiGeometryPropertyType')
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.opengis.net/gml}AbstractGeometricAggregate uses Python identifier AbstractGeometricAggregate
    __AbstractGeometricAggregate = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'AbstractGeometricAggregate'), 'AbstractGeometricAggregate', '__MultiGeometryPropertyType_httpwww_opengis_netgmlAbstractGeometricAggregate', False)
    def AbstractGeometricAggregate (self):
        """Get the value of the {http://www.opengis.net/gml}AbstractGeometricAggregate element."""
        return self.__AbstractGeometricAggregate.value(self)
    def setAbstractGeometricAggregate (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}AbstractGeometricAggregate element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__AbstractGeometricAggregate.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}show uses Python identifier show
    __show = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'show'), 'show', '__MultiGeometryPropertyType_httpwww_w3_org1999xlinkshow', MODULEhttpwww_w3_org1999xlink.UNBOUNDNone_96)
    def show (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}show."""
        return self.__show.value(self)
    def setShow (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}show.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__show.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}title uses Python identifier title
    __title = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'title'), 'title', '__MultiGeometryPropertyType_httpwww_w3_org1999xlinktitle', pyxb.binding.datatypes.string)
    def title (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}title."""
        return self.__title.value(self)
    def setTitle (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}title.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__title.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}arcrole uses Python identifier arcrole
    __arcrole = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'arcrole'), 'arcrole', '__MultiGeometryPropertyType_httpwww_w3_org1999xlinkarcrole', pyxb.binding.datatypes.anyURI)
    def arcrole (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}arcrole."""
        return self.__arcrole.value(self)
    def setArcrole (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}arcrole.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__arcrole.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}href uses Python identifier href
    __href = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'href'), 'href', '__MultiGeometryPropertyType_httpwww_w3_org1999xlinkhref', pyxb.binding.datatypes.anyURI)
    def href (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}href."""
        return self.__href.value(self)
    def setHref (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}href.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__href.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}role uses Python identifier role
    __role = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'role'), 'role', '__MultiGeometryPropertyType_httpwww_w3_org1999xlinkrole', pyxb.binding.datatypes.anyURI)
    def role (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}role."""
        return self.__role.value(self)
    def setRole (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}role.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__role.set(self, new_value)
    
    # Attribute nilReason uses Python identifier nilReason
    __nilReason = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'nilReason'), 'nilReason', '__MultiGeometryPropertyType_nilReason', NilReasonType)
    def nilReason (self):
        """Get the attribute value for nilReason."""
        return self.__nilReason.value(self)
    def setNilReason (self, new_value):
        """Set the attribute value for nilReason.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__nilReason.set(self, new_value)
    
    # Attribute owns uses Python identifier owns
    __owns = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'owns'), 'owns', '__MultiGeometryPropertyType_owns', pyxb.binding.datatypes.boolean, unicode_default=u'false')
    def owns (self):
        """Get the attribute value for owns."""
        return self.__owns.value(self)
    def setOwns (self, new_value):
        """Set the attribute value for owns.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__owns.set(self, new_value)
    
    # Attribute {http://www.opengis.net/gml}remoteSchema uses Python identifier remoteSchema
    __remoteSchema = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(Namespace, u'remoteSchema'), 'remoteSchema', '__MultiGeometryPropertyType_httpwww_opengis_netgmlremoteSchema', pyxb.binding.datatypes.anyURI)
    def remoteSchema (self):
        """Get the attribute value for {http://www.opengis.net/gml}remoteSchema."""
        return self.__remoteSchema.value(self)
    def setRemoteSchema (self, new_value):
        """Set the attribute value for {http://www.opengis.net/gml}remoteSchema.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__remoteSchema.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}type uses Python identifier type
    __type = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'type'), 'type', '__MultiGeometryPropertyType_httpwww_w3_org1999xlinktype', pyxb.binding.datatypes.string, fixed=True, unicode_default=u'simple')
    def type (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}type."""
        return self.__type.value(self)
    def setType (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}type.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__type.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}actuate uses Python identifier actuate
    __actuate = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'actuate'), 'actuate', '__MultiGeometryPropertyType_httpwww_w3_org1999xlinkactuate', MODULEhttpwww_w3_org1999xlink.UNBOUNDNone_97)
    def actuate (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}actuate."""
        return self.__actuate.value(self)
    def setActuate (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}actuate.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__actuate.set(self, new_value)

    _ElementMap = {
        __AbstractGeometricAggregate.name() : __AbstractGeometricAggregate
    }
    _AttributeMap = {
        __show.name() : __show,
        __title.name() : __title,
        __arcrole.name() : __arcrole,
        __href.name() : __href,
        __role.name() : __role,
        __nilReason.name() : __nilReason,
        __owns.name() : __owns,
        __remoteSchema.name() : __remoteSchema,
        __type.name() : __type,
        __actuate.name() : __actuate
    }
Namespace.addCategoryObject('typeBinding', u'MultiGeometryPropertyType', MultiGeometryPropertyType)


# Complex type MultiPointPropertyType with content type ELEMENT_ONLY
class MultiPointPropertyType (pyxb.binding.basis.complexTypeDefinition):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'MultiPointPropertyType')
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.opengis.net/gml}MultiPoint uses Python identifier MultiPoint
    __MultiPoint = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'MultiPoint'), 'MultiPoint', '__MultiPointPropertyType_httpwww_opengis_netgmlMultiPoint', False)
    def MultiPoint (self):
        """Get the value of the {http://www.opengis.net/gml}MultiPoint element."""
        return self.__MultiPoint.value(self)
    def setMultiPoint (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}MultiPoint element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__MultiPoint.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}show uses Python identifier show
    __show = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'show'), 'show', '__MultiPointPropertyType_httpwww_w3_org1999xlinkshow', MODULEhttpwww_w3_org1999xlink.UNBOUNDNone_98)
    def show (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}show."""
        return self.__show.value(self)
    def setShow (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}show.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__show.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}actuate uses Python identifier actuate
    __actuate = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'actuate'), 'actuate', '__MultiPointPropertyType_httpwww_w3_org1999xlinkactuate', MODULEhttpwww_w3_org1999xlink.UNBOUNDNone_99)
    def actuate (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}actuate."""
        return self.__actuate.value(self)
    def setActuate (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}actuate.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__actuate.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}type uses Python identifier type
    __type = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'type'), 'type', '__MultiPointPropertyType_httpwww_w3_org1999xlinktype', pyxb.binding.datatypes.string, fixed=True, unicode_default=u'simple')
    def type (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}type."""
        return self.__type.value(self)
    def setType (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}type.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__type.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}role uses Python identifier role
    __role = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'role'), 'role', '__MultiPointPropertyType_httpwww_w3_org1999xlinkrole', pyxb.binding.datatypes.anyURI)
    def role (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}role."""
        return self.__role.value(self)
    def setRole (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}role.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__role.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}title uses Python identifier title
    __title = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'title'), 'title', '__MultiPointPropertyType_httpwww_w3_org1999xlinktitle', pyxb.binding.datatypes.string)
    def title (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}title."""
        return self.__title.value(self)
    def setTitle (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}title.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__title.set(self, new_value)
    
    # Attribute nilReason uses Python identifier nilReason
    __nilReason = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'nilReason'), 'nilReason', '__MultiPointPropertyType_nilReason', NilReasonType)
    def nilReason (self):
        """Get the attribute value for nilReason."""
        return self.__nilReason.value(self)
    def setNilReason (self, new_value):
        """Set the attribute value for nilReason.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__nilReason.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}href uses Python identifier href
    __href = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'href'), 'href', '__MultiPointPropertyType_httpwww_w3_org1999xlinkhref', pyxb.binding.datatypes.anyURI)
    def href (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}href."""
        return self.__href.value(self)
    def setHref (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}href.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__href.set(self, new_value)
    
    # Attribute owns uses Python identifier owns
    __owns = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'owns'), 'owns', '__MultiPointPropertyType_owns', pyxb.binding.datatypes.boolean, unicode_default=u'false')
    def owns (self):
        """Get the attribute value for owns."""
        return self.__owns.value(self)
    def setOwns (self, new_value):
        """Set the attribute value for owns.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__owns.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}arcrole uses Python identifier arcrole
    __arcrole = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'arcrole'), 'arcrole', '__MultiPointPropertyType_httpwww_w3_org1999xlinkarcrole', pyxb.binding.datatypes.anyURI)
    def arcrole (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}arcrole."""
        return self.__arcrole.value(self)
    def setArcrole (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}arcrole.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__arcrole.set(self, new_value)
    
    # Attribute {http://www.opengis.net/gml}remoteSchema uses Python identifier remoteSchema
    __remoteSchema = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(Namespace, u'remoteSchema'), 'remoteSchema', '__MultiPointPropertyType_httpwww_opengis_netgmlremoteSchema', pyxb.binding.datatypes.anyURI)
    def remoteSchema (self):
        """Get the attribute value for {http://www.opengis.net/gml}remoteSchema."""
        return self.__remoteSchema.value(self)
    def setRemoteSchema (self, new_value):
        """Set the attribute value for {http://www.opengis.net/gml}remoteSchema.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__remoteSchema.set(self, new_value)

    _ElementMap = {
        __MultiPoint.name() : __MultiPoint
    }
    _AttributeMap = {
        __show.name() : __show,
        __actuate.name() : __actuate,
        __type.name() : __type,
        __role.name() : __role,
        __title.name() : __title,
        __nilReason.name() : __nilReason,
        __href.name() : __href,
        __owns.name() : __owns,
        __arcrole.name() : __arcrole,
        __remoteSchema.name() : __remoteSchema
    }
Namespace.addCategoryObject('typeBinding', u'MultiPointPropertyType', MultiPointPropertyType)


# Complex type MultiSolidPropertyType with content type ELEMENT_ONLY
class MultiSolidPropertyType (pyxb.binding.basis.complexTypeDefinition):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'MultiSolidPropertyType')
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.opengis.net/gml}MultiSolid uses Python identifier MultiSolid
    __MultiSolid = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'MultiSolid'), 'MultiSolid', '__MultiSolidPropertyType_httpwww_opengis_netgmlMultiSolid', False)
    def MultiSolid (self):
        """Get the value of the {http://www.opengis.net/gml}MultiSolid element."""
        return self.__MultiSolid.value(self)
    def setMultiSolid (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}MultiSolid element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__MultiSolid.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}title uses Python identifier title
    __title = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'title'), 'title', '__MultiSolidPropertyType_httpwww_w3_org1999xlinktitle', pyxb.binding.datatypes.string)
    def title (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}title."""
        return self.__title.value(self)
    def setTitle (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}title.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__title.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}show uses Python identifier show
    __show = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'show'), 'show', '__MultiSolidPropertyType_httpwww_w3_org1999xlinkshow', MODULEhttpwww_w3_org1999xlink.UNBOUNDNone_100)
    def show (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}show."""
        return self.__show.value(self)
    def setShow (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}show.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__show.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}role uses Python identifier role
    __role = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'role'), 'role', '__MultiSolidPropertyType_httpwww_w3_org1999xlinkrole', pyxb.binding.datatypes.anyURI)
    def role (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}role."""
        return self.__role.value(self)
    def setRole (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}role.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__role.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}href uses Python identifier href
    __href = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'href'), 'href', '__MultiSolidPropertyType_httpwww_w3_org1999xlinkhref', pyxb.binding.datatypes.anyURI)
    def href (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}href."""
        return self.__href.value(self)
    def setHref (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}href.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__href.set(self, new_value)
    
    # Attribute owns uses Python identifier owns
    __owns = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'owns'), 'owns', '__MultiSolidPropertyType_owns', pyxb.binding.datatypes.boolean, unicode_default=u'false')
    def owns (self):
        """Get the attribute value for owns."""
        return self.__owns.value(self)
    def setOwns (self, new_value):
        """Set the attribute value for owns.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__owns.set(self, new_value)
    
    # Attribute nilReason uses Python identifier nilReason
    __nilReason = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'nilReason'), 'nilReason', '__MultiSolidPropertyType_nilReason', NilReasonType)
    def nilReason (self):
        """Get the attribute value for nilReason."""
        return self.__nilReason.value(self)
    def setNilReason (self, new_value):
        """Set the attribute value for nilReason.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__nilReason.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}arcrole uses Python identifier arcrole
    __arcrole = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'arcrole'), 'arcrole', '__MultiSolidPropertyType_httpwww_w3_org1999xlinkarcrole', pyxb.binding.datatypes.anyURI)
    def arcrole (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}arcrole."""
        return self.__arcrole.value(self)
    def setArcrole (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}arcrole.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__arcrole.set(self, new_value)
    
    # Attribute {http://www.opengis.net/gml}remoteSchema uses Python identifier remoteSchema
    __remoteSchema = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(Namespace, u'remoteSchema'), 'remoteSchema', '__MultiSolidPropertyType_httpwww_opengis_netgmlremoteSchema', pyxb.binding.datatypes.anyURI)
    def remoteSchema (self):
        """Get the attribute value for {http://www.opengis.net/gml}remoteSchema."""
        return self.__remoteSchema.value(self)
    def setRemoteSchema (self, new_value):
        """Set the attribute value for {http://www.opengis.net/gml}remoteSchema.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__remoteSchema.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}actuate uses Python identifier actuate
    __actuate = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'actuate'), 'actuate', '__MultiSolidPropertyType_httpwww_w3_org1999xlinkactuate', MODULEhttpwww_w3_org1999xlink.UNBOUNDNone_101)
    def actuate (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}actuate."""
        return self.__actuate.value(self)
    def setActuate (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}actuate.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__actuate.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}type uses Python identifier type
    __type = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'type'), 'type', '__MultiSolidPropertyType_httpwww_w3_org1999xlinktype', pyxb.binding.datatypes.string, fixed=True, unicode_default=u'simple')
    def type (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}type."""
        return self.__type.value(self)
    def setType (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}type.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__type.set(self, new_value)

    _ElementMap = {
        __MultiSolid.name() : __MultiSolid
    }
    _AttributeMap = {
        __title.name() : __title,
        __show.name() : __show,
        __role.name() : __role,
        __href.name() : __href,
        __owns.name() : __owns,
        __nilReason.name() : __nilReason,
        __arcrole.name() : __arcrole,
        __remoteSchema.name() : __remoteSchema,
        __actuate.name() : __actuate,
        __type.name() : __type
    }
Namespace.addCategoryObject('typeBinding', u'MultiSolidPropertyType', MultiSolidPropertyType)


# Complex type MultiSurfacePropertyType with content type ELEMENT_ONLY
class MultiSurfacePropertyType (pyxb.binding.basis.complexTypeDefinition):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'MultiSurfacePropertyType')
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.opengis.net/gml}MultiSurface uses Python identifier MultiSurface
    __MultiSurface = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'MultiSurface'), 'MultiSurface', '__MultiSurfacePropertyType_httpwww_opengis_netgmlMultiSurface', False)
    def MultiSurface (self):
        """Get the value of the {http://www.opengis.net/gml}MultiSurface element."""
        return self.__MultiSurface.value(self)
    def setMultiSurface (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}MultiSurface element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__MultiSurface.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}show uses Python identifier show
    __show = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'show'), 'show', '__MultiSurfacePropertyType_httpwww_w3_org1999xlinkshow', MODULEhttpwww_w3_org1999xlink.UNBOUNDNone_102)
    def show (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}show."""
        return self.__show.value(self)
    def setShow (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}show.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__show.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}href uses Python identifier href
    __href = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'href'), 'href', '__MultiSurfacePropertyType_httpwww_w3_org1999xlinkhref', pyxb.binding.datatypes.anyURI)
    def href (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}href."""
        return self.__href.value(self)
    def setHref (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}href.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__href.set(self, new_value)
    
    # Attribute owns uses Python identifier owns
    __owns = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'owns'), 'owns', '__MultiSurfacePropertyType_owns', pyxb.binding.datatypes.boolean, unicode_default=u'false')
    def owns (self):
        """Get the attribute value for owns."""
        return self.__owns.value(self)
    def setOwns (self, new_value):
        """Set the attribute value for owns.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__owns.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}arcrole uses Python identifier arcrole
    __arcrole = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'arcrole'), 'arcrole', '__MultiSurfacePropertyType_httpwww_w3_org1999xlinkarcrole', pyxb.binding.datatypes.anyURI)
    def arcrole (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}arcrole."""
        return self.__arcrole.value(self)
    def setArcrole (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}arcrole.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__arcrole.set(self, new_value)
    
    # Attribute {http://www.opengis.net/gml}remoteSchema uses Python identifier remoteSchema
    __remoteSchema = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(Namespace, u'remoteSchema'), 'remoteSchema', '__MultiSurfacePropertyType_httpwww_opengis_netgmlremoteSchema', pyxb.binding.datatypes.anyURI)
    def remoteSchema (self):
        """Get the attribute value for {http://www.opengis.net/gml}remoteSchema."""
        return self.__remoteSchema.value(self)
    def setRemoteSchema (self, new_value):
        """Set the attribute value for {http://www.opengis.net/gml}remoteSchema.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__remoteSchema.set(self, new_value)
    
    # Attribute nilReason uses Python identifier nilReason
    __nilReason = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'nilReason'), 'nilReason', '__MultiSurfacePropertyType_nilReason', NilReasonType)
    def nilReason (self):
        """Get the attribute value for nilReason."""
        return self.__nilReason.value(self)
    def setNilReason (self, new_value):
        """Set the attribute value for nilReason.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__nilReason.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}type uses Python identifier type
    __type = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'type'), 'type', '__MultiSurfacePropertyType_httpwww_w3_org1999xlinktype', pyxb.binding.datatypes.string, fixed=True, unicode_default=u'simple')
    def type (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}type."""
        return self.__type.value(self)
    def setType (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}type.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__type.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}title uses Python identifier title
    __title = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'title'), 'title', '__MultiSurfacePropertyType_httpwww_w3_org1999xlinktitle', pyxb.binding.datatypes.string)
    def title (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}title."""
        return self.__title.value(self)
    def setTitle (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}title.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__title.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}actuate uses Python identifier actuate
    __actuate = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'actuate'), 'actuate', '__MultiSurfacePropertyType_httpwww_w3_org1999xlinkactuate', MODULEhttpwww_w3_org1999xlink.UNBOUNDNone_103)
    def actuate (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}actuate."""
        return self.__actuate.value(self)
    def setActuate (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}actuate.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__actuate.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}role uses Python identifier role
    __role = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'role'), 'role', '__MultiSurfacePropertyType_httpwww_w3_org1999xlinkrole', pyxb.binding.datatypes.anyURI)
    def role (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}role."""
        return self.__role.value(self)
    def setRole (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}role.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__role.set(self, new_value)

    _ElementMap = {
        __MultiSurface.name() : __MultiSurface
    }
    _AttributeMap = {
        __show.name() : __show,
        __href.name() : __href,
        __owns.name() : __owns,
        __arcrole.name() : __arcrole,
        __remoteSchema.name() : __remoteSchema,
        __nilReason.name() : __nilReason,
        __type.name() : __type,
        __title.name() : __title,
        __actuate.name() : __actuate,
        __role.name() : __role
    }
Namespace.addCategoryObject('typeBinding', u'MultiSurfacePropertyType', MultiSurfacePropertyType)


# Complex type ObliqueCartesianCSPropertyType with content type ELEMENT_ONLY
class ObliqueCartesianCSPropertyType (pyxb.binding.basis.complexTypeDefinition):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'ObliqueCartesianCSPropertyType')
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.opengis.net/gml}ObliqueCartesianCS uses Python identifier ObliqueCartesianCS
    __ObliqueCartesianCS = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'ObliqueCartesianCS'), 'ObliqueCartesianCS', '__ObliqueCartesianCSPropertyType_httpwww_opengis_netgmlObliqueCartesianCS', False)
    def ObliqueCartesianCS (self):
        """Get the value of the {http://www.opengis.net/gml}ObliqueCartesianCS element."""
        return self.__ObliqueCartesianCS.value(self)
    def setObliqueCartesianCS (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}ObliqueCartesianCS element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__ObliqueCartesianCS.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}title uses Python identifier title
    __title = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'title'), 'title', '__ObliqueCartesianCSPropertyType_httpwww_w3_org1999xlinktitle', pyxb.binding.datatypes.string)
    def title (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}title."""
        return self.__title.value(self)
    def setTitle (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}title.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__title.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}show uses Python identifier show
    __show = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'show'), 'show', '__ObliqueCartesianCSPropertyType_httpwww_w3_org1999xlinkshow', MODULEhttpwww_w3_org1999xlink.UNBOUNDNone_104)
    def show (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}show."""
        return self.__show.value(self)
    def setShow (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}show.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__show.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}role uses Python identifier role
    __role = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'role'), 'role', '__ObliqueCartesianCSPropertyType_httpwww_w3_org1999xlinkrole', pyxb.binding.datatypes.anyURI)
    def role (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}role."""
        return self.__role.value(self)
    def setRole (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}role.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__role.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}href uses Python identifier href
    __href = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'href'), 'href', '__ObliqueCartesianCSPropertyType_httpwww_w3_org1999xlinkhref', pyxb.binding.datatypes.anyURI)
    def href (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}href."""
        return self.__href.value(self)
    def setHref (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}href.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__href.set(self, new_value)
    
    # Attribute nilReason uses Python identifier nilReason
    __nilReason = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'nilReason'), 'nilReason', '__ObliqueCartesianCSPropertyType_nilReason', NilReasonType)
    def nilReason (self):
        """Get the attribute value for nilReason."""
        return self.__nilReason.value(self)
    def setNilReason (self, new_value):
        """Set the attribute value for nilReason.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__nilReason.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}arcrole uses Python identifier arcrole
    __arcrole = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'arcrole'), 'arcrole', '__ObliqueCartesianCSPropertyType_httpwww_w3_org1999xlinkarcrole', pyxb.binding.datatypes.anyURI)
    def arcrole (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}arcrole."""
        return self.__arcrole.value(self)
    def setArcrole (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}arcrole.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__arcrole.set(self, new_value)
    
    # Attribute {http://www.opengis.net/gml}remoteSchema uses Python identifier remoteSchema
    __remoteSchema = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(Namespace, u'remoteSchema'), 'remoteSchema', '__ObliqueCartesianCSPropertyType_httpwww_opengis_netgmlremoteSchema', pyxb.binding.datatypes.anyURI)
    def remoteSchema (self):
        """Get the attribute value for {http://www.opengis.net/gml}remoteSchema."""
        return self.__remoteSchema.value(self)
    def setRemoteSchema (self, new_value):
        """Set the attribute value for {http://www.opengis.net/gml}remoteSchema.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__remoteSchema.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}actuate uses Python identifier actuate
    __actuate = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'actuate'), 'actuate', '__ObliqueCartesianCSPropertyType_httpwww_w3_org1999xlinkactuate', MODULEhttpwww_w3_org1999xlink.UNBOUNDNone_105)
    def actuate (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}actuate."""
        return self.__actuate.value(self)
    def setActuate (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}actuate.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__actuate.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}type uses Python identifier type
    __type = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'type'), 'type', '__ObliqueCartesianCSPropertyType_httpwww_w3_org1999xlinktype', pyxb.binding.datatypes.string, fixed=True, unicode_default=u'simple')
    def type (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}type."""
        return self.__type.value(self)
    def setType (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}type.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__type.set(self, new_value)

    _ElementMap = {
        __ObliqueCartesianCS.name() : __ObliqueCartesianCS
    }
    _AttributeMap = {
        __title.name() : __title,
        __show.name() : __show,
        __role.name() : __role,
        __href.name() : __href,
        __nilReason.name() : __nilReason,
        __arcrole.name() : __arcrole,
        __remoteSchema.name() : __remoteSchema,
        __actuate.name() : __actuate,
        __type.name() : __type
    }
Namespace.addCategoryObject('typeBinding', u'ObliqueCartesianCSPropertyType', ObliqueCartesianCSPropertyType)


# Complex type OperationMethodPropertyType with content type ELEMENT_ONLY
class OperationMethodPropertyType (pyxb.binding.basis.complexTypeDefinition):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'OperationMethodPropertyType')
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.opengis.net/gml}OperationMethod uses Python identifier OperationMethod
    __OperationMethod = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'OperationMethod'), 'OperationMethod', '__OperationMethodPropertyType_httpwww_opengis_netgmlOperationMethod', False)
    def OperationMethod (self):
        """Get the value of the {http://www.opengis.net/gml}OperationMethod element."""
        return self.__OperationMethod.value(self)
    def setOperationMethod (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}OperationMethod element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__OperationMethod.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}show uses Python identifier show
    __show = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'show'), 'show', '__OperationMethodPropertyType_httpwww_w3_org1999xlinkshow', MODULEhttpwww_w3_org1999xlink.UNBOUNDNone_106)
    def show (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}show."""
        return self.__show.value(self)
    def setShow (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}show.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__show.set(self, new_value)
    
    # Attribute {http://www.opengis.net/gml}remoteSchema uses Python identifier remoteSchema
    __remoteSchema = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(Namespace, u'remoteSchema'), 'remoteSchema', '__OperationMethodPropertyType_httpwww_opengis_netgmlremoteSchema', pyxb.binding.datatypes.anyURI)
    def remoteSchema (self):
        """Get the attribute value for {http://www.opengis.net/gml}remoteSchema."""
        return self.__remoteSchema.value(self)
    def setRemoteSchema (self, new_value):
        """Set the attribute value for {http://www.opengis.net/gml}remoteSchema.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__remoteSchema.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}actuate uses Python identifier actuate
    __actuate = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'actuate'), 'actuate', '__OperationMethodPropertyType_httpwww_w3_org1999xlinkactuate', MODULEhttpwww_w3_org1999xlink.UNBOUNDNone_107)
    def actuate (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}actuate."""
        return self.__actuate.value(self)
    def setActuate (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}actuate.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__actuate.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}type uses Python identifier type
    __type = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'type'), 'type', '__OperationMethodPropertyType_httpwww_w3_org1999xlinktype', pyxb.binding.datatypes.string, fixed=True, unicode_default=u'simple')
    def type (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}type."""
        return self.__type.value(self)
    def setType (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}type.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__type.set(self, new_value)
    
    # Attribute nilReason uses Python identifier nilReason
    __nilReason = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'nilReason'), 'nilReason', '__OperationMethodPropertyType_nilReason', NilReasonType)
    def nilReason (self):
        """Get the attribute value for nilReason."""
        return self.__nilReason.value(self)
    def setNilReason (self, new_value):
        """Set the attribute value for nilReason.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__nilReason.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}title uses Python identifier title
    __title = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'title'), 'title', '__OperationMethodPropertyType_httpwww_w3_org1999xlinktitle', pyxb.binding.datatypes.string)
    def title (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}title."""
        return self.__title.value(self)
    def setTitle (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}title.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__title.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}role uses Python identifier role
    __role = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'role'), 'role', '__OperationMethodPropertyType_httpwww_w3_org1999xlinkrole', pyxb.binding.datatypes.anyURI)
    def role (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}role."""
        return self.__role.value(self)
    def setRole (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}role.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__role.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}arcrole uses Python identifier arcrole
    __arcrole = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'arcrole'), 'arcrole', '__OperationMethodPropertyType_httpwww_w3_org1999xlinkarcrole', pyxb.binding.datatypes.anyURI)
    def arcrole (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}arcrole."""
        return self.__arcrole.value(self)
    def setArcrole (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}arcrole.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__arcrole.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}href uses Python identifier href
    __href = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'href'), 'href', '__OperationMethodPropertyType_httpwww_w3_org1999xlinkhref', pyxb.binding.datatypes.anyURI)
    def href (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}href."""
        return self.__href.value(self)
    def setHref (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}href.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__href.set(self, new_value)

    _ElementMap = {
        __OperationMethod.name() : __OperationMethod
    }
    _AttributeMap = {
        __show.name() : __show,
        __remoteSchema.name() : __remoteSchema,
        __actuate.name() : __actuate,
        __type.name() : __type,
        __nilReason.name() : __nilReason,
        __title.name() : __title,
        __role.name() : __role,
        __arcrole.name() : __arcrole,
        __href.name() : __href
    }
Namespace.addCategoryObject('typeBinding', u'OperationMethodPropertyType', OperationMethodPropertyType)


# Complex type OperationParameterGroupPropertyType with content type ELEMENT_ONLY
class OperationParameterGroupPropertyType (pyxb.binding.basis.complexTypeDefinition):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'OperationParameterGroupPropertyType')
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.opengis.net/gml}OperationParameterGroup uses Python identifier OperationParameterGroup
    __OperationParameterGroup = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'OperationParameterGroup'), 'OperationParameterGroup', '__OperationParameterGroupPropertyType_httpwww_opengis_netgmlOperationParameterGroup', False)
    def OperationParameterGroup (self):
        """Get the value of the {http://www.opengis.net/gml}OperationParameterGroup element."""
        return self.__OperationParameterGroup.value(self)
    def setOperationParameterGroup (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}OperationParameterGroup element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__OperationParameterGroup.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}href uses Python identifier href
    __href = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'href'), 'href', '__OperationParameterGroupPropertyType_httpwww_w3_org1999xlinkhref', pyxb.binding.datatypes.anyURI)
    def href (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}href."""
        return self.__href.value(self)
    def setHref (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}href.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__href.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}show uses Python identifier show
    __show = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'show'), 'show', '__OperationParameterGroupPropertyType_httpwww_w3_org1999xlinkshow', MODULEhttpwww_w3_org1999xlink.UNBOUNDNone_108)
    def show (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}show."""
        return self.__show.value(self)
    def setShow (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}show.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__show.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}arcrole uses Python identifier arcrole
    __arcrole = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'arcrole'), 'arcrole', '__OperationParameterGroupPropertyType_httpwww_w3_org1999xlinkarcrole', pyxb.binding.datatypes.anyURI)
    def arcrole (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}arcrole."""
        return self.__arcrole.value(self)
    def setArcrole (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}arcrole.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__arcrole.set(self, new_value)
    
    # Attribute {http://www.opengis.net/gml}remoteSchema uses Python identifier remoteSchema
    __remoteSchema = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(Namespace, u'remoteSchema'), 'remoteSchema', '__OperationParameterGroupPropertyType_httpwww_opengis_netgmlremoteSchema', pyxb.binding.datatypes.anyURI)
    def remoteSchema (self):
        """Get the attribute value for {http://www.opengis.net/gml}remoteSchema."""
        return self.__remoteSchema.value(self)
    def setRemoteSchema (self, new_value):
        """Set the attribute value for {http://www.opengis.net/gml}remoteSchema.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__remoteSchema.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}actuate uses Python identifier actuate
    __actuate = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'actuate'), 'actuate', '__OperationParameterGroupPropertyType_httpwww_w3_org1999xlinkactuate', MODULEhttpwww_w3_org1999xlink.UNBOUNDNone_109)
    def actuate (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}actuate."""
        return self.__actuate.value(self)
    def setActuate (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}actuate.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__actuate.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}type uses Python identifier type
    __type = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'type'), 'type', '__OperationParameterGroupPropertyType_httpwww_w3_org1999xlinktype', pyxb.binding.datatypes.string, fixed=True, unicode_default=u'simple')
    def type (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}type."""
        return self.__type.value(self)
    def setType (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}type.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__type.set(self, new_value)
    
    # Attribute nilReason uses Python identifier nilReason
    __nilReason = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'nilReason'), 'nilReason', '__OperationParameterGroupPropertyType_nilReason', NilReasonType)
    def nilReason (self):
        """Get the attribute value for nilReason."""
        return self.__nilReason.value(self)
    def setNilReason (self, new_value):
        """Set the attribute value for nilReason.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__nilReason.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}title uses Python identifier title
    __title = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'title'), 'title', '__OperationParameterGroupPropertyType_httpwww_w3_org1999xlinktitle', pyxb.binding.datatypes.string)
    def title (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}title."""
        return self.__title.value(self)
    def setTitle (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}title.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__title.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}role uses Python identifier role
    __role = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'role'), 'role', '__OperationParameterGroupPropertyType_httpwww_w3_org1999xlinkrole', pyxb.binding.datatypes.anyURI)
    def role (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}role."""
        return self.__role.value(self)
    def setRole (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}role.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__role.set(self, new_value)

    _ElementMap = {
        __OperationParameterGroup.name() : __OperationParameterGroup
    }
    _AttributeMap = {
        __href.name() : __href,
        __show.name() : __show,
        __arcrole.name() : __arcrole,
        __remoteSchema.name() : __remoteSchema,
        __actuate.name() : __actuate,
        __type.name() : __type,
        __nilReason.name() : __nilReason,
        __title.name() : __title,
        __role.name() : __role
    }
Namespace.addCategoryObject('typeBinding', u'OperationParameterGroupPropertyType', OperationParameterGroupPropertyType)


# Complex type OperationParameterPropertyType with content type ELEMENT_ONLY
class OperationParameterPropertyType (pyxb.binding.basis.complexTypeDefinition):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'OperationParameterPropertyType')
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.opengis.net/gml}OperationParameter uses Python identifier OperationParameter
    __OperationParameter = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'OperationParameter'), 'OperationParameter', '__OperationParameterPropertyType_httpwww_opengis_netgmlOperationParameter', False)
    def OperationParameter (self):
        """Get the value of the {http://www.opengis.net/gml}OperationParameter element."""
        return self.__OperationParameter.value(self)
    def setOperationParameter (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}OperationParameter element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__OperationParameter.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}href uses Python identifier href
    __href = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'href'), 'href', '__OperationParameterPropertyType_httpwww_w3_org1999xlinkhref', pyxb.binding.datatypes.anyURI)
    def href (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}href."""
        return self.__href.value(self)
    def setHref (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}href.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__href.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}show uses Python identifier show
    __show = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'show'), 'show', '__OperationParameterPropertyType_httpwww_w3_org1999xlinkshow', MODULEhttpwww_w3_org1999xlink.UNBOUNDNone_110)
    def show (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}show."""
        return self.__show.value(self)
    def setShow (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}show.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__show.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}arcrole uses Python identifier arcrole
    __arcrole = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'arcrole'), 'arcrole', '__OperationParameterPropertyType_httpwww_w3_org1999xlinkarcrole', pyxb.binding.datatypes.anyURI)
    def arcrole (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}arcrole."""
        return self.__arcrole.value(self)
    def setArcrole (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}arcrole.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__arcrole.set(self, new_value)
    
    # Attribute {http://www.opengis.net/gml}remoteSchema uses Python identifier remoteSchema
    __remoteSchema = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(Namespace, u'remoteSchema'), 'remoteSchema', '__OperationParameterPropertyType_httpwww_opengis_netgmlremoteSchema', pyxb.binding.datatypes.anyURI)
    def remoteSchema (self):
        """Get the attribute value for {http://www.opengis.net/gml}remoteSchema."""
        return self.__remoteSchema.value(self)
    def setRemoteSchema (self, new_value):
        """Set the attribute value for {http://www.opengis.net/gml}remoteSchema.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__remoteSchema.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}actuate uses Python identifier actuate
    __actuate = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'actuate'), 'actuate', '__OperationParameterPropertyType_httpwww_w3_org1999xlinkactuate', MODULEhttpwww_w3_org1999xlink.UNBOUNDNone_111)
    def actuate (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}actuate."""
        return self.__actuate.value(self)
    def setActuate (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}actuate.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__actuate.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}type uses Python identifier type
    __type = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'type'), 'type', '__OperationParameterPropertyType_httpwww_w3_org1999xlinktype', pyxb.binding.datatypes.string, fixed=True, unicode_default=u'simple')
    def type (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}type."""
        return self.__type.value(self)
    def setType (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}type.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__type.set(self, new_value)
    
    # Attribute nilReason uses Python identifier nilReason
    __nilReason = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'nilReason'), 'nilReason', '__OperationParameterPropertyType_nilReason', NilReasonType)
    def nilReason (self):
        """Get the attribute value for nilReason."""
        return self.__nilReason.value(self)
    def setNilReason (self, new_value):
        """Set the attribute value for nilReason.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__nilReason.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}title uses Python identifier title
    __title = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'title'), 'title', '__OperationParameterPropertyType_httpwww_w3_org1999xlinktitle', pyxb.binding.datatypes.string)
    def title (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}title."""
        return self.__title.value(self)
    def setTitle (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}title.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__title.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}role uses Python identifier role
    __role = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'role'), 'role', '__OperationParameterPropertyType_httpwww_w3_org1999xlinkrole', pyxb.binding.datatypes.anyURI)
    def role (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}role."""
        return self.__role.value(self)
    def setRole (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}role.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__role.set(self, new_value)

    _ElementMap = {
        __OperationParameter.name() : __OperationParameter
    }
    _AttributeMap = {
        __href.name() : __href,
        __show.name() : __show,
        __arcrole.name() : __arcrole,
        __remoteSchema.name() : __remoteSchema,
        __actuate.name() : __actuate,
        __type.name() : __type,
        __nilReason.name() : __nilReason,
        __title.name() : __title,
        __role.name() : __role
    }
Namespace.addCategoryObject('typeBinding', u'OperationParameterPropertyType', OperationParameterPropertyType)


# Complex type OperationPropertyType with content type ELEMENT_ONLY
class OperationPropertyType (pyxb.binding.basis.complexTypeDefinition):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'OperationPropertyType')
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.opengis.net/gml}AbstractOperation uses Python identifier AbstractOperation
    __AbstractOperation = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'AbstractOperation'), 'AbstractOperation', '__OperationPropertyType_httpwww_opengis_netgmlAbstractOperation', False)
    def AbstractOperation (self):
        """Get the value of the {http://www.opengis.net/gml}AbstractOperation element."""
        return self.__AbstractOperation.value(self)
    def setAbstractOperation (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}AbstractOperation element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__AbstractOperation.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}title uses Python identifier title
    __title = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'title'), 'title', '__OperationPropertyType_httpwww_w3_org1999xlinktitle', pyxb.binding.datatypes.string)
    def title (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}title."""
        return self.__title.value(self)
    def setTitle (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}title.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__title.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}show uses Python identifier show
    __show = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'show'), 'show', '__OperationPropertyType_httpwww_w3_org1999xlinkshow', MODULEhttpwww_w3_org1999xlink.UNBOUNDNone_112)
    def show (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}show."""
        return self.__show.value(self)
    def setShow (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}show.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__show.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}role uses Python identifier role
    __role = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'role'), 'role', '__OperationPropertyType_httpwww_w3_org1999xlinkrole', pyxb.binding.datatypes.anyURI)
    def role (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}role."""
        return self.__role.value(self)
    def setRole (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}role.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__role.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}href uses Python identifier href
    __href = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'href'), 'href', '__OperationPropertyType_httpwww_w3_org1999xlinkhref', pyxb.binding.datatypes.anyURI)
    def href (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}href."""
        return self.__href.value(self)
    def setHref (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}href.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__href.set(self, new_value)
    
    # Attribute nilReason uses Python identifier nilReason
    __nilReason = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'nilReason'), 'nilReason', '__OperationPropertyType_nilReason', NilReasonType)
    def nilReason (self):
        """Get the attribute value for nilReason."""
        return self.__nilReason.value(self)
    def setNilReason (self, new_value):
        """Set the attribute value for nilReason.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__nilReason.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}arcrole uses Python identifier arcrole
    __arcrole = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'arcrole'), 'arcrole', '__OperationPropertyType_httpwww_w3_org1999xlinkarcrole', pyxb.binding.datatypes.anyURI)
    def arcrole (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}arcrole."""
        return self.__arcrole.value(self)
    def setArcrole (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}arcrole.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__arcrole.set(self, new_value)
    
    # Attribute {http://www.opengis.net/gml}remoteSchema uses Python identifier remoteSchema
    __remoteSchema = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(Namespace, u'remoteSchema'), 'remoteSchema', '__OperationPropertyType_httpwww_opengis_netgmlremoteSchema', pyxb.binding.datatypes.anyURI)
    def remoteSchema (self):
        """Get the attribute value for {http://www.opengis.net/gml}remoteSchema."""
        return self.__remoteSchema.value(self)
    def setRemoteSchema (self, new_value):
        """Set the attribute value for {http://www.opengis.net/gml}remoteSchema.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__remoteSchema.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}actuate uses Python identifier actuate
    __actuate = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'actuate'), 'actuate', '__OperationPropertyType_httpwww_w3_org1999xlinkactuate', MODULEhttpwww_w3_org1999xlink.UNBOUNDNone_113)
    def actuate (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}actuate."""
        return self.__actuate.value(self)
    def setActuate (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}actuate.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__actuate.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}type uses Python identifier type
    __type = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'type'), 'type', '__OperationPropertyType_httpwww_w3_org1999xlinktype', pyxb.binding.datatypes.string, fixed=True, unicode_default=u'simple')
    def type (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}type."""
        return self.__type.value(self)
    def setType (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}type.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__type.set(self, new_value)

    _ElementMap = {
        __AbstractOperation.name() : __AbstractOperation
    }
    _AttributeMap = {
        __title.name() : __title,
        __show.name() : __show,
        __role.name() : __role,
        __href.name() : __href,
        __nilReason.name() : __nilReason,
        __arcrole.name() : __arcrole,
        __remoteSchema.name() : __remoteSchema,
        __actuate.name() : __actuate,
        __type.name() : __type
    }
Namespace.addCategoryObject('typeBinding', u'OperationPropertyType', OperationPropertyType)


# Complex type PassThroughOperationPropertyType with content type ELEMENT_ONLY
class PassThroughOperationPropertyType (pyxb.binding.basis.complexTypeDefinition):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'PassThroughOperationPropertyType')
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.opengis.net/gml}PassThroughOperation uses Python identifier PassThroughOperation
    __PassThroughOperation = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'PassThroughOperation'), 'PassThroughOperation', '__PassThroughOperationPropertyType_httpwww_opengis_netgmlPassThroughOperation', False)
    def PassThroughOperation (self):
        """Get the value of the {http://www.opengis.net/gml}PassThroughOperation element."""
        return self.__PassThroughOperation.value(self)
    def setPassThroughOperation (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}PassThroughOperation element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__PassThroughOperation.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}show uses Python identifier show
    __show = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'show'), 'show', '__PassThroughOperationPropertyType_httpwww_w3_org1999xlinkshow', MODULEhttpwww_w3_org1999xlink.UNBOUNDNone_114)
    def show (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}show."""
        return self.__show.value(self)
    def setShow (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}show.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__show.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}title uses Python identifier title
    __title = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'title'), 'title', '__PassThroughOperationPropertyType_httpwww_w3_org1999xlinktitle', pyxb.binding.datatypes.string)
    def title (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}title."""
        return self.__title.value(self)
    def setTitle (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}title.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__title.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}role uses Python identifier role
    __role = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'role'), 'role', '__PassThroughOperationPropertyType_httpwww_w3_org1999xlinkrole', pyxb.binding.datatypes.anyURI)
    def role (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}role."""
        return self.__role.value(self)
    def setRole (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}role.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__role.set(self, new_value)
    
    # Attribute nilReason uses Python identifier nilReason
    __nilReason = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'nilReason'), 'nilReason', '__PassThroughOperationPropertyType_nilReason', NilReasonType)
    def nilReason (self):
        """Get the attribute value for nilReason."""
        return self.__nilReason.value(self)
    def setNilReason (self, new_value):
        """Set the attribute value for nilReason.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__nilReason.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}href uses Python identifier href
    __href = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'href'), 'href', '__PassThroughOperationPropertyType_httpwww_w3_org1999xlinkhref', pyxb.binding.datatypes.anyURI)
    def href (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}href."""
        return self.__href.value(self)
    def setHref (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}href.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__href.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}arcrole uses Python identifier arcrole
    __arcrole = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'arcrole'), 'arcrole', '__PassThroughOperationPropertyType_httpwww_w3_org1999xlinkarcrole', pyxb.binding.datatypes.anyURI)
    def arcrole (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}arcrole."""
        return self.__arcrole.value(self)
    def setArcrole (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}arcrole.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__arcrole.set(self, new_value)
    
    # Attribute {http://www.opengis.net/gml}remoteSchema uses Python identifier remoteSchema
    __remoteSchema = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(Namespace, u'remoteSchema'), 'remoteSchema', '__PassThroughOperationPropertyType_httpwww_opengis_netgmlremoteSchema', pyxb.binding.datatypes.anyURI)
    def remoteSchema (self):
        """Get the attribute value for {http://www.opengis.net/gml}remoteSchema."""
        return self.__remoteSchema.value(self)
    def setRemoteSchema (self, new_value):
        """Set the attribute value for {http://www.opengis.net/gml}remoteSchema.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__remoteSchema.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}actuate uses Python identifier actuate
    __actuate = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'actuate'), 'actuate', '__PassThroughOperationPropertyType_httpwww_w3_org1999xlinkactuate', MODULEhttpwww_w3_org1999xlink.UNBOUNDNone_115)
    def actuate (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}actuate."""
        return self.__actuate.value(self)
    def setActuate (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}actuate.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__actuate.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}type uses Python identifier type
    __type = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'type'), 'type', '__PassThroughOperationPropertyType_httpwww_w3_org1999xlinktype', pyxb.binding.datatypes.string, fixed=True, unicode_default=u'simple')
    def type (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}type."""
        return self.__type.value(self)
    def setType (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}type.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__type.set(self, new_value)

    _ElementMap = {
        __PassThroughOperation.name() : __PassThroughOperation
    }
    _AttributeMap = {
        __show.name() : __show,
        __title.name() : __title,
        __role.name() : __role,
        __nilReason.name() : __nilReason,
        __href.name() : __href,
        __arcrole.name() : __arcrole,
        __remoteSchema.name() : __remoteSchema,
        __actuate.name() : __actuate,
        __type.name() : __type
    }
Namespace.addCategoryObject('typeBinding', u'PassThroughOperationPropertyType', PassThroughOperationPropertyType)


# Complex type PointArrayPropertyType with content type ELEMENT_ONLY
class PointArrayPropertyType (pyxb.binding.basis.complexTypeDefinition):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'PointArrayPropertyType')
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.opengis.net/gml}Point uses Python identifier Point
    __Point = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'Point'), 'Point', '__PointArrayPropertyType_httpwww_opengis_netgmlPoint', True)
    def Point (self):
        """Get the value of the {http://www.opengis.net/gml}Point element."""
        return self.__Point.value(self)
    def setPoint (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}Point element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__Point.set(self, new_value)
    
    def addPoint (self, new_value):
        """Add the value as another occurrence of the {http://www.opengis.net/gml}Point element.  Raises
        BadValueTypeException if the new value is not consistent with the
        element's type."""
        return self.__Point.append(self, new_value)
    
    # Attribute owns uses Python identifier owns
    __owns = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'owns'), 'owns', '__PointArrayPropertyType_owns', pyxb.binding.datatypes.boolean, unicode_default=u'false')
    def owns (self):
        """Get the attribute value for owns."""
        return self.__owns.value(self)
    def setOwns (self, new_value):
        """Set the attribute value for owns.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__owns.set(self, new_value)

    _ElementMap = {
        __Point.name() : __Point
    }
    _AttributeMap = {
        __owns.name() : __owns
    }
Namespace.addCategoryObject('typeBinding', u'PointArrayPropertyType', PointArrayPropertyType)


# Complex type PointPropertyType with content type ELEMENT_ONLY
class PointPropertyType (pyxb.binding.basis.complexTypeDefinition):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'PointPropertyType')
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.opengis.net/gml}Point uses Python identifier Point
    __Point = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'Point'), 'Point', '__PointPropertyType_httpwww_opengis_netgmlPoint', False)
    def Point (self):
        """Get the value of the {http://www.opengis.net/gml}Point element."""
        return self.__Point.value(self)
    def setPoint (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}Point element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__Point.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}actuate uses Python identifier actuate
    __actuate = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'actuate'), 'actuate', '__PointPropertyType_httpwww_w3_org1999xlinkactuate', MODULEhttpwww_w3_org1999xlink.UNBOUNDNone_116)
    def actuate (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}actuate."""
        return self.__actuate.value(self)
    def setActuate (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}actuate.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__actuate.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}show uses Python identifier show
    __show = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'show'), 'show', '__PointPropertyType_httpwww_w3_org1999xlinkshow', MODULEhttpwww_w3_org1999xlink.UNBOUNDNone_117)
    def show (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}show."""
        return self.__show.value(self)
    def setShow (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}show.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__show.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}type uses Python identifier type
    __type = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'type'), 'type', '__PointPropertyType_httpwww_w3_org1999xlinktype', pyxb.binding.datatypes.string, fixed=True, unicode_default=u'simple')
    def type (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}type."""
        return self.__type.value(self)
    def setType (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}type.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__type.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}title uses Python identifier title
    __title = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'title'), 'title', '__PointPropertyType_httpwww_w3_org1999xlinktitle', pyxb.binding.datatypes.string)
    def title (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}title."""
        return self.__title.value(self)
    def setTitle (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}title.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__title.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}role uses Python identifier role
    __role = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'role'), 'role', '__PointPropertyType_httpwww_w3_org1999xlinkrole', pyxb.binding.datatypes.anyURI)
    def role (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}role."""
        return self.__role.value(self)
    def setRole (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}role.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__role.set(self, new_value)
    
    # Attribute nilReason uses Python identifier nilReason
    __nilReason = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'nilReason'), 'nilReason', '__PointPropertyType_nilReason', NilReasonType)
    def nilReason (self):
        """Get the attribute value for nilReason."""
        return self.__nilReason.value(self)
    def setNilReason (self, new_value):
        """Set the attribute value for nilReason.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__nilReason.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}href uses Python identifier href
    __href = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'href'), 'href', '__PointPropertyType_httpwww_w3_org1999xlinkhref', pyxb.binding.datatypes.anyURI)
    def href (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}href."""
        return self.__href.value(self)
    def setHref (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}href.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__href.set(self, new_value)
    
    # Attribute owns uses Python identifier owns
    __owns = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'owns'), 'owns', '__PointPropertyType_owns', pyxb.binding.datatypes.boolean, unicode_default=u'false')
    def owns (self):
        """Get the attribute value for owns."""
        return self.__owns.value(self)
    def setOwns (self, new_value):
        """Set the attribute value for owns.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__owns.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}arcrole uses Python identifier arcrole
    __arcrole = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'arcrole'), 'arcrole', '__PointPropertyType_httpwww_w3_org1999xlinkarcrole', pyxb.binding.datatypes.anyURI)
    def arcrole (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}arcrole."""
        return self.__arcrole.value(self)
    def setArcrole (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}arcrole.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__arcrole.set(self, new_value)
    
    # Attribute {http://www.opengis.net/gml}remoteSchema uses Python identifier remoteSchema
    __remoteSchema = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(Namespace, u'remoteSchema'), 'remoteSchema', '__PointPropertyType_httpwww_opengis_netgmlremoteSchema', pyxb.binding.datatypes.anyURI)
    def remoteSchema (self):
        """Get the attribute value for {http://www.opengis.net/gml}remoteSchema."""
        return self.__remoteSchema.value(self)
    def setRemoteSchema (self, new_value):
        """Set the attribute value for {http://www.opengis.net/gml}remoteSchema.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__remoteSchema.set(self, new_value)

    _ElementMap = {
        __Point.name() : __Point
    }
    _AttributeMap = {
        __actuate.name() : __actuate,
        __show.name() : __show,
        __type.name() : __type,
        __title.name() : __title,
        __role.name() : __role,
        __nilReason.name() : __nilReason,
        __href.name() : __href,
        __owns.name() : __owns,
        __arcrole.name() : __arcrole,
        __remoteSchema.name() : __remoteSchema
    }
Namespace.addCategoryObject('typeBinding', u'PointPropertyType', PointPropertyType)


# Complex type PolarCSPropertyType with content type ELEMENT_ONLY
class PolarCSPropertyType (pyxb.binding.basis.complexTypeDefinition):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'PolarCSPropertyType')
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.opengis.net/gml}PolarCS uses Python identifier PolarCS
    __PolarCS = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'PolarCS'), 'PolarCS', '__PolarCSPropertyType_httpwww_opengis_netgmlPolarCS', False)
    def PolarCS (self):
        """Get the value of the {http://www.opengis.net/gml}PolarCS element."""
        return self.__PolarCS.value(self)
    def setPolarCS (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}PolarCS element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__PolarCS.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}show uses Python identifier show
    __show = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'show'), 'show', '__PolarCSPropertyType_httpwww_w3_org1999xlinkshow', MODULEhttpwww_w3_org1999xlink.UNBOUNDNone_118)
    def show (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}show."""
        return self.__show.value(self)
    def setShow (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}show.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__show.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}role uses Python identifier role
    __role = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'role'), 'role', '__PolarCSPropertyType_httpwww_w3_org1999xlinkrole', pyxb.binding.datatypes.anyURI)
    def role (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}role."""
        return self.__role.value(self)
    def setRole (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}role.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__role.set(self, new_value)
    
    # Attribute {http://www.opengis.net/gml}remoteSchema uses Python identifier remoteSchema
    __remoteSchema = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(Namespace, u'remoteSchema'), 'remoteSchema', '__PolarCSPropertyType_httpwww_opengis_netgmlremoteSchema', pyxb.binding.datatypes.anyURI)
    def remoteSchema (self):
        """Get the attribute value for {http://www.opengis.net/gml}remoteSchema."""
        return self.__remoteSchema.value(self)
    def setRemoteSchema (self, new_value):
        """Set the attribute value for {http://www.opengis.net/gml}remoteSchema.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__remoteSchema.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}href uses Python identifier href
    __href = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'href'), 'href', '__PolarCSPropertyType_httpwww_w3_org1999xlinkhref', pyxb.binding.datatypes.anyURI)
    def href (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}href."""
        return self.__href.value(self)
    def setHref (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}href.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__href.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}arcrole uses Python identifier arcrole
    __arcrole = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'arcrole'), 'arcrole', '__PolarCSPropertyType_httpwww_w3_org1999xlinkarcrole', pyxb.binding.datatypes.anyURI)
    def arcrole (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}arcrole."""
        return self.__arcrole.value(self)
    def setArcrole (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}arcrole.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__arcrole.set(self, new_value)
    
    # Attribute nilReason uses Python identifier nilReason
    __nilReason = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'nilReason'), 'nilReason', '__PolarCSPropertyType_nilReason', NilReasonType)
    def nilReason (self):
        """Get the attribute value for nilReason."""
        return self.__nilReason.value(self)
    def setNilReason (self, new_value):
        """Set the attribute value for nilReason.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__nilReason.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}actuate uses Python identifier actuate
    __actuate = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'actuate'), 'actuate', '__PolarCSPropertyType_httpwww_w3_org1999xlinkactuate', MODULEhttpwww_w3_org1999xlink.UNBOUNDNone_119)
    def actuate (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}actuate."""
        return self.__actuate.value(self)
    def setActuate (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}actuate.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__actuate.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}type uses Python identifier type
    __type = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'type'), 'type', '__PolarCSPropertyType_httpwww_w3_org1999xlinktype', pyxb.binding.datatypes.string, fixed=True, unicode_default=u'simple')
    def type (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}type."""
        return self.__type.value(self)
    def setType (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}type.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__type.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}title uses Python identifier title
    __title = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'title'), 'title', '__PolarCSPropertyType_httpwww_w3_org1999xlinktitle', pyxb.binding.datatypes.string)
    def title (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}title."""
        return self.__title.value(self)
    def setTitle (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}title.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__title.set(self, new_value)

    _ElementMap = {
        __PolarCS.name() : __PolarCS
    }
    _AttributeMap = {
        __show.name() : __show,
        __role.name() : __role,
        __remoteSchema.name() : __remoteSchema,
        __href.name() : __href,
        __arcrole.name() : __arcrole,
        __nilReason.name() : __nilReason,
        __actuate.name() : __actuate,
        __type.name() : __type,
        __title.name() : __title
    }
Namespace.addCategoryObject('typeBinding', u'PolarCSPropertyType', PolarCSPropertyType)


# Complex type PrimeMeridianPropertyType with content type ELEMENT_ONLY
class PrimeMeridianPropertyType (pyxb.binding.basis.complexTypeDefinition):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'PrimeMeridianPropertyType')
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.opengis.net/gml}PrimeMeridian uses Python identifier PrimeMeridian
    __PrimeMeridian = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'PrimeMeridian'), 'PrimeMeridian', '__PrimeMeridianPropertyType_httpwww_opengis_netgmlPrimeMeridian', False)
    def PrimeMeridian (self):
        """Get the value of the {http://www.opengis.net/gml}PrimeMeridian element."""
        return self.__PrimeMeridian.value(self)
    def setPrimeMeridian (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}PrimeMeridian element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__PrimeMeridian.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}show uses Python identifier show
    __show = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'show'), 'show', '__PrimeMeridianPropertyType_httpwww_w3_org1999xlinkshow', MODULEhttpwww_w3_org1999xlink.UNBOUNDNone_120)
    def show (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}show."""
        return self.__show.value(self)
    def setShow (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}show.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__show.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}href uses Python identifier href
    __href = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'href'), 'href', '__PrimeMeridianPropertyType_httpwww_w3_org1999xlinkhref', pyxb.binding.datatypes.anyURI)
    def href (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}href."""
        return self.__href.value(self)
    def setHref (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}href.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__href.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}arcrole uses Python identifier arcrole
    __arcrole = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'arcrole'), 'arcrole', '__PrimeMeridianPropertyType_httpwww_w3_org1999xlinkarcrole', pyxb.binding.datatypes.anyURI)
    def arcrole (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}arcrole."""
        return self.__arcrole.value(self)
    def setArcrole (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}arcrole.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__arcrole.set(self, new_value)
    
    # Attribute {http://www.opengis.net/gml}remoteSchema uses Python identifier remoteSchema
    __remoteSchema = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(Namespace, u'remoteSchema'), 'remoteSchema', '__PrimeMeridianPropertyType_httpwww_opengis_netgmlremoteSchema', pyxb.binding.datatypes.anyURI)
    def remoteSchema (self):
        """Get the attribute value for {http://www.opengis.net/gml}remoteSchema."""
        return self.__remoteSchema.value(self)
    def setRemoteSchema (self, new_value):
        """Set the attribute value for {http://www.opengis.net/gml}remoteSchema.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__remoteSchema.set(self, new_value)
    
    # Attribute nilReason uses Python identifier nilReason
    __nilReason = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'nilReason'), 'nilReason', '__PrimeMeridianPropertyType_nilReason', NilReasonType)
    def nilReason (self):
        """Get the attribute value for nilReason."""
        return self.__nilReason.value(self)
    def setNilReason (self, new_value):
        """Set the attribute value for nilReason.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__nilReason.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}type uses Python identifier type
    __type = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'type'), 'type', '__PrimeMeridianPropertyType_httpwww_w3_org1999xlinktype', pyxb.binding.datatypes.string, fixed=True, unicode_default=u'simple')
    def type (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}type."""
        return self.__type.value(self)
    def setType (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}type.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__type.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}title uses Python identifier title
    __title = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'title'), 'title', '__PrimeMeridianPropertyType_httpwww_w3_org1999xlinktitle', pyxb.binding.datatypes.string)
    def title (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}title."""
        return self.__title.value(self)
    def setTitle (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}title.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__title.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}role uses Python identifier role
    __role = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'role'), 'role', '__PrimeMeridianPropertyType_httpwww_w3_org1999xlinkrole', pyxb.binding.datatypes.anyURI)
    def role (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}role."""
        return self.__role.value(self)
    def setRole (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}role.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__role.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}actuate uses Python identifier actuate
    __actuate = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'actuate'), 'actuate', '__PrimeMeridianPropertyType_httpwww_w3_org1999xlinkactuate', MODULEhttpwww_w3_org1999xlink.UNBOUNDNone_121)
    def actuate (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}actuate."""
        return self.__actuate.value(self)
    def setActuate (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}actuate.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__actuate.set(self, new_value)

    _ElementMap = {
        __PrimeMeridian.name() : __PrimeMeridian
    }
    _AttributeMap = {
        __show.name() : __show,
        __href.name() : __href,
        __arcrole.name() : __arcrole,
        __remoteSchema.name() : __remoteSchema,
        __nilReason.name() : __nilReason,
        __type.name() : __type,
        __title.name() : __title,
        __role.name() : __role,
        __actuate.name() : __actuate
    }
Namespace.addCategoryObject('typeBinding', u'PrimeMeridianPropertyType', PrimeMeridianPropertyType)


# Complex type ProcedurePropertyType with content type ELEMENT_ONLY
class ProcedurePropertyType (pyxb.binding.basis.complexTypeDefinition):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'ProcedurePropertyType')
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.opengis.net/gml}AbstractFeature uses Python identifier AbstractFeature
    __AbstractFeature = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'AbstractFeature'), 'AbstractFeature', '__ProcedurePropertyType_httpwww_opengis_netgmlAbstractFeature', False)
    def AbstractFeature (self):
        """Get the value of the {http://www.opengis.net/gml}AbstractFeature element."""
        return self.__AbstractFeature.value(self)
    def setAbstractFeature (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}AbstractFeature element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__AbstractFeature.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}show uses Python identifier show
    __show = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'show'), 'show', '__ProcedurePropertyType_httpwww_w3_org1999xlinkshow', MODULEhttpwww_w3_org1999xlink.UNBOUNDNone_122)
    def show (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}show."""
        return self.__show.value(self)
    def setShow (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}show.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__show.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}title uses Python identifier title
    __title = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'title'), 'title', '__ProcedurePropertyType_httpwww_w3_org1999xlinktitle', pyxb.binding.datatypes.string)
    def title (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}title."""
        return self.__title.value(self)
    def setTitle (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}title.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__title.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}role uses Python identifier role
    __role = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'role'), 'role', '__ProcedurePropertyType_httpwww_w3_org1999xlinkrole', pyxb.binding.datatypes.anyURI)
    def role (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}role."""
        return self.__role.value(self)
    def setRole (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}role.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__role.set(self, new_value)
    
    # Attribute nilReason uses Python identifier nilReason
    __nilReason = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'nilReason'), 'nilReason', '__ProcedurePropertyType_nilReason', NilReasonType)
    def nilReason (self):
        """Get the attribute value for nilReason."""
        return self.__nilReason.value(self)
    def setNilReason (self, new_value):
        """Set the attribute value for nilReason.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__nilReason.set(self, new_value)
    
    # Attribute owns uses Python identifier owns
    __owns = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'owns'), 'owns', '__ProcedurePropertyType_owns', pyxb.binding.datatypes.boolean, unicode_default=u'false')
    def owns (self):
        """Get the attribute value for owns."""
        return self.__owns.value(self)
    def setOwns (self, new_value):
        """Set the attribute value for owns.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__owns.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}href uses Python identifier href
    __href = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'href'), 'href', '__ProcedurePropertyType_httpwww_w3_org1999xlinkhref', pyxb.binding.datatypes.anyURI)
    def href (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}href."""
        return self.__href.value(self)
    def setHref (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}href.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__href.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}arcrole uses Python identifier arcrole
    __arcrole = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'arcrole'), 'arcrole', '__ProcedurePropertyType_httpwww_w3_org1999xlinkarcrole', pyxb.binding.datatypes.anyURI)
    def arcrole (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}arcrole."""
        return self.__arcrole.value(self)
    def setArcrole (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}arcrole.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__arcrole.set(self, new_value)
    
    # Attribute {http://www.opengis.net/gml}remoteSchema uses Python identifier remoteSchema
    __remoteSchema = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(Namespace, u'remoteSchema'), 'remoteSchema', '__ProcedurePropertyType_httpwww_opengis_netgmlremoteSchema', pyxb.binding.datatypes.anyURI)
    def remoteSchema (self):
        """Get the attribute value for {http://www.opengis.net/gml}remoteSchema."""
        return self.__remoteSchema.value(self)
    def setRemoteSchema (self, new_value):
        """Set the attribute value for {http://www.opengis.net/gml}remoteSchema.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__remoteSchema.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}actuate uses Python identifier actuate
    __actuate = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'actuate'), 'actuate', '__ProcedurePropertyType_httpwww_w3_org1999xlinkactuate', MODULEhttpwww_w3_org1999xlink.UNBOUNDNone_123)
    def actuate (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}actuate."""
        return self.__actuate.value(self)
    def setActuate (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}actuate.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__actuate.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}type uses Python identifier type
    __type = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'type'), 'type', '__ProcedurePropertyType_httpwww_w3_org1999xlinktype', pyxb.binding.datatypes.string, fixed=True, unicode_default=u'simple')
    def type (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}type."""
        return self.__type.value(self)
    def setType (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}type.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__type.set(self, new_value)

    _ElementMap = {
        __AbstractFeature.name() : __AbstractFeature
    }
    _AttributeMap = {
        __show.name() : __show,
        __title.name() : __title,
        __role.name() : __role,
        __nilReason.name() : __nilReason,
        __owns.name() : __owns,
        __href.name() : __href,
        __arcrole.name() : __arcrole,
        __remoteSchema.name() : __remoteSchema,
        __actuate.name() : __actuate,
        __type.name() : __type
    }
Namespace.addCategoryObject('typeBinding', u'ProcedurePropertyType', ProcedurePropertyType)


# Complex type ProjectedCRSPropertyType with content type ELEMENT_ONLY
class ProjectedCRSPropertyType (pyxb.binding.basis.complexTypeDefinition):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'ProjectedCRSPropertyType')
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.opengis.net/gml}ProjectedCRS uses Python identifier ProjectedCRS
    __ProjectedCRS = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'ProjectedCRS'), 'ProjectedCRS', '__ProjectedCRSPropertyType_httpwww_opengis_netgmlProjectedCRS', False)
    def ProjectedCRS (self):
        """Get the value of the {http://www.opengis.net/gml}ProjectedCRS element."""
        return self.__ProjectedCRS.value(self)
    def setProjectedCRS (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}ProjectedCRS element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__ProjectedCRS.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}role uses Python identifier role
    __role = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'role'), 'role', '__ProjectedCRSPropertyType_httpwww_w3_org1999xlinkrole', pyxb.binding.datatypes.anyURI)
    def role (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}role."""
        return self.__role.value(self)
    def setRole (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}role.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__role.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}show uses Python identifier show
    __show = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'show'), 'show', '__ProjectedCRSPropertyType_httpwww_w3_org1999xlinkshow', MODULEhttpwww_w3_org1999xlink.UNBOUNDNone_124)
    def show (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}show."""
        return self.__show.value(self)
    def setShow (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}show.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__show.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}href uses Python identifier href
    __href = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'href'), 'href', '__ProjectedCRSPropertyType_httpwww_w3_org1999xlinkhref', pyxb.binding.datatypes.anyURI)
    def href (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}href."""
        return self.__href.value(self)
    def setHref (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}href.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__href.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}arcrole uses Python identifier arcrole
    __arcrole = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'arcrole'), 'arcrole', '__ProjectedCRSPropertyType_httpwww_w3_org1999xlinkarcrole', pyxb.binding.datatypes.anyURI)
    def arcrole (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}arcrole."""
        return self.__arcrole.value(self)
    def setArcrole (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}arcrole.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__arcrole.set(self, new_value)
    
    # Attribute {http://www.opengis.net/gml}remoteSchema uses Python identifier remoteSchema
    __remoteSchema = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(Namespace, u'remoteSchema'), 'remoteSchema', '__ProjectedCRSPropertyType_httpwww_opengis_netgmlremoteSchema', pyxb.binding.datatypes.anyURI)
    def remoteSchema (self):
        """Get the attribute value for {http://www.opengis.net/gml}remoteSchema."""
        return self.__remoteSchema.value(self)
    def setRemoteSchema (self, new_value):
        """Set the attribute value for {http://www.opengis.net/gml}remoteSchema.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__remoteSchema.set(self, new_value)
    
    # Attribute nilReason uses Python identifier nilReason
    __nilReason = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'nilReason'), 'nilReason', '__ProjectedCRSPropertyType_nilReason', NilReasonType)
    def nilReason (self):
        """Get the attribute value for nilReason."""
        return self.__nilReason.value(self)
    def setNilReason (self, new_value):
        """Set the attribute value for nilReason.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__nilReason.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}actuate uses Python identifier actuate
    __actuate = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'actuate'), 'actuate', '__ProjectedCRSPropertyType_httpwww_w3_org1999xlinkactuate', MODULEhttpwww_w3_org1999xlink.UNBOUNDNone_125)
    def actuate (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}actuate."""
        return self.__actuate.value(self)
    def setActuate (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}actuate.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__actuate.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}type uses Python identifier type
    __type = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'type'), 'type', '__ProjectedCRSPropertyType_httpwww_w3_org1999xlinktype', pyxb.binding.datatypes.string, fixed=True, unicode_default=u'simple')
    def type (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}type."""
        return self.__type.value(self)
    def setType (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}type.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__type.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}title uses Python identifier title
    __title = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'title'), 'title', '__ProjectedCRSPropertyType_httpwww_w3_org1999xlinktitle', pyxb.binding.datatypes.string)
    def title (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}title."""
        return self.__title.value(self)
    def setTitle (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}title.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__title.set(self, new_value)

    _ElementMap = {
        __ProjectedCRS.name() : __ProjectedCRS
    }
    _AttributeMap = {
        __role.name() : __role,
        __show.name() : __show,
        __href.name() : __href,
        __arcrole.name() : __arcrole,
        __remoteSchema.name() : __remoteSchema,
        __nilReason.name() : __nilReason,
        __actuate.name() : __actuate,
        __type.name() : __type,
        __title.name() : __title
    }
Namespace.addCategoryObject('typeBinding', u'ProjectedCRSPropertyType', ProjectedCRSPropertyType)


# Complex type QuantityPropertyType with content type ELEMENT_ONLY
class QuantityPropertyType (pyxb.binding.basis.complexTypeDefinition):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'QuantityPropertyType')
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.opengis.net/gml}Quantity uses Python identifier Quantity
    __Quantity = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'Quantity'), 'Quantity', '__QuantityPropertyType_httpwww_opengis_netgmlQuantity', False)
    def Quantity (self):
        """Get the value of the {http://www.opengis.net/gml}Quantity element."""
        return self.__Quantity.value(self)
    def setQuantity (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}Quantity element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__Quantity.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}show uses Python identifier show
    __show = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'show'), 'show', '__QuantityPropertyType_httpwww_w3_org1999xlinkshow', MODULEhttpwww_w3_org1999xlink.UNBOUNDNone_126)
    def show (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}show."""
        return self.__show.value(self)
    def setShow (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}show.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__show.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}href uses Python identifier href
    __href = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'href'), 'href', '__QuantityPropertyType_httpwww_w3_org1999xlinkhref', pyxb.binding.datatypes.anyURI)
    def href (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}href."""
        return self.__href.value(self)
    def setHref (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}href.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__href.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}arcrole uses Python identifier arcrole
    __arcrole = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'arcrole'), 'arcrole', '__QuantityPropertyType_httpwww_w3_org1999xlinkarcrole', pyxb.binding.datatypes.anyURI)
    def arcrole (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}arcrole."""
        return self.__arcrole.value(self)
    def setArcrole (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}arcrole.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__arcrole.set(self, new_value)
    
    # Attribute {http://www.opengis.net/gml}remoteSchema uses Python identifier remoteSchema
    __remoteSchema = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(Namespace, u'remoteSchema'), 'remoteSchema', '__QuantityPropertyType_httpwww_opengis_netgmlremoteSchema', pyxb.binding.datatypes.anyURI)
    def remoteSchema (self):
        """Get the attribute value for {http://www.opengis.net/gml}remoteSchema."""
        return self.__remoteSchema.value(self)
    def setRemoteSchema (self, new_value):
        """Set the attribute value for {http://www.opengis.net/gml}remoteSchema.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__remoteSchema.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}actuate uses Python identifier actuate
    __actuate = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'actuate'), 'actuate', '__QuantityPropertyType_httpwww_w3_org1999xlinkactuate', MODULEhttpwww_w3_org1999xlink.UNBOUNDNone_127)
    def actuate (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}actuate."""
        return self.__actuate.value(self)
    def setActuate (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}actuate.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__actuate.set(self, new_value)
    
    # Attribute nilReason uses Python identifier nilReason
    __nilReason = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'nilReason'), 'nilReason', '__QuantityPropertyType_nilReason', NilReasonType)
    def nilReason (self):
        """Get the attribute value for nilReason."""
        return self.__nilReason.value(self)
    def setNilReason (self, new_value):
        """Set the attribute value for nilReason.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__nilReason.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}type uses Python identifier type
    __type = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'type'), 'type', '__QuantityPropertyType_httpwww_w3_org1999xlinktype', pyxb.binding.datatypes.string, fixed=True, unicode_default=u'simple')
    def type (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}type."""
        return self.__type.value(self)
    def setType (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}type.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__type.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}title uses Python identifier title
    __title = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'title'), 'title', '__QuantityPropertyType_httpwww_w3_org1999xlinktitle', pyxb.binding.datatypes.string)
    def title (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}title."""
        return self.__title.value(self)
    def setTitle (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}title.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__title.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}role uses Python identifier role
    __role = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'role'), 'role', '__QuantityPropertyType_httpwww_w3_org1999xlinkrole', pyxb.binding.datatypes.anyURI)
    def role (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}role."""
        return self.__role.value(self)
    def setRole (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}role.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__role.set(self, new_value)

    _ElementMap = {
        __Quantity.name() : __Quantity
    }
    _AttributeMap = {
        __show.name() : __show,
        __href.name() : __href,
        __arcrole.name() : __arcrole,
        __remoteSchema.name() : __remoteSchema,
        __actuate.name() : __actuate,
        __nilReason.name() : __nilReason,
        __type.name() : __type,
        __title.name() : __title,
        __role.name() : __role
    }
Namespace.addCategoryObject('typeBinding', u'QuantityPropertyType', QuantityPropertyType)


# Complex type RangeParametersType with content type ELEMENT_ONLY
class RangeParametersType (pyxb.binding.basis.complexTypeDefinition):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'RangeParametersType')
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.opengis.net/gml}AbstractValue uses Python identifier AbstractValue
    __AbstractValue = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'AbstractValue'), 'AbstractValue', '__RangeParametersType_httpwww_opengis_netgmlAbstractValue', False)
    def AbstractValue (self):
        """Get the value of the {http://www.opengis.net/gml}AbstractValue element."""
        return self.__AbstractValue.value(self)
    def setAbstractValue (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}AbstractValue element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__AbstractValue.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}show uses Python identifier show
    __show = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'show'), 'show', '__RangeParametersType_httpwww_w3_org1999xlinkshow', MODULEhttpwww_w3_org1999xlink.UNBOUNDNone_128)
    def show (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}show."""
        return self.__show.value(self)
    def setShow (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}show.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__show.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}role uses Python identifier role
    __role = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'role'), 'role', '__RangeParametersType_httpwww_w3_org1999xlinkrole', pyxb.binding.datatypes.anyURI)
    def role (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}role."""
        return self.__role.value(self)
    def setRole (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}role.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__role.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}href uses Python identifier href
    __href = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'href'), 'href', '__RangeParametersType_httpwww_w3_org1999xlinkhref', pyxb.binding.datatypes.anyURI)
    def href (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}href."""
        return self.__href.value(self)
    def setHref (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}href.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__href.set(self, new_value)
    
    # Attribute owns uses Python identifier owns
    __owns = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'owns'), 'owns', '__RangeParametersType_owns', pyxb.binding.datatypes.boolean, unicode_default=u'false')
    def owns (self):
        """Get the attribute value for owns."""
        return self.__owns.value(self)
    def setOwns (self, new_value):
        """Set the attribute value for owns.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__owns.set(self, new_value)
    
    # Attribute nilReason uses Python identifier nilReason
    __nilReason = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'nilReason'), 'nilReason', '__RangeParametersType_nilReason', NilReasonType)
    def nilReason (self):
        """Get the attribute value for nilReason."""
        return self.__nilReason.value(self)
    def setNilReason (self, new_value):
        """Set the attribute value for nilReason.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__nilReason.set(self, new_value)
    
    # Attribute {http://www.opengis.net/gml}remoteSchema uses Python identifier remoteSchema
    __remoteSchema = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(Namespace, u'remoteSchema'), 'remoteSchema', '__RangeParametersType_httpwww_opengis_netgmlremoteSchema', pyxb.binding.datatypes.anyURI)
    def remoteSchema (self):
        """Get the attribute value for {http://www.opengis.net/gml}remoteSchema."""
        return self.__remoteSchema.value(self)
    def setRemoteSchema (self, new_value):
        """Set the attribute value for {http://www.opengis.net/gml}remoteSchema.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__remoteSchema.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}actuate uses Python identifier actuate
    __actuate = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'actuate'), 'actuate', '__RangeParametersType_httpwww_w3_org1999xlinkactuate', MODULEhttpwww_w3_org1999xlink.UNBOUNDNone_129)
    def actuate (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}actuate."""
        return self.__actuate.value(self)
    def setActuate (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}actuate.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__actuate.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}type uses Python identifier type
    __type = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'type'), 'type', '__RangeParametersType_httpwww_w3_org1999xlinktype', pyxb.binding.datatypes.string, fixed=True, unicode_default=u'simple')
    def type (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}type."""
        return self.__type.value(self)
    def setType (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}type.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__type.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}arcrole uses Python identifier arcrole
    __arcrole = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'arcrole'), 'arcrole', '__RangeParametersType_httpwww_w3_org1999xlinkarcrole', pyxb.binding.datatypes.anyURI)
    def arcrole (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}arcrole."""
        return self.__arcrole.value(self)
    def setArcrole (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}arcrole.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__arcrole.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}title uses Python identifier title
    __title = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'title'), 'title', '__RangeParametersType_httpwww_w3_org1999xlinktitle', pyxb.binding.datatypes.string)
    def title (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}title."""
        return self.__title.value(self)
    def setTitle (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}title.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__title.set(self, new_value)

    _ElementMap = {
        __AbstractValue.name() : __AbstractValue
    }
    _AttributeMap = {
        __show.name() : __show,
        __role.name() : __role,
        __href.name() : __href,
        __owns.name() : __owns,
        __nilReason.name() : __nilReason,
        __remoteSchema.name() : __remoteSchema,
        __actuate.name() : __actuate,
        __type.name() : __type,
        __arcrole.name() : __arcrole,
        __title.name() : __title
    }
Namespace.addCategoryObject('typeBinding', u'RangeParametersType', RangeParametersType)


# Complex type RangeSetType with content type ELEMENT_ONLY
class RangeSetType (pyxb.binding.basis.complexTypeDefinition):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'RangeSetType')
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.opengis.net/gml}File uses Python identifier File
    __File = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'File'), 'File', '__RangeSetType_httpwww_opengis_netgmlFile', False)
    def File (self):
        """Get the value of the {http://www.opengis.net/gml}File element."""
        return self.__File.value(self)
    def setFile (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}File element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__File.set(self, new_value)
    
    # Element {http://www.opengis.net/gml}ValueArray uses Python identifier ValueArray
    __ValueArray = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'ValueArray'), 'ValueArray', '__RangeSetType_httpwww_opengis_netgmlValueArray', True)
    def ValueArray (self):
        """Get the value of the {http://www.opengis.net/gml}ValueArray element."""
        return self.__ValueArray.value(self)
    def setValueArray (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}ValueArray element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__ValueArray.set(self, new_value)
    
    def addValueArray (self, new_value):
        """Add the value as another occurrence of the {http://www.opengis.net/gml}ValueArray element.  Raises
        BadValueTypeException if the new value is not consistent with the
        element's type."""
        return self.__ValueArray.append(self, new_value)
    
    # Element {http://www.opengis.net/gml}DataBlock uses Python identifier DataBlock
    __DataBlock = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'DataBlock'), 'DataBlock', '__RangeSetType_httpwww_opengis_netgmlDataBlock', False)
    def DataBlock (self):
        """Get the value of the {http://www.opengis.net/gml}DataBlock element."""
        return self.__DataBlock.value(self)
    def setDataBlock (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}DataBlock element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__DataBlock.set(self, new_value)
    
    # Element {http://www.opengis.net/gml}AbstractScalarValueList uses Python identifier AbstractScalarValueList
    __AbstractScalarValueList = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'AbstractScalarValueList'), 'AbstractScalarValueList', '__RangeSetType_httpwww_opengis_netgmlAbstractScalarValueList', True)
    def AbstractScalarValueList (self):
        """Get the value of the {http://www.opengis.net/gml}AbstractScalarValueList element."""
        return self.__AbstractScalarValueList.value(self)
    def setAbstractScalarValueList (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}AbstractScalarValueList element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__AbstractScalarValueList.set(self, new_value)
    
    def addAbstractScalarValueList (self, new_value):
        """Add the value as another occurrence of the {http://www.opengis.net/gml}AbstractScalarValueList element.  Raises
        BadValueTypeException if the new value is not consistent with the
        element's type."""
        return self.__AbstractScalarValueList.append(self, new_value)

    _ElementMap = {
        __File.name() : __File,
        __ValueArray.name() : __ValueArray,
        __DataBlock.name() : __DataBlock,
        __AbstractScalarValueList.name() : __AbstractScalarValueList
    }
    _AttributeMap = {
        
    }
Namespace.addCategoryObject('typeBinding', u'RangeSetType', RangeSetType)


# Complex type ReferenceType with content type EMPTY
class ReferenceType (pyxb.binding.basis.complexTypeDefinition):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_EMPTY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'ReferenceType')
    # Base type is pyxb.binding.datatypes.anyType
    
    # Attribute {http://www.w3.org/1999/xlink}arcrole uses Python identifier arcrole
    __arcrole = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'arcrole'), 'arcrole', '__ReferenceType_httpwww_w3_org1999xlinkarcrole', pyxb.binding.datatypes.anyURI)
    def arcrole (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}arcrole."""
        return self.__arcrole.value(self)
    def setArcrole (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}arcrole.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__arcrole.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}show uses Python identifier show
    __show = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'show'), 'show', '__ReferenceType_httpwww_w3_org1999xlinkshow', MODULEhttpwww_w3_org1999xlink.UNBOUNDNone_130)
    def show (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}show."""
        return self.__show.value(self)
    def setShow (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}show.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__show.set(self, new_value)
    
    # Attribute {http://www.opengis.net/gml}remoteSchema uses Python identifier remoteSchema
    __remoteSchema = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(Namespace, u'remoteSchema'), 'remoteSchema', '__ReferenceType_httpwww_opengis_netgmlremoteSchema', pyxb.binding.datatypes.anyURI)
    def remoteSchema (self):
        """Get the attribute value for {http://www.opengis.net/gml}remoteSchema."""
        return self.__remoteSchema.value(self)
    def setRemoteSchema (self, new_value):
        """Set the attribute value for {http://www.opengis.net/gml}remoteSchema.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__remoteSchema.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}actuate uses Python identifier actuate
    __actuate = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'actuate'), 'actuate', '__ReferenceType_httpwww_w3_org1999xlinkactuate', MODULEhttpwww_w3_org1999xlink.UNBOUNDNone_131)
    def actuate (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}actuate."""
        return self.__actuate.value(self)
    def setActuate (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}actuate.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__actuate.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}type uses Python identifier type
    __type = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'type'), 'type', '__ReferenceType_httpwww_w3_org1999xlinktype', pyxb.binding.datatypes.string, fixed=True, unicode_default=u'simple')
    def type (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}type."""
        return self.__type.value(self)
    def setType (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}type.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__type.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}title uses Python identifier title
    __title = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'title'), 'title', '__ReferenceType_httpwww_w3_org1999xlinktitle', pyxb.binding.datatypes.string)
    def title (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}title."""
        return self.__title.value(self)
    def setTitle (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}title.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__title.set(self, new_value)
    
    # Attribute nilReason uses Python identifier nilReason
    __nilReason = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'nilReason'), 'nilReason', '__ReferenceType_nilReason', NilReasonType)
    def nilReason (self):
        """Get the attribute value for nilReason."""
        return self.__nilReason.value(self)
    def setNilReason (self, new_value):
        """Set the attribute value for nilReason.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__nilReason.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}role uses Python identifier role
    __role = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'role'), 'role', '__ReferenceType_httpwww_w3_org1999xlinkrole', pyxb.binding.datatypes.anyURI)
    def role (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}role."""
        return self.__role.value(self)
    def setRole (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}role.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__role.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}href uses Python identifier href
    __href = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'href'), 'href', '__ReferenceType_httpwww_w3_org1999xlinkhref', pyxb.binding.datatypes.anyURI)
    def href (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}href."""
        return self.__href.value(self)
    def setHref (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}href.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__href.set(self, new_value)
    
    # Attribute owns uses Python identifier owns
    __owns = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'owns'), 'owns', '__ReferenceType_owns', pyxb.binding.datatypes.boolean, unicode_default=u'false')
    def owns (self):
        """Get the attribute value for owns."""
        return self.__owns.value(self)
    def setOwns (self, new_value):
        """Set the attribute value for owns.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__owns.set(self, new_value)

    _ElementMap = {
        
    }
    _AttributeMap = {
        __arcrole.name() : __arcrole,
        __show.name() : __show,
        __remoteSchema.name() : __remoteSchema,
        __actuate.name() : __actuate,
        __type.name() : __type,
        __title.name() : __title,
        __nilReason.name() : __nilReason,
        __role.name() : __role,
        __href.name() : __href,
        __owns.name() : __owns
    }
Namespace.addCategoryObject('typeBinding', u'ReferenceType', ReferenceType)


# Complex type ResultType with content type ELEMENT_ONLY
class ResultType (pyxb.binding.basis.complexTypeDefinition):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'ResultType')
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.opengis.net/gml}AbstractObject uses Python identifier AbstractObject
    __AbstractObject = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'AbstractObject'), 'AbstractObject', '__ResultType_httpwww_opengis_netgmlAbstractObject', False)
    def AbstractObject (self):
        """Get the value of the {http://www.opengis.net/gml}AbstractObject element."""
        return self.__AbstractObject.value(self)
    def setAbstractObject (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}AbstractObject element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__AbstractObject.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}show uses Python identifier show
    __show = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'show'), 'show', '__ResultType_httpwww_w3_org1999xlinkshow', MODULEhttpwww_w3_org1999xlink.UNBOUNDNone_132)
    def show (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}show."""
        return self.__show.value(self)
    def setShow (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}show.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__show.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}href uses Python identifier href
    __href = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'href'), 'href', '__ResultType_httpwww_w3_org1999xlinkhref', pyxb.binding.datatypes.anyURI)
    def href (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}href."""
        return self.__href.value(self)
    def setHref (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}href.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__href.set(self, new_value)
    
    # Attribute owns uses Python identifier owns
    __owns = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'owns'), 'owns', '__ResultType_owns', pyxb.binding.datatypes.boolean, unicode_default=u'false')
    def owns (self):
        """Get the attribute value for owns."""
        return self.__owns.value(self)
    def setOwns (self, new_value):
        """Set the attribute value for owns.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__owns.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}arcrole uses Python identifier arcrole
    __arcrole = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'arcrole'), 'arcrole', '__ResultType_httpwww_w3_org1999xlinkarcrole', pyxb.binding.datatypes.anyURI)
    def arcrole (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}arcrole."""
        return self.__arcrole.value(self)
    def setArcrole (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}arcrole.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__arcrole.set(self, new_value)
    
    # Attribute {http://www.opengis.net/gml}remoteSchema uses Python identifier remoteSchema
    __remoteSchema = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(Namespace, u'remoteSchema'), 'remoteSchema', '__ResultType_httpwww_opengis_netgmlremoteSchema', pyxb.binding.datatypes.anyURI)
    def remoteSchema (self):
        """Get the attribute value for {http://www.opengis.net/gml}remoteSchema."""
        return self.__remoteSchema.value(self)
    def setRemoteSchema (self, new_value):
        """Set the attribute value for {http://www.opengis.net/gml}remoteSchema.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__remoteSchema.set(self, new_value)
    
    # Attribute nilReason uses Python identifier nilReason
    __nilReason = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'nilReason'), 'nilReason', '__ResultType_nilReason', NilReasonType)
    def nilReason (self):
        """Get the attribute value for nilReason."""
        return self.__nilReason.value(self)
    def setNilReason (self, new_value):
        """Set the attribute value for nilReason.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__nilReason.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}type uses Python identifier type
    __type = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'type'), 'type', '__ResultType_httpwww_w3_org1999xlinktype', pyxb.binding.datatypes.string, fixed=True, unicode_default=u'simple')
    def type (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}type."""
        return self.__type.value(self)
    def setType (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}type.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__type.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}actuate uses Python identifier actuate
    __actuate = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'actuate'), 'actuate', '__ResultType_httpwww_w3_org1999xlinkactuate', MODULEhttpwww_w3_org1999xlink.UNBOUNDNone_133)
    def actuate (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}actuate."""
        return self.__actuate.value(self)
    def setActuate (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}actuate.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__actuate.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}title uses Python identifier title
    __title = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'title'), 'title', '__ResultType_httpwww_w3_org1999xlinktitle', pyxb.binding.datatypes.string)
    def title (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}title."""
        return self.__title.value(self)
    def setTitle (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}title.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__title.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}role uses Python identifier role
    __role = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'role'), 'role', '__ResultType_httpwww_w3_org1999xlinkrole', pyxb.binding.datatypes.anyURI)
    def role (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}role."""
        return self.__role.value(self)
    def setRole (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}role.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__role.set(self, new_value)

    _ElementMap = {
        __AbstractObject.name() : __AbstractObject
    }
    _AttributeMap = {
        __show.name() : __show,
        __href.name() : __href,
        __owns.name() : __owns,
        __arcrole.name() : __arcrole,
        __remoteSchema.name() : __remoteSchema,
        __nilReason.name() : __nilReason,
        __type.name() : __type,
        __actuate.name() : __actuate,
        __title.name() : __title,
        __role.name() : __role
    }
Namespace.addCategoryObject('typeBinding', u'ResultType', ResultType)


# Complex type RingPropertyType with content type ELEMENT_ONLY
class RingPropertyType (pyxb.binding.basis.complexTypeDefinition):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'RingPropertyType')
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.opengis.net/gml}Ring uses Python identifier Ring
    __Ring = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'Ring'), 'Ring', '__RingPropertyType_httpwww_opengis_netgmlRing', False)
    def Ring (self):
        """Get the value of the {http://www.opengis.net/gml}Ring element."""
        return self.__Ring.value(self)
    def setRing (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}Ring element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__Ring.set(self, new_value)

    _ElementMap = {
        __Ring.name() : __Ring
    }
    _AttributeMap = {
        
    }
Namespace.addCategoryObject('typeBinding', u'RingPropertyType', RingPropertyType)


# Complex type SequenceRuleType with content type SIMPLE
class SequenceRuleType (pyxb.binding.basis.complexTypeDefinition):
    _TypeDefinition = SequenceRuleEnumeration
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_SIMPLE
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'SequenceRuleType')
    # Base type is SequenceRuleEnumeration
    
    # Attribute axisOrder uses Python identifier axisOrder
    __axisOrder = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'axisOrder'), 'axisOrder', '__SequenceRuleType_axisOrder', AxisDirectionList)
    def axisOrder (self):
        """Get the attribute value for axisOrder."""
        return self.__axisOrder.value(self)
    def setAxisOrder (self, new_value):
        """Set the attribute value for axisOrder.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__axisOrder.set(self, new_value)
    
    # Attribute order uses Python identifier order
    __order = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'order'), 'order', '__SequenceRuleType_order', IncrementOrder)
    def order (self):
        """Get the attribute value for order."""
        return self.__order.value(self)
    def setOrder (self, new_value):
        """Set the attribute value for order.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__order.set(self, new_value)

    _ElementMap = {
        
    }
    _AttributeMap = {
        __axisOrder.name() : __axisOrder,
        __order.name() : __order
    }
Namespace.addCategoryObject('typeBinding', u'SequenceRuleType', SequenceRuleType)


# Complex type ShellPropertyType with content type ELEMENT_ONLY
class ShellPropertyType (pyxb.binding.basis.complexTypeDefinition):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'ShellPropertyType')
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.opengis.net/gml}Shell uses Python identifier Shell
    __Shell = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'Shell'), 'Shell', '__ShellPropertyType_httpwww_opengis_netgmlShell', False)
    def Shell (self):
        """Get the value of the {http://www.opengis.net/gml}Shell element."""
        return self.__Shell.value(self)
    def setShell (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}Shell element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__Shell.set(self, new_value)

    _ElementMap = {
        __Shell.name() : __Shell
    }
    _AttributeMap = {
        
    }
Namespace.addCategoryObject('typeBinding', u'ShellPropertyType', ShellPropertyType)


# Complex type ShellType with content type ELEMENT_ONLY
class ShellType (pyxb.binding.basis.complexTypeDefinition):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'ShellType')
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.opengis.net/gml}surfaceMember uses Python identifier surfaceMember
    __surfaceMember = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'surfaceMember'), 'surfaceMember', '__ShellType_httpwww_opengis_netgmlsurfaceMember', True)
    def surfaceMember (self):
        """Get the value of the {http://www.opengis.net/gml}surfaceMember element."""
        return self.__surfaceMember.value(self)
    def setSurfaceMember (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}surfaceMember element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__surfaceMember.set(self, new_value)
    
    def addSurfaceMember (self, new_value):
        """Add the value as another occurrence of the {http://www.opengis.net/gml}surfaceMember element.  Raises
        BadValueTypeException if the new value is not consistent with the
        element's type."""
        return self.__surfaceMember.append(self, new_value)
    
    # Attribute aggregationType uses Python identifier aggregationType
    __aggregationType = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'aggregationType'), 'aggregationType', '__ShellType_aggregationType', AggregationType)
    def aggregationType (self):
        """Get the attribute value for aggregationType."""
        return self.__aggregationType.value(self)
    def setAggregationType (self, new_value):
        """Set the attribute value for aggregationType.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__aggregationType.set(self, new_value)

    _ElementMap = {
        __surfaceMember.name() : __surfaceMember
    }
    _AttributeMap = {
        __aggregationType.name() : __aggregationType
    }
Namespace.addCategoryObject('typeBinding', u'ShellType', ShellType)


# Complex type SingleCRSPropertyType with content type ELEMENT_ONLY
class SingleCRSPropertyType (pyxb.binding.basis.complexTypeDefinition):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'SingleCRSPropertyType')
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.opengis.net/gml}AbstractSingleCRS uses Python identifier AbstractSingleCRS
    __AbstractSingleCRS = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'AbstractSingleCRS'), 'AbstractSingleCRS', '__SingleCRSPropertyType_httpwww_opengis_netgmlAbstractSingleCRS', False)
    def AbstractSingleCRS (self):
        """Get the value of the {http://www.opengis.net/gml}AbstractSingleCRS element."""
        return self.__AbstractSingleCRS.value(self)
    def setAbstractSingleCRS (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}AbstractSingleCRS element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__AbstractSingleCRS.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}show uses Python identifier show
    __show = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'show'), 'show', '__SingleCRSPropertyType_httpwww_w3_org1999xlinkshow', MODULEhttpwww_w3_org1999xlink.UNBOUNDNone_134)
    def show (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}show."""
        return self.__show.value(self)
    def setShow (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}show.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__show.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}href uses Python identifier href
    __href = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'href'), 'href', '__SingleCRSPropertyType_httpwww_w3_org1999xlinkhref', pyxb.binding.datatypes.anyURI)
    def href (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}href."""
        return self.__href.value(self)
    def setHref (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}href.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__href.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}arcrole uses Python identifier arcrole
    __arcrole = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'arcrole'), 'arcrole', '__SingleCRSPropertyType_httpwww_w3_org1999xlinkarcrole', pyxb.binding.datatypes.anyURI)
    def arcrole (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}arcrole."""
        return self.__arcrole.value(self)
    def setArcrole (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}arcrole.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__arcrole.set(self, new_value)
    
    # Attribute {http://www.opengis.net/gml}remoteSchema uses Python identifier remoteSchema
    __remoteSchema = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(Namespace, u'remoteSchema'), 'remoteSchema', '__SingleCRSPropertyType_httpwww_opengis_netgmlremoteSchema', pyxb.binding.datatypes.anyURI)
    def remoteSchema (self):
        """Get the attribute value for {http://www.opengis.net/gml}remoteSchema."""
        return self.__remoteSchema.value(self)
    def setRemoteSchema (self, new_value):
        """Set the attribute value for {http://www.opengis.net/gml}remoteSchema.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__remoteSchema.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}actuate uses Python identifier actuate
    __actuate = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'actuate'), 'actuate', '__SingleCRSPropertyType_httpwww_w3_org1999xlinkactuate', MODULEhttpwww_w3_org1999xlink.UNBOUNDNone_135)
    def actuate (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}actuate."""
        return self.__actuate.value(self)
    def setActuate (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}actuate.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__actuate.set(self, new_value)
    
    # Attribute nilReason uses Python identifier nilReason
    __nilReason = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'nilReason'), 'nilReason', '__SingleCRSPropertyType_nilReason', NilReasonType)
    def nilReason (self):
        """Get the attribute value for nilReason."""
        return self.__nilReason.value(self)
    def setNilReason (self, new_value):
        """Set the attribute value for nilReason.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__nilReason.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}title uses Python identifier title
    __title = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'title'), 'title', '__SingleCRSPropertyType_httpwww_w3_org1999xlinktitle', pyxb.binding.datatypes.string)
    def title (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}title."""
        return self.__title.value(self)
    def setTitle (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}title.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__title.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}role uses Python identifier role
    __role = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'role'), 'role', '__SingleCRSPropertyType_httpwww_w3_org1999xlinkrole', pyxb.binding.datatypes.anyURI)
    def role (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}role."""
        return self.__role.value(self)
    def setRole (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}role.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__role.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}type uses Python identifier type
    __type = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'type'), 'type', '__SingleCRSPropertyType_httpwww_w3_org1999xlinktype', pyxb.binding.datatypes.string, fixed=True, unicode_default=u'simple')
    def type (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}type."""
        return self.__type.value(self)
    def setType (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}type.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__type.set(self, new_value)

    _ElementMap = {
        __AbstractSingleCRS.name() : __AbstractSingleCRS
    }
    _AttributeMap = {
        __show.name() : __show,
        __href.name() : __href,
        __arcrole.name() : __arcrole,
        __remoteSchema.name() : __remoteSchema,
        __actuate.name() : __actuate,
        __nilReason.name() : __nilReason,
        __title.name() : __title,
        __role.name() : __role,
        __type.name() : __type
    }
Namespace.addCategoryObject('typeBinding', u'SingleCRSPropertyType', SingleCRSPropertyType)


# Complex type SingleOperationPropertyType with content type ELEMENT_ONLY
class SingleOperationPropertyType (pyxb.binding.basis.complexTypeDefinition):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'SingleOperationPropertyType')
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.opengis.net/gml}AbstractSingleOperation uses Python identifier AbstractSingleOperation
    __AbstractSingleOperation = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'AbstractSingleOperation'), 'AbstractSingleOperation', '__SingleOperationPropertyType_httpwww_opengis_netgmlAbstractSingleOperation', False)
    def AbstractSingleOperation (self):
        """Get the value of the {http://www.opengis.net/gml}AbstractSingleOperation element."""
        return self.__AbstractSingleOperation.value(self)
    def setAbstractSingleOperation (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}AbstractSingleOperation element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__AbstractSingleOperation.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}show uses Python identifier show
    __show = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'show'), 'show', '__SingleOperationPropertyType_httpwww_w3_org1999xlinkshow', MODULEhttpwww_w3_org1999xlink.UNBOUNDNone_136)
    def show (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}show."""
        return self.__show.value(self)
    def setShow (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}show.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__show.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}role uses Python identifier role
    __role = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'role'), 'role', '__SingleOperationPropertyType_httpwww_w3_org1999xlinkrole', pyxb.binding.datatypes.anyURI)
    def role (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}role."""
        return self.__role.value(self)
    def setRole (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}role.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__role.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}href uses Python identifier href
    __href = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'href'), 'href', '__SingleOperationPropertyType_httpwww_w3_org1999xlinkhref', pyxb.binding.datatypes.anyURI)
    def href (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}href."""
        return self.__href.value(self)
    def setHref (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}href.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__href.set(self, new_value)
    
    # Attribute nilReason uses Python identifier nilReason
    __nilReason = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'nilReason'), 'nilReason', '__SingleOperationPropertyType_nilReason', NilReasonType)
    def nilReason (self):
        """Get the attribute value for nilReason."""
        return self.__nilReason.value(self)
    def setNilReason (self, new_value):
        """Set the attribute value for nilReason.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__nilReason.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}actuate uses Python identifier actuate
    __actuate = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'actuate'), 'actuate', '__SingleOperationPropertyType_httpwww_w3_org1999xlinkactuate', MODULEhttpwww_w3_org1999xlink.UNBOUNDNone_137)
    def actuate (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}actuate."""
        return self.__actuate.value(self)
    def setActuate (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}actuate.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__actuate.set(self, new_value)
    
    # Attribute {http://www.opengis.net/gml}remoteSchema uses Python identifier remoteSchema
    __remoteSchema = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(Namespace, u'remoteSchema'), 'remoteSchema', '__SingleOperationPropertyType_httpwww_opengis_netgmlremoteSchema', pyxb.binding.datatypes.anyURI)
    def remoteSchema (self):
        """Get the attribute value for {http://www.opengis.net/gml}remoteSchema."""
        return self.__remoteSchema.value(self)
    def setRemoteSchema (self, new_value):
        """Set the attribute value for {http://www.opengis.net/gml}remoteSchema.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__remoteSchema.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}arcrole uses Python identifier arcrole
    __arcrole = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'arcrole'), 'arcrole', '__SingleOperationPropertyType_httpwww_w3_org1999xlinkarcrole', pyxb.binding.datatypes.anyURI)
    def arcrole (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}arcrole."""
        return self.__arcrole.value(self)
    def setArcrole (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}arcrole.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__arcrole.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}type uses Python identifier type
    __type = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'type'), 'type', '__SingleOperationPropertyType_httpwww_w3_org1999xlinktype', pyxb.binding.datatypes.string, fixed=True, unicode_default=u'simple')
    def type (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}type."""
        return self.__type.value(self)
    def setType (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}type.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__type.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}title uses Python identifier title
    __title = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'title'), 'title', '__SingleOperationPropertyType_httpwww_w3_org1999xlinktitle', pyxb.binding.datatypes.string)
    def title (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}title."""
        return self.__title.value(self)
    def setTitle (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}title.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__title.set(self, new_value)

    _ElementMap = {
        __AbstractSingleOperation.name() : __AbstractSingleOperation
    }
    _AttributeMap = {
        __show.name() : __show,
        __role.name() : __role,
        __href.name() : __href,
        __nilReason.name() : __nilReason,
        __actuate.name() : __actuate,
        __remoteSchema.name() : __remoteSchema,
        __arcrole.name() : __arcrole,
        __type.name() : __type,
        __title.name() : __title
    }
Namespace.addCategoryObject('typeBinding', u'SingleOperationPropertyType', SingleOperationPropertyType)


# Complex type SolidArrayPropertyType with content type ELEMENT_ONLY
class SolidArrayPropertyType (pyxb.binding.basis.complexTypeDefinition):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'SolidArrayPropertyType')
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.opengis.net/gml}AbstractSolid uses Python identifier AbstractSolid
    __AbstractSolid = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'AbstractSolid'), 'AbstractSolid', '__SolidArrayPropertyType_httpwww_opengis_netgmlAbstractSolid', True)
    def AbstractSolid (self):
        """Get the value of the {http://www.opengis.net/gml}AbstractSolid element."""
        return self.__AbstractSolid.value(self)
    def setAbstractSolid (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}AbstractSolid element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__AbstractSolid.set(self, new_value)
    
    def addAbstractSolid (self, new_value):
        """Add the value as another occurrence of the {http://www.opengis.net/gml}AbstractSolid element.  Raises
        BadValueTypeException if the new value is not consistent with the
        element's type."""
        return self.__AbstractSolid.append(self, new_value)
    
    # Attribute owns uses Python identifier owns
    __owns = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'owns'), 'owns', '__SolidArrayPropertyType_owns', pyxb.binding.datatypes.boolean, unicode_default=u'false')
    def owns (self):
        """Get the attribute value for owns."""
        return self.__owns.value(self)
    def setOwns (self, new_value):
        """Set the attribute value for owns.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__owns.set(self, new_value)

    _ElementMap = {
        __AbstractSolid.name() : __AbstractSolid
    }
    _AttributeMap = {
        __owns.name() : __owns
    }
Namespace.addCategoryObject('typeBinding', u'SolidArrayPropertyType', SolidArrayPropertyType)


# Complex type SolidPropertyType with content type ELEMENT_ONLY
class SolidPropertyType (pyxb.binding.basis.complexTypeDefinition):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'SolidPropertyType')
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.opengis.net/gml}AbstractSolid uses Python identifier AbstractSolid
    __AbstractSolid = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'AbstractSolid'), 'AbstractSolid', '__SolidPropertyType_httpwww_opengis_netgmlAbstractSolid', False)
    def AbstractSolid (self):
        """Get the value of the {http://www.opengis.net/gml}AbstractSolid element."""
        return self.__AbstractSolid.value(self)
    def setAbstractSolid (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}AbstractSolid element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__AbstractSolid.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}show uses Python identifier show
    __show = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'show'), 'show', '__SolidPropertyType_httpwww_w3_org1999xlinkshow', MODULEhttpwww_w3_org1999xlink.UNBOUNDNone_138)
    def show (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}show."""
        return self.__show.value(self)
    def setShow (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}show.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__show.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}title uses Python identifier title
    __title = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'title'), 'title', '__SolidPropertyType_httpwww_w3_org1999xlinktitle', pyxb.binding.datatypes.string)
    def title (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}title."""
        return self.__title.value(self)
    def setTitle (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}title.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__title.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}role uses Python identifier role
    __role = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'role'), 'role', '__SolidPropertyType_httpwww_w3_org1999xlinkrole', pyxb.binding.datatypes.anyURI)
    def role (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}role."""
        return self.__role.value(self)
    def setRole (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}role.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__role.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}href uses Python identifier href
    __href = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'href'), 'href', '__SolidPropertyType_httpwww_w3_org1999xlinkhref', pyxb.binding.datatypes.anyURI)
    def href (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}href."""
        return self.__href.value(self)
    def setHref (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}href.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__href.set(self, new_value)
    
    # Attribute nilReason uses Python identifier nilReason
    __nilReason = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'nilReason'), 'nilReason', '__SolidPropertyType_nilReason', NilReasonType)
    def nilReason (self):
        """Get the attribute value for nilReason."""
        return self.__nilReason.value(self)
    def setNilReason (self, new_value):
        """Set the attribute value for nilReason.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__nilReason.set(self, new_value)
    
    # Attribute owns uses Python identifier owns
    __owns = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'owns'), 'owns', '__SolidPropertyType_owns', pyxb.binding.datatypes.boolean, unicode_default=u'false')
    def owns (self):
        """Get the attribute value for owns."""
        return self.__owns.value(self)
    def setOwns (self, new_value):
        """Set the attribute value for owns.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__owns.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}arcrole uses Python identifier arcrole
    __arcrole = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'arcrole'), 'arcrole', '__SolidPropertyType_httpwww_w3_org1999xlinkarcrole', pyxb.binding.datatypes.anyURI)
    def arcrole (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}arcrole."""
        return self.__arcrole.value(self)
    def setArcrole (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}arcrole.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__arcrole.set(self, new_value)
    
    # Attribute {http://www.opengis.net/gml}remoteSchema uses Python identifier remoteSchema
    __remoteSchema = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(Namespace, u'remoteSchema'), 'remoteSchema', '__SolidPropertyType_httpwww_opengis_netgmlremoteSchema', pyxb.binding.datatypes.anyURI)
    def remoteSchema (self):
        """Get the attribute value for {http://www.opengis.net/gml}remoteSchema."""
        return self.__remoteSchema.value(self)
    def setRemoteSchema (self, new_value):
        """Set the attribute value for {http://www.opengis.net/gml}remoteSchema.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__remoteSchema.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}actuate uses Python identifier actuate
    __actuate = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'actuate'), 'actuate', '__SolidPropertyType_httpwww_w3_org1999xlinkactuate', MODULEhttpwww_w3_org1999xlink.UNBOUNDNone_139)
    def actuate (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}actuate."""
        return self.__actuate.value(self)
    def setActuate (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}actuate.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__actuate.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}type uses Python identifier type
    __type = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'type'), 'type', '__SolidPropertyType_httpwww_w3_org1999xlinktype', pyxb.binding.datatypes.string, fixed=True, unicode_default=u'simple')
    def type (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}type."""
        return self.__type.value(self)
    def setType (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}type.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__type.set(self, new_value)

    _ElementMap = {
        __AbstractSolid.name() : __AbstractSolid
    }
    _AttributeMap = {
        __show.name() : __show,
        __title.name() : __title,
        __role.name() : __role,
        __href.name() : __href,
        __nilReason.name() : __nilReason,
        __owns.name() : __owns,
        __arcrole.name() : __arcrole,
        __remoteSchema.name() : __remoteSchema,
        __actuate.name() : __actuate,
        __type.name() : __type
    }
Namespace.addCategoryObject('typeBinding', u'SolidPropertyType', SolidPropertyType)


# Complex type SphericalCSPropertyType with content type ELEMENT_ONLY
class SphericalCSPropertyType (pyxb.binding.basis.complexTypeDefinition):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'SphericalCSPropertyType')
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.opengis.net/gml}SphericalCS uses Python identifier SphericalCS
    __SphericalCS = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'SphericalCS'), 'SphericalCS', '__SphericalCSPropertyType_httpwww_opengis_netgmlSphericalCS', False)
    def SphericalCS (self):
        """Get the value of the {http://www.opengis.net/gml}SphericalCS element."""
        return self.__SphericalCS.value(self)
    def setSphericalCS (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}SphericalCS element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__SphericalCS.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}show uses Python identifier show
    __show = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'show'), 'show', '__SphericalCSPropertyType_httpwww_w3_org1999xlinkshow', MODULEhttpwww_w3_org1999xlink.UNBOUNDNone_140)
    def show (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}show."""
        return self.__show.value(self)
    def setShow (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}show.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__show.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}role uses Python identifier role
    __role = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'role'), 'role', '__SphericalCSPropertyType_httpwww_w3_org1999xlinkrole', pyxb.binding.datatypes.anyURI)
    def role (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}role."""
        return self.__role.value(self)
    def setRole (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}role.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__role.set(self, new_value)
    
    # Attribute {http://www.opengis.net/gml}remoteSchema uses Python identifier remoteSchema
    __remoteSchema = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(Namespace, u'remoteSchema'), 'remoteSchema', '__SphericalCSPropertyType_httpwww_opengis_netgmlremoteSchema', pyxb.binding.datatypes.anyURI)
    def remoteSchema (self):
        """Get the attribute value for {http://www.opengis.net/gml}remoteSchema."""
        return self.__remoteSchema.value(self)
    def setRemoteSchema (self, new_value):
        """Set the attribute value for {http://www.opengis.net/gml}remoteSchema.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__remoteSchema.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}href uses Python identifier href
    __href = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'href'), 'href', '__SphericalCSPropertyType_httpwww_w3_org1999xlinkhref', pyxb.binding.datatypes.anyURI)
    def href (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}href."""
        return self.__href.value(self)
    def setHref (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}href.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__href.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}arcrole uses Python identifier arcrole
    __arcrole = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'arcrole'), 'arcrole', '__SphericalCSPropertyType_httpwww_w3_org1999xlinkarcrole', pyxb.binding.datatypes.anyURI)
    def arcrole (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}arcrole."""
        return self.__arcrole.value(self)
    def setArcrole (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}arcrole.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__arcrole.set(self, new_value)
    
    # Attribute nilReason uses Python identifier nilReason
    __nilReason = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'nilReason'), 'nilReason', '__SphericalCSPropertyType_nilReason', NilReasonType)
    def nilReason (self):
        """Get the attribute value for nilReason."""
        return self.__nilReason.value(self)
    def setNilReason (self, new_value):
        """Set the attribute value for nilReason.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__nilReason.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}actuate uses Python identifier actuate
    __actuate = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'actuate'), 'actuate', '__SphericalCSPropertyType_httpwww_w3_org1999xlinkactuate', MODULEhttpwww_w3_org1999xlink.UNBOUNDNone_141)
    def actuate (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}actuate."""
        return self.__actuate.value(self)
    def setActuate (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}actuate.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__actuate.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}type uses Python identifier type
    __type = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'type'), 'type', '__SphericalCSPropertyType_httpwww_w3_org1999xlinktype', pyxb.binding.datatypes.string, fixed=True, unicode_default=u'simple')
    def type (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}type."""
        return self.__type.value(self)
    def setType (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}type.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__type.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}title uses Python identifier title
    __title = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'title'), 'title', '__SphericalCSPropertyType_httpwww_w3_org1999xlinktitle', pyxb.binding.datatypes.string)
    def title (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}title."""
        return self.__title.value(self)
    def setTitle (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}title.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__title.set(self, new_value)

    _ElementMap = {
        __SphericalCS.name() : __SphericalCS
    }
    _AttributeMap = {
        __show.name() : __show,
        __role.name() : __role,
        __remoteSchema.name() : __remoteSchema,
        __href.name() : __href,
        __arcrole.name() : __arcrole,
        __nilReason.name() : __nilReason,
        __actuate.name() : __actuate,
        __type.name() : __type,
        __title.name() : __title
    }
Namespace.addCategoryObject('typeBinding', u'SphericalCSPropertyType', SphericalCSPropertyType)


# Complex type StringOrRefType with content type SIMPLE
class StringOrRefType (pyxb.binding.basis.complexTypeDefinition):
    _TypeDefinition = pyxb.binding.datatypes.string
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_SIMPLE
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'StringOrRefType')
    # Base type is pyxb.binding.datatypes.string
    
    # Attribute {http://www.w3.org/1999/xlink}show uses Python identifier show
    __show = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'show'), 'show', '__StringOrRefType_httpwww_w3_org1999xlinkshow', MODULEhttpwww_w3_org1999xlink.UNBOUNDNone_142)
    def show (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}show."""
        return self.__show.value(self)
    def setShow (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}show.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__show.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}title uses Python identifier title
    __title = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'title'), 'title', '__StringOrRefType_httpwww_w3_org1999xlinktitle', pyxb.binding.datatypes.string)
    def title (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}title."""
        return self.__title.value(self)
    def setTitle (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}title.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__title.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}href uses Python identifier href
    __href = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'href'), 'href', '__StringOrRefType_httpwww_w3_org1999xlinkhref', pyxb.binding.datatypes.anyURI)
    def href (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}href."""
        return self.__href.value(self)
    def setHref (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}href.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__href.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}role uses Python identifier role
    __role = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'role'), 'role', '__StringOrRefType_httpwww_w3_org1999xlinkrole', pyxb.binding.datatypes.anyURI)
    def role (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}role."""
        return self.__role.value(self)
    def setRole (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}role.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__role.set(self, new_value)
    
    # Attribute nilReason uses Python identifier nilReason
    __nilReason = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'nilReason'), 'nilReason', '__StringOrRefType_nilReason', NilReasonType)
    def nilReason (self):
        """Get the attribute value for nilReason."""
        return self.__nilReason.value(self)
    def setNilReason (self, new_value):
        """Set the attribute value for nilReason.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__nilReason.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}arcrole uses Python identifier arcrole
    __arcrole = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'arcrole'), 'arcrole', '__StringOrRefType_httpwww_w3_org1999xlinkarcrole', pyxb.binding.datatypes.anyURI)
    def arcrole (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}arcrole."""
        return self.__arcrole.value(self)
    def setArcrole (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}arcrole.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__arcrole.set(self, new_value)
    
    # Attribute {http://www.opengis.net/gml}remoteSchema uses Python identifier remoteSchema
    __remoteSchema = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(Namespace, u'remoteSchema'), 'remoteSchema', '__StringOrRefType_httpwww_opengis_netgmlremoteSchema', pyxb.binding.datatypes.anyURI)
    def remoteSchema (self):
        """Get the attribute value for {http://www.opengis.net/gml}remoteSchema."""
        return self.__remoteSchema.value(self)
    def setRemoteSchema (self, new_value):
        """Set the attribute value for {http://www.opengis.net/gml}remoteSchema.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__remoteSchema.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}actuate uses Python identifier actuate
    __actuate = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'actuate'), 'actuate', '__StringOrRefType_httpwww_w3_org1999xlinkactuate', MODULEhttpwww_w3_org1999xlink.UNBOUNDNone_143)
    def actuate (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}actuate."""
        return self.__actuate.value(self)
    def setActuate (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}actuate.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__actuate.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}type uses Python identifier type
    __type = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'type'), 'type', '__StringOrRefType_httpwww_w3_org1999xlinktype', pyxb.binding.datatypes.string, fixed=True, unicode_default=u'simple')
    def type (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}type."""
        return self.__type.value(self)
    def setType (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}type.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__type.set(self, new_value)

    _ElementMap = {
        
    }
    _AttributeMap = {
        __show.name() : __show,
        __title.name() : __title,
        __href.name() : __href,
        __role.name() : __role,
        __nilReason.name() : __nilReason,
        __arcrole.name() : __arcrole,
        __remoteSchema.name() : __remoteSchema,
        __actuate.name() : __actuate,
        __type.name() : __type
    }
Namespace.addCategoryObject('typeBinding', u'StringOrRefType', StringOrRefType)


# Complex type SurfaceArrayPropertyType with content type ELEMENT_ONLY
class SurfaceArrayPropertyType (pyxb.binding.basis.complexTypeDefinition):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'SurfaceArrayPropertyType')
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.opengis.net/gml}AbstractSurface uses Python identifier AbstractSurface
    __AbstractSurface = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'AbstractSurface'), 'AbstractSurface', '__SurfaceArrayPropertyType_httpwww_opengis_netgmlAbstractSurface', True)
    def AbstractSurface (self):
        """Get the value of the {http://www.opengis.net/gml}AbstractSurface element."""
        return self.__AbstractSurface.value(self)
    def setAbstractSurface (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}AbstractSurface element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__AbstractSurface.set(self, new_value)
    
    def addAbstractSurface (self, new_value):
        """Add the value as another occurrence of the {http://www.opengis.net/gml}AbstractSurface element.  Raises
        BadValueTypeException if the new value is not consistent with the
        element's type."""
        return self.__AbstractSurface.append(self, new_value)
    
    # Attribute owns uses Python identifier owns
    __owns = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'owns'), 'owns', '__SurfaceArrayPropertyType_owns', pyxb.binding.datatypes.boolean, unicode_default=u'false')
    def owns (self):
        """Get the attribute value for owns."""
        return self.__owns.value(self)
    def setOwns (self, new_value):
        """Set the attribute value for owns.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__owns.set(self, new_value)

    _ElementMap = {
        __AbstractSurface.name() : __AbstractSurface
    }
    _AttributeMap = {
        __owns.name() : __owns
    }
Namespace.addCategoryObject('typeBinding', u'SurfaceArrayPropertyType', SurfaceArrayPropertyType)


# Complex type SurfacePatchArrayPropertyType with content type ELEMENT_ONLY
class SurfacePatchArrayPropertyType (pyxb.binding.basis.complexTypeDefinition):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'SurfacePatchArrayPropertyType')
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.opengis.net/gml}AbstractSurfacePatch uses Python identifier AbstractSurfacePatch
    __AbstractSurfacePatch = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'AbstractSurfacePatch'), 'AbstractSurfacePatch', '__SurfacePatchArrayPropertyType_httpwww_opengis_netgmlAbstractSurfacePatch', True)
    def AbstractSurfacePatch (self):
        """Get the value of the {http://www.opengis.net/gml}AbstractSurfacePatch element."""
        return self.__AbstractSurfacePatch.value(self)
    def setAbstractSurfacePatch (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}AbstractSurfacePatch element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__AbstractSurfacePatch.set(self, new_value)
    
    def addAbstractSurfacePatch (self, new_value):
        """Add the value as another occurrence of the {http://www.opengis.net/gml}AbstractSurfacePatch element.  Raises
        BadValueTypeException if the new value is not consistent with the
        element's type."""
        return self.__AbstractSurfacePatch.append(self, new_value)

    _ElementMap = {
        __AbstractSurfacePatch.name() : __AbstractSurfacePatch
    }
    _AttributeMap = {
        
    }
Namespace.addCategoryObject('typeBinding', u'SurfacePatchArrayPropertyType', SurfacePatchArrayPropertyType)


# Complex type SurfacePropertyType with content type ELEMENT_ONLY
class SurfacePropertyType (pyxb.binding.basis.complexTypeDefinition):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'SurfacePropertyType')
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.opengis.net/gml}AbstractSurface uses Python identifier AbstractSurface
    __AbstractSurface = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'AbstractSurface'), 'AbstractSurface', '__SurfacePropertyType_httpwww_opengis_netgmlAbstractSurface', False)
    def AbstractSurface (self):
        """Get the value of the {http://www.opengis.net/gml}AbstractSurface element."""
        return self.__AbstractSurface.value(self)
    def setAbstractSurface (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}AbstractSurface element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__AbstractSurface.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}show uses Python identifier show
    __show = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'show'), 'show', '__SurfacePropertyType_httpwww_w3_org1999xlinkshow', MODULEhttpwww_w3_org1999xlink.UNBOUNDNone_144)
    def show (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}show."""
        return self.__show.value(self)
    def setShow (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}show.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__show.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}href uses Python identifier href
    __href = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'href'), 'href', '__SurfacePropertyType_httpwww_w3_org1999xlinkhref', pyxb.binding.datatypes.anyURI)
    def href (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}href."""
        return self.__href.value(self)
    def setHref (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}href.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__href.set(self, new_value)
    
    # Attribute owns uses Python identifier owns
    __owns = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'owns'), 'owns', '__SurfacePropertyType_owns', pyxb.binding.datatypes.boolean, unicode_default=u'false')
    def owns (self):
        """Get the attribute value for owns."""
        return self.__owns.value(self)
    def setOwns (self, new_value):
        """Set the attribute value for owns.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__owns.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}arcrole uses Python identifier arcrole
    __arcrole = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'arcrole'), 'arcrole', '__SurfacePropertyType_httpwww_w3_org1999xlinkarcrole', pyxb.binding.datatypes.anyURI)
    def arcrole (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}arcrole."""
        return self.__arcrole.value(self)
    def setArcrole (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}arcrole.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__arcrole.set(self, new_value)
    
    # Attribute {http://www.opengis.net/gml}remoteSchema uses Python identifier remoteSchema
    __remoteSchema = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(Namespace, u'remoteSchema'), 'remoteSchema', '__SurfacePropertyType_httpwww_opengis_netgmlremoteSchema', pyxb.binding.datatypes.anyURI)
    def remoteSchema (self):
        """Get the attribute value for {http://www.opengis.net/gml}remoteSchema."""
        return self.__remoteSchema.value(self)
    def setRemoteSchema (self, new_value):
        """Set the attribute value for {http://www.opengis.net/gml}remoteSchema.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__remoteSchema.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}actuate uses Python identifier actuate
    __actuate = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'actuate'), 'actuate', '__SurfacePropertyType_httpwww_w3_org1999xlinkactuate', MODULEhttpwww_w3_org1999xlink.UNBOUNDNone_145)
    def actuate (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}actuate."""
        return self.__actuate.value(self)
    def setActuate (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}actuate.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__actuate.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}type uses Python identifier type
    __type = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'type'), 'type', '__SurfacePropertyType_httpwww_w3_org1999xlinktype', pyxb.binding.datatypes.string, fixed=True, unicode_default=u'simple')
    def type (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}type."""
        return self.__type.value(self)
    def setType (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}type.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__type.set(self, new_value)
    
    # Attribute nilReason uses Python identifier nilReason
    __nilReason = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'nilReason'), 'nilReason', '__SurfacePropertyType_nilReason', NilReasonType)
    def nilReason (self):
        """Get the attribute value for nilReason."""
        return self.__nilReason.value(self)
    def setNilReason (self, new_value):
        """Set the attribute value for nilReason.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__nilReason.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}title uses Python identifier title
    __title = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'title'), 'title', '__SurfacePropertyType_httpwww_w3_org1999xlinktitle', pyxb.binding.datatypes.string)
    def title (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}title."""
        return self.__title.value(self)
    def setTitle (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}title.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__title.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}role uses Python identifier role
    __role = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'role'), 'role', '__SurfacePropertyType_httpwww_w3_org1999xlinkrole', pyxb.binding.datatypes.anyURI)
    def role (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}role."""
        return self.__role.value(self)
    def setRole (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}role.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__role.set(self, new_value)

    _ElementMap = {
        __AbstractSurface.name() : __AbstractSurface
    }
    _AttributeMap = {
        __show.name() : __show,
        __href.name() : __href,
        __owns.name() : __owns,
        __arcrole.name() : __arcrole,
        __remoteSchema.name() : __remoteSchema,
        __actuate.name() : __actuate,
        __type.name() : __type,
        __nilReason.name() : __nilReason,
        __title.name() : __title,
        __role.name() : __role
    }
Namespace.addCategoryObject('typeBinding', u'SurfacePropertyType', SurfacePropertyType)


# Complex type TargetPropertyType with content type ELEMENT_ONLY
class TargetPropertyType (pyxb.binding.basis.complexTypeDefinition):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'TargetPropertyType')
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.opengis.net/gml}AbstractGeometry uses Python identifier AbstractGeometry
    __AbstractGeometry = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'AbstractGeometry'), 'AbstractGeometry', '__TargetPropertyType_httpwww_opengis_netgmlAbstractGeometry', False)
    def AbstractGeometry (self):
        """Get the value of the {http://www.opengis.net/gml}AbstractGeometry element."""
        return self.__AbstractGeometry.value(self)
    def setAbstractGeometry (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}AbstractGeometry element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__AbstractGeometry.set(self, new_value)
    
    # Element {http://www.opengis.net/gml}AbstractFeature uses Python identifier AbstractFeature
    __AbstractFeature = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'AbstractFeature'), 'AbstractFeature', '__TargetPropertyType_httpwww_opengis_netgmlAbstractFeature', False)
    def AbstractFeature (self):
        """Get the value of the {http://www.opengis.net/gml}AbstractFeature element."""
        return self.__AbstractFeature.value(self)
    def setAbstractFeature (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}AbstractFeature element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__AbstractFeature.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}show uses Python identifier show
    __show = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'show'), 'show', '__TargetPropertyType_httpwww_w3_org1999xlinkshow', MODULEhttpwww_w3_org1999xlink.UNBOUNDNone_146)
    def show (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}show."""
        return self.__show.value(self)
    def setShow (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}show.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__show.set(self, new_value)
    
    # Attribute {http://www.opengis.net/gml}remoteSchema uses Python identifier remoteSchema
    __remoteSchema = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(Namespace, u'remoteSchema'), 'remoteSchema', '__TargetPropertyType_httpwww_opengis_netgmlremoteSchema', pyxb.binding.datatypes.anyURI)
    def remoteSchema (self):
        """Get the attribute value for {http://www.opengis.net/gml}remoteSchema."""
        return self.__remoteSchema.value(self)
    def setRemoteSchema (self, new_value):
        """Set the attribute value for {http://www.opengis.net/gml}remoteSchema.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__remoteSchema.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}actuate uses Python identifier actuate
    __actuate = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'actuate'), 'actuate', '__TargetPropertyType_httpwww_w3_org1999xlinkactuate', MODULEhttpwww_w3_org1999xlink.UNBOUNDNone_147)
    def actuate (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}actuate."""
        return self.__actuate.value(self)
    def setActuate (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}actuate.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__actuate.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}type uses Python identifier type
    __type = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'type'), 'type', '__TargetPropertyType_httpwww_w3_org1999xlinktype', pyxb.binding.datatypes.string, fixed=True, unicode_default=u'simple')
    def type (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}type."""
        return self.__type.value(self)
    def setType (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}type.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__type.set(self, new_value)
    
    # Attribute nilReason uses Python identifier nilReason
    __nilReason = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'nilReason'), 'nilReason', '__TargetPropertyType_nilReason', NilReasonType)
    def nilReason (self):
        """Get the attribute value for nilReason."""
        return self.__nilReason.value(self)
    def setNilReason (self, new_value):
        """Set the attribute value for nilReason.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__nilReason.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}title uses Python identifier title
    __title = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'title'), 'title', '__TargetPropertyType_httpwww_w3_org1999xlinktitle', pyxb.binding.datatypes.string)
    def title (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}title."""
        return self.__title.value(self)
    def setTitle (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}title.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__title.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}arcrole uses Python identifier arcrole
    __arcrole = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'arcrole'), 'arcrole', '__TargetPropertyType_httpwww_w3_org1999xlinkarcrole', pyxb.binding.datatypes.anyURI)
    def arcrole (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}arcrole."""
        return self.__arcrole.value(self)
    def setArcrole (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}arcrole.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__arcrole.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}href uses Python identifier href
    __href = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'href'), 'href', '__TargetPropertyType_httpwww_w3_org1999xlinkhref', pyxb.binding.datatypes.anyURI)
    def href (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}href."""
        return self.__href.value(self)
    def setHref (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}href.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__href.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}role uses Python identifier role
    __role = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'role'), 'role', '__TargetPropertyType_httpwww_w3_org1999xlinkrole', pyxb.binding.datatypes.anyURI)
    def role (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}role."""
        return self.__role.value(self)
    def setRole (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}role.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__role.set(self, new_value)
    
    # Attribute owns uses Python identifier owns
    __owns = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'owns'), 'owns', '__TargetPropertyType_owns', pyxb.binding.datatypes.boolean, unicode_default=u'false')
    def owns (self):
        """Get the attribute value for owns."""
        return self.__owns.value(self)
    def setOwns (self, new_value):
        """Set the attribute value for owns.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__owns.set(self, new_value)

    _ElementMap = {
        __AbstractGeometry.name() : __AbstractGeometry,
        __AbstractFeature.name() : __AbstractFeature
    }
    _AttributeMap = {
        __show.name() : __show,
        __remoteSchema.name() : __remoteSchema,
        __actuate.name() : __actuate,
        __type.name() : __type,
        __nilReason.name() : __nilReason,
        __title.name() : __title,
        __arcrole.name() : __arcrole,
        __href.name() : __href,
        __role.name() : __role,
        __owns.name() : __owns
    }
Namespace.addCategoryObject('typeBinding', u'TargetPropertyType', TargetPropertyType)


# Complex type TemporalCRSPropertyType with content type ELEMENT_ONLY
class TemporalCRSPropertyType (pyxb.binding.basis.complexTypeDefinition):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'TemporalCRSPropertyType')
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.opengis.net/gml}TemporalCRS uses Python identifier TemporalCRS
    __TemporalCRS = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'TemporalCRS'), 'TemporalCRS', '__TemporalCRSPropertyType_httpwww_opengis_netgmlTemporalCRS', False)
    def TemporalCRS (self):
        """Get the value of the {http://www.opengis.net/gml}TemporalCRS element."""
        return self.__TemporalCRS.value(self)
    def setTemporalCRS (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}TemporalCRS element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__TemporalCRS.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}show uses Python identifier show
    __show = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'show'), 'show', '__TemporalCRSPropertyType_httpwww_w3_org1999xlinkshow', MODULEhttpwww_w3_org1999xlink.UNBOUNDNone_148)
    def show (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}show."""
        return self.__show.value(self)
    def setShow (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}show.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__show.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}role uses Python identifier role
    __role = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'role'), 'role', '__TemporalCRSPropertyType_httpwww_w3_org1999xlinkrole', pyxb.binding.datatypes.anyURI)
    def role (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}role."""
        return self.__role.value(self)
    def setRole (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}role.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__role.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}href uses Python identifier href
    __href = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'href'), 'href', '__TemporalCRSPropertyType_httpwww_w3_org1999xlinkhref', pyxb.binding.datatypes.anyURI)
    def href (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}href."""
        return self.__href.value(self)
    def setHref (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}href.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__href.set(self, new_value)
    
    # Attribute nilReason uses Python identifier nilReason
    __nilReason = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'nilReason'), 'nilReason', '__TemporalCRSPropertyType_nilReason', NilReasonType)
    def nilReason (self):
        """Get the attribute value for nilReason."""
        return self.__nilReason.value(self)
    def setNilReason (self, new_value):
        """Set the attribute value for nilReason.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__nilReason.set(self, new_value)
    
    # Attribute {http://www.opengis.net/gml}remoteSchema uses Python identifier remoteSchema
    __remoteSchema = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(Namespace, u'remoteSchema'), 'remoteSchema', '__TemporalCRSPropertyType_httpwww_opengis_netgmlremoteSchema', pyxb.binding.datatypes.anyURI)
    def remoteSchema (self):
        """Get the attribute value for {http://www.opengis.net/gml}remoteSchema."""
        return self.__remoteSchema.value(self)
    def setRemoteSchema (self, new_value):
        """Set the attribute value for {http://www.opengis.net/gml}remoteSchema.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__remoteSchema.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}actuate uses Python identifier actuate
    __actuate = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'actuate'), 'actuate', '__TemporalCRSPropertyType_httpwww_w3_org1999xlinkactuate', MODULEhttpwww_w3_org1999xlink.UNBOUNDNone_149)
    def actuate (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}actuate."""
        return self.__actuate.value(self)
    def setActuate (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}actuate.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__actuate.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}type uses Python identifier type
    __type = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'type'), 'type', '__TemporalCRSPropertyType_httpwww_w3_org1999xlinktype', pyxb.binding.datatypes.string, fixed=True, unicode_default=u'simple')
    def type (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}type."""
        return self.__type.value(self)
    def setType (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}type.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__type.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}arcrole uses Python identifier arcrole
    __arcrole = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'arcrole'), 'arcrole', '__TemporalCRSPropertyType_httpwww_w3_org1999xlinkarcrole', pyxb.binding.datatypes.anyURI)
    def arcrole (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}arcrole."""
        return self.__arcrole.value(self)
    def setArcrole (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}arcrole.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__arcrole.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}title uses Python identifier title
    __title = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'title'), 'title', '__TemporalCRSPropertyType_httpwww_w3_org1999xlinktitle', pyxb.binding.datatypes.string)
    def title (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}title."""
        return self.__title.value(self)
    def setTitle (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}title.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__title.set(self, new_value)

    _ElementMap = {
        __TemporalCRS.name() : __TemporalCRS
    }
    _AttributeMap = {
        __show.name() : __show,
        __role.name() : __role,
        __href.name() : __href,
        __nilReason.name() : __nilReason,
        __remoteSchema.name() : __remoteSchema,
        __actuate.name() : __actuate,
        __type.name() : __type,
        __arcrole.name() : __arcrole,
        __title.name() : __title
    }
Namespace.addCategoryObject('typeBinding', u'TemporalCRSPropertyType', TemporalCRSPropertyType)


# Complex type TemporalCSPropertyType with content type ELEMENT_ONLY
class TemporalCSPropertyType (pyxb.binding.basis.complexTypeDefinition):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'TemporalCSPropertyType')
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.opengis.net/gml}TemporalCS uses Python identifier TemporalCS
    __TemporalCS = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'TemporalCS'), 'TemporalCS', '__TemporalCSPropertyType_httpwww_opengis_netgmlTemporalCS', False)
    def TemporalCS (self):
        """Get the value of the {http://www.opengis.net/gml}TemporalCS element."""
        return self.__TemporalCS.value(self)
    def setTemporalCS (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}TemporalCS element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__TemporalCS.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}show uses Python identifier show
    __show = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'show'), 'show', '__TemporalCSPropertyType_httpwww_w3_org1999xlinkshow', MODULEhttpwww_w3_org1999xlink.UNBOUNDNone_150)
    def show (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}show."""
        return self.__show.value(self)
    def setShow (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}show.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__show.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}href uses Python identifier href
    __href = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'href'), 'href', '__TemporalCSPropertyType_httpwww_w3_org1999xlinkhref', pyxb.binding.datatypes.anyURI)
    def href (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}href."""
        return self.__href.value(self)
    def setHref (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}href.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__href.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}arcrole uses Python identifier arcrole
    __arcrole = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'arcrole'), 'arcrole', '__TemporalCSPropertyType_httpwww_w3_org1999xlinkarcrole', pyxb.binding.datatypes.anyURI)
    def arcrole (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}arcrole."""
        return self.__arcrole.value(self)
    def setArcrole (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}arcrole.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__arcrole.set(self, new_value)
    
    # Attribute {http://www.opengis.net/gml}remoteSchema uses Python identifier remoteSchema
    __remoteSchema = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(Namespace, u'remoteSchema'), 'remoteSchema', '__TemporalCSPropertyType_httpwww_opengis_netgmlremoteSchema', pyxb.binding.datatypes.anyURI)
    def remoteSchema (self):
        """Get the attribute value for {http://www.opengis.net/gml}remoteSchema."""
        return self.__remoteSchema.value(self)
    def setRemoteSchema (self, new_value):
        """Set the attribute value for {http://www.opengis.net/gml}remoteSchema.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__remoteSchema.set(self, new_value)
    
    # Attribute nilReason uses Python identifier nilReason
    __nilReason = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'nilReason'), 'nilReason', '__TemporalCSPropertyType_nilReason', NilReasonType)
    def nilReason (self):
        """Get the attribute value for nilReason."""
        return self.__nilReason.value(self)
    def setNilReason (self, new_value):
        """Set the attribute value for nilReason.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__nilReason.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}type uses Python identifier type
    __type = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'type'), 'type', '__TemporalCSPropertyType_httpwww_w3_org1999xlinktype', pyxb.binding.datatypes.string, fixed=True, unicode_default=u'simple')
    def type (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}type."""
        return self.__type.value(self)
    def setType (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}type.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__type.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}actuate uses Python identifier actuate
    __actuate = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'actuate'), 'actuate', '__TemporalCSPropertyType_httpwww_w3_org1999xlinkactuate', MODULEhttpwww_w3_org1999xlink.UNBOUNDNone_151)
    def actuate (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}actuate."""
        return self.__actuate.value(self)
    def setActuate (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}actuate.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__actuate.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}title uses Python identifier title
    __title = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'title'), 'title', '__TemporalCSPropertyType_httpwww_w3_org1999xlinktitle', pyxb.binding.datatypes.string)
    def title (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}title."""
        return self.__title.value(self)
    def setTitle (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}title.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__title.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}role uses Python identifier role
    __role = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'role'), 'role', '__TemporalCSPropertyType_httpwww_w3_org1999xlinkrole', pyxb.binding.datatypes.anyURI)
    def role (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}role."""
        return self.__role.value(self)
    def setRole (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}role.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__role.set(self, new_value)

    _ElementMap = {
        __TemporalCS.name() : __TemporalCS
    }
    _AttributeMap = {
        __show.name() : __show,
        __href.name() : __href,
        __arcrole.name() : __arcrole,
        __remoteSchema.name() : __remoteSchema,
        __nilReason.name() : __nilReason,
        __type.name() : __type,
        __actuate.name() : __actuate,
        __title.name() : __title,
        __role.name() : __role
    }
Namespace.addCategoryObject('typeBinding', u'TemporalCSPropertyType', TemporalCSPropertyType)


# Complex type TemporalDatumPropertyType with content type ELEMENT_ONLY
class TemporalDatumPropertyType (pyxb.binding.basis.complexTypeDefinition):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'TemporalDatumPropertyType')
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.opengis.net/gml}TemporalDatum uses Python identifier TemporalDatum
    __TemporalDatum = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'TemporalDatum'), 'TemporalDatum', '__TemporalDatumPropertyType_httpwww_opengis_netgmlTemporalDatum', False)
    def TemporalDatum (self):
        """Get the value of the {http://www.opengis.net/gml}TemporalDatum element."""
        return self.__TemporalDatum.value(self)
    def setTemporalDatum (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}TemporalDatum element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__TemporalDatum.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}show uses Python identifier show
    __show = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'show'), 'show', '__TemporalDatumPropertyType_httpwww_w3_org1999xlinkshow', MODULEhttpwww_w3_org1999xlink.UNBOUNDNone_152)
    def show (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}show."""
        return self.__show.value(self)
    def setShow (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}show.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__show.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}role uses Python identifier role
    __role = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'role'), 'role', '__TemporalDatumPropertyType_httpwww_w3_org1999xlinkrole', pyxb.binding.datatypes.anyURI)
    def role (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}role."""
        return self.__role.value(self)
    def setRole (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}role.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__role.set(self, new_value)
    
    # Attribute {http://www.opengis.net/gml}remoteSchema uses Python identifier remoteSchema
    __remoteSchema = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(Namespace, u'remoteSchema'), 'remoteSchema', '__TemporalDatumPropertyType_httpwww_opengis_netgmlremoteSchema', pyxb.binding.datatypes.anyURI)
    def remoteSchema (self):
        """Get the attribute value for {http://www.opengis.net/gml}remoteSchema."""
        return self.__remoteSchema.value(self)
    def setRemoteSchema (self, new_value):
        """Set the attribute value for {http://www.opengis.net/gml}remoteSchema.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__remoteSchema.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}href uses Python identifier href
    __href = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'href'), 'href', '__TemporalDatumPropertyType_httpwww_w3_org1999xlinkhref', pyxb.binding.datatypes.anyURI)
    def href (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}href."""
        return self.__href.value(self)
    def setHref (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}href.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__href.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}arcrole uses Python identifier arcrole
    __arcrole = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'arcrole'), 'arcrole', '__TemporalDatumPropertyType_httpwww_w3_org1999xlinkarcrole', pyxb.binding.datatypes.anyURI)
    def arcrole (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}arcrole."""
        return self.__arcrole.value(self)
    def setArcrole (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}arcrole.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__arcrole.set(self, new_value)
    
    # Attribute nilReason uses Python identifier nilReason
    __nilReason = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'nilReason'), 'nilReason', '__TemporalDatumPropertyType_nilReason', NilReasonType)
    def nilReason (self):
        """Get the attribute value for nilReason."""
        return self.__nilReason.value(self)
    def setNilReason (self, new_value):
        """Set the attribute value for nilReason.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__nilReason.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}actuate uses Python identifier actuate
    __actuate = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'actuate'), 'actuate', '__TemporalDatumPropertyType_httpwww_w3_org1999xlinkactuate', MODULEhttpwww_w3_org1999xlink.UNBOUNDNone_153)
    def actuate (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}actuate."""
        return self.__actuate.value(self)
    def setActuate (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}actuate.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__actuate.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}type uses Python identifier type
    __type = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'type'), 'type', '__TemporalDatumPropertyType_httpwww_w3_org1999xlinktype', pyxb.binding.datatypes.string, fixed=True, unicode_default=u'simple')
    def type (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}type."""
        return self.__type.value(self)
    def setType (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}type.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__type.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}title uses Python identifier title
    __title = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'title'), 'title', '__TemporalDatumPropertyType_httpwww_w3_org1999xlinktitle', pyxb.binding.datatypes.string)
    def title (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}title."""
        return self.__title.value(self)
    def setTitle (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}title.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__title.set(self, new_value)

    _ElementMap = {
        __TemporalDatum.name() : __TemporalDatum
    }
    _AttributeMap = {
        __show.name() : __show,
        __role.name() : __role,
        __remoteSchema.name() : __remoteSchema,
        __href.name() : __href,
        __arcrole.name() : __arcrole,
        __nilReason.name() : __nilReason,
        __actuate.name() : __actuate,
        __type.name() : __type,
        __title.name() : __title
    }
Namespace.addCategoryObject('typeBinding', u'TemporalDatumPropertyType', TemporalDatumPropertyType)


# Complex type TimeCSPropertyType with content type ELEMENT_ONLY
class TimeCSPropertyType (pyxb.binding.basis.complexTypeDefinition):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'TimeCSPropertyType')
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.opengis.net/gml}TimeCS uses Python identifier TimeCS
    __TimeCS = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'TimeCS'), 'TimeCS', '__TimeCSPropertyType_httpwww_opengis_netgmlTimeCS', False)
    def TimeCS (self):
        """Get the value of the {http://www.opengis.net/gml}TimeCS element."""
        return self.__TimeCS.value(self)
    def setTimeCS (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}TimeCS element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__TimeCS.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}show uses Python identifier show
    __show = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'show'), 'show', '__TimeCSPropertyType_httpwww_w3_org1999xlinkshow', MODULEhttpwww_w3_org1999xlink.UNBOUNDNone_154)
    def show (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}show."""
        return self.__show.value(self)
    def setShow (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}show.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__show.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}actuate uses Python identifier actuate
    __actuate = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'actuate'), 'actuate', '__TimeCSPropertyType_httpwww_w3_org1999xlinkactuate', MODULEhttpwww_w3_org1999xlink.UNBOUNDNone_155)
    def actuate (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}actuate."""
        return self.__actuate.value(self)
    def setActuate (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}actuate.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__actuate.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}href uses Python identifier href
    __href = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'href'), 'href', '__TimeCSPropertyType_httpwww_w3_org1999xlinkhref', pyxb.binding.datatypes.anyURI)
    def href (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}href."""
        return self.__href.value(self)
    def setHref (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}href.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__href.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}arcrole uses Python identifier arcrole
    __arcrole = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'arcrole'), 'arcrole', '__TimeCSPropertyType_httpwww_w3_org1999xlinkarcrole', pyxb.binding.datatypes.anyURI)
    def arcrole (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}arcrole."""
        return self.__arcrole.value(self)
    def setArcrole (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}arcrole.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__arcrole.set(self, new_value)
    
    # Attribute {http://www.opengis.net/gml}remoteSchema uses Python identifier remoteSchema
    __remoteSchema = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(Namespace, u'remoteSchema'), 'remoteSchema', '__TimeCSPropertyType_httpwww_opengis_netgmlremoteSchema', pyxb.binding.datatypes.anyURI)
    def remoteSchema (self):
        """Get the attribute value for {http://www.opengis.net/gml}remoteSchema."""
        return self.__remoteSchema.value(self)
    def setRemoteSchema (self, new_value):
        """Set the attribute value for {http://www.opengis.net/gml}remoteSchema.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__remoteSchema.set(self, new_value)
    
    # Attribute nilReason uses Python identifier nilReason
    __nilReason = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'nilReason'), 'nilReason', '__TimeCSPropertyType_nilReason', NilReasonType)
    def nilReason (self):
        """Get the attribute value for nilReason."""
        return self.__nilReason.value(self)
    def setNilReason (self, new_value):
        """Set the attribute value for nilReason.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__nilReason.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}type uses Python identifier type
    __type = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'type'), 'type', '__TimeCSPropertyType_httpwww_w3_org1999xlinktype', pyxb.binding.datatypes.string, fixed=True, unicode_default=u'simple')
    def type (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}type."""
        return self.__type.value(self)
    def setType (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}type.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__type.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}title uses Python identifier title
    __title = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'title'), 'title', '__TimeCSPropertyType_httpwww_w3_org1999xlinktitle', pyxb.binding.datatypes.string)
    def title (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}title."""
        return self.__title.value(self)
    def setTitle (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}title.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__title.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}role uses Python identifier role
    __role = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'role'), 'role', '__TimeCSPropertyType_httpwww_w3_org1999xlinkrole', pyxb.binding.datatypes.anyURI)
    def role (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}role."""
        return self.__role.value(self)
    def setRole (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}role.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__role.set(self, new_value)

    _ElementMap = {
        __TimeCS.name() : __TimeCS
    }
    _AttributeMap = {
        __show.name() : __show,
        __actuate.name() : __actuate,
        __href.name() : __href,
        __arcrole.name() : __arcrole,
        __remoteSchema.name() : __remoteSchema,
        __nilReason.name() : __nilReason,
        __type.name() : __type,
        __title.name() : __title,
        __role.name() : __role
    }
Namespace.addCategoryObject('typeBinding', u'TimeCSPropertyType', TimeCSPropertyType)


# Complex type TimeCalendarEraPropertyType with content type ELEMENT_ONLY
class TimeCalendarEraPropertyType (pyxb.binding.basis.complexTypeDefinition):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'TimeCalendarEraPropertyType')
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.opengis.net/gml}TimeCalendarEra uses Python identifier TimeCalendarEra
    __TimeCalendarEra = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'TimeCalendarEra'), 'TimeCalendarEra', '__TimeCalendarEraPropertyType_httpwww_opengis_netgmlTimeCalendarEra', False)
    def TimeCalendarEra (self):
        """Get the value of the {http://www.opengis.net/gml}TimeCalendarEra element."""
        return self.__TimeCalendarEra.value(self)
    def setTimeCalendarEra (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}TimeCalendarEra element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__TimeCalendarEra.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}show uses Python identifier show
    __show = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'show'), 'show', '__TimeCalendarEraPropertyType_httpwww_w3_org1999xlinkshow', MODULEhttpwww_w3_org1999xlink.UNBOUNDNone_156)
    def show (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}show."""
        return self.__show.value(self)
    def setShow (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}show.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__show.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}title uses Python identifier title
    __title = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'title'), 'title', '__TimeCalendarEraPropertyType_httpwww_w3_org1999xlinktitle', pyxb.binding.datatypes.string)
    def title (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}title."""
        return self.__title.value(self)
    def setTitle (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}title.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__title.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}actuate uses Python identifier actuate
    __actuate = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'actuate'), 'actuate', '__TimeCalendarEraPropertyType_httpwww_w3_org1999xlinkactuate', MODULEhttpwww_w3_org1999xlink.UNBOUNDNone_157)
    def actuate (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}actuate."""
        return self.__actuate.value(self)
    def setActuate (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}actuate.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__actuate.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}arcrole uses Python identifier arcrole
    __arcrole = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'arcrole'), 'arcrole', '__TimeCalendarEraPropertyType_httpwww_w3_org1999xlinkarcrole', pyxb.binding.datatypes.anyURI)
    def arcrole (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}arcrole."""
        return self.__arcrole.value(self)
    def setArcrole (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}arcrole.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__arcrole.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}href uses Python identifier href
    __href = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'href'), 'href', '__TimeCalendarEraPropertyType_httpwww_w3_org1999xlinkhref', pyxb.binding.datatypes.anyURI)
    def href (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}href."""
        return self.__href.value(self)
    def setHref (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}href.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__href.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}role uses Python identifier role
    __role = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'role'), 'role', '__TimeCalendarEraPropertyType_httpwww_w3_org1999xlinkrole', pyxb.binding.datatypes.anyURI)
    def role (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}role."""
        return self.__role.value(self)
    def setRole (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}role.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__role.set(self, new_value)
    
    # Attribute nilReason uses Python identifier nilReason
    __nilReason = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'nilReason'), 'nilReason', '__TimeCalendarEraPropertyType_nilReason', NilReasonType)
    def nilReason (self):
        """Get the attribute value for nilReason."""
        return self.__nilReason.value(self)
    def setNilReason (self, new_value):
        """Set the attribute value for nilReason.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__nilReason.set(self, new_value)
    
    # Attribute owns uses Python identifier owns
    __owns = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'owns'), 'owns', '__TimeCalendarEraPropertyType_owns', pyxb.binding.datatypes.boolean, unicode_default=u'false')
    def owns (self):
        """Get the attribute value for owns."""
        return self.__owns.value(self)
    def setOwns (self, new_value):
        """Set the attribute value for owns.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__owns.set(self, new_value)
    
    # Attribute {http://www.opengis.net/gml}remoteSchema uses Python identifier remoteSchema
    __remoteSchema = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(Namespace, u'remoteSchema'), 'remoteSchema', '__TimeCalendarEraPropertyType_httpwww_opengis_netgmlremoteSchema', pyxb.binding.datatypes.anyURI)
    def remoteSchema (self):
        """Get the attribute value for {http://www.opengis.net/gml}remoteSchema."""
        return self.__remoteSchema.value(self)
    def setRemoteSchema (self, new_value):
        """Set the attribute value for {http://www.opengis.net/gml}remoteSchema.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__remoteSchema.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}type uses Python identifier type
    __type = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'type'), 'type', '__TimeCalendarEraPropertyType_httpwww_w3_org1999xlinktype', pyxb.binding.datatypes.string, fixed=True, unicode_default=u'simple')
    def type (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}type."""
        return self.__type.value(self)
    def setType (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}type.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__type.set(self, new_value)

    _ElementMap = {
        __TimeCalendarEra.name() : __TimeCalendarEra
    }
    _AttributeMap = {
        __show.name() : __show,
        __title.name() : __title,
        __actuate.name() : __actuate,
        __arcrole.name() : __arcrole,
        __href.name() : __href,
        __role.name() : __role,
        __nilReason.name() : __nilReason,
        __owns.name() : __owns,
        __remoteSchema.name() : __remoteSchema,
        __type.name() : __type
    }
Namespace.addCategoryObject('typeBinding', u'TimeCalendarEraPropertyType', TimeCalendarEraPropertyType)


# Complex type TimeCalendarPropertyType with content type ELEMENT_ONLY
class TimeCalendarPropertyType (pyxb.binding.basis.complexTypeDefinition):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'TimeCalendarPropertyType')
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.opengis.net/gml}TimeCalendar uses Python identifier TimeCalendar
    __TimeCalendar = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'TimeCalendar'), 'TimeCalendar', '__TimeCalendarPropertyType_httpwww_opengis_netgmlTimeCalendar', False)
    def TimeCalendar (self):
        """Get the value of the {http://www.opengis.net/gml}TimeCalendar element."""
        return self.__TimeCalendar.value(self)
    def setTimeCalendar (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}TimeCalendar element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__TimeCalendar.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}show uses Python identifier show
    __show = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'show'), 'show', '__TimeCalendarPropertyType_httpwww_w3_org1999xlinkshow', MODULEhttpwww_w3_org1999xlink.UNBOUNDNone_158)
    def show (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}show."""
        return self.__show.value(self)
    def setShow (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}show.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__show.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}role uses Python identifier role
    __role = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'role'), 'role', '__TimeCalendarPropertyType_httpwww_w3_org1999xlinkrole', pyxb.binding.datatypes.anyURI)
    def role (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}role."""
        return self.__role.value(self)
    def setRole (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}role.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__role.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}href uses Python identifier href
    __href = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'href'), 'href', '__TimeCalendarPropertyType_httpwww_w3_org1999xlinkhref', pyxb.binding.datatypes.anyURI)
    def href (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}href."""
        return self.__href.value(self)
    def setHref (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}href.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__href.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}arcrole uses Python identifier arcrole
    __arcrole = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'arcrole'), 'arcrole', '__TimeCalendarPropertyType_httpwww_w3_org1999xlinkarcrole', pyxb.binding.datatypes.anyURI)
    def arcrole (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}arcrole."""
        return self.__arcrole.value(self)
    def setArcrole (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}arcrole.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__arcrole.set(self, new_value)
    
    # Attribute owns uses Python identifier owns
    __owns = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'owns'), 'owns', '__TimeCalendarPropertyType_owns', pyxb.binding.datatypes.boolean, unicode_default=u'false')
    def owns (self):
        """Get the attribute value for owns."""
        return self.__owns.value(self)
    def setOwns (self, new_value):
        """Set the attribute value for owns.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__owns.set(self, new_value)
    
    # Attribute nilReason uses Python identifier nilReason
    __nilReason = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'nilReason'), 'nilReason', '__TimeCalendarPropertyType_nilReason', NilReasonType)
    def nilReason (self):
        """Get the attribute value for nilReason."""
        return self.__nilReason.value(self)
    def setNilReason (self, new_value):
        """Set the attribute value for nilReason.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__nilReason.set(self, new_value)
    
    # Attribute {http://www.opengis.net/gml}remoteSchema uses Python identifier remoteSchema
    __remoteSchema = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(Namespace, u'remoteSchema'), 'remoteSchema', '__TimeCalendarPropertyType_httpwww_opengis_netgmlremoteSchema', pyxb.binding.datatypes.anyURI)
    def remoteSchema (self):
        """Get the attribute value for {http://www.opengis.net/gml}remoteSchema."""
        return self.__remoteSchema.value(self)
    def setRemoteSchema (self, new_value):
        """Set the attribute value for {http://www.opengis.net/gml}remoteSchema.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__remoteSchema.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}actuate uses Python identifier actuate
    __actuate = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'actuate'), 'actuate', '__TimeCalendarPropertyType_httpwww_w3_org1999xlinkactuate', MODULEhttpwww_w3_org1999xlink.UNBOUNDNone_159)
    def actuate (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}actuate."""
        return self.__actuate.value(self)
    def setActuate (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}actuate.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__actuate.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}type uses Python identifier type
    __type = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'type'), 'type', '__TimeCalendarPropertyType_httpwww_w3_org1999xlinktype', pyxb.binding.datatypes.string, fixed=True, unicode_default=u'simple')
    def type (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}type."""
        return self.__type.value(self)
    def setType (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}type.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__type.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}title uses Python identifier title
    __title = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'title'), 'title', '__TimeCalendarPropertyType_httpwww_w3_org1999xlinktitle', pyxb.binding.datatypes.string)
    def title (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}title."""
        return self.__title.value(self)
    def setTitle (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}title.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__title.set(self, new_value)

    _ElementMap = {
        __TimeCalendar.name() : __TimeCalendar
    }
    _AttributeMap = {
        __show.name() : __show,
        __role.name() : __role,
        __href.name() : __href,
        __arcrole.name() : __arcrole,
        __owns.name() : __owns,
        __nilReason.name() : __nilReason,
        __remoteSchema.name() : __remoteSchema,
        __actuate.name() : __actuate,
        __type.name() : __type,
        __title.name() : __title
    }
Namespace.addCategoryObject('typeBinding', u'TimeCalendarPropertyType', TimeCalendarPropertyType)


# Complex type TimeClockPropertyType with content type ELEMENT_ONLY
class TimeClockPropertyType (pyxb.binding.basis.complexTypeDefinition):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'TimeClockPropertyType')
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.opengis.net/gml}TimeClock uses Python identifier TimeClock
    __TimeClock = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'TimeClock'), 'TimeClock', '__TimeClockPropertyType_httpwww_opengis_netgmlTimeClock', False)
    def TimeClock (self):
        """Get the value of the {http://www.opengis.net/gml}TimeClock element."""
        return self.__TimeClock.value(self)
    def setTimeClock (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}TimeClock element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__TimeClock.set(self, new_value)
    
    # Attribute {http://www.opengis.net/gml}remoteSchema uses Python identifier remoteSchema
    __remoteSchema = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(Namespace, u'remoteSchema'), 'remoteSchema', '__TimeClockPropertyType_httpwww_opengis_netgmlremoteSchema', pyxb.binding.datatypes.anyURI)
    def remoteSchema (self):
        """Get the attribute value for {http://www.opengis.net/gml}remoteSchema."""
        return self.__remoteSchema.value(self)
    def setRemoteSchema (self, new_value):
        """Set the attribute value for {http://www.opengis.net/gml}remoteSchema.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__remoteSchema.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}show uses Python identifier show
    __show = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'show'), 'show', '__TimeClockPropertyType_httpwww_w3_org1999xlinkshow', MODULEhttpwww_w3_org1999xlink.UNBOUNDNone_160)
    def show (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}show."""
        return self.__show.value(self)
    def setShow (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}show.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__show.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}actuate uses Python identifier actuate
    __actuate = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'actuate'), 'actuate', '__TimeClockPropertyType_httpwww_w3_org1999xlinkactuate', MODULEhttpwww_w3_org1999xlink.UNBOUNDNone_161)
    def actuate (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}actuate."""
        return self.__actuate.value(self)
    def setActuate (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}actuate.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__actuate.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}type uses Python identifier type
    __type = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'type'), 'type', '__TimeClockPropertyType_httpwww_w3_org1999xlinktype', pyxb.binding.datatypes.string, fixed=True, unicode_default=u'simple')
    def type (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}type."""
        return self.__type.value(self)
    def setType (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}type.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__type.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}title uses Python identifier title
    __title = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'title'), 'title', '__TimeClockPropertyType_httpwww_w3_org1999xlinktitle', pyxb.binding.datatypes.string)
    def title (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}title."""
        return self.__title.value(self)
    def setTitle (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}title.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__title.set(self, new_value)
    
    # Attribute nilReason uses Python identifier nilReason
    __nilReason = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'nilReason'), 'nilReason', '__TimeClockPropertyType_nilReason', NilReasonType)
    def nilReason (self):
        """Get the attribute value for nilReason."""
        return self.__nilReason.value(self)
    def setNilReason (self, new_value):
        """Set the attribute value for nilReason.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__nilReason.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}role uses Python identifier role
    __role = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'role'), 'role', '__TimeClockPropertyType_httpwww_w3_org1999xlinkrole', pyxb.binding.datatypes.anyURI)
    def role (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}role."""
        return self.__role.value(self)
    def setRole (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}role.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__role.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}href uses Python identifier href
    __href = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'href'), 'href', '__TimeClockPropertyType_httpwww_w3_org1999xlinkhref', pyxb.binding.datatypes.anyURI)
    def href (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}href."""
        return self.__href.value(self)
    def setHref (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}href.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__href.set(self, new_value)
    
    # Attribute owns uses Python identifier owns
    __owns = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'owns'), 'owns', '__TimeClockPropertyType_owns', pyxb.binding.datatypes.boolean, unicode_default=u'false')
    def owns (self):
        """Get the attribute value for owns."""
        return self.__owns.value(self)
    def setOwns (self, new_value):
        """Set the attribute value for owns.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__owns.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}arcrole uses Python identifier arcrole
    __arcrole = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'arcrole'), 'arcrole', '__TimeClockPropertyType_httpwww_w3_org1999xlinkarcrole', pyxb.binding.datatypes.anyURI)
    def arcrole (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}arcrole."""
        return self.__arcrole.value(self)
    def setArcrole (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}arcrole.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__arcrole.set(self, new_value)

    _ElementMap = {
        __TimeClock.name() : __TimeClock
    }
    _AttributeMap = {
        __remoteSchema.name() : __remoteSchema,
        __show.name() : __show,
        __actuate.name() : __actuate,
        __type.name() : __type,
        __title.name() : __title,
        __nilReason.name() : __nilReason,
        __role.name() : __role,
        __href.name() : __href,
        __owns.name() : __owns,
        __arcrole.name() : __arcrole
    }
Namespace.addCategoryObject('typeBinding', u'TimeClockPropertyType', TimeClockPropertyType)


# Complex type TimeEdgePropertyType with content type ELEMENT_ONLY
class TimeEdgePropertyType (pyxb.binding.basis.complexTypeDefinition):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'TimeEdgePropertyType')
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.opengis.net/gml}TimeEdge uses Python identifier TimeEdge
    __TimeEdge = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'TimeEdge'), 'TimeEdge', '__TimeEdgePropertyType_httpwww_opengis_netgmlTimeEdge', False)
    def TimeEdge (self):
        """Get the value of the {http://www.opengis.net/gml}TimeEdge element."""
        return self.__TimeEdge.value(self)
    def setTimeEdge (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}TimeEdge element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__TimeEdge.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}href uses Python identifier href
    __href = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'href'), 'href', '__TimeEdgePropertyType_httpwww_w3_org1999xlinkhref', pyxb.binding.datatypes.anyURI)
    def href (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}href."""
        return self.__href.value(self)
    def setHref (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}href.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__href.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}show uses Python identifier show
    __show = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'show'), 'show', '__TimeEdgePropertyType_httpwww_w3_org1999xlinkshow', MODULEhttpwww_w3_org1999xlink.UNBOUNDNone_162)
    def show (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}show."""
        return self.__show.value(self)
    def setShow (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}show.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__show.set(self, new_value)
    
    # Attribute owns uses Python identifier owns
    __owns = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'owns'), 'owns', '__TimeEdgePropertyType_owns', pyxb.binding.datatypes.boolean, unicode_default=u'false')
    def owns (self):
        """Get the attribute value for owns."""
        return self.__owns.value(self)
    def setOwns (self, new_value):
        """Set the attribute value for owns.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__owns.set(self, new_value)
    
    # Attribute {http://www.opengis.net/gml}remoteSchema uses Python identifier remoteSchema
    __remoteSchema = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(Namespace, u'remoteSchema'), 'remoteSchema', '__TimeEdgePropertyType_httpwww_opengis_netgmlremoteSchema', pyxb.binding.datatypes.anyURI)
    def remoteSchema (self):
        """Get the attribute value for {http://www.opengis.net/gml}remoteSchema."""
        return self.__remoteSchema.value(self)
    def setRemoteSchema (self, new_value):
        """Set the attribute value for {http://www.opengis.net/gml}remoteSchema.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__remoteSchema.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}type uses Python identifier type
    __type = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'type'), 'type', '__TimeEdgePropertyType_httpwww_w3_org1999xlinktype', pyxb.binding.datatypes.string, fixed=True, unicode_default=u'simple')
    def type (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}type."""
        return self.__type.value(self)
    def setType (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}type.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__type.set(self, new_value)
    
    # Attribute nilReason uses Python identifier nilReason
    __nilReason = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'nilReason'), 'nilReason', '__TimeEdgePropertyType_nilReason', NilReasonType)
    def nilReason (self):
        """Get the attribute value for nilReason."""
        return self.__nilReason.value(self)
    def setNilReason (self, new_value):
        """Set the attribute value for nilReason.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__nilReason.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}title uses Python identifier title
    __title = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'title'), 'title', '__TimeEdgePropertyType_httpwww_w3_org1999xlinktitle', pyxb.binding.datatypes.string)
    def title (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}title."""
        return self.__title.value(self)
    def setTitle (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}title.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__title.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}role uses Python identifier role
    __role = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'role'), 'role', '__TimeEdgePropertyType_httpwww_w3_org1999xlinkrole', pyxb.binding.datatypes.anyURI)
    def role (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}role."""
        return self.__role.value(self)
    def setRole (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}role.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__role.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}arcrole uses Python identifier arcrole
    __arcrole = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'arcrole'), 'arcrole', '__TimeEdgePropertyType_httpwww_w3_org1999xlinkarcrole', pyxb.binding.datatypes.anyURI)
    def arcrole (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}arcrole."""
        return self.__arcrole.value(self)
    def setArcrole (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}arcrole.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__arcrole.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}actuate uses Python identifier actuate
    __actuate = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'actuate'), 'actuate', '__TimeEdgePropertyType_httpwww_w3_org1999xlinkactuate', MODULEhttpwww_w3_org1999xlink.UNBOUNDNone_163)
    def actuate (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}actuate."""
        return self.__actuate.value(self)
    def setActuate (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}actuate.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__actuate.set(self, new_value)

    _ElementMap = {
        __TimeEdge.name() : __TimeEdge
    }
    _AttributeMap = {
        __href.name() : __href,
        __show.name() : __show,
        __owns.name() : __owns,
        __remoteSchema.name() : __remoteSchema,
        __type.name() : __type,
        __nilReason.name() : __nilReason,
        __title.name() : __title,
        __role.name() : __role,
        __arcrole.name() : __arcrole,
        __actuate.name() : __actuate
    }
Namespace.addCategoryObject('typeBinding', u'TimeEdgePropertyType', TimeEdgePropertyType)


# Complex type TimeInstantPropertyType with content type ELEMENT_ONLY
class TimeInstantPropertyType (pyxb.binding.basis.complexTypeDefinition):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'TimeInstantPropertyType')
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.opengis.net/gml}TimeInstant uses Python identifier TimeInstant
    __TimeInstant = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'TimeInstant'), 'TimeInstant', '__TimeInstantPropertyType_httpwww_opengis_netgmlTimeInstant', False)
    def TimeInstant (self):
        """Get the value of the {http://www.opengis.net/gml}TimeInstant element."""
        return self.__TimeInstant.value(self)
    def setTimeInstant (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}TimeInstant element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__TimeInstant.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}arcrole uses Python identifier arcrole
    __arcrole = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'arcrole'), 'arcrole', '__TimeInstantPropertyType_httpwww_w3_org1999xlinkarcrole', pyxb.binding.datatypes.anyURI)
    def arcrole (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}arcrole."""
        return self.__arcrole.value(self)
    def setArcrole (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}arcrole.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__arcrole.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}show uses Python identifier show
    __show = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'show'), 'show', '__TimeInstantPropertyType_httpwww_w3_org1999xlinkshow', MODULEhttpwww_w3_org1999xlink.UNBOUNDNone_164)
    def show (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}show."""
        return self.__show.value(self)
    def setShow (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}show.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__show.set(self, new_value)
    
    # Attribute {http://www.opengis.net/gml}remoteSchema uses Python identifier remoteSchema
    __remoteSchema = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(Namespace, u'remoteSchema'), 'remoteSchema', '__TimeInstantPropertyType_httpwww_opengis_netgmlremoteSchema', pyxb.binding.datatypes.anyURI)
    def remoteSchema (self):
        """Get the attribute value for {http://www.opengis.net/gml}remoteSchema."""
        return self.__remoteSchema.value(self)
    def setRemoteSchema (self, new_value):
        """Set the attribute value for {http://www.opengis.net/gml}remoteSchema.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__remoteSchema.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}actuate uses Python identifier actuate
    __actuate = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'actuate'), 'actuate', '__TimeInstantPropertyType_httpwww_w3_org1999xlinkactuate', MODULEhttpwww_w3_org1999xlink.UNBOUNDNone_165)
    def actuate (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}actuate."""
        return self.__actuate.value(self)
    def setActuate (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}actuate.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__actuate.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}type uses Python identifier type
    __type = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'type'), 'type', '__TimeInstantPropertyType_httpwww_w3_org1999xlinktype', pyxb.binding.datatypes.string, fixed=True, unicode_default=u'simple')
    def type (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}type."""
        return self.__type.value(self)
    def setType (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}type.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__type.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}title uses Python identifier title
    __title = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'title'), 'title', '__TimeInstantPropertyType_httpwww_w3_org1999xlinktitle', pyxb.binding.datatypes.string)
    def title (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}title."""
        return self.__title.value(self)
    def setTitle (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}title.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__title.set(self, new_value)
    
    # Attribute nilReason uses Python identifier nilReason
    __nilReason = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'nilReason'), 'nilReason', '__TimeInstantPropertyType_nilReason', NilReasonType)
    def nilReason (self):
        """Get the attribute value for nilReason."""
        return self.__nilReason.value(self)
    def setNilReason (self, new_value):
        """Set the attribute value for nilReason.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__nilReason.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}role uses Python identifier role
    __role = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'role'), 'role', '__TimeInstantPropertyType_httpwww_w3_org1999xlinkrole', pyxb.binding.datatypes.anyURI)
    def role (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}role."""
        return self.__role.value(self)
    def setRole (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}role.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__role.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}href uses Python identifier href
    __href = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'href'), 'href', '__TimeInstantPropertyType_httpwww_w3_org1999xlinkhref', pyxb.binding.datatypes.anyURI)
    def href (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}href."""
        return self.__href.value(self)
    def setHref (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}href.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__href.set(self, new_value)
    
    # Attribute owns uses Python identifier owns
    __owns = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'owns'), 'owns', '__TimeInstantPropertyType_owns', pyxb.binding.datatypes.boolean, unicode_default=u'false')
    def owns (self):
        """Get the attribute value for owns."""
        return self.__owns.value(self)
    def setOwns (self, new_value):
        """Set the attribute value for owns.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__owns.set(self, new_value)

    _ElementMap = {
        __TimeInstant.name() : __TimeInstant
    }
    _AttributeMap = {
        __arcrole.name() : __arcrole,
        __show.name() : __show,
        __remoteSchema.name() : __remoteSchema,
        __actuate.name() : __actuate,
        __type.name() : __type,
        __title.name() : __title,
        __nilReason.name() : __nilReason,
        __role.name() : __role,
        __href.name() : __href,
        __owns.name() : __owns
    }
Namespace.addCategoryObject('typeBinding', u'TimeInstantPropertyType', TimeInstantPropertyType)


# Complex type TimeIntervalLengthType with content type SIMPLE
class TimeIntervalLengthType (pyxb.binding.basis.complexTypeDefinition):
    _TypeDefinition = pyxb.binding.datatypes.decimal
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_SIMPLE
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'TimeIntervalLengthType')
    # Base type is pyxb.binding.datatypes.decimal
    
    # Attribute radix uses Python identifier radix
    __radix = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'radix'), 'radix', '__TimeIntervalLengthType_radix', pyxb.binding.datatypes.positiveInteger)
    def radix (self):
        """Get the attribute value for radix."""
        return self.__radix.value(self)
    def setRadix (self, new_value):
        """Set the attribute value for radix.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__radix.set(self, new_value)
    
    # Attribute unit uses Python identifier unit
    __unit = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'unit'), 'unit', '__TimeIntervalLengthType_unit', TimeUnitType, required=True)
    def unit (self):
        """Get the attribute value for unit."""
        return self.__unit.value(self)
    def setUnit (self, new_value):
        """Set the attribute value for unit.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__unit.set(self, new_value)
    
    # Attribute factor uses Python identifier factor
    __factor = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'factor'), 'factor', '__TimeIntervalLengthType_factor', pyxb.binding.datatypes.integer)
    def factor (self):
        """Get the attribute value for factor."""
        return self.__factor.value(self)
    def setFactor (self, new_value):
        """Set the attribute value for factor.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__factor.set(self, new_value)

    _ElementMap = {
        
    }
    _AttributeMap = {
        __radix.name() : __radix,
        __unit.name() : __unit,
        __factor.name() : __factor
    }
Namespace.addCategoryObject('typeBinding', u'TimeIntervalLengthType', TimeIntervalLengthType)


# Complex type TimeNodePropertyType with content type ELEMENT_ONLY
class TimeNodePropertyType (pyxb.binding.basis.complexTypeDefinition):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'TimeNodePropertyType')
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.opengis.net/gml}TimeNode uses Python identifier TimeNode
    __TimeNode = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'TimeNode'), 'TimeNode', '__TimeNodePropertyType_httpwww_opengis_netgmlTimeNode', False)
    def TimeNode (self):
        """Get the value of the {http://www.opengis.net/gml}TimeNode element."""
        return self.__TimeNode.value(self)
    def setTimeNode (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}TimeNode element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__TimeNode.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}arcrole uses Python identifier arcrole
    __arcrole = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'arcrole'), 'arcrole', '__TimeNodePropertyType_httpwww_w3_org1999xlinkarcrole', pyxb.binding.datatypes.anyURI)
    def arcrole (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}arcrole."""
        return self.__arcrole.value(self)
    def setArcrole (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}arcrole.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__arcrole.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}show uses Python identifier show
    __show = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'show'), 'show', '__TimeNodePropertyType_httpwww_w3_org1999xlinkshow', MODULEhttpwww_w3_org1999xlink.UNBOUNDNone_166)
    def show (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}show."""
        return self.__show.value(self)
    def setShow (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}show.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__show.set(self, new_value)
    
    # Attribute {http://www.opengis.net/gml}remoteSchema uses Python identifier remoteSchema
    __remoteSchema = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(Namespace, u'remoteSchema'), 'remoteSchema', '__TimeNodePropertyType_httpwww_opengis_netgmlremoteSchema', pyxb.binding.datatypes.anyURI)
    def remoteSchema (self):
        """Get the attribute value for {http://www.opengis.net/gml}remoteSchema."""
        return self.__remoteSchema.value(self)
    def setRemoteSchema (self, new_value):
        """Set the attribute value for {http://www.opengis.net/gml}remoteSchema.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__remoteSchema.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}actuate uses Python identifier actuate
    __actuate = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'actuate'), 'actuate', '__TimeNodePropertyType_httpwww_w3_org1999xlinkactuate', MODULEhttpwww_w3_org1999xlink.UNBOUNDNone_167)
    def actuate (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}actuate."""
        return self.__actuate.value(self)
    def setActuate (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}actuate.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__actuate.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}type uses Python identifier type
    __type = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'type'), 'type', '__TimeNodePropertyType_httpwww_w3_org1999xlinktype', pyxb.binding.datatypes.string, fixed=True, unicode_default=u'simple')
    def type (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}type."""
        return self.__type.value(self)
    def setType (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}type.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__type.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}title uses Python identifier title
    __title = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'title'), 'title', '__TimeNodePropertyType_httpwww_w3_org1999xlinktitle', pyxb.binding.datatypes.string)
    def title (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}title."""
        return self.__title.value(self)
    def setTitle (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}title.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__title.set(self, new_value)
    
    # Attribute nilReason uses Python identifier nilReason
    __nilReason = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'nilReason'), 'nilReason', '__TimeNodePropertyType_nilReason', NilReasonType)
    def nilReason (self):
        """Get the attribute value for nilReason."""
        return self.__nilReason.value(self)
    def setNilReason (self, new_value):
        """Set the attribute value for nilReason.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__nilReason.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}role uses Python identifier role
    __role = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'role'), 'role', '__TimeNodePropertyType_httpwww_w3_org1999xlinkrole', pyxb.binding.datatypes.anyURI)
    def role (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}role."""
        return self.__role.value(self)
    def setRole (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}role.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__role.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}href uses Python identifier href
    __href = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'href'), 'href', '__TimeNodePropertyType_httpwww_w3_org1999xlinkhref', pyxb.binding.datatypes.anyURI)
    def href (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}href."""
        return self.__href.value(self)
    def setHref (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}href.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__href.set(self, new_value)
    
    # Attribute owns uses Python identifier owns
    __owns = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'owns'), 'owns', '__TimeNodePropertyType_owns', pyxb.binding.datatypes.boolean, unicode_default=u'false')
    def owns (self):
        """Get the attribute value for owns."""
        return self.__owns.value(self)
    def setOwns (self, new_value):
        """Set the attribute value for owns.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__owns.set(self, new_value)

    _ElementMap = {
        __TimeNode.name() : __TimeNode
    }
    _AttributeMap = {
        __arcrole.name() : __arcrole,
        __show.name() : __show,
        __remoteSchema.name() : __remoteSchema,
        __actuate.name() : __actuate,
        __type.name() : __type,
        __title.name() : __title,
        __nilReason.name() : __nilReason,
        __role.name() : __role,
        __href.name() : __href,
        __owns.name() : __owns
    }
Namespace.addCategoryObject('typeBinding', u'TimeNodePropertyType', TimeNodePropertyType)


# Complex type TimeOrdinalEraPropertyType with content type ELEMENT_ONLY
class TimeOrdinalEraPropertyType (pyxb.binding.basis.complexTypeDefinition):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'TimeOrdinalEraPropertyType')
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.opengis.net/gml}TimeOrdinalEra uses Python identifier TimeOrdinalEra
    __TimeOrdinalEra = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'TimeOrdinalEra'), 'TimeOrdinalEra', '__TimeOrdinalEraPropertyType_httpwww_opengis_netgmlTimeOrdinalEra', False)
    def TimeOrdinalEra (self):
        """Get the value of the {http://www.opengis.net/gml}TimeOrdinalEra element."""
        return self.__TimeOrdinalEra.value(self)
    def setTimeOrdinalEra (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}TimeOrdinalEra element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__TimeOrdinalEra.set(self, new_value)
    
    # Attribute owns uses Python identifier owns
    __owns = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'owns'), 'owns', '__TimeOrdinalEraPropertyType_owns', pyxb.binding.datatypes.boolean, unicode_default=u'false')
    def owns (self):
        """Get the attribute value for owns."""
        return self.__owns.value(self)
    def setOwns (self, new_value):
        """Set the attribute value for owns.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__owns.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}show uses Python identifier show
    __show = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'show'), 'show', '__TimeOrdinalEraPropertyType_httpwww_w3_org1999xlinkshow', MODULEhttpwww_w3_org1999xlink.UNBOUNDNone_168)
    def show (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}show."""
        return self.__show.value(self)
    def setShow (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}show.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__show.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}href uses Python identifier href
    __href = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'href'), 'href', '__TimeOrdinalEraPropertyType_httpwww_w3_org1999xlinkhref', pyxb.binding.datatypes.anyURI)
    def href (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}href."""
        return self.__href.value(self)
    def setHref (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}href.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__href.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}arcrole uses Python identifier arcrole
    __arcrole = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'arcrole'), 'arcrole', '__TimeOrdinalEraPropertyType_httpwww_w3_org1999xlinkarcrole', pyxb.binding.datatypes.anyURI)
    def arcrole (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}arcrole."""
        return self.__arcrole.value(self)
    def setArcrole (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}arcrole.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__arcrole.set(self, new_value)
    
    # Attribute {http://www.opengis.net/gml}remoteSchema uses Python identifier remoteSchema
    __remoteSchema = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(Namespace, u'remoteSchema'), 'remoteSchema', '__TimeOrdinalEraPropertyType_httpwww_opengis_netgmlremoteSchema', pyxb.binding.datatypes.anyURI)
    def remoteSchema (self):
        """Get the attribute value for {http://www.opengis.net/gml}remoteSchema."""
        return self.__remoteSchema.value(self)
    def setRemoteSchema (self, new_value):
        """Set the attribute value for {http://www.opengis.net/gml}remoteSchema.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__remoteSchema.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}actuate uses Python identifier actuate
    __actuate = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'actuate'), 'actuate', '__TimeOrdinalEraPropertyType_httpwww_w3_org1999xlinkactuate', MODULEhttpwww_w3_org1999xlink.UNBOUNDNone_169)
    def actuate (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}actuate."""
        return self.__actuate.value(self)
    def setActuate (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}actuate.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__actuate.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}type uses Python identifier type
    __type = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'type'), 'type', '__TimeOrdinalEraPropertyType_httpwww_w3_org1999xlinktype', pyxb.binding.datatypes.string, fixed=True, unicode_default=u'simple')
    def type (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}type."""
        return self.__type.value(self)
    def setType (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}type.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__type.set(self, new_value)
    
    # Attribute nilReason uses Python identifier nilReason
    __nilReason = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'nilReason'), 'nilReason', '__TimeOrdinalEraPropertyType_nilReason', NilReasonType)
    def nilReason (self):
        """Get the attribute value for nilReason."""
        return self.__nilReason.value(self)
    def setNilReason (self, new_value):
        """Set the attribute value for nilReason.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__nilReason.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}title uses Python identifier title
    __title = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'title'), 'title', '__TimeOrdinalEraPropertyType_httpwww_w3_org1999xlinktitle', pyxb.binding.datatypes.string)
    def title (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}title."""
        return self.__title.value(self)
    def setTitle (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}title.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__title.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}role uses Python identifier role
    __role = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'role'), 'role', '__TimeOrdinalEraPropertyType_httpwww_w3_org1999xlinkrole', pyxb.binding.datatypes.anyURI)
    def role (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}role."""
        return self.__role.value(self)
    def setRole (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}role.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__role.set(self, new_value)

    _ElementMap = {
        __TimeOrdinalEra.name() : __TimeOrdinalEra
    }
    _AttributeMap = {
        __owns.name() : __owns,
        __show.name() : __show,
        __href.name() : __href,
        __arcrole.name() : __arcrole,
        __remoteSchema.name() : __remoteSchema,
        __actuate.name() : __actuate,
        __type.name() : __type,
        __nilReason.name() : __nilReason,
        __title.name() : __title,
        __role.name() : __role
    }
Namespace.addCategoryObject('typeBinding', u'TimeOrdinalEraPropertyType', TimeOrdinalEraPropertyType)


# Complex type TimePeriodPropertyType with content type ELEMENT_ONLY
class TimePeriodPropertyType (pyxb.binding.basis.complexTypeDefinition):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'TimePeriodPropertyType')
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.opengis.net/gml}TimePeriod uses Python identifier TimePeriod
    __TimePeriod = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'TimePeriod'), 'TimePeriod', '__TimePeriodPropertyType_httpwww_opengis_netgmlTimePeriod', False)
    def TimePeriod (self):
        """Get the value of the {http://www.opengis.net/gml}TimePeriod element."""
        return self.__TimePeriod.value(self)
    def setTimePeriod (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}TimePeriod element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__TimePeriod.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}show uses Python identifier show
    __show = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'show'), 'show', '__TimePeriodPropertyType_httpwww_w3_org1999xlinkshow', MODULEhttpwww_w3_org1999xlink.UNBOUNDNone_170)
    def show (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}show."""
        return self.__show.value(self)
    def setShow (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}show.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__show.set(self, new_value)
    
    # Attribute owns uses Python identifier owns
    __owns = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'owns'), 'owns', '__TimePeriodPropertyType_owns', pyxb.binding.datatypes.boolean, unicode_default=u'false')
    def owns (self):
        """Get the attribute value for owns."""
        return self.__owns.value(self)
    def setOwns (self, new_value):
        """Set the attribute value for owns.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__owns.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}arcrole uses Python identifier arcrole
    __arcrole = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'arcrole'), 'arcrole', '__TimePeriodPropertyType_httpwww_w3_org1999xlinkarcrole', pyxb.binding.datatypes.anyURI)
    def arcrole (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}arcrole."""
        return self.__arcrole.value(self)
    def setArcrole (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}arcrole.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__arcrole.set(self, new_value)
    
    # Attribute {http://www.opengis.net/gml}remoteSchema uses Python identifier remoteSchema
    __remoteSchema = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(Namespace, u'remoteSchema'), 'remoteSchema', '__TimePeriodPropertyType_httpwww_opengis_netgmlremoteSchema', pyxb.binding.datatypes.anyURI)
    def remoteSchema (self):
        """Get the attribute value for {http://www.opengis.net/gml}remoteSchema."""
        return self.__remoteSchema.value(self)
    def setRemoteSchema (self, new_value):
        """Set the attribute value for {http://www.opengis.net/gml}remoteSchema.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__remoteSchema.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}actuate uses Python identifier actuate
    __actuate = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'actuate'), 'actuate', '__TimePeriodPropertyType_httpwww_w3_org1999xlinkactuate', MODULEhttpwww_w3_org1999xlink.UNBOUNDNone_171)
    def actuate (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}actuate."""
        return self.__actuate.value(self)
    def setActuate (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}actuate.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__actuate.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}href uses Python identifier href
    __href = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'href'), 'href', '__TimePeriodPropertyType_httpwww_w3_org1999xlinkhref', pyxb.binding.datatypes.anyURI)
    def href (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}href."""
        return self.__href.value(self)
    def setHref (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}href.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__href.set(self, new_value)
    
    # Attribute nilReason uses Python identifier nilReason
    __nilReason = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'nilReason'), 'nilReason', '__TimePeriodPropertyType_nilReason', NilReasonType)
    def nilReason (self):
        """Get the attribute value for nilReason."""
        return self.__nilReason.value(self)
    def setNilReason (self, new_value):
        """Set the attribute value for nilReason.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__nilReason.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}type uses Python identifier type
    __type = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'type'), 'type', '__TimePeriodPropertyType_httpwww_w3_org1999xlinktype', pyxb.binding.datatypes.string, fixed=True, unicode_default=u'simple')
    def type (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}type."""
        return self.__type.value(self)
    def setType (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}type.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__type.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}title uses Python identifier title
    __title = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'title'), 'title', '__TimePeriodPropertyType_httpwww_w3_org1999xlinktitle', pyxb.binding.datatypes.string)
    def title (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}title."""
        return self.__title.value(self)
    def setTitle (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}title.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__title.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}role uses Python identifier role
    __role = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'role'), 'role', '__TimePeriodPropertyType_httpwww_w3_org1999xlinkrole', pyxb.binding.datatypes.anyURI)
    def role (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}role."""
        return self.__role.value(self)
    def setRole (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}role.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__role.set(self, new_value)

    _ElementMap = {
        __TimePeriod.name() : __TimePeriod
    }
    _AttributeMap = {
        __show.name() : __show,
        __owns.name() : __owns,
        __arcrole.name() : __arcrole,
        __remoteSchema.name() : __remoteSchema,
        __actuate.name() : __actuate,
        __href.name() : __href,
        __nilReason.name() : __nilReason,
        __type.name() : __type,
        __title.name() : __title,
        __role.name() : __role
    }
Namespace.addCategoryObject('typeBinding', u'TimePeriodPropertyType', TimePeriodPropertyType)


# Complex type TimePositionType with content type SIMPLE
class TimePositionType (pyxb.binding.basis.complexTypeDefinition):
    _TypeDefinition = TimePositionUnion
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_SIMPLE
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'TimePositionType')
    # Base type is TimePositionUnion
    
    # Attribute frame uses Python identifier frame
    __frame = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'frame'), 'frame', '__TimePositionType_frame', pyxb.binding.datatypes.anyURI, unicode_default=u'#ISO-8601')
    def frame (self):
        """Get the attribute value for frame."""
        return self.__frame.value(self)
    def setFrame (self, new_value):
        """Set the attribute value for frame.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__frame.set(self, new_value)
    
    # Attribute indeterminatePosition uses Python identifier indeterminatePosition
    __indeterminatePosition = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'indeterminatePosition'), 'indeterminatePosition', '__TimePositionType_indeterminatePosition', TimeIndeterminateValueType)
    def indeterminatePosition (self):
        """Get the attribute value for indeterminatePosition."""
        return self.__indeterminatePosition.value(self)
    def setIndeterminatePosition (self, new_value):
        """Set the attribute value for indeterminatePosition.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__indeterminatePosition.set(self, new_value)
    
    # Attribute calendarEraName uses Python identifier calendarEraName
    __calendarEraName = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'calendarEraName'), 'calendarEraName', '__TimePositionType_calendarEraName', pyxb.binding.datatypes.string)
    def calendarEraName (self):
        """Get the attribute value for calendarEraName."""
        return self.__calendarEraName.value(self)
    def setCalendarEraName (self, new_value):
        """Set the attribute value for calendarEraName.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__calendarEraName.set(self, new_value)

    _ElementMap = {
        
    }
    _AttributeMap = {
        __frame.name() : __frame,
        __indeterminatePosition.name() : __indeterminatePosition,
        __calendarEraName.name() : __calendarEraName
    }
Namespace.addCategoryObject('typeBinding', u'TimePositionType', TimePositionType)


# Complex type TimePrimitivePropertyType with content type ELEMENT_ONLY
class TimePrimitivePropertyType (pyxb.binding.basis.complexTypeDefinition):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'TimePrimitivePropertyType')
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.opengis.net/gml}AbstractTimePrimitive uses Python identifier AbstractTimePrimitive
    __AbstractTimePrimitive = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'AbstractTimePrimitive'), 'AbstractTimePrimitive', '__TimePrimitivePropertyType_httpwww_opengis_netgmlAbstractTimePrimitive', False)
    def AbstractTimePrimitive (self):
        """Get the value of the {http://www.opengis.net/gml}AbstractTimePrimitive element."""
        return self.__AbstractTimePrimitive.value(self)
    def setAbstractTimePrimitive (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}AbstractTimePrimitive element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__AbstractTimePrimitive.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}type uses Python identifier type
    __type = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'type'), 'type', '__TimePrimitivePropertyType_httpwww_w3_org1999xlinktype', pyxb.binding.datatypes.string, fixed=True, unicode_default=u'simple')
    def type (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}type."""
        return self.__type.value(self)
    def setType (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}type.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__type.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}show uses Python identifier show
    __show = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'show'), 'show', '__TimePrimitivePropertyType_httpwww_w3_org1999xlinkshow', MODULEhttpwww_w3_org1999xlink.UNBOUNDNone_172)
    def show (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}show."""
        return self.__show.value(self)
    def setShow (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}show.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__show.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}title uses Python identifier title
    __title = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'title'), 'title', '__TimePrimitivePropertyType_httpwww_w3_org1999xlinktitle', pyxb.binding.datatypes.string)
    def title (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}title."""
        return self.__title.value(self)
    def setTitle (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}title.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__title.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}role uses Python identifier role
    __role = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'role'), 'role', '__TimePrimitivePropertyType_httpwww_w3_org1999xlinkrole', pyxb.binding.datatypes.anyURI)
    def role (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}role."""
        return self.__role.value(self)
    def setRole (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}role.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__role.set(self, new_value)
    
    # Attribute nilReason uses Python identifier nilReason
    __nilReason = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'nilReason'), 'nilReason', '__TimePrimitivePropertyType_nilReason', NilReasonType)
    def nilReason (self):
        """Get the attribute value for nilReason."""
        return self.__nilReason.value(self)
    def setNilReason (self, new_value):
        """Set the attribute value for nilReason.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__nilReason.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}href uses Python identifier href
    __href = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'href'), 'href', '__TimePrimitivePropertyType_httpwww_w3_org1999xlinkhref', pyxb.binding.datatypes.anyURI)
    def href (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}href."""
        return self.__href.value(self)
    def setHref (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}href.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__href.set(self, new_value)
    
    # Attribute owns uses Python identifier owns
    __owns = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'owns'), 'owns', '__TimePrimitivePropertyType_owns', pyxb.binding.datatypes.boolean, unicode_default=u'false')
    def owns (self):
        """Get the attribute value for owns."""
        return self.__owns.value(self)
    def setOwns (self, new_value):
        """Set the attribute value for owns.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__owns.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}arcrole uses Python identifier arcrole
    __arcrole = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'arcrole'), 'arcrole', '__TimePrimitivePropertyType_httpwww_w3_org1999xlinkarcrole', pyxb.binding.datatypes.anyURI)
    def arcrole (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}arcrole."""
        return self.__arcrole.value(self)
    def setArcrole (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}arcrole.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__arcrole.set(self, new_value)
    
    # Attribute {http://www.opengis.net/gml}remoteSchema uses Python identifier remoteSchema
    __remoteSchema = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(Namespace, u'remoteSchema'), 'remoteSchema', '__TimePrimitivePropertyType_httpwww_opengis_netgmlremoteSchema', pyxb.binding.datatypes.anyURI)
    def remoteSchema (self):
        """Get the attribute value for {http://www.opengis.net/gml}remoteSchema."""
        return self.__remoteSchema.value(self)
    def setRemoteSchema (self, new_value):
        """Set the attribute value for {http://www.opengis.net/gml}remoteSchema.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__remoteSchema.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}actuate uses Python identifier actuate
    __actuate = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'actuate'), 'actuate', '__TimePrimitivePropertyType_httpwww_w3_org1999xlinkactuate', MODULEhttpwww_w3_org1999xlink.UNBOUNDNone_173)
    def actuate (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}actuate."""
        return self.__actuate.value(self)
    def setActuate (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}actuate.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__actuate.set(self, new_value)

    _ElementMap = {
        __AbstractTimePrimitive.name() : __AbstractTimePrimitive
    }
    _AttributeMap = {
        __type.name() : __type,
        __show.name() : __show,
        __title.name() : __title,
        __role.name() : __role,
        __nilReason.name() : __nilReason,
        __href.name() : __href,
        __owns.name() : __owns,
        __arcrole.name() : __arcrole,
        __remoteSchema.name() : __remoteSchema,
        __actuate.name() : __actuate
    }
Namespace.addCategoryObject('typeBinding', u'TimePrimitivePropertyType', TimePrimitivePropertyType)


# Complex type TimeTopologyComplexPropertyType with content type ELEMENT_ONLY
class TimeTopologyComplexPropertyType (pyxb.binding.basis.complexTypeDefinition):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'TimeTopologyComplexPropertyType')
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.opengis.net/gml}TimeTopologyComplex uses Python identifier TimeTopologyComplex
    __TimeTopologyComplex = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'TimeTopologyComplex'), 'TimeTopologyComplex', '__TimeTopologyComplexPropertyType_httpwww_opengis_netgmlTimeTopologyComplex', False)
    def TimeTopologyComplex (self):
        """Get the value of the {http://www.opengis.net/gml}TimeTopologyComplex element."""
        return self.__TimeTopologyComplex.value(self)
    def setTimeTopologyComplex (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}TimeTopologyComplex element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__TimeTopologyComplex.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}type uses Python identifier type
    __type = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'type'), 'type', '__TimeTopologyComplexPropertyType_httpwww_w3_org1999xlinktype', pyxb.binding.datatypes.string, fixed=True, unicode_default=u'simple')
    def type (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}type."""
        return self.__type.value(self)
    def setType (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}type.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__type.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}show uses Python identifier show
    __show = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'show'), 'show', '__TimeTopologyComplexPropertyType_httpwww_w3_org1999xlinkshow', MODULEhttpwww_w3_org1999xlink.UNBOUNDNone_174)
    def show (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}show."""
        return self.__show.value(self)
    def setShow (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}show.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__show.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}title uses Python identifier title
    __title = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'title'), 'title', '__TimeTopologyComplexPropertyType_httpwww_w3_org1999xlinktitle', pyxb.binding.datatypes.string)
    def title (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}title."""
        return self.__title.value(self)
    def setTitle (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}title.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__title.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}role uses Python identifier role
    __role = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'role'), 'role', '__TimeTopologyComplexPropertyType_httpwww_w3_org1999xlinkrole', pyxb.binding.datatypes.anyURI)
    def role (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}role."""
        return self.__role.value(self)
    def setRole (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}role.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__role.set(self, new_value)
    
    # Attribute nilReason uses Python identifier nilReason
    __nilReason = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'nilReason'), 'nilReason', '__TimeTopologyComplexPropertyType_nilReason', NilReasonType)
    def nilReason (self):
        """Get the attribute value for nilReason."""
        return self.__nilReason.value(self)
    def setNilReason (self, new_value):
        """Set the attribute value for nilReason.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__nilReason.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}href uses Python identifier href
    __href = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'href'), 'href', '__TimeTopologyComplexPropertyType_httpwww_w3_org1999xlinkhref', pyxb.binding.datatypes.anyURI)
    def href (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}href."""
        return self.__href.value(self)
    def setHref (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}href.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__href.set(self, new_value)
    
    # Attribute owns uses Python identifier owns
    __owns = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'owns'), 'owns', '__TimeTopologyComplexPropertyType_owns', pyxb.binding.datatypes.boolean, unicode_default=u'false')
    def owns (self):
        """Get the attribute value for owns."""
        return self.__owns.value(self)
    def setOwns (self, new_value):
        """Set the attribute value for owns.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__owns.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}arcrole uses Python identifier arcrole
    __arcrole = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'arcrole'), 'arcrole', '__TimeTopologyComplexPropertyType_httpwww_w3_org1999xlinkarcrole', pyxb.binding.datatypes.anyURI)
    def arcrole (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}arcrole."""
        return self.__arcrole.value(self)
    def setArcrole (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}arcrole.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__arcrole.set(self, new_value)
    
    # Attribute {http://www.opengis.net/gml}remoteSchema uses Python identifier remoteSchema
    __remoteSchema = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(Namespace, u'remoteSchema'), 'remoteSchema', '__TimeTopologyComplexPropertyType_httpwww_opengis_netgmlremoteSchema', pyxb.binding.datatypes.anyURI)
    def remoteSchema (self):
        """Get the attribute value for {http://www.opengis.net/gml}remoteSchema."""
        return self.__remoteSchema.value(self)
    def setRemoteSchema (self, new_value):
        """Set the attribute value for {http://www.opengis.net/gml}remoteSchema.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__remoteSchema.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}actuate uses Python identifier actuate
    __actuate = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'actuate'), 'actuate', '__TimeTopologyComplexPropertyType_httpwww_w3_org1999xlinkactuate', MODULEhttpwww_w3_org1999xlink.UNBOUNDNone_175)
    def actuate (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}actuate."""
        return self.__actuate.value(self)
    def setActuate (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}actuate.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__actuate.set(self, new_value)

    _ElementMap = {
        __TimeTopologyComplex.name() : __TimeTopologyComplex
    }
    _AttributeMap = {
        __type.name() : __type,
        __show.name() : __show,
        __title.name() : __title,
        __role.name() : __role,
        __nilReason.name() : __nilReason,
        __href.name() : __href,
        __owns.name() : __owns,
        __arcrole.name() : __arcrole,
        __remoteSchema.name() : __remoteSchema,
        __actuate.name() : __actuate
    }
Namespace.addCategoryObject('typeBinding', u'TimeTopologyComplexPropertyType', TimeTopologyComplexPropertyType)


# Complex type TimeTopologyPrimitivePropertyType with content type ELEMENT_ONLY
class TimeTopologyPrimitivePropertyType (pyxb.binding.basis.complexTypeDefinition):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'TimeTopologyPrimitivePropertyType')
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.opengis.net/gml}AbstractTimeTopologyPrimitive uses Python identifier AbstractTimeTopologyPrimitive
    __AbstractTimeTopologyPrimitive = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'AbstractTimeTopologyPrimitive'), 'AbstractTimeTopologyPrimitive', '__TimeTopologyPrimitivePropertyType_httpwww_opengis_netgmlAbstractTimeTopologyPrimitive', False)
    def AbstractTimeTopologyPrimitive (self):
        """Get the value of the {http://www.opengis.net/gml}AbstractTimeTopologyPrimitive element."""
        return self.__AbstractTimeTopologyPrimitive.value(self)
    def setAbstractTimeTopologyPrimitive (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}AbstractTimeTopologyPrimitive element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__AbstractTimeTopologyPrimitive.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}title uses Python identifier title
    __title = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'title'), 'title', '__TimeTopologyPrimitivePropertyType_httpwww_w3_org1999xlinktitle', pyxb.binding.datatypes.string)
    def title (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}title."""
        return self.__title.value(self)
    def setTitle (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}title.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__title.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}show uses Python identifier show
    __show = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'show'), 'show', '__TimeTopologyPrimitivePropertyType_httpwww_w3_org1999xlinkshow', MODULEhttpwww_w3_org1999xlink.UNBOUNDNone_176)
    def show (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}show."""
        return self.__show.value(self)
    def setShow (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}show.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__show.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}role uses Python identifier role
    __role = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'role'), 'role', '__TimeTopologyPrimitivePropertyType_httpwww_w3_org1999xlinkrole', pyxb.binding.datatypes.anyURI)
    def role (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}role."""
        return self.__role.value(self)
    def setRole (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}role.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__role.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}href uses Python identifier href
    __href = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'href'), 'href', '__TimeTopologyPrimitivePropertyType_httpwww_w3_org1999xlinkhref', pyxb.binding.datatypes.anyURI)
    def href (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}href."""
        return self.__href.value(self)
    def setHref (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}href.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__href.set(self, new_value)
    
    # Attribute owns uses Python identifier owns
    __owns = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'owns'), 'owns', '__TimeTopologyPrimitivePropertyType_owns', pyxb.binding.datatypes.boolean, unicode_default=u'false')
    def owns (self):
        """Get the attribute value for owns."""
        return self.__owns.value(self)
    def setOwns (self, new_value):
        """Set the attribute value for owns.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__owns.set(self, new_value)
    
    # Attribute nilReason uses Python identifier nilReason
    __nilReason = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'nilReason'), 'nilReason', '__TimeTopologyPrimitivePropertyType_nilReason', NilReasonType)
    def nilReason (self):
        """Get the attribute value for nilReason."""
        return self.__nilReason.value(self)
    def setNilReason (self, new_value):
        """Set the attribute value for nilReason.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__nilReason.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}arcrole uses Python identifier arcrole
    __arcrole = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'arcrole'), 'arcrole', '__TimeTopologyPrimitivePropertyType_httpwww_w3_org1999xlinkarcrole', pyxb.binding.datatypes.anyURI)
    def arcrole (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}arcrole."""
        return self.__arcrole.value(self)
    def setArcrole (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}arcrole.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__arcrole.set(self, new_value)
    
    # Attribute {http://www.opengis.net/gml}remoteSchema uses Python identifier remoteSchema
    __remoteSchema = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(Namespace, u'remoteSchema'), 'remoteSchema', '__TimeTopologyPrimitivePropertyType_httpwww_opengis_netgmlremoteSchema', pyxb.binding.datatypes.anyURI)
    def remoteSchema (self):
        """Get the attribute value for {http://www.opengis.net/gml}remoteSchema."""
        return self.__remoteSchema.value(self)
    def setRemoteSchema (self, new_value):
        """Set the attribute value for {http://www.opengis.net/gml}remoteSchema.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__remoteSchema.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}actuate uses Python identifier actuate
    __actuate = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'actuate'), 'actuate', '__TimeTopologyPrimitivePropertyType_httpwww_w3_org1999xlinkactuate', MODULEhttpwww_w3_org1999xlink.UNBOUNDNone_177)
    def actuate (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}actuate."""
        return self.__actuate.value(self)
    def setActuate (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}actuate.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__actuate.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}type uses Python identifier type
    __type = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'type'), 'type', '__TimeTopologyPrimitivePropertyType_httpwww_w3_org1999xlinktype', pyxb.binding.datatypes.string, fixed=True, unicode_default=u'simple')
    def type (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}type."""
        return self.__type.value(self)
    def setType (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}type.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__type.set(self, new_value)

    _ElementMap = {
        __AbstractTimeTopologyPrimitive.name() : __AbstractTimeTopologyPrimitive
    }
    _AttributeMap = {
        __title.name() : __title,
        __show.name() : __show,
        __role.name() : __role,
        __href.name() : __href,
        __owns.name() : __owns,
        __nilReason.name() : __nilReason,
        __arcrole.name() : __arcrole,
        __remoteSchema.name() : __remoteSchema,
        __actuate.name() : __actuate,
        __type.name() : __type
    }
Namespace.addCategoryObject('typeBinding', u'TimeTopologyPrimitivePropertyType', TimeTopologyPrimitivePropertyType)


# Complex type TopoComplexMemberType with content type ELEMENT_ONLY
class TopoComplexMemberType (pyxb.binding.basis.complexTypeDefinition):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'TopoComplexMemberType')
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.opengis.net/gml}TopoComplex uses Python identifier TopoComplex
    __TopoComplex = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'TopoComplex'), 'TopoComplex', '__TopoComplexMemberType_httpwww_opengis_netgmlTopoComplex', False)
    def TopoComplex (self):
        """Get the value of the {http://www.opengis.net/gml}TopoComplex element."""
        return self.__TopoComplex.value(self)
    def setTopoComplex (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}TopoComplex element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__TopoComplex.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}href uses Python identifier href
    __href = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'href'), 'href', '__TopoComplexMemberType_httpwww_w3_org1999xlinkhref', pyxb.binding.datatypes.anyURI)
    def href (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}href."""
        return self.__href.value(self)
    def setHref (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}href.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__href.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}show uses Python identifier show
    __show = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'show'), 'show', '__TopoComplexMemberType_httpwww_w3_org1999xlinkshow', MODULEhttpwww_w3_org1999xlink.UNBOUNDNone_178)
    def show (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}show."""
        return self.__show.value(self)
    def setShow (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}show.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__show.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}actuate uses Python identifier actuate
    __actuate = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'actuate'), 'actuate', '__TopoComplexMemberType_httpwww_w3_org1999xlinkactuate', MODULEhttpwww_w3_org1999xlink.UNBOUNDNone_179)
    def actuate (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}actuate."""
        return self.__actuate.value(self)
    def setActuate (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}actuate.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__actuate.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}arcrole uses Python identifier arcrole
    __arcrole = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'arcrole'), 'arcrole', '__TopoComplexMemberType_httpwww_w3_org1999xlinkarcrole', pyxb.binding.datatypes.anyURI)
    def arcrole (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}arcrole."""
        return self.__arcrole.value(self)
    def setArcrole (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}arcrole.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__arcrole.set(self, new_value)
    
    # Attribute {http://www.opengis.net/gml}remoteSchema uses Python identifier remoteSchema
    __remoteSchema = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(Namespace, u'remoteSchema'), 'remoteSchema', '__TopoComplexMemberType_httpwww_opengis_netgmlremoteSchema', pyxb.binding.datatypes.anyURI)
    def remoteSchema (self):
        """Get the attribute value for {http://www.opengis.net/gml}remoteSchema."""
        return self.__remoteSchema.value(self)
    def setRemoteSchema (self, new_value):
        """Set the attribute value for {http://www.opengis.net/gml}remoteSchema.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__remoteSchema.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}type uses Python identifier type
    __type = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'type'), 'type', '__TopoComplexMemberType_httpwww_w3_org1999xlinktype', pyxb.binding.datatypes.string, fixed=True, unicode_default=u'simple')
    def type (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}type."""
        return self.__type.value(self)
    def setType (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}type.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__type.set(self, new_value)
    
    # Attribute nilReason uses Python identifier nilReason
    __nilReason = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'nilReason'), 'nilReason', '__TopoComplexMemberType_nilReason', NilReasonType)
    def nilReason (self):
        """Get the attribute value for nilReason."""
        return self.__nilReason.value(self)
    def setNilReason (self, new_value):
        """Set the attribute value for nilReason.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__nilReason.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}title uses Python identifier title
    __title = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'title'), 'title', '__TopoComplexMemberType_httpwww_w3_org1999xlinktitle', pyxb.binding.datatypes.string)
    def title (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}title."""
        return self.__title.value(self)
    def setTitle (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}title.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__title.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}role uses Python identifier role
    __role = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'role'), 'role', '__TopoComplexMemberType_httpwww_w3_org1999xlinkrole', pyxb.binding.datatypes.anyURI)
    def role (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}role."""
        return self.__role.value(self)
    def setRole (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}role.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__role.set(self, new_value)

    _ElementMap = {
        __TopoComplex.name() : __TopoComplex
    }
    _AttributeMap = {
        __href.name() : __href,
        __show.name() : __show,
        __actuate.name() : __actuate,
        __arcrole.name() : __arcrole,
        __remoteSchema.name() : __remoteSchema,
        __type.name() : __type,
        __nilReason.name() : __nilReason,
        __title.name() : __title,
        __role.name() : __role
    }
Namespace.addCategoryObject('typeBinding', u'TopoComplexMemberType', TopoComplexMemberType)


# Complex type TopoCurvePropertyType with content type ELEMENT_ONLY
class TopoCurvePropertyType (pyxb.binding.basis.complexTypeDefinition):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'TopoCurvePropertyType')
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.opengis.net/gml}TopoCurve uses Python identifier TopoCurve
    __TopoCurve = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'TopoCurve'), 'TopoCurve', '__TopoCurvePropertyType_httpwww_opengis_netgmlTopoCurve', False)
    def TopoCurve (self):
        """Get the value of the {http://www.opengis.net/gml}TopoCurve element."""
        return self.__TopoCurve.value(self)
    def setTopoCurve (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}TopoCurve element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__TopoCurve.set(self, new_value)
    
    # Attribute owns uses Python identifier owns
    __owns = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'owns'), 'owns', '__TopoCurvePropertyType_owns', pyxb.binding.datatypes.boolean, unicode_default=u'false')
    def owns (self):
        """Get the attribute value for owns."""
        return self.__owns.value(self)
    def setOwns (self, new_value):
        """Set the attribute value for owns.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__owns.set(self, new_value)

    _ElementMap = {
        __TopoCurve.name() : __TopoCurve
    }
    _AttributeMap = {
        __owns.name() : __owns
    }
Namespace.addCategoryObject('typeBinding', u'TopoCurvePropertyType', TopoCurvePropertyType)


# Complex type TopoPointPropertyType with content type ELEMENT_ONLY
class TopoPointPropertyType (pyxb.binding.basis.complexTypeDefinition):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'TopoPointPropertyType')
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.opengis.net/gml}TopoPoint uses Python identifier TopoPoint
    __TopoPoint = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'TopoPoint'), 'TopoPoint', '__TopoPointPropertyType_httpwww_opengis_netgmlTopoPoint', False)
    def TopoPoint (self):
        """Get the value of the {http://www.opengis.net/gml}TopoPoint element."""
        return self.__TopoPoint.value(self)
    def setTopoPoint (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}TopoPoint element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__TopoPoint.set(self, new_value)
    
    # Attribute owns uses Python identifier owns
    __owns = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'owns'), 'owns', '__TopoPointPropertyType_owns', pyxb.binding.datatypes.boolean, unicode_default=u'false')
    def owns (self):
        """Get the attribute value for owns."""
        return self.__owns.value(self)
    def setOwns (self, new_value):
        """Set the attribute value for owns.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__owns.set(self, new_value)

    _ElementMap = {
        __TopoPoint.name() : __TopoPoint
    }
    _AttributeMap = {
        __owns.name() : __owns
    }
Namespace.addCategoryObject('typeBinding', u'TopoPointPropertyType', TopoPointPropertyType)


# Complex type TopoPrimitiveArrayAssociationType with content type ELEMENT_ONLY
class TopoPrimitiveArrayAssociationType (pyxb.binding.basis.complexTypeDefinition):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'TopoPrimitiveArrayAssociationType')
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.opengis.net/gml}AbstractTopoPrimitive uses Python identifier AbstractTopoPrimitive
    __AbstractTopoPrimitive = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'AbstractTopoPrimitive'), 'AbstractTopoPrimitive', '__TopoPrimitiveArrayAssociationType_httpwww_opengis_netgmlAbstractTopoPrimitive', True)
    def AbstractTopoPrimitive (self):
        """Get the value of the {http://www.opengis.net/gml}AbstractTopoPrimitive element."""
        return self.__AbstractTopoPrimitive.value(self)
    def setAbstractTopoPrimitive (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}AbstractTopoPrimitive element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__AbstractTopoPrimitive.set(self, new_value)
    
    def addAbstractTopoPrimitive (self, new_value):
        """Add the value as another occurrence of the {http://www.opengis.net/gml}AbstractTopoPrimitive element.  Raises
        BadValueTypeException if the new value is not consistent with the
        element's type."""
        return self.__AbstractTopoPrimitive.append(self, new_value)
    
    # Attribute owns uses Python identifier owns
    __owns = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'owns'), 'owns', '__TopoPrimitiveArrayAssociationType_owns', pyxb.binding.datatypes.boolean, unicode_default=u'false')
    def owns (self):
        """Get the attribute value for owns."""
        return self.__owns.value(self)
    def setOwns (self, new_value):
        """Set the attribute value for owns.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__owns.set(self, new_value)

    _ElementMap = {
        __AbstractTopoPrimitive.name() : __AbstractTopoPrimitive
    }
    _AttributeMap = {
        __owns.name() : __owns
    }
Namespace.addCategoryObject('typeBinding', u'TopoPrimitiveArrayAssociationType', TopoPrimitiveArrayAssociationType)


# Complex type TopoPrimitiveMemberType with content type ELEMENT_ONLY
class TopoPrimitiveMemberType (pyxb.binding.basis.complexTypeDefinition):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'TopoPrimitiveMemberType')
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.opengis.net/gml}AbstractTopoPrimitive uses Python identifier AbstractTopoPrimitive
    __AbstractTopoPrimitive = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'AbstractTopoPrimitive'), 'AbstractTopoPrimitive', '__TopoPrimitiveMemberType_httpwww_opengis_netgmlAbstractTopoPrimitive', False)
    def AbstractTopoPrimitive (self):
        """Get the value of the {http://www.opengis.net/gml}AbstractTopoPrimitive element."""
        return self.__AbstractTopoPrimitive.value(self)
    def setAbstractTopoPrimitive (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}AbstractTopoPrimitive element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__AbstractTopoPrimitive.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}actuate uses Python identifier actuate
    __actuate = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'actuate'), 'actuate', '__TopoPrimitiveMemberType_httpwww_w3_org1999xlinkactuate', MODULEhttpwww_w3_org1999xlink.UNBOUNDNone_180)
    def actuate (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}actuate."""
        return self.__actuate.value(self)
    def setActuate (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}actuate.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__actuate.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}show uses Python identifier show
    __show = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'show'), 'show', '__TopoPrimitiveMemberType_httpwww_w3_org1999xlinkshow', MODULEhttpwww_w3_org1999xlink.UNBOUNDNone_181)
    def show (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}show."""
        return self.__show.value(self)
    def setShow (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}show.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__show.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}type uses Python identifier type
    __type = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'type'), 'type', '__TopoPrimitiveMemberType_httpwww_w3_org1999xlinktype', pyxb.binding.datatypes.string, fixed=True, unicode_default=u'simple')
    def type (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}type."""
        return self.__type.value(self)
    def setType (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}type.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__type.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}title uses Python identifier title
    __title = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'title'), 'title', '__TopoPrimitiveMemberType_httpwww_w3_org1999xlinktitle', pyxb.binding.datatypes.string)
    def title (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}title."""
        return self.__title.value(self)
    def setTitle (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}title.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__title.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}role uses Python identifier role
    __role = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'role'), 'role', '__TopoPrimitiveMemberType_httpwww_w3_org1999xlinkrole', pyxb.binding.datatypes.anyURI)
    def role (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}role."""
        return self.__role.value(self)
    def setRole (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}role.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__role.set(self, new_value)
    
    # Attribute nilReason uses Python identifier nilReason
    __nilReason = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'nilReason'), 'nilReason', '__TopoPrimitiveMemberType_nilReason', NilReasonType)
    def nilReason (self):
        """Get the attribute value for nilReason."""
        return self.__nilReason.value(self)
    def setNilReason (self, new_value):
        """Set the attribute value for nilReason.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__nilReason.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}href uses Python identifier href
    __href = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'href'), 'href', '__TopoPrimitiveMemberType_httpwww_w3_org1999xlinkhref', pyxb.binding.datatypes.anyURI)
    def href (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}href."""
        return self.__href.value(self)
    def setHref (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}href.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__href.set(self, new_value)
    
    # Attribute owns uses Python identifier owns
    __owns = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'owns'), 'owns', '__TopoPrimitiveMemberType_owns', pyxb.binding.datatypes.boolean, unicode_default=u'false')
    def owns (self):
        """Get the attribute value for owns."""
        return self.__owns.value(self)
    def setOwns (self, new_value):
        """Set the attribute value for owns.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__owns.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}arcrole uses Python identifier arcrole
    __arcrole = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'arcrole'), 'arcrole', '__TopoPrimitiveMemberType_httpwww_w3_org1999xlinkarcrole', pyxb.binding.datatypes.anyURI)
    def arcrole (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}arcrole."""
        return self.__arcrole.value(self)
    def setArcrole (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}arcrole.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__arcrole.set(self, new_value)
    
    # Attribute {http://www.opengis.net/gml}remoteSchema uses Python identifier remoteSchema
    __remoteSchema = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(Namespace, u'remoteSchema'), 'remoteSchema', '__TopoPrimitiveMemberType_httpwww_opengis_netgmlremoteSchema', pyxb.binding.datatypes.anyURI)
    def remoteSchema (self):
        """Get the attribute value for {http://www.opengis.net/gml}remoteSchema."""
        return self.__remoteSchema.value(self)
    def setRemoteSchema (self, new_value):
        """Set the attribute value for {http://www.opengis.net/gml}remoteSchema.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__remoteSchema.set(self, new_value)

    _ElementMap = {
        __AbstractTopoPrimitive.name() : __AbstractTopoPrimitive
    }
    _AttributeMap = {
        __actuate.name() : __actuate,
        __show.name() : __show,
        __type.name() : __type,
        __title.name() : __title,
        __role.name() : __role,
        __nilReason.name() : __nilReason,
        __href.name() : __href,
        __owns.name() : __owns,
        __arcrole.name() : __arcrole,
        __remoteSchema.name() : __remoteSchema
    }
Namespace.addCategoryObject('typeBinding', u'TopoPrimitiveMemberType', TopoPrimitiveMemberType)


# Complex type TopoSurfacePropertyType with content type ELEMENT_ONLY
class TopoSurfacePropertyType (pyxb.binding.basis.complexTypeDefinition):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'TopoSurfacePropertyType')
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.opengis.net/gml}TopoSurface uses Python identifier TopoSurface
    __TopoSurface = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'TopoSurface'), 'TopoSurface', '__TopoSurfacePropertyType_httpwww_opengis_netgmlTopoSurface', False)
    def TopoSurface (self):
        """Get the value of the {http://www.opengis.net/gml}TopoSurface element."""
        return self.__TopoSurface.value(self)
    def setTopoSurface (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}TopoSurface element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__TopoSurface.set(self, new_value)
    
    # Attribute owns uses Python identifier owns
    __owns = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'owns'), 'owns', '__TopoSurfacePropertyType_owns', pyxb.binding.datatypes.boolean, unicode_default=u'false')
    def owns (self):
        """Get the attribute value for owns."""
        return self.__owns.value(self)
    def setOwns (self, new_value):
        """Set the attribute value for owns.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__owns.set(self, new_value)

    _ElementMap = {
        __TopoSurface.name() : __TopoSurface
    }
    _AttributeMap = {
        __owns.name() : __owns
    }
Namespace.addCategoryObject('typeBinding', u'TopoSurfacePropertyType', TopoSurfacePropertyType)


# Complex type TopoVolumePropertyType with content type ELEMENT_ONLY
class TopoVolumePropertyType (pyxb.binding.basis.complexTypeDefinition):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'TopoVolumePropertyType')
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.opengis.net/gml}TopoVolume uses Python identifier TopoVolume
    __TopoVolume = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'TopoVolume'), 'TopoVolume', '__TopoVolumePropertyType_httpwww_opengis_netgmlTopoVolume', False)
    def TopoVolume (self):
        """Get the value of the {http://www.opengis.net/gml}TopoVolume element."""
        return self.__TopoVolume.value(self)
    def setTopoVolume (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}TopoVolume element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__TopoVolume.set(self, new_value)
    
    # Attribute owns uses Python identifier owns
    __owns = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'owns'), 'owns', '__TopoVolumePropertyType_owns', pyxb.binding.datatypes.boolean, unicode_default=u'false')
    def owns (self):
        """Get the attribute value for owns."""
        return self.__owns.value(self)
    def setOwns (self, new_value):
        """Set the attribute value for owns.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__owns.set(self, new_value)

    _ElementMap = {
        __TopoVolume.name() : __TopoVolume
    }
    _AttributeMap = {
        __owns.name() : __owns
    }
Namespace.addCategoryObject('typeBinding', u'TopoVolumePropertyType', TopoVolumePropertyType)


# Complex type TransformationPropertyType with content type ELEMENT_ONLY
class TransformationPropertyType (pyxb.binding.basis.complexTypeDefinition):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'TransformationPropertyType')
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.opengis.net/gml}Transformation uses Python identifier Transformation
    __Transformation = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'Transformation'), 'Transformation', '__TransformationPropertyType_httpwww_opengis_netgmlTransformation', False)
    def Transformation (self):
        """Get the value of the {http://www.opengis.net/gml}Transformation element."""
        return self.__Transformation.value(self)
    def setTransformation (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}Transformation element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__Transformation.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}type uses Python identifier type
    __type = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'type'), 'type', '__TransformationPropertyType_httpwww_w3_org1999xlinktype', pyxb.binding.datatypes.string, fixed=True, unicode_default=u'simple')
    def type (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}type."""
        return self.__type.value(self)
    def setType (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}type.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__type.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}show uses Python identifier show
    __show = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'show'), 'show', '__TransformationPropertyType_httpwww_w3_org1999xlinkshow', MODULEhttpwww_w3_org1999xlink.UNBOUNDNone_182)
    def show (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}show."""
        return self.__show.value(self)
    def setShow (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}show.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__show.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}title uses Python identifier title
    __title = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'title'), 'title', '__TransformationPropertyType_httpwww_w3_org1999xlinktitle', pyxb.binding.datatypes.string)
    def title (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}title."""
        return self.__title.value(self)
    def setTitle (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}title.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__title.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}role uses Python identifier role
    __role = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'role'), 'role', '__TransformationPropertyType_httpwww_w3_org1999xlinkrole', pyxb.binding.datatypes.anyURI)
    def role (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}role."""
        return self.__role.value(self)
    def setRole (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}role.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__role.set(self, new_value)
    
    # Attribute nilReason uses Python identifier nilReason
    __nilReason = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'nilReason'), 'nilReason', '__TransformationPropertyType_nilReason', NilReasonType)
    def nilReason (self):
        """Get the attribute value for nilReason."""
        return self.__nilReason.value(self)
    def setNilReason (self, new_value):
        """Set the attribute value for nilReason.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__nilReason.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}href uses Python identifier href
    __href = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'href'), 'href', '__TransformationPropertyType_httpwww_w3_org1999xlinkhref', pyxb.binding.datatypes.anyURI)
    def href (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}href."""
        return self.__href.value(self)
    def setHref (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}href.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__href.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}arcrole uses Python identifier arcrole
    __arcrole = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'arcrole'), 'arcrole', '__TransformationPropertyType_httpwww_w3_org1999xlinkarcrole', pyxb.binding.datatypes.anyURI)
    def arcrole (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}arcrole."""
        return self.__arcrole.value(self)
    def setArcrole (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}arcrole.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__arcrole.set(self, new_value)
    
    # Attribute {http://www.opengis.net/gml}remoteSchema uses Python identifier remoteSchema
    __remoteSchema = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(Namespace, u'remoteSchema'), 'remoteSchema', '__TransformationPropertyType_httpwww_opengis_netgmlremoteSchema', pyxb.binding.datatypes.anyURI)
    def remoteSchema (self):
        """Get the attribute value for {http://www.opengis.net/gml}remoteSchema."""
        return self.__remoteSchema.value(self)
    def setRemoteSchema (self, new_value):
        """Set the attribute value for {http://www.opengis.net/gml}remoteSchema.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__remoteSchema.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}actuate uses Python identifier actuate
    __actuate = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'actuate'), 'actuate', '__TransformationPropertyType_httpwww_w3_org1999xlinkactuate', MODULEhttpwww_w3_org1999xlink.UNBOUNDNone_183)
    def actuate (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}actuate."""
        return self.__actuate.value(self)
    def setActuate (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}actuate.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__actuate.set(self, new_value)

    _ElementMap = {
        __Transformation.name() : __Transformation
    }
    _AttributeMap = {
        __type.name() : __type,
        __show.name() : __show,
        __title.name() : __title,
        __role.name() : __role,
        __nilReason.name() : __nilReason,
        __href.name() : __href,
        __arcrole.name() : __arcrole,
        __remoteSchema.name() : __remoteSchema,
        __actuate.name() : __actuate
    }
Namespace.addCategoryObject('typeBinding', u'TransformationPropertyType', TransformationPropertyType)


# Complex type UnitOfMeasureType with content type EMPTY
class UnitOfMeasureType (pyxb.binding.basis.complexTypeDefinition):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_EMPTY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'UnitOfMeasureType')
    # Base type is pyxb.binding.datatypes.anyType
    
    # Attribute uom uses Python identifier uom
    __uom = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'uom'), 'uom', '__UnitOfMeasureType_uom', UomIdentifier, required=True)
    def uom (self):
        """Get the attribute value for uom."""
        return self.__uom.value(self)
    def setUom (self, new_value):
        """Set the attribute value for uom.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__uom.set(self, new_value)

    _ElementMap = {
        
    }
    _AttributeMap = {
        __uom.name() : __uom
    }
Namespace.addCategoryObject('typeBinding', u'UnitOfMeasureType', UnitOfMeasureType)


# Complex type UserDefinedCSPropertyType with content type ELEMENT_ONLY
class UserDefinedCSPropertyType (pyxb.binding.basis.complexTypeDefinition):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'UserDefinedCSPropertyType')
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.opengis.net/gml}UserDefinedCS uses Python identifier UserDefinedCS
    __UserDefinedCS = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'UserDefinedCS'), 'UserDefinedCS', '__UserDefinedCSPropertyType_httpwww_opengis_netgmlUserDefinedCS', False)
    def UserDefinedCS (self):
        """Get the value of the {http://www.opengis.net/gml}UserDefinedCS element."""
        return self.__UserDefinedCS.value(self)
    def setUserDefinedCS (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}UserDefinedCS element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__UserDefinedCS.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}role uses Python identifier role
    __role = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'role'), 'role', '__UserDefinedCSPropertyType_httpwww_w3_org1999xlinkrole', pyxb.binding.datatypes.anyURI)
    def role (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}role."""
        return self.__role.value(self)
    def setRole (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}role.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__role.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}show uses Python identifier show
    __show = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'show'), 'show', '__UserDefinedCSPropertyType_httpwww_w3_org1999xlinkshow', MODULEhttpwww_w3_org1999xlink.UNBOUNDNone_184)
    def show (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}show."""
        return self.__show.value(self)
    def setShow (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}show.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__show.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}href uses Python identifier href
    __href = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'href'), 'href', '__UserDefinedCSPropertyType_httpwww_w3_org1999xlinkhref', pyxb.binding.datatypes.anyURI)
    def href (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}href."""
        return self.__href.value(self)
    def setHref (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}href.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__href.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}arcrole uses Python identifier arcrole
    __arcrole = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'arcrole'), 'arcrole', '__UserDefinedCSPropertyType_httpwww_w3_org1999xlinkarcrole', pyxb.binding.datatypes.anyURI)
    def arcrole (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}arcrole."""
        return self.__arcrole.value(self)
    def setArcrole (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}arcrole.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__arcrole.set(self, new_value)
    
    # Attribute {http://www.opengis.net/gml}remoteSchema uses Python identifier remoteSchema
    __remoteSchema = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(Namespace, u'remoteSchema'), 'remoteSchema', '__UserDefinedCSPropertyType_httpwww_opengis_netgmlremoteSchema', pyxb.binding.datatypes.anyURI)
    def remoteSchema (self):
        """Get the attribute value for {http://www.opengis.net/gml}remoteSchema."""
        return self.__remoteSchema.value(self)
    def setRemoteSchema (self, new_value):
        """Set the attribute value for {http://www.opengis.net/gml}remoteSchema.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__remoteSchema.set(self, new_value)
    
    # Attribute nilReason uses Python identifier nilReason
    __nilReason = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'nilReason'), 'nilReason', '__UserDefinedCSPropertyType_nilReason', NilReasonType)
    def nilReason (self):
        """Get the attribute value for nilReason."""
        return self.__nilReason.value(self)
    def setNilReason (self, new_value):
        """Set the attribute value for nilReason.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__nilReason.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}actuate uses Python identifier actuate
    __actuate = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'actuate'), 'actuate', '__UserDefinedCSPropertyType_httpwww_w3_org1999xlinkactuate', MODULEhttpwww_w3_org1999xlink.UNBOUNDNone_185)
    def actuate (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}actuate."""
        return self.__actuate.value(self)
    def setActuate (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}actuate.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__actuate.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}type uses Python identifier type
    __type = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'type'), 'type', '__UserDefinedCSPropertyType_httpwww_w3_org1999xlinktype', pyxb.binding.datatypes.string, fixed=True, unicode_default=u'simple')
    def type (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}type."""
        return self.__type.value(self)
    def setType (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}type.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__type.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}title uses Python identifier title
    __title = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'title'), 'title', '__UserDefinedCSPropertyType_httpwww_w3_org1999xlinktitle', pyxb.binding.datatypes.string)
    def title (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}title."""
        return self.__title.value(self)
    def setTitle (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}title.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__title.set(self, new_value)

    _ElementMap = {
        __UserDefinedCS.name() : __UserDefinedCS
    }
    _AttributeMap = {
        __role.name() : __role,
        __show.name() : __show,
        __href.name() : __href,
        __arcrole.name() : __arcrole,
        __remoteSchema.name() : __remoteSchema,
        __nilReason.name() : __nilReason,
        __actuate.name() : __actuate,
        __type.name() : __type,
        __title.name() : __title
    }
Namespace.addCategoryObject('typeBinding', u'UserDefinedCSPropertyType', UserDefinedCSPropertyType)


# Complex type ValueArrayPropertyType with content type ELEMENT_ONLY
class ValueArrayPropertyType (pyxb.binding.basis.complexTypeDefinition):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'ValueArrayPropertyType')
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.opengis.net/gml}AbstractTimeObject uses Python identifier AbstractTimeObject
    __AbstractTimeObject = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'AbstractTimeObject'), 'AbstractTimeObject', '__ValueArrayPropertyType_httpwww_opengis_netgmlAbstractTimeObject', True)
    def AbstractTimeObject (self):
        """Get the value of the {http://www.opengis.net/gml}AbstractTimeObject element."""
        return self.__AbstractTimeObject.value(self)
    def setAbstractTimeObject (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}AbstractTimeObject element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__AbstractTimeObject.set(self, new_value)
    
    def addAbstractTimeObject (self, new_value):
        """Add the value as another occurrence of the {http://www.opengis.net/gml}AbstractTimeObject element.  Raises
        BadValueTypeException if the new value is not consistent with the
        element's type."""
        return self.__AbstractTimeObject.append(self, new_value)
    
    # Element {http://www.opengis.net/gml}Null uses Python identifier Null
    __Null = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'Null'), 'Null', '__ValueArrayPropertyType_httpwww_opengis_netgmlNull', True)
    def Null (self):
        """Get the value of the {http://www.opengis.net/gml}Null element."""
        return self.__Null.value(self)
    def setNull (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}Null element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__Null.set(self, new_value)
    
    def addNull (self, new_value):
        """Add the value as another occurrence of the {http://www.opengis.net/gml}Null element.  Raises
        BadValueTypeException if the new value is not consistent with the
        element's type."""
        return self.__Null.append(self, new_value)
    
    # Element {http://www.opengis.net/gml}AbstractValue uses Python identifier AbstractValue
    __AbstractValue = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'AbstractValue'), 'AbstractValue', '__ValueArrayPropertyType_httpwww_opengis_netgmlAbstractValue', True)
    def AbstractValue (self):
        """Get the value of the {http://www.opengis.net/gml}AbstractValue element."""
        return self.__AbstractValue.value(self)
    def setAbstractValue (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}AbstractValue element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__AbstractValue.set(self, new_value)
    
    def addAbstractValue (self, new_value):
        """Add the value as another occurrence of the {http://www.opengis.net/gml}AbstractValue element.  Raises
        BadValueTypeException if the new value is not consistent with the
        element's type."""
        return self.__AbstractValue.append(self, new_value)
    
    # Element {http://www.opengis.net/gml}AbstractGeometry uses Python identifier AbstractGeometry
    __AbstractGeometry = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'AbstractGeometry'), 'AbstractGeometry', '__ValueArrayPropertyType_httpwww_opengis_netgmlAbstractGeometry', True)
    def AbstractGeometry (self):
        """Get the value of the {http://www.opengis.net/gml}AbstractGeometry element."""
        return self.__AbstractGeometry.value(self)
    def setAbstractGeometry (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}AbstractGeometry element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__AbstractGeometry.set(self, new_value)
    
    def addAbstractGeometry (self, new_value):
        """Add the value as another occurrence of the {http://www.opengis.net/gml}AbstractGeometry element.  Raises
        BadValueTypeException if the new value is not consistent with the
        element's type."""
        return self.__AbstractGeometry.append(self, new_value)
    
    # Attribute owns uses Python identifier owns
    __owns = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'owns'), 'owns', '__ValueArrayPropertyType_owns', pyxb.binding.datatypes.boolean, unicode_default=u'false')
    def owns (self):
        """Get the attribute value for owns."""
        return self.__owns.value(self)
    def setOwns (self, new_value):
        """Set the attribute value for owns.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__owns.set(self, new_value)

    _ElementMap = {
        __AbstractTimeObject.name() : __AbstractTimeObject,
        __Null.name() : __Null,
        __AbstractValue.name() : __AbstractValue,
        __AbstractGeometry.name() : __AbstractGeometry
    }
    _AttributeMap = {
        __owns.name() : __owns
    }
Namespace.addCategoryObject('typeBinding', u'ValueArrayPropertyType', ValueArrayPropertyType)


# Complex type ValuePropertyType with content type ELEMENT_ONLY
class ValuePropertyType (pyxb.binding.basis.complexTypeDefinition):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'ValuePropertyType')
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.opengis.net/gml}AbstractGeometry uses Python identifier AbstractGeometry
    __AbstractGeometry = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'AbstractGeometry'), 'AbstractGeometry', '__ValuePropertyType_httpwww_opengis_netgmlAbstractGeometry', False)
    def AbstractGeometry (self):
        """Get the value of the {http://www.opengis.net/gml}AbstractGeometry element."""
        return self.__AbstractGeometry.value(self)
    def setAbstractGeometry (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}AbstractGeometry element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__AbstractGeometry.set(self, new_value)
    
    # Element {http://www.opengis.net/gml}Null uses Python identifier Null
    __Null = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'Null'), 'Null', '__ValuePropertyType_httpwww_opengis_netgmlNull', False)
    def Null (self):
        """Get the value of the {http://www.opengis.net/gml}Null element."""
        return self.__Null.value(self)
    def setNull (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}Null element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__Null.set(self, new_value)
    
    # Element {http://www.opengis.net/gml}AbstractValue uses Python identifier AbstractValue
    __AbstractValue = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'AbstractValue'), 'AbstractValue', '__ValuePropertyType_httpwww_opengis_netgmlAbstractValue', False)
    def AbstractValue (self):
        """Get the value of the {http://www.opengis.net/gml}AbstractValue element."""
        return self.__AbstractValue.value(self)
    def setAbstractValue (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}AbstractValue element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__AbstractValue.set(self, new_value)
    
    # Element {http://www.opengis.net/gml}AbstractTimeObject uses Python identifier AbstractTimeObject
    __AbstractTimeObject = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'AbstractTimeObject'), 'AbstractTimeObject', '__ValuePropertyType_httpwww_opengis_netgmlAbstractTimeObject', False)
    def AbstractTimeObject (self):
        """Get the value of the {http://www.opengis.net/gml}AbstractTimeObject element."""
        return self.__AbstractTimeObject.value(self)
    def setAbstractTimeObject (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}AbstractTimeObject element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__AbstractTimeObject.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}show uses Python identifier show
    __show = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'show'), 'show', '__ValuePropertyType_httpwww_w3_org1999xlinkshow', MODULEhttpwww_w3_org1999xlink.UNBOUNDNone_186)
    def show (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}show."""
        return self.__show.value(self)
    def setShow (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}show.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__show.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}title uses Python identifier title
    __title = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'title'), 'title', '__ValuePropertyType_httpwww_w3_org1999xlinktitle', pyxb.binding.datatypes.string)
    def title (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}title."""
        return self.__title.value(self)
    def setTitle (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}title.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__title.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}role uses Python identifier role
    __role = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'role'), 'role', '__ValuePropertyType_httpwww_w3_org1999xlinkrole', pyxb.binding.datatypes.anyURI)
    def role (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}role."""
        return self.__role.value(self)
    def setRole (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}role.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__role.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}href uses Python identifier href
    __href = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'href'), 'href', '__ValuePropertyType_httpwww_w3_org1999xlinkhref', pyxb.binding.datatypes.anyURI)
    def href (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}href."""
        return self.__href.value(self)
    def setHref (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}href.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__href.set(self, new_value)
    
    # Attribute owns uses Python identifier owns
    __owns = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'owns'), 'owns', '__ValuePropertyType_owns', pyxb.binding.datatypes.boolean, unicode_default=u'false')
    def owns (self):
        """Get the attribute value for owns."""
        return self.__owns.value(self)
    def setOwns (self, new_value):
        """Set the attribute value for owns.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__owns.set(self, new_value)
    
    # Attribute nilReason uses Python identifier nilReason
    __nilReason = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'nilReason'), 'nilReason', '__ValuePropertyType_nilReason', NilReasonType)
    def nilReason (self):
        """Get the attribute value for nilReason."""
        return self.__nilReason.value(self)
    def setNilReason (self, new_value):
        """Set the attribute value for nilReason.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__nilReason.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}arcrole uses Python identifier arcrole
    __arcrole = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'arcrole'), 'arcrole', '__ValuePropertyType_httpwww_w3_org1999xlinkarcrole', pyxb.binding.datatypes.anyURI)
    def arcrole (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}arcrole."""
        return self.__arcrole.value(self)
    def setArcrole (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}arcrole.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__arcrole.set(self, new_value)
    
    # Attribute {http://www.opengis.net/gml}remoteSchema uses Python identifier remoteSchema
    __remoteSchema = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(Namespace, u'remoteSchema'), 'remoteSchema', '__ValuePropertyType_httpwww_opengis_netgmlremoteSchema', pyxb.binding.datatypes.anyURI)
    def remoteSchema (self):
        """Get the attribute value for {http://www.opengis.net/gml}remoteSchema."""
        return self.__remoteSchema.value(self)
    def setRemoteSchema (self, new_value):
        """Set the attribute value for {http://www.opengis.net/gml}remoteSchema.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__remoteSchema.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}actuate uses Python identifier actuate
    __actuate = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'actuate'), 'actuate', '__ValuePropertyType_httpwww_w3_org1999xlinkactuate', MODULEhttpwww_w3_org1999xlink.UNBOUNDNone_187)
    def actuate (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}actuate."""
        return self.__actuate.value(self)
    def setActuate (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}actuate.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__actuate.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}type uses Python identifier type
    __type = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'type'), 'type', '__ValuePropertyType_httpwww_w3_org1999xlinktype', pyxb.binding.datatypes.string, fixed=True, unicode_default=u'simple')
    def type (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}type."""
        return self.__type.value(self)
    def setType (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}type.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__type.set(self, new_value)

    _ElementMap = {
        __AbstractGeometry.name() : __AbstractGeometry,
        __Null.name() : __Null,
        __AbstractValue.name() : __AbstractValue,
        __AbstractTimeObject.name() : __AbstractTimeObject
    }
    _AttributeMap = {
        __show.name() : __show,
        __title.name() : __title,
        __role.name() : __role,
        __href.name() : __href,
        __owns.name() : __owns,
        __nilReason.name() : __nilReason,
        __arcrole.name() : __arcrole,
        __remoteSchema.name() : __remoteSchema,
        __actuate.name() : __actuate,
        __type.name() : __type
    }
Namespace.addCategoryObject('typeBinding', u'ValuePropertyType', ValuePropertyType)


# Complex type VerticalCRSPropertyType with content type ELEMENT_ONLY
class VerticalCRSPropertyType (pyxb.binding.basis.complexTypeDefinition):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'VerticalCRSPropertyType')
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.opengis.net/gml}VerticalCRS uses Python identifier VerticalCRS
    __VerticalCRS = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'VerticalCRS'), 'VerticalCRS', '__VerticalCRSPropertyType_httpwww_opengis_netgmlVerticalCRS', False)
    def VerticalCRS (self):
        """Get the value of the {http://www.opengis.net/gml}VerticalCRS element."""
        return self.__VerticalCRS.value(self)
    def setVerticalCRS (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}VerticalCRS element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__VerticalCRS.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}actuate uses Python identifier actuate
    __actuate = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'actuate'), 'actuate', '__VerticalCRSPropertyType_httpwww_w3_org1999xlinkactuate', MODULEhttpwww_w3_org1999xlink.UNBOUNDNone_188)
    def actuate (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}actuate."""
        return self.__actuate.value(self)
    def setActuate (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}actuate.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__actuate.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}show uses Python identifier show
    __show = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'show'), 'show', '__VerticalCRSPropertyType_httpwww_w3_org1999xlinkshow', MODULEhttpwww_w3_org1999xlink.UNBOUNDNone_189)
    def show (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}show."""
        return self.__show.value(self)
    def setShow (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}show.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__show.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}href uses Python identifier href
    __href = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'href'), 'href', '__VerticalCRSPropertyType_httpwww_w3_org1999xlinkhref', pyxb.binding.datatypes.anyURI)
    def href (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}href."""
        return self.__href.value(self)
    def setHref (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}href.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__href.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}arcrole uses Python identifier arcrole
    __arcrole = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'arcrole'), 'arcrole', '__VerticalCRSPropertyType_httpwww_w3_org1999xlinkarcrole', pyxb.binding.datatypes.anyURI)
    def arcrole (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}arcrole."""
        return self.__arcrole.value(self)
    def setArcrole (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}arcrole.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__arcrole.set(self, new_value)
    
    # Attribute {http://www.opengis.net/gml}remoteSchema uses Python identifier remoteSchema
    __remoteSchema = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(Namespace, u'remoteSchema'), 'remoteSchema', '__VerticalCRSPropertyType_httpwww_opengis_netgmlremoteSchema', pyxb.binding.datatypes.anyURI)
    def remoteSchema (self):
        """Get the attribute value for {http://www.opengis.net/gml}remoteSchema."""
        return self.__remoteSchema.value(self)
    def setRemoteSchema (self, new_value):
        """Set the attribute value for {http://www.opengis.net/gml}remoteSchema.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__remoteSchema.set(self, new_value)
    
    # Attribute nilReason uses Python identifier nilReason
    __nilReason = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'nilReason'), 'nilReason', '__VerticalCRSPropertyType_nilReason', NilReasonType)
    def nilReason (self):
        """Get the attribute value for nilReason."""
        return self.__nilReason.value(self)
    def setNilReason (self, new_value):
        """Set the attribute value for nilReason.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__nilReason.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}type uses Python identifier type
    __type = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'type'), 'type', '__VerticalCRSPropertyType_httpwww_w3_org1999xlinktype', pyxb.binding.datatypes.string, fixed=True, unicode_default=u'simple')
    def type (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}type."""
        return self.__type.value(self)
    def setType (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}type.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__type.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}title uses Python identifier title
    __title = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'title'), 'title', '__VerticalCRSPropertyType_httpwww_w3_org1999xlinktitle', pyxb.binding.datatypes.string)
    def title (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}title."""
        return self.__title.value(self)
    def setTitle (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}title.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__title.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}role uses Python identifier role
    __role = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'role'), 'role', '__VerticalCRSPropertyType_httpwww_w3_org1999xlinkrole', pyxb.binding.datatypes.anyURI)
    def role (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}role."""
        return self.__role.value(self)
    def setRole (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}role.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__role.set(self, new_value)

    _ElementMap = {
        __VerticalCRS.name() : __VerticalCRS
    }
    _AttributeMap = {
        __actuate.name() : __actuate,
        __show.name() : __show,
        __href.name() : __href,
        __arcrole.name() : __arcrole,
        __remoteSchema.name() : __remoteSchema,
        __nilReason.name() : __nilReason,
        __type.name() : __type,
        __title.name() : __title,
        __role.name() : __role
    }
Namespace.addCategoryObject('typeBinding', u'VerticalCRSPropertyType', VerticalCRSPropertyType)


# Complex type VerticalCSPropertyType with content type ELEMENT_ONLY
class VerticalCSPropertyType (pyxb.binding.basis.complexTypeDefinition):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'VerticalCSPropertyType')
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.opengis.net/gml}VerticalCS uses Python identifier VerticalCS
    __VerticalCS = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'VerticalCS'), 'VerticalCS', '__VerticalCSPropertyType_httpwww_opengis_netgmlVerticalCS', False)
    def VerticalCS (self):
        """Get the value of the {http://www.opengis.net/gml}VerticalCS element."""
        return self.__VerticalCS.value(self)
    def setVerticalCS (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}VerticalCS element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__VerticalCS.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}show uses Python identifier show
    __show = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'show'), 'show', '__VerticalCSPropertyType_httpwww_w3_org1999xlinkshow', MODULEhttpwww_w3_org1999xlink.UNBOUNDNone_190)
    def show (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}show."""
        return self.__show.value(self)
    def setShow (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}show.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__show.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}href uses Python identifier href
    __href = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'href'), 'href', '__VerticalCSPropertyType_httpwww_w3_org1999xlinkhref', pyxb.binding.datatypes.anyURI)
    def href (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}href."""
        return self.__href.value(self)
    def setHref (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}href.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__href.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}arcrole uses Python identifier arcrole
    __arcrole = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'arcrole'), 'arcrole', '__VerticalCSPropertyType_httpwww_w3_org1999xlinkarcrole', pyxb.binding.datatypes.anyURI)
    def arcrole (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}arcrole."""
        return self.__arcrole.value(self)
    def setArcrole (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}arcrole.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__arcrole.set(self, new_value)
    
    # Attribute {http://www.opengis.net/gml}remoteSchema uses Python identifier remoteSchema
    __remoteSchema = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(Namespace, u'remoteSchema'), 'remoteSchema', '__VerticalCSPropertyType_httpwww_opengis_netgmlremoteSchema', pyxb.binding.datatypes.anyURI)
    def remoteSchema (self):
        """Get the attribute value for {http://www.opengis.net/gml}remoteSchema."""
        return self.__remoteSchema.value(self)
    def setRemoteSchema (self, new_value):
        """Set the attribute value for {http://www.opengis.net/gml}remoteSchema.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__remoteSchema.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}actuate uses Python identifier actuate
    __actuate = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'actuate'), 'actuate', '__VerticalCSPropertyType_httpwww_w3_org1999xlinkactuate', MODULEhttpwww_w3_org1999xlink.UNBOUNDNone_191)
    def actuate (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}actuate."""
        return self.__actuate.value(self)
    def setActuate (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}actuate.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__actuate.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}type uses Python identifier type
    __type = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'type'), 'type', '__VerticalCSPropertyType_httpwww_w3_org1999xlinktype', pyxb.binding.datatypes.string, fixed=True, unicode_default=u'simple')
    def type (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}type."""
        return self.__type.value(self)
    def setType (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}type.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__type.set(self, new_value)
    
    # Attribute nilReason uses Python identifier nilReason
    __nilReason = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'nilReason'), 'nilReason', '__VerticalCSPropertyType_nilReason', NilReasonType)
    def nilReason (self):
        """Get the attribute value for nilReason."""
        return self.__nilReason.value(self)
    def setNilReason (self, new_value):
        """Set the attribute value for nilReason.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__nilReason.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}title uses Python identifier title
    __title = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'title'), 'title', '__VerticalCSPropertyType_httpwww_w3_org1999xlinktitle', pyxb.binding.datatypes.string)
    def title (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}title."""
        return self.__title.value(self)
    def setTitle (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}title.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__title.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}role uses Python identifier role
    __role = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'role'), 'role', '__VerticalCSPropertyType_httpwww_w3_org1999xlinkrole', pyxb.binding.datatypes.anyURI)
    def role (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}role."""
        return self.__role.value(self)
    def setRole (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}role.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__role.set(self, new_value)

    _ElementMap = {
        __VerticalCS.name() : __VerticalCS
    }
    _AttributeMap = {
        __show.name() : __show,
        __href.name() : __href,
        __arcrole.name() : __arcrole,
        __remoteSchema.name() : __remoteSchema,
        __actuate.name() : __actuate,
        __type.name() : __type,
        __nilReason.name() : __nilReason,
        __title.name() : __title,
        __role.name() : __role
    }
Namespace.addCategoryObject('typeBinding', u'VerticalCSPropertyType', VerticalCSPropertyType)


# Complex type VerticalDatumPropertyType with content type ELEMENT_ONLY
class VerticalDatumPropertyType (pyxb.binding.basis.complexTypeDefinition):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'VerticalDatumPropertyType')
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.opengis.net/gml}VerticalDatum uses Python identifier VerticalDatum
    __VerticalDatum = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'VerticalDatum'), 'VerticalDatum', '__VerticalDatumPropertyType_httpwww_opengis_netgmlVerticalDatum', False)
    def VerticalDatum (self):
        """Get the value of the {http://www.opengis.net/gml}VerticalDatum element."""
        return self.__VerticalDatum.value(self)
    def setVerticalDatum (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}VerticalDatum element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__VerticalDatum.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}role uses Python identifier role
    __role = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'role'), 'role', '__VerticalDatumPropertyType_httpwww_w3_org1999xlinkrole', pyxb.binding.datatypes.anyURI)
    def role (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}role."""
        return self.__role.value(self)
    def setRole (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}role.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__role.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}show uses Python identifier show
    __show = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'show'), 'show', '__VerticalDatumPropertyType_httpwww_w3_org1999xlinkshow', MODULEhttpwww_w3_org1999xlink.UNBOUNDNone_192)
    def show (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}show."""
        return self.__show.value(self)
    def setShow (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}show.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__show.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}href uses Python identifier href
    __href = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'href'), 'href', '__VerticalDatumPropertyType_httpwww_w3_org1999xlinkhref', pyxb.binding.datatypes.anyURI)
    def href (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}href."""
        return self.__href.value(self)
    def setHref (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}href.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__href.set(self, new_value)
    
    # Attribute {http://www.opengis.net/gml}remoteSchema uses Python identifier remoteSchema
    __remoteSchema = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(Namespace, u'remoteSchema'), 'remoteSchema', '__VerticalDatumPropertyType_httpwww_opengis_netgmlremoteSchema', pyxb.binding.datatypes.anyURI)
    def remoteSchema (self):
        """Get the attribute value for {http://www.opengis.net/gml}remoteSchema."""
        return self.__remoteSchema.value(self)
    def setRemoteSchema (self, new_value):
        """Set the attribute value for {http://www.opengis.net/gml}remoteSchema.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__remoteSchema.set(self, new_value)
    
    # Attribute nilReason uses Python identifier nilReason
    __nilReason = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'nilReason'), 'nilReason', '__VerticalDatumPropertyType_nilReason', NilReasonType)
    def nilReason (self):
        """Get the attribute value for nilReason."""
        return self.__nilReason.value(self)
    def setNilReason (self, new_value):
        """Set the attribute value for nilReason.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__nilReason.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}type uses Python identifier type
    __type = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'type'), 'type', '__VerticalDatumPropertyType_httpwww_w3_org1999xlinktype', pyxb.binding.datatypes.string, fixed=True, unicode_default=u'simple')
    def type (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}type."""
        return self.__type.value(self)
    def setType (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}type.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__type.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}actuate uses Python identifier actuate
    __actuate = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'actuate'), 'actuate', '__VerticalDatumPropertyType_httpwww_w3_org1999xlinkactuate', MODULEhttpwww_w3_org1999xlink.UNBOUNDNone_193)
    def actuate (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}actuate."""
        return self.__actuate.value(self)
    def setActuate (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}actuate.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__actuate.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}title uses Python identifier title
    __title = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'title'), 'title', '__VerticalDatumPropertyType_httpwww_w3_org1999xlinktitle', pyxb.binding.datatypes.string)
    def title (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}title."""
        return self.__title.value(self)
    def setTitle (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}title.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__title.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}arcrole uses Python identifier arcrole
    __arcrole = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'arcrole'), 'arcrole', '__VerticalDatumPropertyType_httpwww_w3_org1999xlinkarcrole', pyxb.binding.datatypes.anyURI)
    def arcrole (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}arcrole."""
        return self.__arcrole.value(self)
    def setArcrole (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}arcrole.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__arcrole.set(self, new_value)

    _ElementMap = {
        __VerticalDatum.name() : __VerticalDatum
    }
    _AttributeMap = {
        __role.name() : __role,
        __show.name() : __show,
        __href.name() : __href,
        __remoteSchema.name() : __remoteSchema,
        __nilReason.name() : __nilReason,
        __type.name() : __type,
        __actuate.name() : __actuate,
        __title.name() : __title,
        __arcrole.name() : __arcrole
    }
Namespace.addCategoryObject('typeBinding', u'VerticalDatumPropertyType', VerticalDatumPropertyType)


# Complex type _CTD_ANON_27 with content type SIMPLE
class _CTD_ANON_27 (MeasureType):
    _TypeDefinition = pyxb.binding.datatypes.double
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_SIMPLE
    _Abstract = False
    _ExpandedName = None
    # Base type is MeasureType
    
    # Attribute nilReason uses Python identifier nilReason
    __nilReason = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'nilReason'), 'nilReason', '__CTD_ANON_27_nilReason', NilReasonType)
    def nilReason (self):
        """Get the attribute value for nilReason."""
        return self.__nilReason.value(self)
    def setNilReason (self, new_value):
        """Set the attribute value for nilReason.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__nilReason.set(self, new_value)
    
    # Attribute uom inherited from {http://www.opengis.net/gml}MeasureType

    _ElementMap = MeasureType._ElementMap.copy()
    _ElementMap.update({
        
    })
    _AttributeMap = MeasureType._AttributeMap.copy()
    _AttributeMap.update({
        __nilReason.name() : __nilReason
    })



# Complex type _CTD_ANON_26 with content type SIMPLE
class _CTD_ANON_26 (CodeType):
    _TypeDefinition = pyxb.binding.datatypes.string
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_SIMPLE
    _Abstract = False
    _ExpandedName = None
    # Base type is CodeType
    
    # Attribute nilReason uses Python identifier nilReason
    __nilReason = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'nilReason'), 'nilReason', '__CTD_ANON_26_nilReason', NilReasonType)
    def nilReason (self):
        """Get the attribute value for nilReason."""
        return self.__nilReason.value(self)
    def setNilReason (self, new_value):
        """Set the attribute value for nilReason.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__nilReason.set(self, new_value)
    
    # Attribute codeSpace inherited from {http://www.opengis.net/gml}CodeType

    _ElementMap = CodeType._ElementMap.copy()
    _ElementMap.update({
        
    })
    _AttributeMap = CodeType._AttributeMap.copy()
    _AttributeMap.update({
        __nilReason.name() : __nilReason
    })



# Complex type AbstractFeatureType with content type ELEMENT_ONLY
class AbstractFeatureType (AbstractGMLType):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = True
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'AbstractFeatureType')
    # Base type is AbstractGMLType
    
    # Element descriptionReference inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element name inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element {http://www.opengis.net/gml}boundedBy uses Python identifier boundedBy
    __boundedBy = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'boundedBy'), 'boundedBy', '__AbstractFeatureType_httpwww_opengis_netgmlboundedBy', False)
    def boundedBy (self):
        """Get the value of the {http://www.opengis.net/gml}boundedBy element."""
        return self.__boundedBy.value(self)
    def setBoundedBy (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}boundedBy element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__boundedBy.set(self, new_value)
    
    # Element identifier inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element {http://www.opengis.net/gml}location uses Python identifier location
    __location = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'location'), 'location', '__AbstractFeatureType_httpwww_opengis_netgmllocation', False)
    def location (self):
        """Get the value of the {http://www.opengis.net/gml}location element."""
        return self.__location.value(self)
    def setLocation (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}location element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__location.set(self, new_value)
    
    # Element description inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element metaDataProperty inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Attribute id inherited from {http://www.opengis.net/gml}AbstractGMLType

    _ElementMap = AbstractGMLType._ElementMap.copy()
    _ElementMap.update({
        __boundedBy.name() : __boundedBy,
        __location.name() : __location
    })
    _AttributeMap = AbstractGMLType._AttributeMap.copy()
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', u'AbstractFeatureType', AbstractFeatureType)


# Complex type AbstractGeometryType with content type ELEMENT_ONLY
class AbstractGeometryType (AbstractGMLType):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = True
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'AbstractGeometryType')
    # Base type is AbstractGMLType
    
    # Element descriptionReference inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element name inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element identifier inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element metaDataProperty inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element description inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Attribute srsName uses Python identifier srsName
    __srsName = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'srsName'), 'srsName', '__AbstractGeometryType_srsName', pyxb.binding.datatypes.anyURI)
    def srsName (self):
        """Get the attribute value for srsName."""
        return self.__srsName.value(self)
    def setSrsName (self, new_value):
        """Set the attribute value for srsName.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__srsName.set(self, new_value)
    
    # Attribute axisLabels uses Python identifier axisLabels
    __axisLabels = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'axisLabels'), 'axisLabels', '__AbstractGeometryType_axisLabels', NCNameList)
    def axisLabels (self):
        """Get the attribute value for axisLabels."""
        return self.__axisLabels.value(self)
    def setAxisLabels (self, new_value):
        """Set the attribute value for axisLabels.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__axisLabels.set(self, new_value)
    
    # Attribute id inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Attribute uomLabels uses Python identifier uomLabels
    __uomLabels = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'uomLabels'), 'uomLabels', '__AbstractGeometryType_uomLabels', NCNameList)
    def uomLabels (self):
        """Get the attribute value for uomLabels."""
        return self.__uomLabels.value(self)
    def setUomLabels (self, new_value):
        """Set the attribute value for uomLabels.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__uomLabels.set(self, new_value)
    
    # Attribute srsDimension uses Python identifier srsDimension
    __srsDimension = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'srsDimension'), 'srsDimension', '__AbstractGeometryType_srsDimension', pyxb.binding.datatypes.positiveInteger)
    def srsDimension (self):
        """Get the attribute value for srsDimension."""
        return self.__srsDimension.value(self)
    def setSrsDimension (self, new_value):
        """Set the attribute value for srsDimension.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__srsDimension.set(self, new_value)

    _ElementMap = AbstractGMLType._ElementMap.copy()
    _ElementMap.update({
        
    })
    _AttributeMap = AbstractGMLType._AttributeMap.copy()
    _AttributeMap.update({
        __srsName.name() : __srsName,
        __axisLabels.name() : __axisLabels,
        __uomLabels.name() : __uomLabels,
        __srsDimension.name() : __srsDimension
    })
Namespace.addCategoryObject('typeBinding', u'AbstractGeometryType', AbstractGeometryType)


# Complex type AbstractParametricCurveSurfaceType with content type EMPTY
class AbstractParametricCurveSurfaceType (AbstractSurfacePatchType):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_EMPTY
    _Abstract = True
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'AbstractParametricCurveSurfaceType')
    # Base type is AbstractSurfacePatchType
    
    # Attribute aggregationType uses Python identifier aggregationType
    __aggregationType = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'aggregationType'), 'aggregationType', '__AbstractParametricCurveSurfaceType_aggregationType', AggregationType)
    def aggregationType (self):
        """Get the attribute value for aggregationType."""
        return self.__aggregationType.value(self)
    def setAggregationType (self, new_value):
        """Set the attribute value for aggregationType.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__aggregationType.set(self, new_value)

    _ElementMap = AbstractSurfacePatchType._ElementMap.copy()
    _ElementMap.update({
        
    })
    _AttributeMap = AbstractSurfacePatchType._AttributeMap.copy()
    _AttributeMap.update({
        __aggregationType.name() : __aggregationType
    })
Namespace.addCategoryObject('typeBinding', u'AbstractParametricCurveSurfaceType', AbstractParametricCurveSurfaceType)


# Complex type AbstractTimeObjectType with content type ELEMENT_ONLY
class AbstractTimeObjectType (AbstractGMLType):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = True
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'AbstractTimeObjectType')
    # Base type is AbstractGMLType
    
    # Element descriptionReference inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element name inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element identifier inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element metaDataProperty inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element description inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Attribute id inherited from {http://www.opengis.net/gml}AbstractGMLType

    _ElementMap = AbstractGMLType._ElementMap.copy()
    _ElementMap.update({
        
    })
    _AttributeMap = AbstractGMLType._AttributeMap.copy()
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', u'AbstractTimeObjectType', AbstractTimeObjectType)


# Complex type AbstractTimeSliceType with content type ELEMENT_ONLY
class AbstractTimeSliceType (AbstractGMLType):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = True
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'AbstractTimeSliceType')
    # Base type is AbstractGMLType
    
    # Element descriptionReference inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element description inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element {http://www.opengis.net/gml}validTime uses Python identifier validTime
    __validTime = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'validTime'), 'validTime', '__AbstractTimeSliceType_httpwww_opengis_netgmlvalidTime', False)
    def validTime (self):
        """Get the value of the {http://www.opengis.net/gml}validTime element."""
        return self.__validTime.value(self)
    def setValidTime (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}validTime element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__validTime.set(self, new_value)
    
    # Element identifier inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element {http://www.opengis.net/gml}dataSource uses Python identifier dataSource
    __dataSource = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'dataSource'), 'dataSource', '__AbstractTimeSliceType_httpwww_opengis_netgmldataSource', False)
    def dataSource (self):
        """Get the value of the {http://www.opengis.net/gml}dataSource element."""
        return self.__dataSource.value(self)
    def setDataSource (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}dataSource element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__dataSource.set(self, new_value)
    
    # Element name inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element metaDataProperty inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Attribute id inherited from {http://www.opengis.net/gml}AbstractGMLType

    _ElementMap = AbstractGMLType._ElementMap.copy()
    _ElementMap.update({
        __validTime.name() : __validTime,
        __dataSource.name() : __dataSource
    })
    _AttributeMap = AbstractGMLType._AttributeMap.copy()
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', u'AbstractTimeSliceType', AbstractTimeSliceType)


# Complex type AbstractTopologyType with content type ELEMENT_ONLY
class AbstractTopologyType (AbstractGMLType):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = True
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'AbstractTopologyType')
    # Base type is AbstractGMLType
    
    # Element descriptionReference inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element name inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element identifier inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element metaDataProperty inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element description inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Attribute id inherited from {http://www.opengis.net/gml}AbstractGMLType

    _ElementMap = AbstractGMLType._ElementMap.copy()
    _ElementMap.update({
        
    })
    _AttributeMap = AbstractGMLType._AttributeMap.copy()
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', u'AbstractTopologyType', AbstractTopologyType)


# Complex type AngleType with content type SIMPLE
class AngleType (MeasureType):
    _TypeDefinition = pyxb.binding.datatypes.double
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_SIMPLE
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'AngleType')
    # Base type is MeasureType
    
    # Attribute uom inherited from {http://www.opengis.net/gml}MeasureType

    _ElementMap = MeasureType._ElementMap.copy()
    _ElementMap.update({
        
    })
    _AttributeMap = MeasureType._AttributeMap.copy()
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', u'AngleType', AngleType)


# Complex type ArcByCenterPointType with content type ELEMENT_ONLY
class ArcByCenterPointType (AbstractCurveSegmentType):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'ArcByCenterPointType')
    # Base type is AbstractCurveSegmentType
    
    # Element {http://www.opengis.net/gml}endAngle uses Python identifier endAngle
    __endAngle = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'endAngle'), 'endAngle', '__ArcByCenterPointType_httpwww_opengis_netgmlendAngle', True)
    def endAngle (self):
        """Get the value of the {http://www.opengis.net/gml}endAngle element."""
        return self.__endAngle.value(self)
    def setEndAngle (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}endAngle element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__endAngle.set(self, new_value)
    
    def addEndAngle (self, new_value):
        """Add the value as another occurrence of the {http://www.opengis.net/gml}endAngle element.  Raises
        BadValueTypeException if the new value is not consistent with the
        element's type."""
        return self.__endAngle.append(self, new_value)
    
    # Element {http://www.opengis.net/gml}startAngle uses Python identifier startAngle
    __startAngle = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'startAngle'), 'startAngle', '__ArcByCenterPointType_httpwww_opengis_netgmlstartAngle', True)
    def startAngle (self):
        """Get the value of the {http://www.opengis.net/gml}startAngle element."""
        return self.__startAngle.value(self)
    def setStartAngle (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}startAngle element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__startAngle.set(self, new_value)
    
    def addStartAngle (self, new_value):
        """Add the value as another occurrence of the {http://www.opengis.net/gml}startAngle element.  Raises
        BadValueTypeException if the new value is not consistent with the
        element's type."""
        return self.__startAngle.append(self, new_value)
    
    # Element {http://www.opengis.net/gml}posList uses Python identifier posList
    __posList = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'posList'), 'posList', '__ArcByCenterPointType_httpwww_opengis_netgmlposList', False)
    def posList (self):
        """Get the value of the {http://www.opengis.net/gml}posList element."""
        return self.__posList.value(self)
    def setPosList (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}posList element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__posList.set(self, new_value)
    
    # Element {http://www.opengis.net/gml}radius uses Python identifier radius
    __radius = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'radius'), 'radius', '__ArcByCenterPointType_httpwww_opengis_netgmlradius', True)
    def radius (self):
        """Get the value of the {http://www.opengis.net/gml}radius element."""
        return self.__radius.value(self)
    def setRadius (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}radius element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__radius.set(self, new_value)
    
    def addRadius (self, new_value):
        """Add the value as another occurrence of the {http://www.opengis.net/gml}radius element.  Raises
        BadValueTypeException if the new value is not consistent with the
        element's type."""
        return self.__radius.append(self, new_value)
    
    # Element {http://www.opengis.net/gml}coordinates uses Python identifier coordinates
    __coordinates = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'coordinates'), 'coordinates', '__ArcByCenterPointType_httpwww_opengis_netgmlcoordinates', False)
    def coordinates (self):
        """Get the value of the {http://www.opengis.net/gml}coordinates element."""
        return self.__coordinates.value(self)
    def setCoordinates (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}coordinates element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__coordinates.set(self, new_value)
    
    # Element {http://www.opengis.net/gml}pointRep uses Python identifier pointRep
    __pointRep = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'pointRep'), 'pointRep', '__ArcByCenterPointType_httpwww_opengis_netgmlpointRep', False)
    def pointRep (self):
        """Get the value of the {http://www.opengis.net/gml}pointRep element."""
        return self.__pointRep.value(self)
    def setPointRep (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}pointRep element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__pointRep.set(self, new_value)
    
    # Element {http://www.opengis.net/gml}pos uses Python identifier pos
    __pos = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'pos'), 'pos', '__ArcByCenterPointType_httpwww_opengis_netgmlpos', False)
    def pos (self):
        """Get the value of the {http://www.opengis.net/gml}pos element."""
        return self.__pos.value(self)
    def setPos (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}pos element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__pos.set(self, new_value)
    
    # Element {http://www.opengis.net/gml}pointProperty uses Python identifier pointProperty
    __pointProperty = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'pointProperty'), 'pointProperty', '__ArcByCenterPointType_httpwww_opengis_netgmlpointProperty', False)
    def pointProperty (self):
        """Get the value of the {http://www.opengis.net/gml}pointProperty element."""
        return self.__pointProperty.value(self)
    def setPointProperty (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}pointProperty element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__pointProperty.set(self, new_value)
    
    # Attribute numDerivativeInterior inherited from {http://www.opengis.net/gml}AbstractCurveSegmentType
    
    # Attribute numDerivativesAtEnd inherited from {http://www.opengis.net/gml}AbstractCurveSegmentType
    
    # Attribute numDerivativesAtStart inherited from {http://www.opengis.net/gml}AbstractCurveSegmentType
    
    # Attribute numArc uses Python identifier numArc
    __numArc = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'numArc'), 'numArc', '__ArcByCenterPointType_numArc', pyxb.binding.datatypes.integer, fixed=True, unicode_default=u'1', required=True)
    def numArc (self):
        """Get the attribute value for numArc."""
        return self.__numArc.value(self)
    def setNumArc (self, new_value):
        """Set the attribute value for numArc.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__numArc.set(self, new_value)
    
    # Attribute interpolation uses Python identifier interpolation
    __interpolation = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'interpolation'), 'interpolation', '__ArcByCenterPointType_interpolation', CurveInterpolationType, fixed=True, unicode_default=u'circularArcCenterPointWithRadius')
    def interpolation (self):
        """Get the attribute value for interpolation."""
        return self.__interpolation.value(self)
    def setInterpolation (self, new_value):
        """Set the attribute value for interpolation.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__interpolation.set(self, new_value)

    _ElementMap = AbstractCurveSegmentType._ElementMap.copy()
    _ElementMap.update({
        __endAngle.name() : __endAngle,
        __startAngle.name() : __startAngle,
        __posList.name() : __posList,
        __radius.name() : __radius,
        __coordinates.name() : __coordinates,
        __pointRep.name() : __pointRep,
        __pos.name() : __pos,
        __pointProperty.name() : __pointProperty
    })
    _AttributeMap = AbstractCurveSegmentType._AttributeMap.copy()
    _AttributeMap.update({
        __numArc.name() : __numArc,
        __interpolation.name() : __interpolation
    })
Namespace.addCategoryObject('typeBinding', u'ArcByCenterPointType', ArcByCenterPointType)


# Complex type ArcStringByBulgeType with content type ELEMENT_ONLY
class ArcStringByBulgeType (AbstractCurveSegmentType):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'ArcStringByBulgeType')
    # Base type is AbstractCurveSegmentType
    
    # Element {http://www.opengis.net/gml}bulge uses Python identifier bulge
    __bulge = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'bulge'), 'bulge', '__ArcStringByBulgeType_httpwww_opengis_netgmlbulge', True)
    def bulge (self):
        """Get the value of the {http://www.opengis.net/gml}bulge element."""
        return self.__bulge.value(self)
    def setBulge (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}bulge element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__bulge.set(self, new_value)
    
    def addBulge (self, new_value):
        """Add the value as another occurrence of the {http://www.opengis.net/gml}bulge element.  Raises
        BadValueTypeException if the new value is not consistent with the
        element's type."""
        return self.__bulge.append(self, new_value)
    
    # Element {http://www.opengis.net/gml}posList uses Python identifier posList
    __posList = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'posList'), 'posList', '__ArcStringByBulgeType_httpwww_opengis_netgmlposList', False)
    def posList (self):
        """Get the value of the {http://www.opengis.net/gml}posList element."""
        return self.__posList.value(self)
    def setPosList (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}posList element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__posList.set(self, new_value)
    
    # Element {http://www.opengis.net/gml}coordinates uses Python identifier coordinates
    __coordinates = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'coordinates'), 'coordinates', '__ArcStringByBulgeType_httpwww_opengis_netgmlcoordinates', False)
    def coordinates (self):
        """Get the value of the {http://www.opengis.net/gml}coordinates element."""
        return self.__coordinates.value(self)
    def setCoordinates (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}coordinates element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__coordinates.set(self, new_value)
    
    # Element {http://www.opengis.net/gml}pointRep uses Python identifier pointRep
    __pointRep = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'pointRep'), 'pointRep', '__ArcStringByBulgeType_httpwww_opengis_netgmlpointRep', True)
    def pointRep (self):
        """Get the value of the {http://www.opengis.net/gml}pointRep element."""
        return self.__pointRep.value(self)
    def setPointRep (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}pointRep element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__pointRep.set(self, new_value)
    
    def addPointRep (self, new_value):
        """Add the value as another occurrence of the {http://www.opengis.net/gml}pointRep element.  Raises
        BadValueTypeException if the new value is not consistent with the
        element's type."""
        return self.__pointRep.append(self, new_value)
    
    # Element {http://www.opengis.net/gml}pos uses Python identifier pos
    __pos = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'pos'), 'pos', '__ArcStringByBulgeType_httpwww_opengis_netgmlpos', True)
    def pos (self):
        """Get the value of the {http://www.opengis.net/gml}pos element."""
        return self.__pos.value(self)
    def setPos (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}pos element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__pos.set(self, new_value)
    
    def addPos (self, new_value):
        """Add the value as another occurrence of the {http://www.opengis.net/gml}pos element.  Raises
        BadValueTypeException if the new value is not consistent with the
        element's type."""
        return self.__pos.append(self, new_value)
    
    # Element {http://www.opengis.net/gml}normal uses Python identifier normal
    __normal = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'normal'), 'normal', '__ArcStringByBulgeType_httpwww_opengis_netgmlnormal', True)
    def normal (self):
        """Get the value of the {http://www.opengis.net/gml}normal element."""
        return self.__normal.value(self)
    def setNormal (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}normal element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__normal.set(self, new_value)
    
    def addNormal (self, new_value):
        """Add the value as another occurrence of the {http://www.opengis.net/gml}normal element.  Raises
        BadValueTypeException if the new value is not consistent with the
        element's type."""
        return self.__normal.append(self, new_value)
    
    # Element {http://www.opengis.net/gml}pointProperty uses Python identifier pointProperty
    __pointProperty = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'pointProperty'), 'pointProperty', '__ArcStringByBulgeType_httpwww_opengis_netgmlpointProperty', True)
    def pointProperty (self):
        """Get the value of the {http://www.opengis.net/gml}pointProperty element."""
        return self.__pointProperty.value(self)
    def setPointProperty (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}pointProperty element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__pointProperty.set(self, new_value)
    
    def addPointProperty (self, new_value):
        """Add the value as another occurrence of the {http://www.opengis.net/gml}pointProperty element.  Raises
        BadValueTypeException if the new value is not consistent with the
        element's type."""
        return self.__pointProperty.append(self, new_value)
    
    # Attribute numDerivativeInterior inherited from {http://www.opengis.net/gml}AbstractCurveSegmentType
    
    # Attribute numDerivativesAtEnd inherited from {http://www.opengis.net/gml}AbstractCurveSegmentType
    
    # Attribute numDerivativesAtStart inherited from {http://www.opengis.net/gml}AbstractCurveSegmentType
    
    # Attribute interpolation uses Python identifier interpolation
    __interpolation = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'interpolation'), 'interpolation', '__ArcStringByBulgeType_interpolation', CurveInterpolationType, fixed=True, unicode_default=u'circularArc2PointWithBulge')
    def interpolation (self):
        """Get the attribute value for interpolation."""
        return self.__interpolation.value(self)
    def setInterpolation (self, new_value):
        """Set the attribute value for interpolation.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__interpolation.set(self, new_value)
    
    # Attribute numArc uses Python identifier numArc
    __numArc = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'numArc'), 'numArc', '__ArcStringByBulgeType_numArc', pyxb.binding.datatypes.integer)
    def numArc (self):
        """Get the attribute value for numArc."""
        return self.__numArc.value(self)
    def setNumArc (self, new_value):
        """Set the attribute value for numArc.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__numArc.set(self, new_value)

    _ElementMap = AbstractCurveSegmentType._ElementMap.copy()
    _ElementMap.update({
        __bulge.name() : __bulge,
        __posList.name() : __posList,
        __coordinates.name() : __coordinates,
        __pointRep.name() : __pointRep,
        __pos.name() : __pos,
        __normal.name() : __normal,
        __pointProperty.name() : __pointProperty
    })
    _AttributeMap = AbstractCurveSegmentType._AttributeMap.copy()
    _AttributeMap.update({
        __interpolation.name() : __interpolation,
        __numArc.name() : __numArc
    })
Namespace.addCategoryObject('typeBinding', u'ArcStringByBulgeType', ArcStringByBulgeType)


# Complex type ArcStringType with content type ELEMENT_ONLY
class ArcStringType (AbstractCurveSegmentType):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'ArcStringType')
    # Base type is AbstractCurveSegmentType
    
    # Element {http://www.opengis.net/gml}pos uses Python identifier pos
    __pos = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'pos'), 'pos', '__ArcStringType_httpwww_opengis_netgmlpos', True)
    def pos (self):
        """Get the value of the {http://www.opengis.net/gml}pos element."""
        return self.__pos.value(self)
    def setPos (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}pos element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__pos.set(self, new_value)
    
    def addPos (self, new_value):
        """Add the value as another occurrence of the {http://www.opengis.net/gml}pos element.  Raises
        BadValueTypeException if the new value is not consistent with the
        element's type."""
        return self.__pos.append(self, new_value)
    
    # Element {http://www.opengis.net/gml}pointRep uses Python identifier pointRep
    __pointRep = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'pointRep'), 'pointRep', '__ArcStringType_httpwww_opengis_netgmlpointRep', True)
    def pointRep (self):
        """Get the value of the {http://www.opengis.net/gml}pointRep element."""
        return self.__pointRep.value(self)
    def setPointRep (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}pointRep element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__pointRep.set(self, new_value)
    
    def addPointRep (self, new_value):
        """Add the value as another occurrence of the {http://www.opengis.net/gml}pointRep element.  Raises
        BadValueTypeException if the new value is not consistent with the
        element's type."""
        return self.__pointRep.append(self, new_value)
    
    # Element {http://www.opengis.net/gml}pointProperty uses Python identifier pointProperty
    __pointProperty = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'pointProperty'), 'pointProperty', '__ArcStringType_httpwww_opengis_netgmlpointProperty', True)
    def pointProperty (self):
        """Get the value of the {http://www.opengis.net/gml}pointProperty element."""
        return self.__pointProperty.value(self)
    def setPointProperty (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}pointProperty element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__pointProperty.set(self, new_value)
    
    def addPointProperty (self, new_value):
        """Add the value as another occurrence of the {http://www.opengis.net/gml}pointProperty element.  Raises
        BadValueTypeException if the new value is not consistent with the
        element's type."""
        return self.__pointProperty.append(self, new_value)
    
    # Element {http://www.opengis.net/gml}posList uses Python identifier posList
    __posList = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'posList'), 'posList', '__ArcStringType_httpwww_opengis_netgmlposList', False)
    def posList (self):
        """Get the value of the {http://www.opengis.net/gml}posList element."""
        return self.__posList.value(self)
    def setPosList (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}posList element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__posList.set(self, new_value)
    
    # Element {http://www.opengis.net/gml}coordinates uses Python identifier coordinates
    __coordinates = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'coordinates'), 'coordinates', '__ArcStringType_httpwww_opengis_netgmlcoordinates', False)
    def coordinates (self):
        """Get the value of the {http://www.opengis.net/gml}coordinates element."""
        return self.__coordinates.value(self)
    def setCoordinates (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}coordinates element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__coordinates.set(self, new_value)
    
    # Attribute numDerivativeInterior inherited from {http://www.opengis.net/gml}AbstractCurveSegmentType
    
    # Attribute numDerivativesAtEnd inherited from {http://www.opengis.net/gml}AbstractCurveSegmentType
    
    # Attribute numDerivativesAtStart inherited from {http://www.opengis.net/gml}AbstractCurveSegmentType
    
    # Attribute numArc uses Python identifier numArc
    __numArc = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'numArc'), 'numArc', '__ArcStringType_numArc', pyxb.binding.datatypes.integer)
    def numArc (self):
        """Get the attribute value for numArc."""
        return self.__numArc.value(self)
    def setNumArc (self, new_value):
        """Set the attribute value for numArc.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__numArc.set(self, new_value)
    
    # Attribute interpolation uses Python identifier interpolation
    __interpolation = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'interpolation'), 'interpolation', '__ArcStringType_interpolation', CurveInterpolationType, fixed=True, unicode_default=u'circularArc3Points')
    def interpolation (self):
        """Get the attribute value for interpolation."""
        return self.__interpolation.value(self)
    def setInterpolation (self, new_value):
        """Set the attribute value for interpolation.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__interpolation.set(self, new_value)

    _ElementMap = AbstractCurveSegmentType._ElementMap.copy()
    _ElementMap.update({
        __pos.name() : __pos,
        __pointRep.name() : __pointRep,
        __pointProperty.name() : __pointProperty,
        __posList.name() : __posList,
        __coordinates.name() : __coordinates
    })
    _AttributeMap = AbstractCurveSegmentType._AttributeMap.copy()
    _AttributeMap.update({
        __numArc.name() : __numArc,
        __interpolation.name() : __interpolation
    })
Namespace.addCategoryObject('typeBinding', u'ArcStringType', ArcStringType)


# Complex type AreaType with content type SIMPLE
class AreaType (MeasureType):
    _TypeDefinition = pyxb.binding.datatypes.double
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_SIMPLE
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'AreaType')
    # Base type is MeasureType
    
    # Attribute uom inherited from {http://www.opengis.net/gml}MeasureType

    _ElementMap = MeasureType._ElementMap.copy()
    _ElementMap.update({
        
    })
    _AttributeMap = MeasureType._AttributeMap.copy()
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', u'AreaType', AreaType)


# Complex type ArrayType with content type ELEMENT_ONLY
class ArrayType (AbstractGMLType):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'ArrayType')
    # Base type is AbstractGMLType
    
    # Element descriptionReference inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element description inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element {http://www.opengis.net/gml}members uses Python identifier members
    __members = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'members'), 'members', '__ArrayType_httpwww_opengis_netgmlmembers', False)
    def members (self):
        """Get the value of the {http://www.opengis.net/gml}members element."""
        return self.__members.value(self)
    def setMembers (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}members element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__members.set(self, new_value)
    
    # Element identifier inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element name inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element metaDataProperty inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Attribute id inherited from {http://www.opengis.net/gml}AbstractGMLType

    _ElementMap = AbstractGMLType._ElementMap.copy()
    _ElementMap.update({
        __members.name() : __members
    })
    _AttributeMap = AbstractGMLType._AttributeMap.copy()
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', u'ArrayType', ArrayType)


# Complex type BSplineType with content type ELEMENT_ONLY
class BSplineType (AbstractCurveSegmentType):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'BSplineType')
    # Base type is AbstractCurveSegmentType
    
    # Element {http://www.opengis.net/gml}degree uses Python identifier degree
    __degree = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'degree'), 'degree', '__BSplineType_httpwww_opengis_netgmldegree', True)
    def degree (self):
        """Get the value of the {http://www.opengis.net/gml}degree element."""
        return self.__degree.value(self)
    def setDegree (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}degree element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__degree.set(self, new_value)
    
    def addDegree (self, new_value):
        """Add the value as another occurrence of the {http://www.opengis.net/gml}degree element.  Raises
        BadValueTypeException if the new value is not consistent with the
        element's type."""
        return self.__degree.append(self, new_value)
    
    # Element {http://www.opengis.net/gml}knot uses Python identifier knot
    __knot = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'knot'), 'knot', '__BSplineType_httpwww_opengis_netgmlknot', True)
    def knot (self):
        """Get the value of the {http://www.opengis.net/gml}knot element."""
        return self.__knot.value(self)
    def setKnot (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}knot element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__knot.set(self, new_value)
    
    def addKnot (self, new_value):
        """Add the value as another occurrence of the {http://www.opengis.net/gml}knot element.  Raises
        BadValueTypeException if the new value is not consistent with the
        element's type."""
        return self.__knot.append(self, new_value)
    
    # Element {http://www.opengis.net/gml}posList uses Python identifier posList
    __posList = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'posList'), 'posList', '__BSplineType_httpwww_opengis_netgmlposList', False)
    def posList (self):
        """Get the value of the {http://www.opengis.net/gml}posList element."""
        return self.__posList.value(self)
    def setPosList (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}posList element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__posList.set(self, new_value)
    
    # Element {http://www.opengis.net/gml}coordinates uses Python identifier coordinates
    __coordinates = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'coordinates'), 'coordinates', '__BSplineType_httpwww_opengis_netgmlcoordinates', False)
    def coordinates (self):
        """Get the value of the {http://www.opengis.net/gml}coordinates element."""
        return self.__coordinates.value(self)
    def setCoordinates (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}coordinates element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__coordinates.set(self, new_value)
    
    # Element {http://www.opengis.net/gml}pointRep uses Python identifier pointRep
    __pointRep = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'pointRep'), 'pointRep', '__BSplineType_httpwww_opengis_netgmlpointRep', True)
    def pointRep (self):
        """Get the value of the {http://www.opengis.net/gml}pointRep element."""
        return self.__pointRep.value(self)
    def setPointRep (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}pointRep element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__pointRep.set(self, new_value)
    
    def addPointRep (self, new_value):
        """Add the value as another occurrence of the {http://www.opengis.net/gml}pointRep element.  Raises
        BadValueTypeException if the new value is not consistent with the
        element's type."""
        return self.__pointRep.append(self, new_value)
    
    # Element {http://www.opengis.net/gml}pos uses Python identifier pos
    __pos = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'pos'), 'pos', '__BSplineType_httpwww_opengis_netgmlpos', True)
    def pos (self):
        """Get the value of the {http://www.opengis.net/gml}pos element."""
        return self.__pos.value(self)
    def setPos (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}pos element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__pos.set(self, new_value)
    
    def addPos (self, new_value):
        """Add the value as another occurrence of the {http://www.opengis.net/gml}pos element.  Raises
        BadValueTypeException if the new value is not consistent with the
        element's type."""
        return self.__pos.append(self, new_value)
    
    # Element {http://www.opengis.net/gml}pointProperty uses Python identifier pointProperty
    __pointProperty = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'pointProperty'), 'pointProperty', '__BSplineType_httpwww_opengis_netgmlpointProperty', True)
    def pointProperty (self):
        """Get the value of the {http://www.opengis.net/gml}pointProperty element."""
        return self.__pointProperty.value(self)
    def setPointProperty (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}pointProperty element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__pointProperty.set(self, new_value)
    
    def addPointProperty (self, new_value):
        """Add the value as another occurrence of the {http://www.opengis.net/gml}pointProperty element.  Raises
        BadValueTypeException if the new value is not consistent with the
        element's type."""
        return self.__pointProperty.append(self, new_value)
    
    # Attribute knotType uses Python identifier knotType
    __knotType = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'knotType'), 'knotType', '__BSplineType_knotType', KnotTypesType)
    def knotType (self):
        """Get the attribute value for knotType."""
        return self.__knotType.value(self)
    def setKnotType (self, new_value):
        """Set the attribute value for knotType.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__knotType.set(self, new_value)
    
    # Attribute interpolation uses Python identifier interpolation
    __interpolation = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'interpolation'), 'interpolation', '__BSplineType_interpolation', CurveInterpolationType, unicode_default=u'polynomialSpline')
    def interpolation (self):
        """Get the attribute value for interpolation."""
        return self.__interpolation.value(self)
    def setInterpolation (self, new_value):
        """Set the attribute value for interpolation.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__interpolation.set(self, new_value)
    
    # Attribute numDerivativeInterior inherited from {http://www.opengis.net/gml}AbstractCurveSegmentType
    
    # Attribute isPolynomial uses Python identifier isPolynomial
    __isPolynomial = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'isPolynomial'), 'isPolynomial', '__BSplineType_isPolynomial', pyxb.binding.datatypes.boolean)
    def isPolynomial (self):
        """Get the attribute value for isPolynomial."""
        return self.__isPolynomial.value(self)
    def setIsPolynomial (self, new_value):
        """Set the attribute value for isPolynomial.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__isPolynomial.set(self, new_value)
    
    # Attribute numDerivativesAtStart inherited from {http://www.opengis.net/gml}AbstractCurveSegmentType
    
    # Attribute numDerivativesAtEnd inherited from {http://www.opengis.net/gml}AbstractCurveSegmentType

    _ElementMap = AbstractCurveSegmentType._ElementMap.copy()
    _ElementMap.update({
        __degree.name() : __degree,
        __knot.name() : __knot,
        __posList.name() : __posList,
        __coordinates.name() : __coordinates,
        __pointRep.name() : __pointRep,
        __pos.name() : __pos,
        __pointProperty.name() : __pointProperty
    })
    _AttributeMap = AbstractCurveSegmentType._AttributeMap.copy()
    _AttributeMap.update({
        __knotType.name() : __knotType,
        __interpolation.name() : __interpolation,
        __isPolynomial.name() : __isPolynomial
    })
Namespace.addCategoryObject('typeBinding', u'BSplineType', BSplineType)


# Complex type BagType with content type ELEMENT_ONLY
class BagType (AbstractGMLType):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'BagType')
    # Base type is AbstractGMLType
    
    # Element descriptionReference inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element {http://www.opengis.net/gml}member uses Python identifier member
    __member = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'member'), 'member', '__BagType_httpwww_opengis_netgmlmember', True)
    def member (self):
        """Get the value of the {http://www.opengis.net/gml}member element."""
        return self.__member.value(self)
    def setMember (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}member element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__member.set(self, new_value)
    
    def addMember (self, new_value):
        """Add the value as another occurrence of the {http://www.opengis.net/gml}member element.  Raises
        BadValueTypeException if the new value is not consistent with the
        element's type."""
        return self.__member.append(self, new_value)
    
    # Element description inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element {http://www.opengis.net/gml}members uses Python identifier members
    __members = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'members'), 'members', '__BagType_httpwww_opengis_netgmlmembers', False)
    def members (self):
        """Get the value of the {http://www.opengis.net/gml}members element."""
        return self.__members.value(self)
    def setMembers (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}members element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__members.set(self, new_value)
    
    # Element identifier inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element name inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element metaDataProperty inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Attribute id inherited from {http://www.opengis.net/gml}AbstractGMLType

    _ElementMap = AbstractGMLType._ElementMap.copy()
    _ElementMap.update({
        __member.name() : __member,
        __members.name() : __members
    })
    _AttributeMap = AbstractGMLType._AttributeMap.copy()
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', u'BagType', BagType)


# Complex type CategoryExtentType with content type SIMPLE
class CategoryExtentType (CodeOrNilReasonListType):
    _TypeDefinition = _STD_ANON_14
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_SIMPLE
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'CategoryExtentType')
    # Base type is CodeOrNilReasonListType
    
    # Attribute codeSpace inherited from {http://www.opengis.net/gml}CodeOrNilReasonListType

    _ElementMap = CodeOrNilReasonListType._ElementMap.copy()
    _ElementMap.update({
        
    })
    _AttributeMap = CodeOrNilReasonListType._AttributeMap.copy()
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', u'CategoryExtentType', CategoryExtentType)


# Complex type ClothoidType with content type ELEMENT_ONLY
class ClothoidType (AbstractCurveSegmentType):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'ClothoidType')
    # Base type is AbstractCurveSegmentType
    
    # Element {http://www.opengis.net/gml}refLocation uses Python identifier refLocation
    __refLocation = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'refLocation'), 'refLocation', '__ClothoidType_httpwww_opengis_netgmlrefLocation', False)
    def refLocation (self):
        """Get the value of the {http://www.opengis.net/gml}refLocation element."""
        return self.__refLocation.value(self)
    def setRefLocation (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}refLocation element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__refLocation.set(self, new_value)
    
    # Element {http://www.opengis.net/gml}endParameter uses Python identifier endParameter
    __endParameter = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'endParameter'), 'endParameter', '__ClothoidType_httpwww_opengis_netgmlendParameter', False)
    def endParameter (self):
        """Get the value of the {http://www.opengis.net/gml}endParameter element."""
        return self.__endParameter.value(self)
    def setEndParameter (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}endParameter element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__endParameter.set(self, new_value)
    
    # Element {http://www.opengis.net/gml}startParameter uses Python identifier startParameter
    __startParameter = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'startParameter'), 'startParameter', '__ClothoidType_httpwww_opengis_netgmlstartParameter', False)
    def startParameter (self):
        """Get the value of the {http://www.opengis.net/gml}startParameter element."""
        return self.__startParameter.value(self)
    def setStartParameter (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}startParameter element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__startParameter.set(self, new_value)
    
    # Element {http://www.opengis.net/gml}scaleFactor uses Python identifier scaleFactor
    __scaleFactor = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'scaleFactor'), 'scaleFactor', '__ClothoidType_httpwww_opengis_netgmlscaleFactor', False)
    def scaleFactor (self):
        """Get the value of the {http://www.opengis.net/gml}scaleFactor element."""
        return self.__scaleFactor.value(self)
    def setScaleFactor (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}scaleFactor element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__scaleFactor.set(self, new_value)
    
    # Attribute numDerivativesAtEnd inherited from {http://www.opengis.net/gml}AbstractCurveSegmentType
    
    # Attribute numDerivativeInterior inherited from {http://www.opengis.net/gml}AbstractCurveSegmentType
    
    # Attribute numDerivativesAtStart inherited from {http://www.opengis.net/gml}AbstractCurveSegmentType
    
    # Attribute interpolation uses Python identifier interpolation
    __interpolation = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'interpolation'), 'interpolation', '__ClothoidType_interpolation', CurveInterpolationType, fixed=True, unicode_default=u'clothoid')
    def interpolation (self):
        """Get the attribute value for interpolation."""
        return self.__interpolation.value(self)
    def setInterpolation (self, new_value):
        """Set the attribute value for interpolation.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__interpolation.set(self, new_value)

    _ElementMap = AbstractCurveSegmentType._ElementMap.copy()
    _ElementMap.update({
        __refLocation.name() : __refLocation,
        __endParameter.name() : __endParameter,
        __startParameter.name() : __startParameter,
        __scaleFactor.name() : __scaleFactor
    })
    _AttributeMap = AbstractCurveSegmentType._AttributeMap.copy()
    _AttributeMap.update({
        __interpolation.name() : __interpolation
    })
Namespace.addCategoryObject('typeBinding', u'ClothoidType', ClothoidType)


# Complex type CodeWithAuthorityType with content type SIMPLE
class CodeWithAuthorityType (CodeType):
    _TypeDefinition = _STD_ANON_6
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_SIMPLE
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'CodeWithAuthorityType')
    # Base type is CodeType
    
    # Attribute codeSpace uses Python identifier codeSpace
    __codeSpace = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'codeSpace'), 'codeSpace', '__CodeWithAuthorityType_codeSpace', pyxb.binding.datatypes.anyURI, required=True)
    def codeSpace (self):
        """Get the attribute value for codeSpace."""
        return self.__codeSpace.value(self)
    def setCodeSpace (self, new_value):
        """Set the attribute value for codeSpace.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__codeSpace.set(self, new_value)

    _ElementMap = CodeType._ElementMap.copy()
    _ElementMap.update({
        
    })
    _AttributeMap = CodeType._AttributeMap.copy()
    _AttributeMap.update({
        __codeSpace.name() : __codeSpace
    })
Namespace.addCategoryObject('typeBinding', u'CodeWithAuthorityType', CodeWithAuthorityType)


# Complex type CompositeValueType with content type ELEMENT_ONLY
class CompositeValueType (AbstractGMLType):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'CompositeValueType')
    # Base type is AbstractGMLType
    
    # Element descriptionReference inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element {http://www.opengis.net/gml}valueComponents uses Python identifier valueComponents
    __valueComponents = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'valueComponents'), 'valueComponents', '__CompositeValueType_httpwww_opengis_netgmlvalueComponents', False)
    def valueComponents (self):
        """Get the value of the {http://www.opengis.net/gml}valueComponents element."""
        return self.__valueComponents.value(self)
    def setValueComponents (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}valueComponents element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__valueComponents.set(self, new_value)
    
    # Element name inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element {http://www.opengis.net/gml}valueComponent uses Python identifier valueComponent
    __valueComponent = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'valueComponent'), 'valueComponent', '__CompositeValueType_httpwww_opengis_netgmlvalueComponent', True)
    def valueComponent (self):
        """Get the value of the {http://www.opengis.net/gml}valueComponent element."""
        return self.__valueComponent.value(self)
    def setValueComponent (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}valueComponent element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__valueComponent.set(self, new_value)
    
    def addValueComponent (self, new_value):
        """Add the value as another occurrence of the {http://www.opengis.net/gml}valueComponent element.  Raises
        BadValueTypeException if the new value is not consistent with the
        element's type."""
        return self.__valueComponent.append(self, new_value)
    
    # Element identifier inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element description inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element metaDataProperty inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Attribute aggregationType uses Python identifier aggregationType
    __aggregationType = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'aggregationType'), 'aggregationType', '__CompositeValueType_aggregationType', AggregationType)
    def aggregationType (self):
        """Get the attribute value for aggregationType."""
        return self.__aggregationType.value(self)
    def setAggregationType (self, new_value):
        """Set the attribute value for aggregationType.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__aggregationType.set(self, new_value)
    
    # Attribute id inherited from {http://www.opengis.net/gml}AbstractGMLType

    _ElementMap = AbstractGMLType._ElementMap.copy()
    _ElementMap.update({
        __valueComponents.name() : __valueComponents,
        __valueComponent.name() : __valueComponent
    })
    _AttributeMap = AbstractGMLType._AttributeMap.copy()
    _AttributeMap.update({
        __aggregationType.name() : __aggregationType
    })
Namespace.addCategoryObject('typeBinding', u'CompositeValueType', CompositeValueType)


# Complex type ConversionToPreferredUnitType with content type ELEMENT_ONLY
class ConversionToPreferredUnitType (UnitOfMeasureType):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'ConversionToPreferredUnitType')
    # Base type is UnitOfMeasureType
    
    # Element {http://www.opengis.net/gml}formula uses Python identifier formula
    __formula = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'formula'), 'formula', '__ConversionToPreferredUnitType_httpwww_opengis_netgmlformula', False)
    def formula (self):
        """Get the value of the {http://www.opengis.net/gml}formula element."""
        return self.__formula.value(self)
    def setFormula (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}formula element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__formula.set(self, new_value)
    
    # Element {http://www.opengis.net/gml}factor uses Python identifier factor
    __factor = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'factor'), 'factor', '__ConversionToPreferredUnitType_httpwww_opengis_netgmlfactor', False)
    def factor (self):
        """Get the value of the {http://www.opengis.net/gml}factor element."""
        return self.__factor.value(self)
    def setFactor (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}factor element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__factor.set(self, new_value)
    
    # Attribute uom inherited from {http://www.opengis.net/gml}UnitOfMeasureType

    _ElementMap = UnitOfMeasureType._ElementMap.copy()
    _ElementMap.update({
        __formula.name() : __formula,
        __factor.name() : __factor
    })
    _AttributeMap = UnitOfMeasureType._AttributeMap.copy()
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', u'ConversionToPreferredUnitType', ConversionToPreferredUnitType)


# Complex type CubicSplineType with content type ELEMENT_ONLY
class CubicSplineType (AbstractCurveSegmentType):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'CubicSplineType')
    # Base type is AbstractCurveSegmentType
    
    # Element {http://www.opengis.net/gml}vectorAtEnd uses Python identifier vectorAtEnd
    __vectorAtEnd = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'vectorAtEnd'), 'vectorAtEnd', '__CubicSplineType_httpwww_opengis_netgmlvectorAtEnd', True)
    def vectorAtEnd (self):
        """Get the value of the {http://www.opengis.net/gml}vectorAtEnd element."""
        return self.__vectorAtEnd.value(self)
    def setVectorAtEnd (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}vectorAtEnd element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__vectorAtEnd.set(self, new_value)
    
    def addVectorAtEnd (self, new_value):
        """Add the value as another occurrence of the {http://www.opengis.net/gml}vectorAtEnd element.  Raises
        BadValueTypeException if the new value is not consistent with the
        element's type."""
        return self.__vectorAtEnd.append(self, new_value)
    
    # Element {http://www.opengis.net/gml}vectorAtStart uses Python identifier vectorAtStart
    __vectorAtStart = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'vectorAtStart'), 'vectorAtStart', '__CubicSplineType_httpwww_opengis_netgmlvectorAtStart', True)
    def vectorAtStart (self):
        """Get the value of the {http://www.opengis.net/gml}vectorAtStart element."""
        return self.__vectorAtStart.value(self)
    def setVectorAtStart (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}vectorAtStart element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__vectorAtStart.set(self, new_value)
    
    def addVectorAtStart (self, new_value):
        """Add the value as another occurrence of the {http://www.opengis.net/gml}vectorAtStart element.  Raises
        BadValueTypeException if the new value is not consistent with the
        element's type."""
        return self.__vectorAtStart.append(self, new_value)
    
    # Element {http://www.opengis.net/gml}posList uses Python identifier posList
    __posList = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'posList'), 'posList', '__CubicSplineType_httpwww_opengis_netgmlposList', False)
    def posList (self):
        """Get the value of the {http://www.opengis.net/gml}posList element."""
        return self.__posList.value(self)
    def setPosList (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}posList element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__posList.set(self, new_value)
    
    # Element {http://www.opengis.net/gml}coordinates uses Python identifier coordinates
    __coordinates = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'coordinates'), 'coordinates', '__CubicSplineType_httpwww_opengis_netgmlcoordinates', False)
    def coordinates (self):
        """Get the value of the {http://www.opengis.net/gml}coordinates element."""
        return self.__coordinates.value(self)
    def setCoordinates (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}coordinates element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__coordinates.set(self, new_value)
    
    # Element {http://www.opengis.net/gml}pointRep uses Python identifier pointRep
    __pointRep = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'pointRep'), 'pointRep', '__CubicSplineType_httpwww_opengis_netgmlpointRep', True)
    def pointRep (self):
        """Get the value of the {http://www.opengis.net/gml}pointRep element."""
        return self.__pointRep.value(self)
    def setPointRep (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}pointRep element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__pointRep.set(self, new_value)
    
    def addPointRep (self, new_value):
        """Add the value as another occurrence of the {http://www.opengis.net/gml}pointRep element.  Raises
        BadValueTypeException if the new value is not consistent with the
        element's type."""
        return self.__pointRep.append(self, new_value)
    
    # Element {http://www.opengis.net/gml}pos uses Python identifier pos
    __pos = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'pos'), 'pos', '__CubicSplineType_httpwww_opengis_netgmlpos', True)
    def pos (self):
        """Get the value of the {http://www.opengis.net/gml}pos element."""
        return self.__pos.value(self)
    def setPos (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}pos element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__pos.set(self, new_value)
    
    def addPos (self, new_value):
        """Add the value as another occurrence of the {http://www.opengis.net/gml}pos element.  Raises
        BadValueTypeException if the new value is not consistent with the
        element's type."""
        return self.__pos.append(self, new_value)
    
    # Element {http://www.opengis.net/gml}pointProperty uses Python identifier pointProperty
    __pointProperty = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'pointProperty'), 'pointProperty', '__CubicSplineType_httpwww_opengis_netgmlpointProperty', True)
    def pointProperty (self):
        """Get the value of the {http://www.opengis.net/gml}pointProperty element."""
        return self.__pointProperty.value(self)
    def setPointProperty (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}pointProperty element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__pointProperty.set(self, new_value)
    
    def addPointProperty (self, new_value):
        """Add the value as another occurrence of the {http://www.opengis.net/gml}pointProperty element.  Raises
        BadValueTypeException if the new value is not consistent with the
        element's type."""
        return self.__pointProperty.append(self, new_value)
    
    # Attribute numDerivativeInterior inherited from {http://www.opengis.net/gml}AbstractCurveSegmentType
    
    # Attribute numDerivativesAtEnd inherited from {http://www.opengis.net/gml}AbstractCurveSegmentType
    
    # Attribute numDerivativesAtStart inherited from {http://www.opengis.net/gml}AbstractCurveSegmentType
    
    # Attribute degree uses Python identifier degree
    __degree = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'degree'), 'degree', '__CubicSplineType_degree', pyxb.binding.datatypes.integer, fixed=True, unicode_default=u'3')
    def degree (self):
        """Get the attribute value for degree."""
        return self.__degree.value(self)
    def setDegree (self, new_value):
        """Set the attribute value for degree.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__degree.set(self, new_value)
    
    # Attribute interpolation uses Python identifier interpolation
    __interpolation = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'interpolation'), 'interpolation', '__CubicSplineType_interpolation', CurveInterpolationType, fixed=True, unicode_default=u'cubicSpline')
    def interpolation (self):
        """Get the attribute value for interpolation."""
        return self.__interpolation.value(self)
    def setInterpolation (self, new_value):
        """Set the attribute value for interpolation.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__interpolation.set(self, new_value)

    _ElementMap = AbstractCurveSegmentType._ElementMap.copy()
    _ElementMap.update({
        __vectorAtEnd.name() : __vectorAtEnd,
        __vectorAtStart.name() : __vectorAtStart,
        __posList.name() : __posList,
        __coordinates.name() : __coordinates,
        __pointRep.name() : __pointRep,
        __pos.name() : __pos,
        __pointProperty.name() : __pointProperty
    })
    _AttributeMap = AbstractCurveSegmentType._AttributeMap.copy()
    _AttributeMap.update({
        __degree.name() : __degree,
        __interpolation.name() : __interpolation
    })
Namespace.addCategoryObject('typeBinding', u'CubicSplineType', CubicSplineType)


# Complex type DefinitionBaseType with content type ELEMENT_ONLY
class DefinitionBaseType (AbstractGMLType):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'DefinitionBaseType')
    # Base type is AbstractGMLType
    
    # Element descriptionReference inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element name inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element identifier inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element metaDataProperty inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element description inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Attribute {http://www.opengis.net/gml}id uses Python identifier id
    __id = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(Namespace, u'id'), 'id', '__DefinitionBaseType_httpwww_opengis_netgmlid', pyxb.binding.datatypes.ID, required=True)
    def id (self):
        """Get the attribute value for {http://www.opengis.net/gml}id."""
        return self.__id.value(self)
    def setId (self, new_value):
        """Set the attribute value for {http://www.opengis.net/gml}id.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__id.set(self, new_value)

    _ElementMap = AbstractGMLType._ElementMap.copy()
    _ElementMap.update({
        
    })
    _AttributeMap = AbstractGMLType._AttributeMap.copy()
    _AttributeMap.update({
        __id.name() : __id
    })
Namespace.addCategoryObject('typeBinding', u'DefinitionBaseType', DefinitionBaseType)


# Complex type DerivationUnitTermType with content type EMPTY
class DerivationUnitTermType (UnitOfMeasureType):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_EMPTY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'DerivationUnitTermType')
    # Base type is UnitOfMeasureType
    
    # Attribute exponent uses Python identifier exponent
    __exponent = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'exponent'), 'exponent', '__DerivationUnitTermType_exponent', pyxb.binding.datatypes.integer)
    def exponent (self):
        """Get the attribute value for exponent."""
        return self.__exponent.value(self)
    def setExponent (self, new_value):
        """Set the attribute value for exponent.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__exponent.set(self, new_value)
    
    # Attribute uom inherited from {http://www.opengis.net/gml}UnitOfMeasureType

    _ElementMap = UnitOfMeasureType._ElementMap.copy()
    _ElementMap.update({
        
    })
    _AttributeMap = UnitOfMeasureType._AttributeMap.copy()
    _AttributeMap.update({
        __exponent.name() : __exponent
    })
Namespace.addCategoryObject('typeBinding', u'DerivationUnitTermType', DerivationUnitTermType)


# Complex type DictionaryEntryType with content type ELEMENT_ONLY
class DictionaryEntryType (AbstractMemberType):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'DictionaryEntryType')
    # Base type is AbstractMemberType
    
    # Element {http://www.opengis.net/gml}Definition uses Python identifier Definition
    __Definition = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'Definition'), 'Definition', '__DictionaryEntryType_httpwww_opengis_netgmlDefinition', False)
    def Definition (self):
        """Get the value of the {http://www.opengis.net/gml}Definition element."""
        return self.__Definition.value(self)
    def setDefinition (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}Definition element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__Definition.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}show uses Python identifier show
    __show = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'show'), 'show', '__DictionaryEntryType_httpwww_w3_org1999xlinkshow', MODULEhttpwww_w3_org1999xlink.UNBOUNDNone_194)
    def show (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}show."""
        return self.__show.value(self)
    def setShow (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}show.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__show.set(self, new_value)
    
    # Attribute owns inherited from {http://www.opengis.net/gml}AbstractMemberType
    
    # Attribute {http://www.opengis.net/gml}remoteSchema uses Python identifier remoteSchema
    __remoteSchema = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(Namespace, u'remoteSchema'), 'remoteSchema', '__DictionaryEntryType_httpwww_opengis_netgmlremoteSchema', pyxb.binding.datatypes.anyURI)
    def remoteSchema (self):
        """Get the attribute value for {http://www.opengis.net/gml}remoteSchema."""
        return self.__remoteSchema.value(self)
    def setRemoteSchema (self, new_value):
        """Set the attribute value for {http://www.opengis.net/gml}remoteSchema.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__remoteSchema.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}actuate uses Python identifier actuate
    __actuate = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'actuate'), 'actuate', '__DictionaryEntryType_httpwww_w3_org1999xlinkactuate', MODULEhttpwww_w3_org1999xlink.UNBOUNDNone_195)
    def actuate (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}actuate."""
        return self.__actuate.value(self)
    def setActuate (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}actuate.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__actuate.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}type uses Python identifier type
    __type = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'type'), 'type', '__DictionaryEntryType_httpwww_w3_org1999xlinktype', pyxb.binding.datatypes.string, fixed=True, unicode_default=u'simple')
    def type (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}type."""
        return self.__type.value(self)
    def setType (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}type.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__type.set(self, new_value)
    
    # Attribute nilReason uses Python identifier nilReason
    __nilReason = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'nilReason'), 'nilReason', '__DictionaryEntryType_nilReason', NilReasonType)
    def nilReason (self):
        """Get the attribute value for nilReason."""
        return self.__nilReason.value(self)
    def setNilReason (self, new_value):
        """Set the attribute value for nilReason.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__nilReason.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}title uses Python identifier title
    __title = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'title'), 'title', '__DictionaryEntryType_httpwww_w3_org1999xlinktitle', pyxb.binding.datatypes.string)
    def title (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}title."""
        return self.__title.value(self)
    def setTitle (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}title.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__title.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}role uses Python identifier role
    __role = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'role'), 'role', '__DictionaryEntryType_httpwww_w3_org1999xlinkrole', pyxb.binding.datatypes.anyURI)
    def role (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}role."""
        return self.__role.value(self)
    def setRole (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}role.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__role.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}arcrole uses Python identifier arcrole
    __arcrole = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'arcrole'), 'arcrole', '__DictionaryEntryType_httpwww_w3_org1999xlinkarcrole', pyxb.binding.datatypes.anyURI)
    def arcrole (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}arcrole."""
        return self.__arcrole.value(self)
    def setArcrole (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}arcrole.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__arcrole.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}href uses Python identifier href
    __href = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'href'), 'href', '__DictionaryEntryType_httpwww_w3_org1999xlinkhref', pyxb.binding.datatypes.anyURI)
    def href (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}href."""
        return self.__href.value(self)
    def setHref (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}href.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__href.set(self, new_value)

    _ElementMap = AbstractMemberType._ElementMap.copy()
    _ElementMap.update({
        __Definition.name() : __Definition
    })
    _AttributeMap = AbstractMemberType._AttributeMap.copy()
    _AttributeMap.update({
        __show.name() : __show,
        __remoteSchema.name() : __remoteSchema,
        __actuate.name() : __actuate,
        __type.name() : __type,
        __nilReason.name() : __nilReason,
        __title.name() : __title,
        __role.name() : __role,
        __arcrole.name() : __arcrole,
        __href.name() : __href
    })
Namespace.addCategoryObject('typeBinding', u'DictionaryEntryType', DictionaryEntryType)


# Complex type DynamicFeatureMemberType with content type ELEMENT_ONLY
class DynamicFeatureMemberType (AbstractFeatureMemberType):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'DynamicFeatureMemberType')
    # Base type is AbstractFeatureMemberType
    
    # Element {http://www.opengis.net/gml}DynamicFeature uses Python identifier DynamicFeature
    __DynamicFeature = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'DynamicFeature'), 'DynamicFeature', '__DynamicFeatureMemberType_httpwww_opengis_netgmlDynamicFeature', True)
    def DynamicFeature (self):
        """Get the value of the {http://www.opengis.net/gml}DynamicFeature element."""
        return self.__DynamicFeature.value(self)
    def setDynamicFeature (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}DynamicFeature element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__DynamicFeature.set(self, new_value)
    
    def addDynamicFeature (self, new_value):
        """Add the value as another occurrence of the {http://www.opengis.net/gml}DynamicFeature element.  Raises
        BadValueTypeException if the new value is not consistent with the
        element's type."""
        return self.__DynamicFeature.append(self, new_value)
    
    # Attribute {http://www.opengis.net/gml}remoteSchema uses Python identifier remoteSchema
    __remoteSchema = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(Namespace, u'remoteSchema'), 'remoteSchema', '__DynamicFeatureMemberType_httpwww_opengis_netgmlremoteSchema', pyxb.binding.datatypes.anyURI)
    def remoteSchema (self):
        """Get the attribute value for {http://www.opengis.net/gml}remoteSchema."""
        return self.__remoteSchema.value(self)
    def setRemoteSchema (self, new_value):
        """Set the attribute value for {http://www.opengis.net/gml}remoteSchema.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__remoteSchema.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}show uses Python identifier show
    __show = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'show'), 'show', '__DynamicFeatureMemberType_httpwww_w3_org1999xlinkshow', MODULEhttpwww_w3_org1999xlink.UNBOUNDNone_196)
    def show (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}show."""
        return self.__show.value(self)
    def setShow (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}show.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__show.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}actuate uses Python identifier actuate
    __actuate = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'actuate'), 'actuate', '__DynamicFeatureMemberType_httpwww_w3_org1999xlinkactuate', MODULEhttpwww_w3_org1999xlink.UNBOUNDNone_197)
    def actuate (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}actuate."""
        return self.__actuate.value(self)
    def setActuate (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}actuate.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__actuate.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}type uses Python identifier type
    __type = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'type'), 'type', '__DynamicFeatureMemberType_httpwww_w3_org1999xlinktype', pyxb.binding.datatypes.string, fixed=True, unicode_default=u'simple')
    def type (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}type."""
        return self.__type.value(self)
    def setType (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}type.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__type.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}title uses Python identifier title
    __title = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'title'), 'title', '__DynamicFeatureMemberType_httpwww_w3_org1999xlinktitle', pyxb.binding.datatypes.string)
    def title (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}title."""
        return self.__title.value(self)
    def setTitle (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}title.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__title.set(self, new_value)
    
    # Attribute owns inherited from {http://www.opengis.net/gml}AbstractFeatureMemberType
    
    # Attribute nilReason uses Python identifier nilReason
    __nilReason = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'nilReason'), 'nilReason', '__DynamicFeatureMemberType_nilReason', NilReasonType)
    def nilReason (self):
        """Get the attribute value for nilReason."""
        return self.__nilReason.value(self)
    def setNilReason (self, new_value):
        """Set the attribute value for nilReason.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__nilReason.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}role uses Python identifier role
    __role = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'role'), 'role', '__DynamicFeatureMemberType_httpwww_w3_org1999xlinkrole', pyxb.binding.datatypes.anyURI)
    def role (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}role."""
        return self.__role.value(self)
    def setRole (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}role.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__role.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}href uses Python identifier href
    __href = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'href'), 'href', '__DynamicFeatureMemberType_httpwww_w3_org1999xlinkhref', pyxb.binding.datatypes.anyURI)
    def href (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}href."""
        return self.__href.value(self)
    def setHref (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}href.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__href.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}arcrole uses Python identifier arcrole
    __arcrole = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'arcrole'), 'arcrole', '__DynamicFeatureMemberType_httpwww_w3_org1999xlinkarcrole', pyxb.binding.datatypes.anyURI)
    def arcrole (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}arcrole."""
        return self.__arcrole.value(self)
    def setArcrole (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}arcrole.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__arcrole.set(self, new_value)

    _ElementMap = AbstractFeatureMemberType._ElementMap.copy()
    _ElementMap.update({
        __DynamicFeature.name() : __DynamicFeature
    })
    _AttributeMap = AbstractFeatureMemberType._AttributeMap.copy()
    _AttributeMap.update({
        __remoteSchema.name() : __remoteSchema,
        __show.name() : __show,
        __actuate.name() : __actuate,
        __type.name() : __type,
        __title.name() : __title,
        __nilReason.name() : __nilReason,
        __role.name() : __role,
        __href.name() : __href,
        __arcrole.name() : __arcrole
    })
Namespace.addCategoryObject('typeBinding', u'DynamicFeatureMemberType', DynamicFeatureMemberType)


# Complex type EnvelopeWithTimePeriodType with content type ELEMENT_ONLY
class EnvelopeWithTimePeriodType (EnvelopeType):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'EnvelopeWithTimePeriodType')
    # Base type is EnvelopeType
    
    # Element {http://www.opengis.net/gml}endPosition uses Python identifier endPosition
    __endPosition = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'endPosition'), 'endPosition', '__EnvelopeWithTimePeriodType_httpwww_opengis_netgmlendPosition', True)
    def endPosition (self):
        """Get the value of the {http://www.opengis.net/gml}endPosition element."""
        return self.__endPosition.value(self)
    def setEndPosition (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}endPosition element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__endPosition.set(self, new_value)
    
    def addEndPosition (self, new_value):
        """Add the value as another occurrence of the {http://www.opengis.net/gml}endPosition element.  Raises
        BadValueTypeException if the new value is not consistent with the
        element's type."""
        return self.__endPosition.append(self, new_value)
    
    # Element {http://www.opengis.net/gml}beginPosition uses Python identifier beginPosition
    __beginPosition = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'beginPosition'), 'beginPosition', '__EnvelopeWithTimePeriodType_httpwww_opengis_netgmlbeginPosition', True)
    def beginPosition (self):
        """Get the value of the {http://www.opengis.net/gml}beginPosition element."""
        return self.__beginPosition.value(self)
    def setBeginPosition (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}beginPosition element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__beginPosition.set(self, new_value)
    
    def addBeginPosition (self, new_value):
        """Add the value as another occurrence of the {http://www.opengis.net/gml}beginPosition element.  Raises
        BadValueTypeException if the new value is not consistent with the
        element's type."""
        return self.__beginPosition.append(self, new_value)
    
    # Element lowerCorner inherited from {http://www.opengis.net/gml}EnvelopeType
    
    # Element upperCorner inherited from {http://www.opengis.net/gml}EnvelopeType
    
    # Element coordinates inherited from {http://www.opengis.net/gml}EnvelopeType
    
    # Element pos inherited from {http://www.opengis.net/gml}EnvelopeType
    
    # Attribute srsName inherited from {http://www.opengis.net/gml}EnvelopeType
    
    # Attribute axisLabels inherited from {http://www.opengis.net/gml}EnvelopeType
    
    # Attribute frame uses Python identifier frame
    __frame = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'frame'), 'frame', '__EnvelopeWithTimePeriodType_frame', pyxb.binding.datatypes.anyURI, unicode_default=u'#ISO-8601')
    def frame (self):
        """Get the attribute value for frame."""
        return self.__frame.value(self)
    def setFrame (self, new_value):
        """Set the attribute value for frame.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__frame.set(self, new_value)
    
    # Attribute srsDimension inherited from {http://www.opengis.net/gml}EnvelopeType
    
    # Attribute uomLabels inherited from {http://www.opengis.net/gml}EnvelopeType

    _ElementMap = EnvelopeType._ElementMap.copy()
    _ElementMap.update({
        __endPosition.name() : __endPosition,
        __beginPosition.name() : __beginPosition
    })
    _AttributeMap = EnvelopeType._AttributeMap.copy()
    _AttributeMap.update({
        __frame.name() : __frame
    })
Namespace.addCategoryObject('typeBinding', u'EnvelopeWithTimePeriodType', EnvelopeWithTimePeriodType)


# Complex type GenericMetaDataType with content type MIXED
class GenericMetaDataType (AbstractMetaDataType):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_MIXED
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'GenericMetaDataType')
    # Base type is AbstractMetaDataType
    
    # Attribute id inherited from {http://www.opengis.net/gml}AbstractMetaDataType
    _HasWildcardElement = True

    _ElementMap = AbstractMetaDataType._ElementMap.copy()
    _ElementMap.update({
        
    })
    _AttributeMap = AbstractMetaDataType._AttributeMap.copy()
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', u'GenericMetaDataType', GenericMetaDataType)


# Complex type GeodesicStringType with content type ELEMENT_ONLY
class GeodesicStringType (AbstractCurveSegmentType):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'GeodesicStringType')
    # Base type is AbstractCurveSegmentType
    
    # Element {http://www.opengis.net/gml}posList uses Python identifier posList
    __posList = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'posList'), 'posList', '__GeodesicStringType_httpwww_opengis_netgmlposList', False)
    def posList (self):
        """Get the value of the {http://www.opengis.net/gml}posList element."""
        return self.__posList.value(self)
    def setPosList (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}posList element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__posList.set(self, new_value)
    
    # Element {http://www.opengis.net/gml}pos uses Python identifier pos
    __pos = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'pos'), 'pos', '__GeodesicStringType_httpwww_opengis_netgmlpos', True)
    def pos (self):
        """Get the value of the {http://www.opengis.net/gml}pos element."""
        return self.__pos.value(self)
    def setPos (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}pos element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__pos.set(self, new_value)
    
    def addPos (self, new_value):
        """Add the value as another occurrence of the {http://www.opengis.net/gml}pos element.  Raises
        BadValueTypeException if the new value is not consistent with the
        element's type."""
        return self.__pos.append(self, new_value)
    
    # Element {http://www.opengis.net/gml}pointProperty uses Python identifier pointProperty
    __pointProperty = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'pointProperty'), 'pointProperty', '__GeodesicStringType_httpwww_opengis_netgmlpointProperty', True)
    def pointProperty (self):
        """Get the value of the {http://www.opengis.net/gml}pointProperty element."""
        return self.__pointProperty.value(self)
    def setPointProperty (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}pointProperty element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__pointProperty.set(self, new_value)
    
    def addPointProperty (self, new_value):
        """Add the value as another occurrence of the {http://www.opengis.net/gml}pointProperty element.  Raises
        BadValueTypeException if the new value is not consistent with the
        element's type."""
        return self.__pointProperty.append(self, new_value)
    
    # Attribute numDerivativesAtEnd inherited from {http://www.opengis.net/gml}AbstractCurveSegmentType
    
    # Attribute numDerivativeInterior inherited from {http://www.opengis.net/gml}AbstractCurveSegmentType
    
    # Attribute numDerivativesAtStart inherited from {http://www.opengis.net/gml}AbstractCurveSegmentType
    
    # Attribute interpolation uses Python identifier interpolation
    __interpolation = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'interpolation'), 'interpolation', '__GeodesicStringType_interpolation', CurveInterpolationType, fixed=True, unicode_default=u'geodesic')
    def interpolation (self):
        """Get the attribute value for interpolation."""
        return self.__interpolation.value(self)
    def setInterpolation (self, new_value):
        """Set the attribute value for interpolation.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__interpolation.set(self, new_value)

    _ElementMap = AbstractCurveSegmentType._ElementMap.copy()
    _ElementMap.update({
        __posList.name() : __posList,
        __pos.name() : __pos,
        __pointProperty.name() : __pointProperty
    })
    _AttributeMap = AbstractCurveSegmentType._AttributeMap.copy()
    _AttributeMap.update({
        __interpolation.name() : __interpolation
    })
Namespace.addCategoryObject('typeBinding', u'GeodesicStringType', GeodesicStringType)


# Complex type GridDomainType with content type ELEMENT_ONLY
class GridDomainType (DomainSetType):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'GridDomainType')
    # Base type is DomainSetType
    
    # Element {http://www.opengis.net/gml}Grid uses Python identifier Grid
    __Grid = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'Grid'), 'Grid', '__GridDomainType_httpwww_opengis_netgmlGrid', False)
    def Grid (self):
        """Get the value of the {http://www.opengis.net/gml}Grid element."""
        return self.__Grid.value(self)
    def setGrid (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}Grid element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__Grid.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}show uses Python identifier show
    __show = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'show'), 'show', '__GridDomainType_httpwww_w3_org1999xlinkshow', MODULEhttpwww_w3_org1999xlink.UNBOUNDNone_198)
    def show (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}show."""
        return self.__show.value(self)
    def setShow (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}show.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__show.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}actuate uses Python identifier actuate
    __actuate = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'actuate'), 'actuate', '__GridDomainType_httpwww_w3_org1999xlinkactuate', MODULEhttpwww_w3_org1999xlink.UNBOUNDNone_199)
    def actuate (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}actuate."""
        return self.__actuate.value(self)
    def setActuate (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}actuate.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__actuate.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}href uses Python identifier href
    __href = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'href'), 'href', '__GridDomainType_httpwww_w3_org1999xlinkhref', pyxb.binding.datatypes.anyURI)
    def href (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}href."""
        return self.__href.value(self)
    def setHref (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}href.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__href.set(self, new_value)
    
    # Attribute owns uses Python identifier owns
    __owns = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'owns'), 'owns', '__GridDomainType_owns', pyxb.binding.datatypes.boolean, unicode_default=u'false')
    def owns (self):
        """Get the attribute value for owns."""
        return self.__owns.value(self)
    def setOwns (self, new_value):
        """Set the attribute value for owns.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__owns.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}arcrole uses Python identifier arcrole
    __arcrole = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'arcrole'), 'arcrole', '__GridDomainType_httpwww_w3_org1999xlinkarcrole', pyxb.binding.datatypes.anyURI)
    def arcrole (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}arcrole."""
        return self.__arcrole.value(self)
    def setArcrole (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}arcrole.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__arcrole.set(self, new_value)
    
    # Attribute {http://www.opengis.net/gml}remoteSchema uses Python identifier remoteSchema
    __remoteSchema = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(Namespace, u'remoteSchema'), 'remoteSchema', '__GridDomainType_httpwww_opengis_netgmlremoteSchema', pyxb.binding.datatypes.anyURI)
    def remoteSchema (self):
        """Get the attribute value for {http://www.opengis.net/gml}remoteSchema."""
        return self.__remoteSchema.value(self)
    def setRemoteSchema (self, new_value):
        """Set the attribute value for {http://www.opengis.net/gml}remoteSchema.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__remoteSchema.set(self, new_value)
    
    # Attribute nilReason uses Python identifier nilReason
    __nilReason = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'nilReason'), 'nilReason', '__GridDomainType_nilReason', NilReasonType)
    def nilReason (self):
        """Get the attribute value for nilReason."""
        return self.__nilReason.value(self)
    def setNilReason (self, new_value):
        """Set the attribute value for nilReason.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__nilReason.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}type uses Python identifier type
    __type = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'type'), 'type', '__GridDomainType_httpwww_w3_org1999xlinktype', pyxb.binding.datatypes.string, fixed=True, unicode_default=u'simple')
    def type (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}type."""
        return self.__type.value(self)
    def setType (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}type.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__type.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}title uses Python identifier title
    __title = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'title'), 'title', '__GridDomainType_httpwww_w3_org1999xlinktitle', pyxb.binding.datatypes.string)
    def title (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}title."""
        return self.__title.value(self)
    def setTitle (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}title.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__title.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}role uses Python identifier role
    __role = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'role'), 'role', '__GridDomainType_httpwww_w3_org1999xlinkrole', pyxb.binding.datatypes.anyURI)
    def role (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}role."""
        return self.__role.value(self)
    def setRole (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}role.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__role.set(self, new_value)

    _ElementMap = DomainSetType._ElementMap.copy()
    _ElementMap.update({
        __Grid.name() : __Grid
    })
    _AttributeMap = DomainSetType._AttributeMap.copy()
    _AttributeMap.update({
        __show.name() : __show,
        __actuate.name() : __actuate,
        __href.name() : __href,
        __owns.name() : __owns,
        __arcrole.name() : __arcrole,
        __remoteSchema.name() : __remoteSchema,
        __nilReason.name() : __nilReason,
        __type.name() : __type,
        __title.name() : __title,
        __role.name() : __role
    })
Namespace.addCategoryObject('typeBinding', u'GridDomainType', GridDomainType)


# Complex type GridLengthType with content type SIMPLE
class GridLengthType (MeasureType):
    _TypeDefinition = pyxb.binding.datatypes.double
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_SIMPLE
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'GridLengthType')
    # Base type is MeasureType
    
    # Attribute uom inherited from {http://www.opengis.net/gml}MeasureType

    _ElementMap = MeasureType._ElementMap.copy()
    _ElementMap.update({
        
    })
    _AttributeMap = MeasureType._AttributeMap.copy()
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', u'GridLengthType', GridLengthType)


# Complex type LengthType with content type SIMPLE
class LengthType (MeasureType):
    _TypeDefinition = pyxb.binding.datatypes.double
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_SIMPLE
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'LengthType')
    # Base type is MeasureType
    
    # Attribute uom inherited from {http://www.opengis.net/gml}MeasureType

    _ElementMap = MeasureType._ElementMap.copy()
    _ElementMap.update({
        
    })
    _AttributeMap = MeasureType._AttributeMap.copy()
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', u'LengthType', LengthType)


# Complex type LineStringSegmentType with content type ELEMENT_ONLY
class LineStringSegmentType (AbstractCurveSegmentType):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'LineStringSegmentType')
    # Base type is AbstractCurveSegmentType
    
    # Element {http://www.opengis.net/gml}pos uses Python identifier pos
    __pos = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'pos'), 'pos', '__LineStringSegmentType_httpwww_opengis_netgmlpos', True)
    def pos (self):
        """Get the value of the {http://www.opengis.net/gml}pos element."""
        return self.__pos.value(self)
    def setPos (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}pos element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__pos.set(self, new_value)
    
    def addPos (self, new_value):
        """Add the value as another occurrence of the {http://www.opengis.net/gml}pos element.  Raises
        BadValueTypeException if the new value is not consistent with the
        element's type."""
        return self.__pos.append(self, new_value)
    
    # Element {http://www.opengis.net/gml}pointRep uses Python identifier pointRep
    __pointRep = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'pointRep'), 'pointRep', '__LineStringSegmentType_httpwww_opengis_netgmlpointRep', True)
    def pointRep (self):
        """Get the value of the {http://www.opengis.net/gml}pointRep element."""
        return self.__pointRep.value(self)
    def setPointRep (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}pointRep element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__pointRep.set(self, new_value)
    
    def addPointRep (self, new_value):
        """Add the value as another occurrence of the {http://www.opengis.net/gml}pointRep element.  Raises
        BadValueTypeException if the new value is not consistent with the
        element's type."""
        return self.__pointRep.append(self, new_value)
    
    # Element {http://www.opengis.net/gml}pointProperty uses Python identifier pointProperty
    __pointProperty = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'pointProperty'), 'pointProperty', '__LineStringSegmentType_httpwww_opengis_netgmlpointProperty', True)
    def pointProperty (self):
        """Get the value of the {http://www.opengis.net/gml}pointProperty element."""
        return self.__pointProperty.value(self)
    def setPointProperty (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}pointProperty element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__pointProperty.set(self, new_value)
    
    def addPointProperty (self, new_value):
        """Add the value as another occurrence of the {http://www.opengis.net/gml}pointProperty element.  Raises
        BadValueTypeException if the new value is not consistent with the
        element's type."""
        return self.__pointProperty.append(self, new_value)
    
    # Element {http://www.opengis.net/gml}posList uses Python identifier posList
    __posList = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'posList'), 'posList', '__LineStringSegmentType_httpwww_opengis_netgmlposList', False)
    def posList (self):
        """Get the value of the {http://www.opengis.net/gml}posList element."""
        return self.__posList.value(self)
    def setPosList (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}posList element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__posList.set(self, new_value)
    
    # Element {http://www.opengis.net/gml}coordinates uses Python identifier coordinates
    __coordinates = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'coordinates'), 'coordinates', '__LineStringSegmentType_httpwww_opengis_netgmlcoordinates', False)
    def coordinates (self):
        """Get the value of the {http://www.opengis.net/gml}coordinates element."""
        return self.__coordinates.value(self)
    def setCoordinates (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}coordinates element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__coordinates.set(self, new_value)
    
    # Attribute numDerivativesAtEnd inherited from {http://www.opengis.net/gml}AbstractCurveSegmentType
    
    # Attribute numDerivativeInterior inherited from {http://www.opengis.net/gml}AbstractCurveSegmentType
    
    # Attribute numDerivativesAtStart inherited from {http://www.opengis.net/gml}AbstractCurveSegmentType
    
    # Attribute interpolation uses Python identifier interpolation
    __interpolation = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'interpolation'), 'interpolation', '__LineStringSegmentType_interpolation', CurveInterpolationType, fixed=True, unicode_default=u'linear')
    def interpolation (self):
        """Get the attribute value for interpolation."""
        return self.__interpolation.value(self)
    def setInterpolation (self, new_value):
        """Set the attribute value for interpolation.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__interpolation.set(self, new_value)

    _ElementMap = AbstractCurveSegmentType._ElementMap.copy()
    _ElementMap.update({
        __pos.name() : __pos,
        __pointRep.name() : __pointRep,
        __pointProperty.name() : __pointProperty,
        __posList.name() : __posList,
        __coordinates.name() : __coordinates
    })
    _AttributeMap = AbstractCurveSegmentType._AttributeMap.copy()
    _AttributeMap.update({
        __interpolation.name() : __interpolation
    })
Namespace.addCategoryObject('typeBinding', u'LineStringSegmentType', LineStringSegmentType)


# Complex type LinearRingType with content type ELEMENT_ONLY
class LinearRingType (AbstractRingType):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'LinearRingType')
    # Base type is AbstractRingType
    
    # Element {http://www.opengis.net/gml}pos uses Python identifier pos
    __pos = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'pos'), 'pos', '__LinearRingType_httpwww_opengis_netgmlpos', True)
    def pos (self):
        """Get the value of the {http://www.opengis.net/gml}pos element."""
        return self.__pos.value(self)
    def setPos (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}pos element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__pos.set(self, new_value)
    
    def addPos (self, new_value):
        """Add the value as another occurrence of the {http://www.opengis.net/gml}pos element.  Raises
        BadValueTypeException if the new value is not consistent with the
        element's type."""
        return self.__pos.append(self, new_value)
    
    # Element {http://www.opengis.net/gml}pointRep uses Python identifier pointRep
    __pointRep = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'pointRep'), 'pointRep', '__LinearRingType_httpwww_opengis_netgmlpointRep', True)
    def pointRep (self):
        """Get the value of the {http://www.opengis.net/gml}pointRep element."""
        return self.__pointRep.value(self)
    def setPointRep (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}pointRep element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__pointRep.set(self, new_value)
    
    def addPointRep (self, new_value):
        """Add the value as another occurrence of the {http://www.opengis.net/gml}pointRep element.  Raises
        BadValueTypeException if the new value is not consistent with the
        element's type."""
        return self.__pointRep.append(self, new_value)
    
    # Element {http://www.opengis.net/gml}pointProperty uses Python identifier pointProperty
    __pointProperty = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'pointProperty'), 'pointProperty', '__LinearRingType_httpwww_opengis_netgmlpointProperty', True)
    def pointProperty (self):
        """Get the value of the {http://www.opengis.net/gml}pointProperty element."""
        return self.__pointProperty.value(self)
    def setPointProperty (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}pointProperty element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__pointProperty.set(self, new_value)
    
    def addPointProperty (self, new_value):
        """Add the value as another occurrence of the {http://www.opengis.net/gml}pointProperty element.  Raises
        BadValueTypeException if the new value is not consistent with the
        element's type."""
        return self.__pointProperty.append(self, new_value)
    
    # Element {http://www.opengis.net/gml}posList uses Python identifier posList
    __posList = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'posList'), 'posList', '__LinearRingType_httpwww_opengis_netgmlposList', False)
    def posList (self):
        """Get the value of the {http://www.opengis.net/gml}posList element."""
        return self.__posList.value(self)
    def setPosList (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}posList element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__posList.set(self, new_value)
    
    # Element {http://www.opengis.net/gml}coordinates uses Python identifier coordinates
    __coordinates = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'coordinates'), 'coordinates', '__LinearRingType_httpwww_opengis_netgmlcoordinates', False)
    def coordinates (self):
        """Get the value of the {http://www.opengis.net/gml}coordinates element."""
        return self.__coordinates.value(self)
    def setCoordinates (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}coordinates element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__coordinates.set(self, new_value)

    _ElementMap = AbstractRingType._ElementMap.copy()
    _ElementMap.update({
        __pos.name() : __pos,
        __pointRep.name() : __pointRep,
        __pointProperty.name() : __pointProperty,
        __posList.name() : __posList,
        __coordinates.name() : __coordinates
    })
    _AttributeMap = AbstractRingType._AttributeMap.copy()
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', u'LinearRingType', LinearRingType)


# Complex type MultiCurveDomainType with content type ELEMENT_ONLY
class MultiCurveDomainType (DomainSetType):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'MultiCurveDomainType')
    # Base type is DomainSetType
    
    # Element {http://www.opengis.net/gml}MultiCurve uses Python identifier MultiCurve
    __MultiCurve = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'MultiCurve'), 'MultiCurve', '__MultiCurveDomainType_httpwww_opengis_netgmlMultiCurve', False)
    def MultiCurve (self):
        """Get the value of the {http://www.opengis.net/gml}MultiCurve element."""
        return self.__MultiCurve.value(self)
    def setMultiCurve (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}MultiCurve element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__MultiCurve.set(self, new_value)
    
    # Attribute show inherited from {http://www.opengis.net/gml}DomainSetType
    
    # Attribute href inherited from {http://www.opengis.net/gml}DomainSetType
    
    # Attribute owns inherited from {http://www.opengis.net/gml}DomainSetType
    
    # Attribute type inherited from {http://www.opengis.net/gml}DomainSetType
    
    # Attribute remoteSchema inherited from {http://www.opengis.net/gml}DomainSetType
    
    # Attribute nilReason inherited from {http://www.opengis.net/gml}DomainSetType
    
    # Attribute title inherited from {http://www.opengis.net/gml}DomainSetType
    
    # Attribute actuate inherited from {http://www.opengis.net/gml}DomainSetType
    
    # Attribute arcrole inherited from {http://www.opengis.net/gml}DomainSetType
    
    # Attribute role inherited from {http://www.opengis.net/gml}DomainSetType

    _ElementMap = DomainSetType._ElementMap.copy()
    _ElementMap.update({
        __MultiCurve.name() : __MultiCurve
    })
    _AttributeMap = DomainSetType._AttributeMap.copy()
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', u'MultiCurveDomainType', MultiCurveDomainType)


# Complex type MultiPointDomainType with content type ELEMENT_ONLY
class MultiPointDomainType (DomainSetType):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'MultiPointDomainType')
    # Base type is DomainSetType
    
    # Element {http://www.opengis.net/gml}MultiPoint uses Python identifier MultiPoint
    __MultiPoint = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'MultiPoint'), 'MultiPoint', '__MultiPointDomainType_httpwww_opengis_netgmlMultiPoint', False)
    def MultiPoint (self):
        """Get the value of the {http://www.opengis.net/gml}MultiPoint element."""
        return self.__MultiPoint.value(self)
    def setMultiPoint (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}MultiPoint element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__MultiPoint.set(self, new_value)
    
    # Attribute show inherited from {http://www.opengis.net/gml}DomainSetType
    
    # Attribute href inherited from {http://www.opengis.net/gml}DomainSetType
    
    # Attribute owns inherited from {http://www.opengis.net/gml}DomainSetType
    
    # Attribute type inherited from {http://www.opengis.net/gml}DomainSetType
    
    # Attribute remoteSchema inherited from {http://www.opengis.net/gml}DomainSetType
    
    # Attribute nilReason inherited from {http://www.opengis.net/gml}DomainSetType
    
    # Attribute title inherited from {http://www.opengis.net/gml}DomainSetType
    
    # Attribute actuate inherited from {http://www.opengis.net/gml}DomainSetType
    
    # Attribute arcrole inherited from {http://www.opengis.net/gml}DomainSetType
    
    # Attribute role inherited from {http://www.opengis.net/gml}DomainSetType

    _ElementMap = DomainSetType._ElementMap.copy()
    _ElementMap.update({
        __MultiPoint.name() : __MultiPoint
    })
    _AttributeMap = DomainSetType._AttributeMap.copy()
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', u'MultiPointDomainType', MultiPointDomainType)


# Complex type MultiSolidDomainType with content type ELEMENT_ONLY
class MultiSolidDomainType (DomainSetType):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'MultiSolidDomainType')
    # Base type is DomainSetType
    
    # Element {http://www.opengis.net/gml}MultiSolid uses Python identifier MultiSolid
    __MultiSolid = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'MultiSolid'), 'MultiSolid', '__MultiSolidDomainType_httpwww_opengis_netgmlMultiSolid', False)
    def MultiSolid (self):
        """Get the value of the {http://www.opengis.net/gml}MultiSolid element."""
        return self.__MultiSolid.value(self)
    def setMultiSolid (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}MultiSolid element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__MultiSolid.set(self, new_value)
    
    # Attribute show inherited from {http://www.opengis.net/gml}DomainSetType
    
    # Attribute href inherited from {http://www.opengis.net/gml}DomainSetType
    
    # Attribute owns inherited from {http://www.opengis.net/gml}DomainSetType
    
    # Attribute type inherited from {http://www.opengis.net/gml}DomainSetType
    
    # Attribute remoteSchema inherited from {http://www.opengis.net/gml}DomainSetType
    
    # Attribute nilReason inherited from {http://www.opengis.net/gml}DomainSetType
    
    # Attribute title inherited from {http://www.opengis.net/gml}DomainSetType
    
    # Attribute actuate inherited from {http://www.opengis.net/gml}DomainSetType
    
    # Attribute arcrole inherited from {http://www.opengis.net/gml}DomainSetType
    
    # Attribute role inherited from {http://www.opengis.net/gml}DomainSetType

    _ElementMap = DomainSetType._ElementMap.copy()
    _ElementMap.update({
        __MultiSolid.name() : __MultiSolid
    })
    _AttributeMap = DomainSetType._AttributeMap.copy()
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', u'MultiSolidDomainType', MultiSolidDomainType)


# Complex type MultiSurfaceDomainType with content type ELEMENT_ONLY
class MultiSurfaceDomainType (DomainSetType):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'MultiSurfaceDomainType')
    # Base type is DomainSetType
    
    # Element {http://www.opengis.net/gml}MultiSurface uses Python identifier MultiSurface
    __MultiSurface = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'MultiSurface'), 'MultiSurface', '__MultiSurfaceDomainType_httpwww_opengis_netgmlMultiSurface', False)
    def MultiSurface (self):
        """Get the value of the {http://www.opengis.net/gml}MultiSurface element."""
        return self.__MultiSurface.value(self)
    def setMultiSurface (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}MultiSurface element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__MultiSurface.set(self, new_value)
    
    # Attribute show inherited from {http://www.opengis.net/gml}DomainSetType
    
    # Attribute href inherited from {http://www.opengis.net/gml}DomainSetType
    
    # Attribute owns inherited from {http://www.opengis.net/gml}DomainSetType
    
    # Attribute type inherited from {http://www.opengis.net/gml}DomainSetType
    
    # Attribute remoteSchema inherited from {http://www.opengis.net/gml}DomainSetType
    
    # Attribute nilReason inherited from {http://www.opengis.net/gml}DomainSetType
    
    # Attribute title inherited from {http://www.opengis.net/gml}DomainSetType
    
    # Attribute actuate inherited from {http://www.opengis.net/gml}DomainSetType
    
    # Attribute arcrole inherited from {http://www.opengis.net/gml}DomainSetType
    
    # Attribute role inherited from {http://www.opengis.net/gml}DomainSetType

    _ElementMap = DomainSetType._ElementMap.copy()
    _ElementMap.update({
        __MultiSurface.name() : __MultiSurface
    })
    _AttributeMap = DomainSetType._AttributeMap.copy()
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', u'MultiSurfaceDomainType', MultiSurfaceDomainType)


# Complex type OffsetCurveType with content type ELEMENT_ONLY
class OffsetCurveType (AbstractCurveSegmentType):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'OffsetCurveType')
    # Base type is AbstractCurveSegmentType
    
    # Element {http://www.opengis.net/gml}distance uses Python identifier distance
    __distance = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'distance'), 'distance', '__OffsetCurveType_httpwww_opengis_netgmldistance', False)
    def distance (self):
        """Get the value of the {http://www.opengis.net/gml}distance element."""
        return self.__distance.value(self)
    def setDistance (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}distance element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__distance.set(self, new_value)
    
    # Element {http://www.opengis.net/gml}offsetBase uses Python identifier offsetBase
    __offsetBase = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'offsetBase'), 'offsetBase', '__OffsetCurveType_httpwww_opengis_netgmloffsetBase', False)
    def offsetBase (self):
        """Get the value of the {http://www.opengis.net/gml}offsetBase element."""
        return self.__offsetBase.value(self)
    def setOffsetBase (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}offsetBase element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__offsetBase.set(self, new_value)
    
    # Element {http://www.opengis.net/gml}refDirection uses Python identifier refDirection
    __refDirection = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'refDirection'), 'refDirection', '__OffsetCurveType_httpwww_opengis_netgmlrefDirection', False)
    def refDirection (self):
        """Get the value of the {http://www.opengis.net/gml}refDirection element."""
        return self.__refDirection.value(self)
    def setRefDirection (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}refDirection element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__refDirection.set(self, new_value)
    
    # Attribute numDerivativesAtEnd inherited from {http://www.opengis.net/gml}AbstractCurveSegmentType
    
    # Attribute numDerivativeInterior inherited from {http://www.opengis.net/gml}AbstractCurveSegmentType
    
    # Attribute numDerivativesAtStart inherited from {http://www.opengis.net/gml}AbstractCurveSegmentType

    _ElementMap = AbstractCurveSegmentType._ElementMap.copy()
    _ElementMap.update({
        __distance.name() : __distance,
        __offsetBase.name() : __offsetBase,
        __refDirection.name() : __refDirection
    })
    _AttributeMap = AbstractCurveSegmentType._AttributeMap.copy()
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', u'OffsetCurveType', OffsetCurveType)


# Complex type ParameterValueGroupType with content type ELEMENT_ONLY
class ParameterValueGroupType (AbstractGeneralParameterValueType):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'ParameterValueGroupType')
    # Base type is AbstractGeneralParameterValueType
    
    # Element {http://www.opengis.net/gml}parameterValue uses Python identifier parameterValue
    __parameterValue = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'parameterValue'), 'parameterValue', '__ParameterValueGroupType_httpwww_opengis_netgmlparameterValue', True)
    def parameterValue (self):
        """Get the value of the {http://www.opengis.net/gml}parameterValue element."""
        return self.__parameterValue.value(self)
    def setParameterValue (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}parameterValue element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__parameterValue.set(self, new_value)
    
    def addParameterValue (self, new_value):
        """Add the value as another occurrence of the {http://www.opengis.net/gml}parameterValue element.  Raises
        BadValueTypeException if the new value is not consistent with the
        element's type."""
        return self.__parameterValue.append(self, new_value)
    
    # Element {http://www.opengis.net/gml}group uses Python identifier group
    __group = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'group'), 'group', '__ParameterValueGroupType_httpwww_opengis_netgmlgroup', False)
    def group (self):
        """Get the value of the {http://www.opengis.net/gml}group element."""
        return self.__group.value(self)
    def setGroup (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}group element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__group.set(self, new_value)

    _ElementMap = AbstractGeneralParameterValueType._ElementMap.copy()
    _ElementMap.update({
        __parameterValue.name() : __parameterValue,
        __group.name() : __group
    })
    _AttributeMap = AbstractGeneralParameterValueType._AttributeMap.copy()
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', u'ParameterValueGroupType', ParameterValueGroupType)


# Complex type ParameterValueType with content type ELEMENT_ONLY
class ParameterValueType (AbstractGeneralParameterValueType):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'ParameterValueType')
    # Base type is AbstractGeneralParameterValueType
    
    # Element {http://www.opengis.net/gml}operationParameter uses Python identifier operationParameter
    __operationParameter = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'operationParameter'), 'operationParameter', '__ParameterValueType_httpwww_opengis_netgmloperationParameter', True)
    def operationParameter (self):
        """Get the value of the {http://www.opengis.net/gml}operationParameter element."""
        return self.__operationParameter.value(self)
    def setOperationParameter (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}operationParameter element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__operationParameter.set(self, new_value)
    
    def addOperationParameter (self, new_value):
        """Add the value as another occurrence of the {http://www.opengis.net/gml}operationParameter element.  Raises
        BadValueTypeException if the new value is not consistent with the
        element's type."""
        return self.__operationParameter.append(self, new_value)
    
    # Element {http://www.opengis.net/gml}valueFile uses Python identifier valueFile
    __valueFile = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'valueFile'), 'valueFile', '__ParameterValueType_httpwww_opengis_netgmlvalueFile', False)
    def valueFile (self):
        """Get the value of the {http://www.opengis.net/gml}valueFile element."""
        return self.__valueFile.value(self)
    def setValueFile (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}valueFile element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__valueFile.set(self, new_value)
    
    # Element {http://www.opengis.net/gml}integerValueList uses Python identifier integerValueList
    __integerValueList = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'integerValueList'), 'integerValueList', '__ParameterValueType_httpwww_opengis_netgmlintegerValueList', False)
    def integerValueList (self):
        """Get the value of the {http://www.opengis.net/gml}integerValueList element."""
        return self.__integerValueList.value(self)
    def setIntegerValueList (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}integerValueList element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__integerValueList.set(self, new_value)
    
    # Element {http://www.opengis.net/gml}dmsAngleValue uses Python identifier dmsAngleValue
    __dmsAngleValue = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'dmsAngleValue'), 'dmsAngleValue', '__ParameterValueType_httpwww_opengis_netgmldmsAngleValue', False)
    def dmsAngleValue (self):
        """Get the value of the {http://www.opengis.net/gml}dmsAngleValue element."""
        return self.__dmsAngleValue.value(self)
    def setDmsAngleValue (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}dmsAngleValue element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__dmsAngleValue.set(self, new_value)
    
    # Element {http://www.opengis.net/gml}integerValue uses Python identifier integerValue
    __integerValue = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'integerValue'), 'integerValue', '__ParameterValueType_httpwww_opengis_netgmlintegerValue', False)
    def integerValue (self):
        """Get the value of the {http://www.opengis.net/gml}integerValue element."""
        return self.__integerValue.value(self)
    def setIntegerValue (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}integerValue element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__integerValue.set(self, new_value)
    
    # Element {http://www.opengis.net/gml}valueList uses Python identifier valueList
    __valueList = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'valueList'), 'valueList', '__ParameterValueType_httpwww_opengis_netgmlvalueList', False)
    def valueList (self):
        """Get the value of the {http://www.opengis.net/gml}valueList element."""
        return self.__valueList.value(self)
    def setValueList (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}valueList element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__valueList.set(self, new_value)
    
    # Element {http://www.opengis.net/gml}booleanValue uses Python identifier booleanValue
    __booleanValue = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'booleanValue'), 'booleanValue', '__ParameterValueType_httpwww_opengis_netgmlbooleanValue', False)
    def booleanValue (self):
        """Get the value of the {http://www.opengis.net/gml}booleanValue element."""
        return self.__booleanValue.value(self)
    def setBooleanValue (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}booleanValue element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__booleanValue.set(self, new_value)
    
    # Element {http://www.opengis.net/gml}stringValue uses Python identifier stringValue
    __stringValue = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'stringValue'), 'stringValue', '__ParameterValueType_httpwww_opengis_netgmlstringValue', False)
    def stringValue (self):
        """Get the value of the {http://www.opengis.net/gml}stringValue element."""
        return self.__stringValue.value(self)
    def setStringValue (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}stringValue element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__stringValue.set(self, new_value)
    
    # Element {http://www.opengis.net/gml}value uses Python identifier value
    __value = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'value'), 'value', '__ParameterValueType_httpwww_opengis_netgmlvalue', False)
    def value (self):
        """Get the value of the {http://www.opengis.net/gml}value element."""
        return self.__value.value(self)
    def setValue (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}value element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__value.set(self, new_value)

    _ElementMap = AbstractGeneralParameterValueType._ElementMap.copy()
    _ElementMap.update({
        __operationParameter.name() : __operationParameter,
        __valueFile.name() : __valueFile,
        __integerValueList.name() : __integerValueList,
        __dmsAngleValue.name() : __dmsAngleValue,
        __integerValue.name() : __integerValue,
        __valueList.name() : __valueList,
        __booleanValue.name() : __booleanValue,
        __stringValue.name() : __stringValue,
        __value.name() : __value
    })
    _AttributeMap = AbstractGeneralParameterValueType._AttributeMap.copy()
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', u'ParameterValueType', ParameterValueType)


# Complex type PolygonPatchArrayPropertyType with content type ELEMENT_ONLY
class PolygonPatchArrayPropertyType (SurfacePatchArrayPropertyType):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'PolygonPatchArrayPropertyType')
    # Base type is SurfacePatchArrayPropertyType
    
    # Element {http://www.opengis.net/gml}PolygonPatch uses Python identifier PolygonPatch
    __PolygonPatch = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'PolygonPatch'), 'PolygonPatch', '__PolygonPatchArrayPropertyType_httpwww_opengis_netgmlPolygonPatch', True)
    def PolygonPatch (self):
        """Get the value of the {http://www.opengis.net/gml}PolygonPatch element."""
        return self.__PolygonPatch.value(self)
    def setPolygonPatch (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}PolygonPatch element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__PolygonPatch.set(self, new_value)
    
    def addPolygonPatch (self, new_value):
        """Add the value as another occurrence of the {http://www.opengis.net/gml}PolygonPatch element.  Raises
        BadValueTypeException if the new value is not consistent with the
        element's type."""
        return self.__PolygonPatch.append(self, new_value)

    _ElementMap = SurfacePatchArrayPropertyType._ElementMap.copy()
    _ElementMap.update({
        __PolygonPatch.name() : __PolygonPatch
    })
    _AttributeMap = SurfacePatchArrayPropertyType._AttributeMap.copy()
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', u'PolygonPatchArrayPropertyType', PolygonPatchArrayPropertyType)


# Complex type PolygonPatchType with content type ELEMENT_ONLY
class PolygonPatchType (AbstractSurfacePatchType):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'PolygonPatchType')
    # Base type is AbstractSurfacePatchType
    
    # Element {http://www.opengis.net/gml}exterior uses Python identifier exterior
    __exterior = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'exterior'), 'exterior', '__PolygonPatchType_httpwww_opengis_netgmlexterior', False)
    def exterior (self):
        """Get the value of the {http://www.opengis.net/gml}exterior element."""
        return self.__exterior.value(self)
    def setExterior (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}exterior element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__exterior.set(self, new_value)
    
    # Element {http://www.opengis.net/gml}interior uses Python identifier interior
    __interior = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'interior'), 'interior', '__PolygonPatchType_httpwww_opengis_netgmlinterior', True)
    def interior (self):
        """Get the value of the {http://www.opengis.net/gml}interior element."""
        return self.__interior.value(self)
    def setInterior (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}interior element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__interior.set(self, new_value)
    
    def addInterior (self, new_value):
        """Add the value as another occurrence of the {http://www.opengis.net/gml}interior element.  Raises
        BadValueTypeException if the new value is not consistent with the
        element's type."""
        return self.__interior.append(self, new_value)
    
    # Attribute interpolation uses Python identifier interpolation
    __interpolation = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'interpolation'), 'interpolation', '__PolygonPatchType_interpolation', SurfaceInterpolationType, fixed=True, unicode_default=u'planar')
    def interpolation (self):
        """Get the attribute value for interpolation."""
        return self.__interpolation.value(self)
    def setInterpolation (self, new_value):
        """Set the attribute value for interpolation.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__interpolation.set(self, new_value)

    _ElementMap = AbstractSurfacePatchType._ElementMap.copy()
    _ElementMap.update({
        __exterior.name() : __exterior,
        __interior.name() : __interior
    })
    _AttributeMap = AbstractSurfacePatchType._AttributeMap.copy()
    _AttributeMap.update({
        __interpolation.name() : __interpolation
    })
Namespace.addCategoryObject('typeBinding', u'PolygonPatchType', PolygonPatchType)


# Complex type PriorityLocationPropertyType with content type ELEMENT_ONLY
class PriorityLocationPropertyType (LocationPropertyType):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'PriorityLocationPropertyType')
    # Base type is LocationPropertyType
    
    # Element LocationKeyWord inherited from {http://www.opengis.net/gml}LocationPropertyType
    
    # Element AbstractGeometry inherited from {http://www.opengis.net/gml}LocationPropertyType
    
    # Element Null inherited from {http://www.opengis.net/gml}LocationPropertyType
    
    # Element LocationString inherited from {http://www.opengis.net/gml}LocationPropertyType
    
    # Attribute title inherited from {http://www.opengis.net/gml}LocationPropertyType
    
    # Attribute remoteSchema inherited from {http://www.opengis.net/gml}LocationPropertyType
    
    # Attribute role inherited from {http://www.opengis.net/gml}LocationPropertyType
    
    # Attribute priority uses Python identifier priority
    __priority = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'priority'), 'priority', '__PriorityLocationPropertyType_priority', pyxb.binding.datatypes.string)
    def priority (self):
        """Get the attribute value for priority."""
        return self.__priority.value(self)
    def setPriority (self, new_value):
        """Set the attribute value for priority.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__priority.set(self, new_value)
    
    # Attribute href inherited from {http://www.opengis.net/gml}LocationPropertyType
    
    # Attribute show inherited from {http://www.opengis.net/gml}LocationPropertyType
    
    # Attribute nilReason inherited from {http://www.opengis.net/gml}LocationPropertyType
    
    # Attribute arcrole inherited from {http://www.opengis.net/gml}LocationPropertyType
    
    # Attribute actuate inherited from {http://www.opengis.net/gml}LocationPropertyType
    
    # Attribute type inherited from {http://www.opengis.net/gml}LocationPropertyType

    _ElementMap = LocationPropertyType._ElementMap.copy()
    _ElementMap.update({
        
    })
    _AttributeMap = LocationPropertyType._AttributeMap.copy()
    _AttributeMap.update({
        __priority.name() : __priority
    })
Namespace.addCategoryObject('typeBinding', u'PriorityLocationPropertyType', PriorityLocationPropertyType)


# Complex type QuantityExtentType with content type SIMPLE
class QuantityExtentType (MeasureOrNilReasonListType):
    _TypeDefinition = _STD_ANON_15
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_SIMPLE
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'QuantityExtentType')
    # Base type is MeasureOrNilReasonListType
    
    # Attribute uom inherited from {http://www.opengis.net/gml}MeasureOrNilReasonListType

    _ElementMap = MeasureOrNilReasonListType._ElementMap.copy()
    _ElementMap.update({
        
    })
    _AttributeMap = MeasureOrNilReasonListType._AttributeMap.copy()
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', u'QuantityExtentType', QuantityExtentType)


# Complex type RectangleType with content type ELEMENT_ONLY
class RectangleType (AbstractSurfacePatchType):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'RectangleType')
    # Base type is AbstractSurfacePatchType
    
    # Element {http://www.opengis.net/gml}exterior uses Python identifier exterior
    __exterior = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'exterior'), 'exterior', '__RectangleType_httpwww_opengis_netgmlexterior', False)
    def exterior (self):
        """Get the value of the {http://www.opengis.net/gml}exterior element."""
        return self.__exterior.value(self)
    def setExterior (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}exterior element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__exterior.set(self, new_value)
    
    # Attribute interpolation uses Python identifier interpolation
    __interpolation = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'interpolation'), 'interpolation', '__RectangleType_interpolation', SurfaceInterpolationType, fixed=True, unicode_default=u'planar')
    def interpolation (self):
        """Get the attribute value for interpolation."""
        return self.__interpolation.value(self)
    def setInterpolation (self, new_value):
        """Set the attribute value for interpolation.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__interpolation.set(self, new_value)

    _ElementMap = AbstractSurfacePatchType._ElementMap.copy()
    _ElementMap.update({
        __exterior.name() : __exterior
    })
    _AttributeMap = AbstractSurfacePatchType._AttributeMap.copy()
    _AttributeMap.update({
        __interpolation.name() : __interpolation
    })
Namespace.addCategoryObject('typeBinding', u'RectangleType', RectangleType)


# Complex type RectifiedGridDomainType with content type ELEMENT_ONLY
class RectifiedGridDomainType (DomainSetType):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'RectifiedGridDomainType')
    # Base type is DomainSetType
    
    # Element {http://www.opengis.net/gml}RectifiedGrid uses Python identifier RectifiedGrid
    __RectifiedGrid = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'RectifiedGrid'), 'RectifiedGrid', '__RectifiedGridDomainType_httpwww_opengis_netgmlRectifiedGrid', False)
    def RectifiedGrid (self):
        """Get the value of the {http://www.opengis.net/gml}RectifiedGrid element."""
        return self.__RectifiedGrid.value(self)
    def setRectifiedGrid (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}RectifiedGrid element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__RectifiedGrid.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}show uses Python identifier show
    __show = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'show'), 'show', '__RectifiedGridDomainType_httpwww_w3_org1999xlinkshow', MODULEhttpwww_w3_org1999xlink.UNBOUNDNone_200)
    def show (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}show."""
        return self.__show.value(self)
    def setShow (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}show.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__show.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}role uses Python identifier role
    __role = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'role'), 'role', '__RectifiedGridDomainType_httpwww_w3_org1999xlinkrole', pyxb.binding.datatypes.anyURI)
    def role (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}role."""
        return self.__role.value(self)
    def setRole (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}role.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__role.set(self, new_value)
    
    # Attribute owns uses Python identifier owns
    __owns = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'owns'), 'owns', '__RectifiedGridDomainType_owns', pyxb.binding.datatypes.boolean, unicode_default=u'false')
    def owns (self):
        """Get the attribute value for owns."""
        return self.__owns.value(self)
    def setOwns (self, new_value):
        """Set the attribute value for owns.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__owns.set(self, new_value)
    
    # Attribute nilReason uses Python identifier nilReason
    __nilReason = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'nilReason'), 'nilReason', '__RectifiedGridDomainType_nilReason', NilReasonType)
    def nilReason (self):
        """Get the attribute value for nilReason."""
        return self.__nilReason.value(self)
    def setNilReason (self, new_value):
        """Set the attribute value for nilReason.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__nilReason.set(self, new_value)
    
    # Attribute {http://www.opengis.net/gml}remoteSchema uses Python identifier remoteSchema
    __remoteSchema = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(Namespace, u'remoteSchema'), 'remoteSchema', '__RectifiedGridDomainType_httpwww_opengis_netgmlremoteSchema', pyxb.binding.datatypes.anyURI)
    def remoteSchema (self):
        """Get the attribute value for {http://www.opengis.net/gml}remoteSchema."""
        return self.__remoteSchema.value(self)
    def setRemoteSchema (self, new_value):
        """Set the attribute value for {http://www.opengis.net/gml}remoteSchema.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__remoteSchema.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}type uses Python identifier type
    __type = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'type'), 'type', '__RectifiedGridDomainType_httpwww_w3_org1999xlinktype', pyxb.binding.datatypes.string, fixed=True, unicode_default=u'simple')
    def type (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}type."""
        return self.__type.value(self)
    def setType (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}type.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__type.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}actuate uses Python identifier actuate
    __actuate = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'actuate'), 'actuate', '__RectifiedGridDomainType_httpwww_w3_org1999xlinkactuate', MODULEhttpwww_w3_org1999xlink.UNBOUNDNone_201)
    def actuate (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}actuate."""
        return self.__actuate.value(self)
    def setActuate (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}actuate.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__actuate.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}arcrole uses Python identifier arcrole
    __arcrole = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'arcrole'), 'arcrole', '__RectifiedGridDomainType_httpwww_w3_org1999xlinkarcrole', pyxb.binding.datatypes.anyURI)
    def arcrole (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}arcrole."""
        return self.__arcrole.value(self)
    def setArcrole (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}arcrole.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__arcrole.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}href uses Python identifier href
    __href = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'href'), 'href', '__RectifiedGridDomainType_httpwww_w3_org1999xlinkhref', pyxb.binding.datatypes.anyURI)
    def href (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}href."""
        return self.__href.value(self)
    def setHref (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}href.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__href.set(self, new_value)
    
    # Attribute {http://www.w3.org/1999/xlink}title uses Python identifier title
    __title = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(MODULEhttpwww_w3_org1999xlink.Namespace, u'title'), 'title', '__RectifiedGridDomainType_httpwww_w3_org1999xlinktitle', pyxb.binding.datatypes.string)
    def title (self):
        """Get the attribute value for {http://www.w3.org/1999/xlink}title."""
        return self.__title.value(self)
    def setTitle (self, new_value):
        """Set the attribute value for {http://www.w3.org/1999/xlink}title.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__title.set(self, new_value)

    _ElementMap = DomainSetType._ElementMap.copy()
    _ElementMap.update({
        __RectifiedGrid.name() : __RectifiedGrid
    })
    _AttributeMap = DomainSetType._AttributeMap.copy()
    _AttributeMap.update({
        __show.name() : __show,
        __role.name() : __role,
        __owns.name() : __owns,
        __nilReason.name() : __nilReason,
        __remoteSchema.name() : __remoteSchema,
        __type.name() : __type,
        __actuate.name() : __actuate,
        __arcrole.name() : __arcrole,
        __href.name() : __href,
        __title.name() : __title
    })
Namespace.addCategoryObject('typeBinding', u'RectifiedGridDomainType', RectifiedGridDomainType)


# Complex type RelatedTimeType with content type ELEMENT_ONLY
class RelatedTimeType (TimePrimitivePropertyType):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'RelatedTimeType')
    # Base type is TimePrimitivePropertyType
    
    # Element AbstractTimePrimitive inherited from {http://www.opengis.net/gml}TimePrimitivePropertyType
    
    # Attribute type inherited from {http://www.opengis.net/gml}TimePrimitivePropertyType
    
    # Attribute relativePosition uses Python identifier relativePosition
    __relativePosition = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'relativePosition'), 'relativePosition', '__RelatedTimeType_relativePosition', _STD_ANON_11)
    def relativePosition (self):
        """Get the attribute value for relativePosition."""
        return self.__relativePosition.value(self)
    def setRelativePosition (self, new_value):
        """Set the attribute value for relativePosition.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__relativePosition.set(self, new_value)
    
    # Attribute title inherited from {http://www.opengis.net/gml}TimePrimitivePropertyType
    
    # Attribute role inherited from {http://www.opengis.net/gml}TimePrimitivePropertyType
    
    # Attribute show inherited from {http://www.opengis.net/gml}TimePrimitivePropertyType
    
    # Attribute nilReason inherited from {http://www.opengis.net/gml}TimePrimitivePropertyType
    
    # Attribute href inherited from {http://www.opengis.net/gml}TimePrimitivePropertyType
    
    # Attribute owns inherited from {http://www.opengis.net/gml}TimePrimitivePropertyType
    
    # Attribute arcrole inherited from {http://www.opengis.net/gml}TimePrimitivePropertyType
    
    # Attribute remoteSchema inherited from {http://www.opengis.net/gml}TimePrimitivePropertyType
    
    # Attribute actuate inherited from {http://www.opengis.net/gml}TimePrimitivePropertyType

    _ElementMap = TimePrimitivePropertyType._ElementMap.copy()
    _ElementMap.update({
        
    })
    _AttributeMap = TimePrimitivePropertyType._AttributeMap.copy()
    _AttributeMap.update({
        __relativePosition.name() : __relativePosition
    })
Namespace.addCategoryObject('typeBinding', u'RelatedTimeType', RelatedTimeType)


# Complex type RingType with content type ELEMENT_ONLY
class RingType (AbstractRingType):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'RingType')
    # Base type is AbstractRingType
    
    # Element {http://www.opengis.net/gml}curveMember uses Python identifier curveMember
    __curveMember = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'curveMember'), 'curveMember', '__RingType_httpwww_opengis_netgmlcurveMember', True)
    def curveMember (self):
        """Get the value of the {http://www.opengis.net/gml}curveMember element."""
        return self.__curveMember.value(self)
    def setCurveMember (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}curveMember element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__curveMember.set(self, new_value)
    
    def addCurveMember (self, new_value):
        """Add the value as another occurrence of the {http://www.opengis.net/gml}curveMember element.  Raises
        BadValueTypeException if the new value is not consistent with the
        element's type."""
        return self.__curveMember.append(self, new_value)
    
    # Attribute aggregationType uses Python identifier aggregationType
    __aggregationType = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'aggregationType'), 'aggregationType', '__RingType_aggregationType', AggregationType)
    def aggregationType (self):
        """Get the attribute value for aggregationType."""
        return self.__aggregationType.value(self)
    def setAggregationType (self, new_value):
        """Set the attribute value for aggregationType.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__aggregationType.set(self, new_value)

    _ElementMap = AbstractRingType._ElementMap.copy()
    _ElementMap.update({
        __curveMember.name() : __curveMember
    })
    _AttributeMap = AbstractRingType._AttributeMap.copy()
    _AttributeMap.update({
        __aggregationType.name() : __aggregationType
    })
Namespace.addCategoryObject('typeBinding', u'RingType', RingType)


# Complex type ScaleType with content type SIMPLE
class ScaleType (MeasureType):
    _TypeDefinition = pyxb.binding.datatypes.double
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_SIMPLE
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'ScaleType')
    # Base type is MeasureType
    
    # Attribute uom inherited from {http://www.opengis.net/gml}MeasureType

    _ElementMap = MeasureType._ElementMap.copy()
    _ElementMap.update({
        
    })
    _AttributeMap = MeasureType._AttributeMap.copy()
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', u'ScaleType', ScaleType)


# Complex type SpeedType with content type SIMPLE
class SpeedType (MeasureType):
    _TypeDefinition = pyxb.binding.datatypes.double
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_SIMPLE
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'SpeedType')
    # Base type is MeasureType
    
    # Attribute uom inherited from {http://www.opengis.net/gml}MeasureType

    _ElementMap = MeasureType._ElementMap.copy()
    _ElementMap.update({
        
    })
    _AttributeMap = MeasureType._AttributeMap.copy()
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', u'SpeedType', SpeedType)


# Complex type TimeType with content type SIMPLE
class TimeType (MeasureType):
    _TypeDefinition = pyxb.binding.datatypes.double
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_SIMPLE
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'TimeType')
    # Base type is MeasureType
    
    # Attribute uom inherited from {http://www.opengis.net/gml}MeasureType

    _ElementMap = MeasureType._ElementMap.copy()
    _ElementMap.update({
        
    })
    _AttributeMap = MeasureType._AttributeMap.copy()
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', u'TimeType', TimeType)


# Complex type TrianglePatchArrayPropertyType with content type ELEMENT_ONLY
class TrianglePatchArrayPropertyType (SurfacePatchArrayPropertyType):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'TrianglePatchArrayPropertyType')
    # Base type is SurfacePatchArrayPropertyType
    
    # Element {http://www.opengis.net/gml}Triangle uses Python identifier Triangle
    __Triangle = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'Triangle'), 'Triangle', '__TrianglePatchArrayPropertyType_httpwww_opengis_netgmlTriangle', True)
    def Triangle (self):
        """Get the value of the {http://www.opengis.net/gml}Triangle element."""
        return self.__Triangle.value(self)
    def setTriangle (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}Triangle element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__Triangle.set(self, new_value)
    
    def addTriangle (self, new_value):
        """Add the value as another occurrence of the {http://www.opengis.net/gml}Triangle element.  Raises
        BadValueTypeException if the new value is not consistent with the
        element's type."""
        return self.__Triangle.append(self, new_value)

    _ElementMap = SurfacePatchArrayPropertyType._ElementMap.copy()
    _ElementMap.update({
        __Triangle.name() : __Triangle
    })
    _AttributeMap = SurfacePatchArrayPropertyType._AttributeMap.copy()
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', u'TrianglePatchArrayPropertyType', TrianglePatchArrayPropertyType)


# Complex type TriangleType with content type ELEMENT_ONLY
class TriangleType (AbstractSurfacePatchType):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'TriangleType')
    # Base type is AbstractSurfacePatchType
    
    # Element {http://www.opengis.net/gml}exterior uses Python identifier exterior
    __exterior = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'exterior'), 'exterior', '__TriangleType_httpwww_opengis_netgmlexterior', False)
    def exterior (self):
        """Get the value of the {http://www.opengis.net/gml}exterior element."""
        return self.__exterior.value(self)
    def setExterior (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}exterior element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__exterior.set(self, new_value)
    
    # Attribute interpolation uses Python identifier interpolation
    __interpolation = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'interpolation'), 'interpolation', '__TriangleType_interpolation', SurfaceInterpolationType, fixed=True, unicode_default=u'planar')
    def interpolation (self):
        """Get the attribute value for interpolation."""
        return self.__interpolation.value(self)
    def setInterpolation (self, new_value):
        """Set the attribute value for interpolation.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__interpolation.set(self, new_value)

    _ElementMap = AbstractSurfacePatchType._ElementMap.copy()
    _ElementMap.update({
        __exterior.name() : __exterior
    })
    _AttributeMap = AbstractSurfacePatchType._AttributeMap.copy()
    _AttributeMap.update({
        __interpolation.name() : __interpolation
    })
Namespace.addCategoryObject('typeBinding', u'TriangleType', TriangleType)


# Complex type VectorType with content type SIMPLE
class VectorType (DirectPositionType):
    _TypeDefinition = _STD_ANON_13
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_SIMPLE
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'VectorType')
    # Base type is DirectPositionType
    
    # Attribute srsName inherited from {http://www.opengis.net/gml}DirectPositionType
    
    # Attribute axisLabels inherited from {http://www.opengis.net/gml}DirectPositionType
    
    # Attribute uomLabels inherited from {http://www.opengis.net/gml}DirectPositionType
    
    # Attribute srsDimension inherited from {http://www.opengis.net/gml}DirectPositionType

    _ElementMap = DirectPositionType._ElementMap.copy()
    _ElementMap.update({
        
    })
    _AttributeMap = DirectPositionType._AttributeMap.copy()
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', u'VectorType', VectorType)


# Complex type VolumeType with content type SIMPLE
class VolumeType (MeasureType):
    _TypeDefinition = pyxb.binding.datatypes.double
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_SIMPLE
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'VolumeType')
    # Base type is MeasureType
    
    # Attribute uom inherited from {http://www.opengis.net/gml}MeasureType

    _ElementMap = MeasureType._ElementMap.copy()
    _ElementMap.update({
        
    })
    _AttributeMap = MeasureType._AttributeMap.copy()
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', u'VolumeType', VolumeType)


# Complex type AbstractCoverageType with content type ELEMENT_ONLY
class AbstractCoverageType (AbstractFeatureType):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = True
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'AbstractCoverageType')
    # Base type is AbstractFeatureType
    
    # Element descriptionReference inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element name inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element {http://www.opengis.net/gml}rangeSet uses Python identifier rangeSet
    __rangeSet = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'rangeSet'), 'rangeSet', '__AbstractCoverageType_httpwww_opengis_netgmlrangeSet', False)
    def rangeSet (self):
        """Get the value of the {http://www.opengis.net/gml}rangeSet element."""
        return self.__rangeSet.value(self)
    def setRangeSet (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}rangeSet element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__rangeSet.set(self, new_value)
    
    # Element {http://www.opengis.net/gml}domainSet uses Python identifier domainSet
    __domainSet = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'domainSet'), 'domainSet', '__AbstractCoverageType_httpwww_opengis_netgmldomainSet', False)
    def domainSet (self):
        """Get the value of the {http://www.opengis.net/gml}domainSet element."""
        return self.__domainSet.value(self)
    def setDomainSet (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}domainSet element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__domainSet.set(self, new_value)
    
    # Element boundedBy inherited from {http://www.opengis.net/gml}AbstractFeatureType
    
    # Element identifier inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element location inherited from {http://www.opengis.net/gml}AbstractFeatureType
    
    # Element description inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element metaDataProperty inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Attribute id inherited from {http://www.opengis.net/gml}AbstractGMLType

    _ElementMap = AbstractFeatureType._ElementMap.copy()
    _ElementMap.update({
        __rangeSet.name() : __rangeSet,
        __domainSet.name() : __domainSet
    })
    _AttributeMap = AbstractFeatureType._AttributeMap.copy()
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', u'AbstractCoverageType', AbstractCoverageType)


# Complex type AbstractFeatureCollectionType with content type ELEMENT_ONLY
class AbstractFeatureCollectionType (AbstractFeatureType):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = True
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'AbstractFeatureCollectionType')
    # Base type is AbstractFeatureType
    
    # Element descriptionReference inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element {http://www.opengis.net/gml}featureMembers uses Python identifier featureMembers
    __featureMembers = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'featureMembers'), 'featureMembers', '__AbstractFeatureCollectionType_httpwww_opengis_netgmlfeatureMembers', False)
    def featureMembers (self):
        """Get the value of the {http://www.opengis.net/gml}featureMembers element."""
        return self.__featureMembers.value(self)
    def setFeatureMembers (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}featureMembers element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__featureMembers.set(self, new_value)
    
    # Element {http://www.opengis.net/gml}featureMember uses Python identifier featureMember
    __featureMember = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'featureMember'), 'featureMember', '__AbstractFeatureCollectionType_httpwww_opengis_netgmlfeatureMember', True)
    def featureMember (self):
        """Get the value of the {http://www.opengis.net/gml}featureMember element."""
        return self.__featureMember.value(self)
    def setFeatureMember (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}featureMember element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__featureMember.set(self, new_value)
    
    def addFeatureMember (self, new_value):
        """Add the value as another occurrence of the {http://www.opengis.net/gml}featureMember element.  Raises
        BadValueTypeException if the new value is not consistent with the
        element's type."""
        return self.__featureMember.append(self, new_value)
    
    # Element boundedBy inherited from {http://www.opengis.net/gml}AbstractFeatureType
    
    # Element identifier inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element location inherited from {http://www.opengis.net/gml}AbstractFeatureType
    
    # Element description inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element metaDataProperty inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element name inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Attribute id inherited from {http://www.opengis.net/gml}AbstractGMLType

    _ElementMap = AbstractFeatureType._ElementMap.copy()
    _ElementMap.update({
        __featureMembers.name() : __featureMembers,
        __featureMember.name() : __featureMember
    })
    _AttributeMap = AbstractFeatureType._AttributeMap.copy()
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', u'AbstractFeatureCollectionType', AbstractFeatureCollectionType)


# Complex type AbstractGeometricAggregateType with content type ELEMENT_ONLY
class AbstractGeometricAggregateType (AbstractGeometryType):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = True
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'AbstractGeometricAggregateType')
    # Base type is AbstractGeometryType
    
    # Element descriptionReference inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element name inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element identifier inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element metaDataProperty inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element description inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Attribute uomLabels inherited from {http://www.opengis.net/gml}AbstractGeometryType
    
    # Attribute axisLabels inherited from {http://www.opengis.net/gml}AbstractGeometryType
    
    # Attribute aggregationType uses Python identifier aggregationType
    __aggregationType = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'aggregationType'), 'aggregationType', '__AbstractGeometricAggregateType_aggregationType', AggregationType)
    def aggregationType (self):
        """Get the attribute value for aggregationType."""
        return self.__aggregationType.value(self)
    def setAggregationType (self, new_value):
        """Set the attribute value for aggregationType.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__aggregationType.set(self, new_value)
    
    # Attribute id inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Attribute srsName inherited from {http://www.opengis.net/gml}AbstractGeometryType
    
    # Attribute srsDimension inherited from {http://www.opengis.net/gml}AbstractGeometryType

    _ElementMap = AbstractGeometryType._ElementMap.copy()
    _ElementMap.update({
        
    })
    _AttributeMap = AbstractGeometryType._AttributeMap.copy()
    _AttributeMap.update({
        __aggregationType.name() : __aggregationType
    })
Namespace.addCategoryObject('typeBinding', u'AbstractGeometricAggregateType', AbstractGeometricAggregateType)


# Complex type AbstractGeometricPrimitiveType with content type ELEMENT_ONLY
class AbstractGeometricPrimitiveType (AbstractGeometryType):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = True
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'AbstractGeometricPrimitiveType')
    # Base type is AbstractGeometryType
    
    # Element descriptionReference inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element name inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element identifier inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element metaDataProperty inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element description inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Attribute srsName inherited from {http://www.opengis.net/gml}AbstractGeometryType
    
    # Attribute axisLabels inherited from {http://www.opengis.net/gml}AbstractGeometryType
    
    # Attribute id inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Attribute uomLabels inherited from {http://www.opengis.net/gml}AbstractGeometryType
    
    # Attribute srsDimension inherited from {http://www.opengis.net/gml}AbstractGeometryType

    _ElementMap = AbstractGeometryType._ElementMap.copy()
    _ElementMap.update({
        
    })
    _AttributeMap = AbstractGeometryType._AttributeMap.copy()
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', u'AbstractGeometricPrimitiveType', AbstractGeometricPrimitiveType)


# Complex type AbstractGriddedSurfaceType with content type ELEMENT_ONLY
class AbstractGriddedSurfaceType (AbstractParametricCurveSurfaceType):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = True
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'AbstractGriddedSurfaceType')
    # Base type is AbstractParametricCurveSurfaceType
    
    # Element {http://www.opengis.net/gml}rows uses Python identifier rows
    __rows = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'rows'), 'rows', '__AbstractGriddedSurfaceType_httpwww_opengis_netgmlrows', False)
    def rows (self):
        """Get the value of the {http://www.opengis.net/gml}rows element."""
        return self.__rows.value(self)
    def setRows (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}rows element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__rows.set(self, new_value)
    
    # Attribute aggregationType inherited from {http://www.opengis.net/gml}AbstractParametricCurveSurfaceType
    
    # Attribute rows uses Python identifier rows_
    __rows_ = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'rows'), 'rows_', '__AbstractGriddedSurfaceType_rows', pyxb.binding.datatypes.integer)
    def rows_ (self):
        """Get the attribute value for rows."""
        return self.__rows_.value(self)
    def setRows_ (self, new_value):
        """Set the attribute value for rows.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__rows_.set(self, new_value)
    
    # Attribute columns uses Python identifier columns
    __columns = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'columns'), 'columns', '__AbstractGriddedSurfaceType_columns', pyxb.binding.datatypes.integer)
    def columns (self):
        """Get the attribute value for columns."""
        return self.__columns.value(self)
    def setColumns (self, new_value):
        """Set the attribute value for columns.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__columns.set(self, new_value)

    _ElementMap = AbstractParametricCurveSurfaceType._ElementMap.copy()
    _ElementMap.update({
        __rows.name() : __rows
    })
    _AttributeMap = AbstractParametricCurveSurfaceType._AttributeMap.copy()
    _AttributeMap.update({
        __rows_.name() : __rows_,
        __columns.name() : __columns
    })
Namespace.addCategoryObject('typeBinding', u'AbstractGriddedSurfaceType', AbstractGriddedSurfaceType)


# Complex type AbstractTimeComplexType with content type ELEMENT_ONLY
class AbstractTimeComplexType (AbstractTimeObjectType):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = True
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'AbstractTimeComplexType')
    # Base type is AbstractTimeObjectType
    
    # Element descriptionReference inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element name inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element identifier inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element metaDataProperty inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element description inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Attribute id inherited from {http://www.opengis.net/gml}AbstractGMLType

    _ElementMap = AbstractTimeObjectType._ElementMap.copy()
    _ElementMap.update({
        
    })
    _AttributeMap = AbstractTimeObjectType._AttributeMap.copy()
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', u'AbstractTimeComplexType', AbstractTimeComplexType)


# Complex type AbstractTimePrimitiveType with content type ELEMENT_ONLY
class AbstractTimePrimitiveType (AbstractTimeObjectType):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = True
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'AbstractTimePrimitiveType')
    # Base type is AbstractTimeObjectType
    
    # Element descriptionReference inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element name inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element identifier inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element description inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element metaDataProperty inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element {http://www.opengis.net/gml}relatedTime uses Python identifier relatedTime
    __relatedTime = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'relatedTime'), 'relatedTime', '__AbstractTimePrimitiveType_httpwww_opengis_netgmlrelatedTime', True)
    def relatedTime (self):
        """Get the value of the {http://www.opengis.net/gml}relatedTime element."""
        return self.__relatedTime.value(self)
    def setRelatedTime (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}relatedTime element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__relatedTime.set(self, new_value)
    
    def addRelatedTime (self, new_value):
        """Add the value as another occurrence of the {http://www.opengis.net/gml}relatedTime element.  Raises
        BadValueTypeException if the new value is not consistent with the
        element's type."""
        return self.__relatedTime.append(self, new_value)
    
    # Attribute id inherited from {http://www.opengis.net/gml}AbstractGMLType

    _ElementMap = AbstractTimeObjectType._ElementMap.copy()
    _ElementMap.update({
        __relatedTime.name() : __relatedTime
    })
    _AttributeMap = AbstractTimeObjectType._AttributeMap.copy()
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', u'AbstractTimePrimitiveType', AbstractTimePrimitiveType)


# Complex type AbstractTopoPrimitiveType with content type ELEMENT_ONLY
class AbstractTopoPrimitiveType (AbstractTopologyType):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = True
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'AbstractTopoPrimitiveType')
    # Base type is AbstractTopologyType
    
    # Element descriptionReference inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element name inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element {http://www.opengis.net/gml}container uses Python identifier container
    __container = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'container'), 'container', '__AbstractTopoPrimitiveType_httpwww_opengis_netgmlcontainer', False)
    def container (self):
        """Get the value of the {http://www.opengis.net/gml}container element."""
        return self.__container.value(self)
    def setContainer (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}container element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__container.set(self, new_value)
    
    # Element identifier inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element description inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element metaDataProperty inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element {http://www.opengis.net/gml}isolated uses Python identifier isolated
    __isolated = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'isolated'), 'isolated', '__AbstractTopoPrimitiveType_httpwww_opengis_netgmlisolated', True)
    def isolated (self):
        """Get the value of the {http://www.opengis.net/gml}isolated element."""
        return self.__isolated.value(self)
    def setIsolated (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}isolated element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__isolated.set(self, new_value)
    
    def addIsolated (self, new_value):
        """Add the value as another occurrence of the {http://www.opengis.net/gml}isolated element.  Raises
        BadValueTypeException if the new value is not consistent with the
        element's type."""
        return self.__isolated.append(self, new_value)
    
    # Attribute id inherited from {http://www.opengis.net/gml}AbstractGMLType

    _ElementMap = AbstractTopologyType._ElementMap.copy()
    _ElementMap.update({
        __container.name() : __container,
        __isolated.name() : __isolated
    })
    _AttributeMap = AbstractTopologyType._AttributeMap.copy()
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', u'AbstractTopoPrimitiveType', AbstractTopoPrimitiveType)


# Complex type ArcByBulgeType with content type ELEMENT_ONLY
class ArcByBulgeType (ArcStringByBulgeType):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'ArcByBulgeType')
    # Base type is ArcStringByBulgeType
    
    # Element bulge inherited from {http://www.opengis.net/gml}ArcStringByBulgeType
    
    # Element posList inherited from {http://www.opengis.net/gml}ArcStringByBulgeType
    
    # Element coordinates inherited from {http://www.opengis.net/gml}ArcStringByBulgeType
    
    # Element pointRep inherited from {http://www.opengis.net/gml}ArcStringByBulgeType
    
    # Element pos inherited from {http://www.opengis.net/gml}ArcStringByBulgeType
    
    # Element normal inherited from {http://www.opengis.net/gml}ArcStringByBulgeType
    
    # Element pointProperty inherited from {http://www.opengis.net/gml}ArcStringByBulgeType
    
    # Attribute numDerivativeInterior inherited from {http://www.opengis.net/gml}AbstractCurveSegmentType
    
    # Attribute numDerivativesAtEnd inherited from {http://www.opengis.net/gml}AbstractCurveSegmentType
    
    # Attribute numDerivativesAtStart inherited from {http://www.opengis.net/gml}AbstractCurveSegmentType
    
    # Attribute interpolation inherited from {http://www.opengis.net/gml}ArcStringByBulgeType
    
    # Attribute numArc uses Python identifier numArc
    __numArc = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'numArc'), 'numArc', '__ArcByBulgeType_numArc', pyxb.binding.datatypes.integer, fixed=True, unicode_default=u'1')
    def numArc (self):
        """Get the attribute value for numArc."""
        return self.__numArc.value(self)
    def setNumArc (self, new_value):
        """Set the attribute value for numArc.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__numArc.set(self, new_value)

    _ElementMap = ArcStringByBulgeType._ElementMap.copy()
    _ElementMap.update({
        
    })
    _AttributeMap = ArcStringByBulgeType._AttributeMap.copy()
    _AttributeMap.update({
        __numArc.name() : __numArc
    })
Namespace.addCategoryObject('typeBinding', u'ArcByBulgeType', ArcByBulgeType)


# Complex type ArcType with content type ELEMENT_ONLY
class ArcType (ArcStringType):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'ArcType')
    # Base type is ArcStringType
    
    # Element pos inherited from {http://www.opengis.net/gml}ArcStringType
    
    # Element pointRep inherited from {http://www.opengis.net/gml}ArcStringType
    
    # Element pointProperty inherited from {http://www.opengis.net/gml}ArcStringType
    
    # Element posList inherited from {http://www.opengis.net/gml}ArcStringType
    
    # Element coordinates inherited from {http://www.opengis.net/gml}ArcStringType
    
    # Attribute numDerivativeInterior inherited from {http://www.opengis.net/gml}AbstractCurveSegmentType
    
    # Attribute numDerivativesAtEnd inherited from {http://www.opengis.net/gml}AbstractCurveSegmentType
    
    # Attribute numDerivativesAtStart inherited from {http://www.opengis.net/gml}AbstractCurveSegmentType
    
    # Attribute numArc uses Python identifier numArc
    __numArc = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'numArc'), 'numArc', '__ArcType_numArc', pyxb.binding.datatypes.integer, fixed=True, unicode_default=u'1')
    def numArc (self):
        """Get the attribute value for numArc."""
        return self.__numArc.value(self)
    def setNumArc (self, new_value):
        """Set the attribute value for numArc.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__numArc.set(self, new_value)
    
    # Attribute interpolation inherited from {http://www.opengis.net/gml}ArcStringType

    _ElementMap = ArcStringType._ElementMap.copy()
    _ElementMap.update({
        
    })
    _AttributeMap = ArcStringType._AttributeMap.copy()
    _AttributeMap.update({
        __numArc.name() : __numArc
    })
Namespace.addCategoryObject('typeBinding', u'ArcType', ArcType)


# Complex type BezierType with content type ELEMENT_ONLY
class BezierType (BSplineType):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'BezierType')
    # Base type is BSplineType
    
    # Element degree inherited from {http://www.opengis.net/gml}BSplineType
    
    # Element knot inherited from {http://www.opengis.net/gml}BSplineType
    
    # Element posList inherited from {http://www.opengis.net/gml}BSplineType
    
    # Element coordinates inherited from {http://www.opengis.net/gml}BSplineType
    
    # Element pointRep inherited from {http://www.opengis.net/gml}BSplineType
    
    # Element pos inherited from {http://www.opengis.net/gml}BSplineType
    
    # Element pointProperty inherited from {http://www.opengis.net/gml}BSplineType
    
    # Attribute knotType marked prohibited in this type
    def knotType (self):
        raise pyxb.ProhibitedAttributeError("Attribute knotType is prohibited in BezierType")
    def setKnotType (self, new_value):
        raise pyxb.ProhibitedAttributeError("Attribute knotType is prohibited in BezierType")

    
    # Attribute numDerivativesAtEnd inherited from {http://www.opengis.net/gml}AbstractCurveSegmentType
    
    # Attribute numDerivativeInterior inherited from {http://www.opengis.net/gml}AbstractCurveSegmentType
    
    # Attribute numDerivativesAtStart inherited from {http://www.opengis.net/gml}AbstractCurveSegmentType
    
    # Attribute interpolation uses Python identifier interpolation
    __interpolation = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'interpolation'), 'interpolation', '__BezierType_interpolation', CurveInterpolationType, fixed=True, unicode_default=u'polynomialSpline')
    def interpolation (self):
        """Get the attribute value for interpolation."""
        return self.__interpolation.value(self)
    def setInterpolation (self, new_value):
        """Set the attribute value for interpolation.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__interpolation.set(self, new_value)
    
    # Attribute isPolynomial uses Python identifier isPolynomial
    __isPolynomial = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'isPolynomial'), 'isPolynomial', '__BezierType_isPolynomial', pyxb.binding.datatypes.boolean, fixed=True, unicode_default=u'true')
    def isPolynomial (self):
        """Get the attribute value for isPolynomial."""
        return self.__isPolynomial.value(self)
    def setIsPolynomial (self, new_value):
        """Set the attribute value for isPolynomial.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__isPolynomial.set(self, new_value)

    _ElementMap = BSplineType._ElementMap.copy()
    _ElementMap.update({
        
    })
    _AttributeMap = BSplineType._AttributeMap.copy()
    _AttributeMap.update({
        pyxb.namespace.ExpandedName(None, u'knotType') : None,
        __interpolation.name() : __interpolation,
        __isPolynomial.name() : __isPolynomial
    })
Namespace.addCategoryObject('typeBinding', u'BezierType', BezierType)


# Complex type BoundedFeatureType with content type ELEMENT_ONLY
class BoundedFeatureType (AbstractFeatureType):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = True
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'BoundedFeatureType')
    # Base type is AbstractFeatureType
    
    # Element descriptionReference inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element description inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element boundedBy inherited from {http://www.opengis.net/gml}AbstractFeatureType
    
    # Element identifier inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element location inherited from {http://www.opengis.net/gml}AbstractFeatureType
    
    # Element name inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element metaDataProperty inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Attribute id inherited from {http://www.opengis.net/gml}AbstractGMLType

    _ElementMap = AbstractFeatureType._ElementMap.copy()
    _ElementMap.update({
        
    })
    _AttributeMap = AbstractFeatureType._AttributeMap.copy()
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', u'BoundedFeatureType', BoundedFeatureType)


# Complex type CircleByCenterPointType with content type ELEMENT_ONLY
class CircleByCenterPointType (ArcByCenterPointType):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'CircleByCenterPointType')
    # Base type is ArcByCenterPointType
    
    # Element posList inherited from {http://www.opengis.net/gml}ArcByCenterPointType
    
    # Element radius inherited from {http://www.opengis.net/gml}ArcByCenterPointType
    
    # Element coordinates inherited from {http://www.opengis.net/gml}ArcByCenterPointType
    
    # Element pointRep inherited from {http://www.opengis.net/gml}ArcByCenterPointType
    
    # Element pos inherited from {http://www.opengis.net/gml}ArcByCenterPointType
    
    # Element pointProperty inherited from {http://www.opengis.net/gml}ArcByCenterPointType
    
    # Attribute numDerivativeInterior inherited from {http://www.opengis.net/gml}AbstractCurveSegmentType
    
    # Attribute numDerivativesAtEnd inherited from {http://www.opengis.net/gml}AbstractCurveSegmentType
    
    # Attribute numDerivativesAtStart inherited from {http://www.opengis.net/gml}AbstractCurveSegmentType
    
    # Attribute numArc inherited from {http://www.opengis.net/gml}ArcByCenterPointType
    
    # Attribute interpolation inherited from {http://www.opengis.net/gml}ArcByCenterPointType

    _ElementMap = ArcByCenterPointType._ElementMap.copy()
    _ElementMap.update({
        
    })
    _AttributeMap = ArcByCenterPointType._AttributeMap.copy()
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', u'CircleByCenterPointType', CircleByCenterPointType)


# Complex type DefinitionType with content type ELEMENT_ONLY
class DefinitionType (DefinitionBaseType):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'DefinitionType')
    # Base type is DefinitionBaseType
    
    # Element descriptionReference inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element metaDataProperty inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element name inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element identifier inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element description inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element {http://www.opengis.net/gml}remarks uses Python identifier remarks
    __remarks = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'remarks'), 'remarks', '__DefinitionType_httpwww_opengis_netgmlremarks', False)
    def remarks (self):
        """Get the value of the {http://www.opengis.net/gml}remarks element."""
        return self.__remarks.value(self)
    def setRemarks (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}remarks element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__remarks.set(self, new_value)
    
    # Attribute id inherited from {http://www.opengis.net/gml}DefinitionBaseType

    _ElementMap = DefinitionBaseType._ElementMap.copy()
    _ElementMap.update({
        __remarks.name() : __remarks
    })
    _AttributeMap = DefinitionBaseType._AttributeMap.copy()
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', u'DefinitionType', DefinitionType)


# Complex type DynamicFeatureType with content type ELEMENT_ONLY
class DynamicFeatureType (AbstractFeatureType):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'DynamicFeatureType')
    # Base type is AbstractFeatureType
    
    # Element descriptionReference inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element metaDataProperty inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element name inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element {http://www.opengis.net/gml}history uses Python identifier history
    __history = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'history'), 'history', '__DynamicFeatureType_httpwww_opengis_netgmlhistory', False)
    def history (self):
        """Get the value of the {http://www.opengis.net/gml}history element."""
        return self.__history.value(self)
    def setHistory (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}history element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__history.set(self, new_value)
    
    # Element {http://www.opengis.net/gml}validTime uses Python identifier validTime
    __validTime = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'validTime'), 'validTime', '__DynamicFeatureType_httpwww_opengis_netgmlvalidTime', False)
    def validTime (self):
        """Get the value of the {http://www.opengis.net/gml}validTime element."""
        return self.__validTime.value(self)
    def setValidTime (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}validTime element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__validTime.set(self, new_value)
    
    # Element boundedBy inherited from {http://www.opengis.net/gml}AbstractFeatureType
    
    # Element identifier inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element {http://www.opengis.net/gml}dataSourceReference uses Python identifier dataSourceReference
    __dataSourceReference = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'dataSourceReference'), 'dataSourceReference', '__DynamicFeatureType_httpwww_opengis_netgmldataSourceReference', False)
    def dataSourceReference (self):
        """Get the value of the {http://www.opengis.net/gml}dataSourceReference element."""
        return self.__dataSourceReference.value(self)
    def setDataSourceReference (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}dataSourceReference element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__dataSourceReference.set(self, new_value)
    
    # Element description inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element location inherited from {http://www.opengis.net/gml}AbstractFeatureType
    
    # Element {http://www.opengis.net/gml}dataSource uses Python identifier dataSource
    __dataSource = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'dataSource'), 'dataSource', '__DynamicFeatureType_httpwww_opengis_netgmldataSource', False)
    def dataSource (self):
        """Get the value of the {http://www.opengis.net/gml}dataSource element."""
        return self.__dataSource.value(self)
    def setDataSource (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}dataSource element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__dataSource.set(self, new_value)
    
    # Attribute id inherited from {http://www.opengis.net/gml}AbstractGMLType

    _ElementMap = AbstractFeatureType._ElementMap.copy()
    _ElementMap.update({
        __history.name() : __history,
        __validTime.name() : __validTime,
        __dataSourceReference.name() : __dataSourceReference,
        __dataSource.name() : __dataSource
    })
    _AttributeMap = AbstractFeatureType._AttributeMap.copy()
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', u'DynamicFeatureType', DynamicFeatureType)


# Complex type GeodesicType with content type ELEMENT_ONLY
class GeodesicType (GeodesicStringType):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'GeodesicType')
    # Base type is GeodesicStringType
    
    # Element posList inherited from {http://www.opengis.net/gml}GeodesicStringType
    
    # Element pos inherited from {http://www.opengis.net/gml}GeodesicStringType
    
    # Element pointProperty inherited from {http://www.opengis.net/gml}GeodesicStringType
    
    # Attribute numDerivativesAtEnd inherited from {http://www.opengis.net/gml}AbstractCurveSegmentType
    
    # Attribute numDerivativeInterior inherited from {http://www.opengis.net/gml}AbstractCurveSegmentType
    
    # Attribute numDerivativesAtStart inherited from {http://www.opengis.net/gml}AbstractCurveSegmentType
    
    # Attribute interpolation inherited from {http://www.opengis.net/gml}GeodesicStringType

    _ElementMap = GeodesicStringType._ElementMap.copy()
    _ElementMap.update({
        
    })
    _AttributeMap = GeodesicStringType._AttributeMap.copy()
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', u'GeodesicType', GeodesicType)


# Complex type GeometricComplexType with content type ELEMENT_ONLY
class GeometricComplexType (AbstractGeometryType):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'GeometricComplexType')
    # Base type is AbstractGeometryType
    
    # Element descriptionReference inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element name inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element identifier inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element {http://www.opengis.net/gml}element uses Python identifier element
    __element = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'element'), 'element', '__GeometricComplexType_httpwww_opengis_netgmlelement', True)
    def element (self):
        """Get the value of the {http://www.opengis.net/gml}element element."""
        return self.__element.value(self)
    def setElement (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}element element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__element.set(self, new_value)
    
    def addElement (self, new_value):
        """Add the value as another occurrence of the {http://www.opengis.net/gml}element element.  Raises
        BadValueTypeException if the new value is not consistent with the
        element's type."""
        return self.__element.append(self, new_value)
    
    # Element description inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element metaDataProperty inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Attribute uomLabels inherited from {http://www.opengis.net/gml}AbstractGeometryType
    
    # Attribute axisLabels inherited from {http://www.opengis.net/gml}AbstractGeometryType
    
    # Attribute id inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Attribute srsName inherited from {http://www.opengis.net/gml}AbstractGeometryType
    
    # Attribute srsDimension inherited from {http://www.opengis.net/gml}AbstractGeometryType
    
    # Attribute aggregationType uses Python identifier aggregationType
    __aggregationType = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'aggregationType'), 'aggregationType', '__GeometricComplexType_aggregationType', AggregationType)
    def aggregationType (self):
        """Get the attribute value for aggregationType."""
        return self.__aggregationType.value(self)
    def setAggregationType (self, new_value):
        """Set the attribute value for aggregationType.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__aggregationType.set(self, new_value)

    _ElementMap = AbstractGeometryType._ElementMap.copy()
    _ElementMap.update({
        __element.name() : __element
    })
    _AttributeMap = AbstractGeometryType._AttributeMap.copy()
    _AttributeMap.update({
        __aggregationType.name() : __aggregationType
    })
Namespace.addCategoryObject('typeBinding', u'GeometricComplexType', GeometricComplexType)


# Complex type GridType with content type ELEMENT_ONLY
class GridType (AbstractGeometryType):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'GridType')
    # Base type is AbstractGeometryType
    
    # Element descriptionReference inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element {http://www.opengis.net/gml}limits uses Python identifier limits
    __limits = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'limits'), 'limits', '__GridType_httpwww_opengis_netgmllimits', True)
    def limits (self):
        """Get the value of the {http://www.opengis.net/gml}limits element."""
        return self.__limits.value(self)
    def setLimits (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}limits element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__limits.set(self, new_value)
    
    def addLimits (self, new_value):
        """Add the value as another occurrence of the {http://www.opengis.net/gml}limits element.  Raises
        BadValueTypeException if the new value is not consistent with the
        element's type."""
        return self.__limits.append(self, new_value)
    
    # Element {http://www.opengis.net/gml}axisLabels uses Python identifier axisLabels
    __axisLabels = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'axisLabels'), 'axisLabels', '__GridType_httpwww_opengis_netgmlaxisLabels', False)
    def axisLabels (self):
        """Get the value of the {http://www.opengis.net/gml}axisLabels element."""
        return self.__axisLabels.value(self)
    def setAxisLabels (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}axisLabels element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__axisLabels.set(self, new_value)
    
    # Element description inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element {http://www.opengis.net/gml}axisName uses Python identifier axisName
    __axisName = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'axisName'), 'axisName', '__GridType_httpwww_opengis_netgmlaxisName', True)
    def axisName (self):
        """Get the value of the {http://www.opengis.net/gml}axisName element."""
        return self.__axisName.value(self)
    def setAxisName (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}axisName element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__axisName.set(self, new_value)
    
    def addAxisName (self, new_value):
        """Add the value as another occurrence of the {http://www.opengis.net/gml}axisName element.  Raises
        BadValueTypeException if the new value is not consistent with the
        element's type."""
        return self.__axisName.append(self, new_value)
    
    # Element identifier inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element name inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element metaDataProperty inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Attribute uomLabels inherited from {http://www.opengis.net/gml}AbstractGeometryType
    
    # Attribute axisLabels inherited from {http://www.opengis.net/gml}AbstractGeometryType
    
    # Attribute id inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Attribute dimension uses Python identifier dimension
    __dimension = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'dimension'), 'dimension', '__GridType_dimension', pyxb.binding.datatypes.positiveInteger, required=True)
    def dimension (self):
        """Get the attribute value for dimension."""
        return self.__dimension.value(self)
    def setDimension (self, new_value):
        """Set the attribute value for dimension.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__dimension.set(self, new_value)
    
    # Attribute srsName inherited from {http://www.opengis.net/gml}AbstractGeometryType
    
    # Attribute srsDimension inherited from {http://www.opengis.net/gml}AbstractGeometryType

    _ElementMap = AbstractGeometryType._ElementMap.copy()
    _ElementMap.update({
        __limits.name() : __limits,
        __axisLabels.name() : __axisLabels,
        __axisName.name() : __axisName
    })
    _AttributeMap = AbstractGeometryType._AttributeMap.copy()
    _AttributeMap.update({
        __dimension.name() : __dimension
    })
Namespace.addCategoryObject('typeBinding', u'GridType', GridType)


# Complex type MovingObjectStatusType with content type ELEMENT_ONLY
class MovingObjectStatusType (AbstractTimeSliceType):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'MovingObjectStatusType')
    # Base type is AbstractTimeSliceType
    
    # Element descriptionReference inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element description inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element {http://www.opengis.net/gml}locationName uses Python identifier locationName
    __locationName = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'locationName'), 'locationName', '__MovingObjectStatusType_httpwww_opengis_netgmllocationName', False)
    def locationName (self):
        """Get the value of the {http://www.opengis.net/gml}locationName element."""
        return self.__locationName.value(self)
    def setLocationName (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}locationName element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__locationName.set(self, new_value)
    
    # Element name inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element {http://www.opengis.net/gml}elevation uses Python identifier elevation
    __elevation = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'elevation'), 'elevation', '__MovingObjectStatusType_httpwww_opengis_netgmlelevation', True)
    def elevation (self):
        """Get the value of the {http://www.opengis.net/gml}elevation element."""
        return self.__elevation.value(self)
    def setElevation (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}elevation element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__elevation.set(self, new_value)
    
    def addElevation (self, new_value):
        """Add the value as another occurrence of the {http://www.opengis.net/gml}elevation element.  Raises
        BadValueTypeException if the new value is not consistent with the
        element's type."""
        return self.__elevation.append(self, new_value)
    
    # Element validTime inherited from {http://www.opengis.net/gml}AbstractTimeSliceType
    
    # Element {http://www.opengis.net/gml}locationReference uses Python identifier locationReference
    __locationReference = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'locationReference'), 'locationReference', '__MovingObjectStatusType_httpwww_opengis_netgmllocationReference', False)
    def locationReference (self):
        """Get the value of the {http://www.opengis.net/gml}locationReference element."""
        return self.__locationReference.value(self)
    def setLocationReference (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}locationReference element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__locationReference.set(self, new_value)
    
    # Element {http://www.opengis.net/gml}speed uses Python identifier speed
    __speed = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'speed'), 'speed', '__MovingObjectStatusType_httpwww_opengis_netgmlspeed', True)
    def speed (self):
        """Get the value of the {http://www.opengis.net/gml}speed element."""
        return self.__speed.value(self)
    def setSpeed (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}speed element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__speed.set(self, new_value)
    
    def addSpeed (self, new_value):
        """Add the value as another occurrence of the {http://www.opengis.net/gml}speed element.  Raises
        BadValueTypeException if the new value is not consistent with the
        element's type."""
        return self.__speed.append(self, new_value)
    
    # Element {http://www.opengis.net/gml}bearing uses Python identifier bearing
    __bearing = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'bearing'), 'bearing', '__MovingObjectStatusType_httpwww_opengis_netgmlbearing', True)
    def bearing (self):
        """Get the value of the {http://www.opengis.net/gml}bearing element."""
        return self.__bearing.value(self)
    def setBearing (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}bearing element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__bearing.set(self, new_value)
    
    def addBearing (self, new_value):
        """Add the value as another occurrence of the {http://www.opengis.net/gml}bearing element.  Raises
        BadValueTypeException if the new value is not consistent with the
        element's type."""
        return self.__bearing.append(self, new_value)
    
    # Element identifier inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element {http://www.opengis.net/gml}status uses Python identifier status
    __status = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'status'), 'status', '__MovingObjectStatusType_httpwww_opengis_netgmlstatus', True)
    def status (self):
        """Get the value of the {http://www.opengis.net/gml}status element."""
        return self.__status.value(self)
    def setStatus (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}status element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__status.set(self, new_value)
    
    def addStatus (self, new_value):
        """Add the value as another occurrence of the {http://www.opengis.net/gml}status element.  Raises
        BadValueTypeException if the new value is not consistent with the
        element's type."""
        return self.__status.append(self, new_value)
    
    # Element {http://www.opengis.net/gml}location uses Python identifier location
    __location = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'location'), 'location', '__MovingObjectStatusType_httpwww_opengis_netgmllocation', False)
    def location (self):
        """Get the value of the {http://www.opengis.net/gml}location element."""
        return self.__location.value(self)
    def setLocation (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}location element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__location.set(self, new_value)
    
    # Element {http://www.opengis.net/gml}acceleration uses Python identifier acceleration
    __acceleration = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'acceleration'), 'acceleration', '__MovingObjectStatusType_httpwww_opengis_netgmlacceleration', True)
    def acceleration (self):
        """Get the value of the {http://www.opengis.net/gml}acceleration element."""
        return self.__acceleration.value(self)
    def setAcceleration (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}acceleration element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__acceleration.set(self, new_value)
    
    def addAcceleration (self, new_value):
        """Add the value as another occurrence of the {http://www.opengis.net/gml}acceleration element.  Raises
        BadValueTypeException if the new value is not consistent with the
        element's type."""
        return self.__acceleration.append(self, new_value)
    
    # Element {http://www.opengis.net/gml}position uses Python identifier position
    __position = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'position'), 'position', '__MovingObjectStatusType_httpwww_opengis_netgmlposition', False)
    def position (self):
        """Get the value of the {http://www.opengis.net/gml}position element."""
        return self.__position.value(self)
    def setPosition (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}position element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__position.set(self, new_value)
    
    # Element dataSource inherited from {http://www.opengis.net/gml}AbstractTimeSliceType
    
    # Element metaDataProperty inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element {http://www.opengis.net/gml}pos uses Python identifier pos
    __pos = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'pos'), 'pos', '__MovingObjectStatusType_httpwww_opengis_netgmlpos', False)
    def pos (self):
        """Get the value of the {http://www.opengis.net/gml}pos element."""
        return self.__pos.value(self)
    def setPos (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}pos element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__pos.set(self, new_value)
    
    # Element {http://www.opengis.net/gml}statusReference uses Python identifier statusReference
    __statusReference = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'statusReference'), 'statusReference', '__MovingObjectStatusType_httpwww_opengis_netgmlstatusReference', True)
    def statusReference (self):
        """Get the value of the {http://www.opengis.net/gml}statusReference element."""
        return self.__statusReference.value(self)
    def setStatusReference (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}statusReference element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__statusReference.set(self, new_value)
    
    def addStatusReference (self, new_value):
        """Add the value as another occurrence of the {http://www.opengis.net/gml}statusReference element.  Raises
        BadValueTypeException if the new value is not consistent with the
        element's type."""
        return self.__statusReference.append(self, new_value)
    
    # Attribute id inherited from {http://www.opengis.net/gml}AbstractGMLType

    _ElementMap = AbstractTimeSliceType._ElementMap.copy()
    _ElementMap.update({
        __locationName.name() : __locationName,
        __elevation.name() : __elevation,
        __locationReference.name() : __locationReference,
        __speed.name() : __speed,
        __bearing.name() : __bearing,
        __status.name() : __status,
        __location.name() : __location,
        __acceleration.name() : __acceleration,
        __position.name() : __position,
        __pos.name() : __pos,
        __statusReference.name() : __statusReference
    })
    _AttributeMap = AbstractTimeSliceType._AttributeMap.copy()
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', u'MovingObjectStatusType', MovingObjectStatusType)


# Complex type ObservationType with content type ELEMENT_ONLY
class ObservationType (AbstractFeatureType):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'ObservationType')
    # Base type is AbstractFeatureType
    
    # Element descriptionReference inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element {http://www.opengis.net/gml}target uses Python identifier target
    __target = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'target'), 'target', '__ObservationType_httpwww_opengis_netgmltarget', False)
    def target (self):
        """Get the value of the {http://www.opengis.net/gml}target element."""
        return self.__target.value(self)
    def setTarget (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}target element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__target.set(self, new_value)
    
    # Element {http://www.opengis.net/gml}resultOf uses Python identifier resultOf
    __resultOf = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'resultOf'), 'resultOf', '__ObservationType_httpwww_opengis_netgmlresultOf', False)
    def resultOf (self):
        """Get the value of the {http://www.opengis.net/gml}resultOf element."""
        return self.__resultOf.value(self)
    def setResultOf (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}resultOf element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__resultOf.set(self, new_value)
    
    # Element {http://www.opengis.net/gml}validTime uses Python identifier validTime
    __validTime = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'validTime'), 'validTime', '__ObservationType_httpwww_opengis_netgmlvalidTime', False)
    def validTime (self):
        """Get the value of the {http://www.opengis.net/gml}validTime element."""
        return self.__validTime.value(self)
    def setValidTime (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}validTime element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__validTime.set(self, new_value)
    
    # Element boundedBy inherited from {http://www.opengis.net/gml}AbstractFeatureType
    
    # Element identifier inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element location inherited from {http://www.opengis.net/gml}AbstractFeatureType
    
    # Element {http://www.opengis.net/gml}using uses Python identifier using
    __using = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'using'), 'using', '__ObservationType_httpwww_opengis_netgmlusing', False)
    def using (self):
        """Get the value of the {http://www.opengis.net/gml}using element."""
        return self.__using.value(self)
    def setUsing (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}using element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__using.set(self, new_value)
    
    # Element description inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element metaDataProperty inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element name inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Attribute id inherited from {http://www.opengis.net/gml}AbstractGMLType

    _ElementMap = AbstractFeatureType._ElementMap.copy()
    _ElementMap.update({
        __target.name() : __target,
        __resultOf.name() : __resultOf,
        __validTime.name() : __validTime,
        __using.name() : __using
    })
    _AttributeMap = AbstractFeatureType._AttributeMap.copy()
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', u'ObservationType', ObservationType)


# Complex type TopoComplexType with content type ELEMENT_ONLY
class TopoComplexType (AbstractTopologyType):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'TopoComplexType')
    # Base type is AbstractTopologyType
    
    # Element descriptionReference inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element name inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element {http://www.opengis.net/gml}superComplex uses Python identifier superComplex
    __superComplex = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'superComplex'), 'superComplex', '__TopoComplexType_httpwww_opengis_netgmlsuperComplex', True)
    def superComplex (self):
        """Get the value of the {http://www.opengis.net/gml}superComplex element."""
        return self.__superComplex.value(self)
    def setSuperComplex (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}superComplex element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__superComplex.set(self, new_value)
    
    def addSuperComplex (self, new_value):
        """Add the value as another occurrence of the {http://www.opengis.net/gml}superComplex element.  Raises
        BadValueTypeException if the new value is not consistent with the
        element's type."""
        return self.__superComplex.append(self, new_value)
    
    # Element {http://www.opengis.net/gml}subComplex uses Python identifier subComplex
    __subComplex = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'subComplex'), 'subComplex', '__TopoComplexType_httpwww_opengis_netgmlsubComplex', True)
    def subComplex (self):
        """Get the value of the {http://www.opengis.net/gml}subComplex element."""
        return self.__subComplex.value(self)
    def setSubComplex (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}subComplex element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__subComplex.set(self, new_value)
    
    def addSubComplex (self, new_value):
        """Add the value as another occurrence of the {http://www.opengis.net/gml}subComplex element.  Raises
        BadValueTypeException if the new value is not consistent with the
        element's type."""
        return self.__subComplex.append(self, new_value)
    
    # Element {http://www.opengis.net/gml}topoPrimitiveMember uses Python identifier topoPrimitiveMember
    __topoPrimitiveMember = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'topoPrimitiveMember'), 'topoPrimitiveMember', '__TopoComplexType_httpwww_opengis_netgmltopoPrimitiveMember', True)
    def topoPrimitiveMember (self):
        """Get the value of the {http://www.opengis.net/gml}topoPrimitiveMember element."""
        return self.__topoPrimitiveMember.value(self)
    def setTopoPrimitiveMember (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}topoPrimitiveMember element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__topoPrimitiveMember.set(self, new_value)
    
    def addTopoPrimitiveMember (self, new_value):
        """Add the value as another occurrence of the {http://www.opengis.net/gml}topoPrimitiveMember element.  Raises
        BadValueTypeException if the new value is not consistent with the
        element's type."""
        return self.__topoPrimitiveMember.append(self, new_value)
    
    # Element identifier inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element {http://www.opengis.net/gml}topoPrimitiveMembers uses Python identifier topoPrimitiveMembers
    __topoPrimitiveMembers = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'topoPrimitiveMembers'), 'topoPrimitiveMembers', '__TopoComplexType_httpwww_opengis_netgmltopoPrimitiveMembers', False)
    def topoPrimitiveMembers (self):
        """Get the value of the {http://www.opengis.net/gml}topoPrimitiveMembers element."""
        return self.__topoPrimitiveMembers.value(self)
    def setTopoPrimitiveMembers (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}topoPrimitiveMembers element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__topoPrimitiveMembers.set(self, new_value)
    
    # Element description inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element {http://www.opengis.net/gml}maximalComplex uses Python identifier maximalComplex
    __maximalComplex = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'maximalComplex'), 'maximalComplex', '__TopoComplexType_httpwww_opengis_netgmlmaximalComplex', False)
    def maximalComplex (self):
        """Get the value of the {http://www.opengis.net/gml}maximalComplex element."""
        return self.__maximalComplex.value(self)
    def setMaximalComplex (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}maximalComplex element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__maximalComplex.set(self, new_value)
    
    # Element metaDataProperty inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Attribute aggregationType uses Python identifier aggregationType
    __aggregationType = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'aggregationType'), 'aggregationType', '__TopoComplexType_aggregationType', AggregationType)
    def aggregationType (self):
        """Get the attribute value for aggregationType."""
        return self.__aggregationType.value(self)
    def setAggregationType (self, new_value):
        """Set the attribute value for aggregationType.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__aggregationType.set(self, new_value)
    
    # Attribute id inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Attribute isMaximal uses Python identifier isMaximal
    __isMaximal = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'isMaximal'), 'isMaximal', '__TopoComplexType_isMaximal', pyxb.binding.datatypes.boolean, unicode_default=u'false')
    def isMaximal (self):
        """Get the attribute value for isMaximal."""
        return self.__isMaximal.value(self)
    def setIsMaximal (self, new_value):
        """Set the attribute value for isMaximal.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__isMaximal.set(self, new_value)

    _ElementMap = AbstractTopologyType._ElementMap.copy()
    _ElementMap.update({
        __superComplex.name() : __superComplex,
        __subComplex.name() : __subComplex,
        __topoPrimitiveMember.name() : __topoPrimitiveMember,
        __topoPrimitiveMembers.name() : __topoPrimitiveMembers,
        __maximalComplex.name() : __maximalComplex
    })
    _AttributeMap = AbstractTopologyType._AttributeMap.copy()
    _AttributeMap.update({
        __aggregationType.name() : __aggregationType,
        __isMaximal.name() : __isMaximal
    })
Namespace.addCategoryObject('typeBinding', u'TopoComplexType', TopoComplexType)


# Complex type TopoCurveType with content type ELEMENT_ONLY
class TopoCurveType (AbstractTopologyType):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'TopoCurveType')
    # Base type is AbstractTopologyType
    
    # Element descriptionReference inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element name inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element identifier inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element description inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element {http://www.opengis.net/gml}directedEdge uses Python identifier directedEdge
    __directedEdge = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'directedEdge'), 'directedEdge', '__TopoCurveType_httpwww_opengis_netgmldirectedEdge', True)
    def directedEdge (self):
        """Get the value of the {http://www.opengis.net/gml}directedEdge element."""
        return self.__directedEdge.value(self)
    def setDirectedEdge (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}directedEdge element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__directedEdge.set(self, new_value)
    
    def addDirectedEdge (self, new_value):
        """Add the value as another occurrence of the {http://www.opengis.net/gml}directedEdge element.  Raises
        BadValueTypeException if the new value is not consistent with the
        element's type."""
        return self.__directedEdge.append(self, new_value)
    
    # Element metaDataProperty inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Attribute aggregationType uses Python identifier aggregationType
    __aggregationType = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'aggregationType'), 'aggregationType', '__TopoCurveType_aggregationType', AggregationType)
    def aggregationType (self):
        """Get the attribute value for aggregationType."""
        return self.__aggregationType.value(self)
    def setAggregationType (self, new_value):
        """Set the attribute value for aggregationType.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__aggregationType.set(self, new_value)
    
    # Attribute id inherited from {http://www.opengis.net/gml}AbstractGMLType

    _ElementMap = AbstractTopologyType._ElementMap.copy()
    _ElementMap.update({
        __directedEdge.name() : __directedEdge
    })
    _AttributeMap = AbstractTopologyType._AttributeMap.copy()
    _AttributeMap.update({
        __aggregationType.name() : __aggregationType
    })
Namespace.addCategoryObject('typeBinding', u'TopoCurveType', TopoCurveType)


# Complex type TopoPointType with content type ELEMENT_ONLY
class TopoPointType (AbstractTopologyType):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'TopoPointType')
    # Base type is AbstractTopologyType
    
    # Element descriptionReference inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element name inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element identifier inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element {http://www.opengis.net/gml}directedNode uses Python identifier directedNode
    __directedNode = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'directedNode'), 'directedNode', '__TopoPointType_httpwww_opengis_netgmldirectedNode', False)
    def directedNode (self):
        """Get the value of the {http://www.opengis.net/gml}directedNode element."""
        return self.__directedNode.value(self)
    def setDirectedNode (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}directedNode element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__directedNode.set(self, new_value)
    
    # Element description inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element metaDataProperty inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Attribute id inherited from {http://www.opengis.net/gml}AbstractGMLType

    _ElementMap = AbstractTopologyType._ElementMap.copy()
    _ElementMap.update({
        __directedNode.name() : __directedNode
    })
    _AttributeMap = AbstractTopologyType._AttributeMap.copy()
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', u'TopoPointType', TopoPointType)


# Complex type TopoSurfaceType with content type ELEMENT_ONLY
class TopoSurfaceType (AbstractTopologyType):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'TopoSurfaceType')
    # Base type is AbstractTopologyType
    
    # Element descriptionReference inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element name inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element {http://www.opengis.net/gml}directedFace uses Python identifier directedFace
    __directedFace = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'directedFace'), 'directedFace', '__TopoSurfaceType_httpwww_opengis_netgmldirectedFace', True)
    def directedFace (self):
        """Get the value of the {http://www.opengis.net/gml}directedFace element."""
        return self.__directedFace.value(self)
    def setDirectedFace (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}directedFace element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__directedFace.set(self, new_value)
    
    def addDirectedFace (self, new_value):
        """Add the value as another occurrence of the {http://www.opengis.net/gml}directedFace element.  Raises
        BadValueTypeException if the new value is not consistent with the
        element's type."""
        return self.__directedFace.append(self, new_value)
    
    # Element identifier inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element description inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element metaDataProperty inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Attribute aggregationType uses Python identifier aggregationType
    __aggregationType = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'aggregationType'), 'aggregationType', '__TopoSurfaceType_aggregationType', AggregationType)
    def aggregationType (self):
        """Get the attribute value for aggregationType."""
        return self.__aggregationType.value(self)
    def setAggregationType (self, new_value):
        """Set the attribute value for aggregationType.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__aggregationType.set(self, new_value)
    
    # Attribute id inherited from {http://www.opengis.net/gml}AbstractGMLType

    _ElementMap = AbstractTopologyType._ElementMap.copy()
    _ElementMap.update({
        __directedFace.name() : __directedFace
    })
    _AttributeMap = AbstractTopologyType._AttributeMap.copy()
    _AttributeMap.update({
        __aggregationType.name() : __aggregationType
    })
Namespace.addCategoryObject('typeBinding', u'TopoSurfaceType', TopoSurfaceType)


# Complex type TopoVolumeType with content type ELEMENT_ONLY
class TopoVolumeType (AbstractTopologyType):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'TopoVolumeType')
    # Base type is AbstractTopologyType
    
    # Element descriptionReference inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element {http://www.opengis.net/gml}directedTopoSolid uses Python identifier directedTopoSolid
    __directedTopoSolid = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'directedTopoSolid'), 'directedTopoSolid', '__TopoVolumeType_httpwww_opengis_netgmldirectedTopoSolid', True)
    def directedTopoSolid (self):
        """Get the value of the {http://www.opengis.net/gml}directedTopoSolid element."""
        return self.__directedTopoSolid.value(self)
    def setDirectedTopoSolid (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}directedTopoSolid element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__directedTopoSolid.set(self, new_value)
    
    def addDirectedTopoSolid (self, new_value):
        """Add the value as another occurrence of the {http://www.opengis.net/gml}directedTopoSolid element.  Raises
        BadValueTypeException if the new value is not consistent with the
        element's type."""
        return self.__directedTopoSolid.append(self, new_value)
    
    # Element name inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element identifier inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element description inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element metaDataProperty inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Attribute aggregationType uses Python identifier aggregationType
    __aggregationType = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'aggregationType'), 'aggregationType', '__TopoVolumeType_aggregationType', AggregationType)
    def aggregationType (self):
        """Get the attribute value for aggregationType."""
        return self.__aggregationType.value(self)
    def setAggregationType (self, new_value):
        """Set the attribute value for aggregationType.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__aggregationType.set(self, new_value)
    
    # Attribute id inherited from {http://www.opengis.net/gml}AbstractGMLType

    _ElementMap = AbstractTopologyType._ElementMap.copy()
    _ElementMap.update({
        __directedTopoSolid.name() : __directedTopoSolid
    })
    _AttributeMap = AbstractTopologyType._AttributeMap.copy()
    _AttributeMap.update({
        __aggregationType.name() : __aggregationType
    })
Namespace.addCategoryObject('typeBinding', u'TopoVolumeType', TopoVolumeType)


# Complex type ValueArrayType with content type ELEMENT_ONLY
class ValueArrayType (CompositeValueType):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'ValueArrayType')
    # Base type is CompositeValueType
    
    # Element descriptionReference inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element valueComponents inherited from {http://www.opengis.net/gml}CompositeValueType
    
    # Element name inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element valueComponent inherited from {http://www.opengis.net/gml}CompositeValueType
    
    # Element identifier inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element description inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element metaDataProperty inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Attribute aggregationType inherited from {http://www.opengis.net/gml}CompositeValueType
    
    # Attribute id inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Attribute codeSpace uses Python identifier codeSpace
    __codeSpace = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'codeSpace'), 'codeSpace', '__ValueArrayType_codeSpace', pyxb.binding.datatypes.anyURI)
    def codeSpace (self):
        """Get the attribute value for codeSpace."""
        return self.__codeSpace.value(self)
    def setCodeSpace (self, new_value):
        """Set the attribute value for codeSpace.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__codeSpace.set(self, new_value)
    
    # Attribute uom uses Python identifier uom
    __uom = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'uom'), 'uom', '__ValueArrayType_uom', UomIdentifier)
    def uom (self):
        """Get the attribute value for uom."""
        return self.__uom.value(self)
    def setUom (self, new_value):
        """Set the attribute value for uom.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__uom.set(self, new_value)

    _ElementMap = CompositeValueType._ElementMap.copy()
    _ElementMap.update({
        
    })
    _AttributeMap = CompositeValueType._AttributeMap.copy()
    _AttributeMap.update({
        __codeSpace.name() : __codeSpace,
        __uom.name() : __uom
    })
Namespace.addCategoryObject('typeBinding', u'ValueArrayType', ValueArrayType)


# Complex type AbstractContinuousCoverageType with content type ELEMENT_ONLY
class AbstractContinuousCoverageType (AbstractCoverageType):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = True
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'AbstractContinuousCoverageType')
    # Base type is AbstractCoverageType
    
    # Element descriptionReference inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element name inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element rangeSet inherited from {http://www.opengis.net/gml}AbstractCoverageType
    
    # Element domainSet inherited from {http://www.opengis.net/gml}AbstractCoverageType
    
    # Element boundedBy inherited from {http://www.opengis.net/gml}AbstractFeatureType
    
    # Element identifier inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element location inherited from {http://www.opengis.net/gml}AbstractFeatureType
    
    # Element {http://www.opengis.net/gml}coverageFunction uses Python identifier coverageFunction
    __coverageFunction = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'coverageFunction'), 'coverageFunction', '__AbstractContinuousCoverageType_httpwww_opengis_netgmlcoverageFunction', False)
    def coverageFunction (self):
        """Get the value of the {http://www.opengis.net/gml}coverageFunction element."""
        return self.__coverageFunction.value(self)
    def setCoverageFunction (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}coverageFunction element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__coverageFunction.set(self, new_value)
    
    # Element description inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element metaDataProperty inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Attribute id inherited from {http://www.opengis.net/gml}AbstractGMLType

    _ElementMap = AbstractCoverageType._ElementMap.copy()
    _ElementMap.update({
        __coverageFunction.name() : __coverageFunction
    })
    _AttributeMap = AbstractCoverageType._AttributeMap.copy()
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', u'AbstractContinuousCoverageType', AbstractContinuousCoverageType)


# Complex type AbstractCurveType with content type ELEMENT_ONLY
class AbstractCurveType (AbstractGeometricPrimitiveType):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = True
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'AbstractCurveType')
    # Base type is AbstractGeometricPrimitiveType
    
    # Element descriptionReference inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element name inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element identifier inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element metaDataProperty inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element description inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Attribute srsName inherited from {http://www.opengis.net/gml}AbstractGeometryType
    
    # Attribute axisLabels inherited from {http://www.opengis.net/gml}AbstractGeometryType
    
    # Attribute id inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Attribute uomLabels inherited from {http://www.opengis.net/gml}AbstractGeometryType
    
    # Attribute srsDimension inherited from {http://www.opengis.net/gml}AbstractGeometryType

    _ElementMap = AbstractGeometricPrimitiveType._ElementMap.copy()
    _ElementMap.update({
        
    })
    _AttributeMap = AbstractGeometricPrimitiveType._AttributeMap.copy()
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', u'AbstractCurveType', AbstractCurveType)


# Complex type AbstractDiscreteCoverageType with content type ELEMENT_ONLY
class AbstractDiscreteCoverageType (AbstractCoverageType):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = True
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'AbstractDiscreteCoverageType')
    # Base type is AbstractCoverageType
    
    # Element descriptionReference inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element name inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element rangeSet inherited from {http://www.opengis.net/gml}AbstractCoverageType
    
    # Element domainSet inherited from {http://www.opengis.net/gml}AbstractCoverageType
    
    # Element boundedBy inherited from {http://www.opengis.net/gml}AbstractFeatureType
    
    # Element identifier inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element location inherited from {http://www.opengis.net/gml}AbstractFeatureType
    
    # Element {http://www.opengis.net/gml}coverageFunction uses Python identifier coverageFunction
    __coverageFunction = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'coverageFunction'), 'coverageFunction', '__AbstractDiscreteCoverageType_httpwww_opengis_netgmlcoverageFunction', False)
    def coverageFunction (self):
        """Get the value of the {http://www.opengis.net/gml}coverageFunction element."""
        return self.__coverageFunction.value(self)
    def setCoverageFunction (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}coverageFunction element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__coverageFunction.set(self, new_value)
    
    # Element description inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element metaDataProperty inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Attribute id inherited from {http://www.opengis.net/gml}AbstractGMLType

    _ElementMap = AbstractCoverageType._ElementMap.copy()
    _ElementMap.update({
        __coverageFunction.name() : __coverageFunction
    })
    _AttributeMap = AbstractCoverageType._AttributeMap.copy()
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', u'AbstractDiscreteCoverageType', AbstractDiscreteCoverageType)


# Complex type AbstractSolidType with content type ELEMENT_ONLY
class AbstractSolidType (AbstractGeometricPrimitiveType):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'AbstractSolidType')
    # Base type is AbstractGeometricPrimitiveType
    
    # Element descriptionReference inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element name inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element identifier inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element metaDataProperty inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element description inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Attribute srsName inherited from {http://www.opengis.net/gml}AbstractGeometryType
    
    # Attribute axisLabels inherited from {http://www.opengis.net/gml}AbstractGeometryType
    
    # Attribute id inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Attribute uomLabels inherited from {http://www.opengis.net/gml}AbstractGeometryType
    
    # Attribute srsDimension inherited from {http://www.opengis.net/gml}AbstractGeometryType

    _ElementMap = AbstractGeometricPrimitiveType._ElementMap.copy()
    _ElementMap.update({
        
    })
    _AttributeMap = AbstractGeometricPrimitiveType._AttributeMap.copy()
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', u'AbstractSolidType', AbstractSolidType)


# Complex type AbstractSurfaceType with content type ELEMENT_ONLY
class AbstractSurfaceType (AbstractGeometricPrimitiveType):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = True
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'AbstractSurfaceType')
    # Base type is AbstractGeometricPrimitiveType
    
    # Element descriptionReference inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element name inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element identifier inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element metaDataProperty inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element description inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Attribute srsName inherited from {http://www.opengis.net/gml}AbstractGeometryType
    
    # Attribute axisLabels inherited from {http://www.opengis.net/gml}AbstractGeometryType
    
    # Attribute id inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Attribute uomLabels inherited from {http://www.opengis.net/gml}AbstractGeometryType
    
    # Attribute srsDimension inherited from {http://www.opengis.net/gml}AbstractGeometryType

    _ElementMap = AbstractGeometricPrimitiveType._ElementMap.copy()
    _ElementMap.update({
        
    })
    _AttributeMap = AbstractGeometricPrimitiveType._AttributeMap.copy()
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', u'AbstractSurfaceType', AbstractSurfaceType)


# Complex type AbstractTimeGeometricPrimitiveType with content type ELEMENT_ONLY
class AbstractTimeGeometricPrimitiveType (AbstractTimePrimitiveType):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = True
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'AbstractTimeGeometricPrimitiveType')
    # Base type is AbstractTimePrimitiveType
    
    # Element descriptionReference inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element name inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element identifier inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element description inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element metaDataProperty inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element relatedTime inherited from {http://www.opengis.net/gml}AbstractTimePrimitiveType
    
    # Attribute frame uses Python identifier frame
    __frame = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'frame'), 'frame', '__AbstractTimeGeometricPrimitiveType_frame', pyxb.binding.datatypes.anyURI, unicode_default=u'#ISO-8601')
    def frame (self):
        """Get the attribute value for frame."""
        return self.__frame.value(self)
    def setFrame (self, new_value):
        """Set the attribute value for frame.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__frame.set(self, new_value)
    
    # Attribute id inherited from {http://www.opengis.net/gml}AbstractGMLType

    _ElementMap = AbstractTimePrimitiveType._ElementMap.copy()
    _ElementMap.update({
        
    })
    _AttributeMap = AbstractTimePrimitiveType._AttributeMap.copy()
    _AttributeMap.update({
        __frame.name() : __frame
    })
Namespace.addCategoryObject('typeBinding', u'AbstractTimeGeometricPrimitiveType', AbstractTimeGeometricPrimitiveType)


# Complex type AbstractTimeTopologyPrimitiveType with content type ELEMENT_ONLY
class AbstractTimeTopologyPrimitiveType (AbstractTimePrimitiveType):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = True
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'AbstractTimeTopologyPrimitiveType')
    # Base type is AbstractTimePrimitiveType
    
    # Element descriptionReference inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element name inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element identifier inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element description inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element {http://www.opengis.net/gml}complex uses Python identifier complex
    __complex = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'complex'), 'complex', '__AbstractTimeTopologyPrimitiveType_httpwww_opengis_netgmlcomplex', False)
    def complex (self):
        """Get the value of the {http://www.opengis.net/gml}complex element."""
        return self.__complex.value(self)
    def setComplex (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}complex element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__complex.set(self, new_value)
    
    # Element metaDataProperty inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element relatedTime inherited from {http://www.opengis.net/gml}AbstractTimePrimitiveType
    
    # Attribute id inherited from {http://www.opengis.net/gml}AbstractGMLType

    _ElementMap = AbstractTimePrimitiveType._ElementMap.copy()
    _ElementMap.update({
        __complex.name() : __complex
    })
    _AttributeMap = AbstractTimePrimitiveType._AttributeMap.copy()
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', u'AbstractTimeTopologyPrimitiveType', AbstractTimeTopologyPrimitiveType)


# Complex type CircleType with content type ELEMENT_ONLY
class CircleType (ArcType):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'CircleType')
    # Base type is ArcType
    
    # Element pos inherited from {http://www.opengis.net/gml}ArcStringType
    
    # Element pointRep inherited from {http://www.opengis.net/gml}ArcStringType
    
    # Element pointProperty inherited from {http://www.opengis.net/gml}ArcStringType
    
    # Element posList inherited from {http://www.opengis.net/gml}ArcStringType
    
    # Element coordinates inherited from {http://www.opengis.net/gml}ArcStringType
    
    # Attribute numDerivativeInterior inherited from {http://www.opengis.net/gml}AbstractCurveSegmentType
    
    # Attribute numDerivativesAtEnd inherited from {http://www.opengis.net/gml}AbstractCurveSegmentType
    
    # Attribute numDerivativesAtStart inherited from {http://www.opengis.net/gml}AbstractCurveSegmentType
    
    # Attribute numArc inherited from {http://www.opengis.net/gml}ArcType
    
    # Attribute interpolation inherited from {http://www.opengis.net/gml}ArcStringType

    _ElementMap = ArcType._ElementMap.copy()
    _ElementMap.update({
        
    })
    _AttributeMap = ArcType._AttributeMap.copy()
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', u'CircleType', CircleType)


# Complex type ConeType with content type ELEMENT_ONLY
class ConeType (AbstractGriddedSurfaceType):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'ConeType')
    # Base type is AbstractGriddedSurfaceType
    
    # Element rows inherited from {http://www.opengis.net/gml}AbstractGriddedSurfaceType
    
    # Attribute aggregationType inherited from {http://www.opengis.net/gml}AbstractParametricCurveSurfaceType
    
    # Attribute horizontalCurveType uses Python identifier horizontalCurveType
    __horizontalCurveType = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'horizontalCurveType'), 'horizontalCurveType', '__ConeType_horizontalCurveType', CurveInterpolationType, fixed=True, unicode_default=u'circularArc3Points')
    def horizontalCurveType (self):
        """Get the attribute value for horizontalCurveType."""
        return self.__horizontalCurveType.value(self)
    def setHorizontalCurveType (self, new_value):
        """Set the attribute value for horizontalCurveType.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__horizontalCurveType.set(self, new_value)
    
    # Attribute columns inherited from {http://www.opengis.net/gml}AbstractGriddedSurfaceType
    
    # Attribute verticalCurveType uses Python identifier verticalCurveType
    __verticalCurveType = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'verticalCurveType'), 'verticalCurveType', '__ConeType_verticalCurveType', CurveInterpolationType, fixed=True, unicode_default=u'linear')
    def verticalCurveType (self):
        """Get the attribute value for verticalCurveType."""
        return self.__verticalCurveType.value(self)
    def setVerticalCurveType (self, new_value):
        """Set the attribute value for verticalCurveType.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__verticalCurveType.set(self, new_value)
    
    # Attribute rows_ inherited from {http://www.opengis.net/gml}AbstractGriddedSurfaceType

    _ElementMap = AbstractGriddedSurfaceType._ElementMap.copy()
    _ElementMap.update({
        
    })
    _AttributeMap = AbstractGriddedSurfaceType._AttributeMap.copy()
    _AttributeMap.update({
        __horizontalCurveType.name() : __horizontalCurveType,
        __verticalCurveType.name() : __verticalCurveType
    })
Namespace.addCategoryObject('typeBinding', u'ConeType', ConeType)


# Complex type CylinderType with content type ELEMENT_ONLY
class CylinderType (AbstractGriddedSurfaceType):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'CylinderType')
    # Base type is AbstractGriddedSurfaceType
    
    # Element rows inherited from {http://www.opengis.net/gml}AbstractGriddedSurfaceType
    
    # Attribute aggregationType inherited from {http://www.opengis.net/gml}AbstractParametricCurveSurfaceType
    
    # Attribute horizontalCurveType uses Python identifier horizontalCurveType
    __horizontalCurveType = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'horizontalCurveType'), 'horizontalCurveType', '__CylinderType_horizontalCurveType', CurveInterpolationType, fixed=True, unicode_default=u'circularArc3Points')
    def horizontalCurveType (self):
        """Get the attribute value for horizontalCurveType."""
        return self.__horizontalCurveType.value(self)
    def setHorizontalCurveType (self, new_value):
        """Set the attribute value for horizontalCurveType.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__horizontalCurveType.set(self, new_value)
    
    # Attribute columns inherited from {http://www.opengis.net/gml}AbstractGriddedSurfaceType
    
    # Attribute verticalCurveType uses Python identifier verticalCurveType
    __verticalCurveType = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'verticalCurveType'), 'verticalCurveType', '__CylinderType_verticalCurveType', CurveInterpolationType, fixed=True, unicode_default=u'linear')
    def verticalCurveType (self):
        """Get the attribute value for verticalCurveType."""
        return self.__verticalCurveType.value(self)
    def setVerticalCurveType (self, new_value):
        """Set the attribute value for verticalCurveType.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__verticalCurveType.set(self, new_value)
    
    # Attribute rows_ inherited from {http://www.opengis.net/gml}AbstractGriddedSurfaceType

    _ElementMap = AbstractGriddedSurfaceType._ElementMap.copy()
    _ElementMap.update({
        
    })
    _AttributeMap = AbstractGriddedSurfaceType._AttributeMap.copy()
    _AttributeMap.update({
        __horizontalCurveType.name() : __horizontalCurveType,
        __verticalCurveType.name() : __verticalCurveType
    })
Namespace.addCategoryObject('typeBinding', u'CylinderType', CylinderType)


# Complex type DefinitionProxyType with content type ELEMENT_ONLY
class DefinitionProxyType (DefinitionType):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'DefinitionProxyType')
    # Base type is DefinitionType
    
    # Element descriptionReference inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element metaDataProperty inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element name inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element {http://www.opengis.net/gml}definitionRef uses Python identifier definitionRef
    __definitionRef = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'definitionRef'), 'definitionRef', '__DefinitionProxyType_httpwww_opengis_netgmldefinitionRef', False)
    def definitionRef (self):
        """Get the value of the {http://www.opengis.net/gml}definitionRef element."""
        return self.__definitionRef.value(self)
    def setDefinitionRef (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}definitionRef element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__definitionRef.set(self, new_value)
    
    # Element identifier inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element description inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element remarks inherited from {http://www.opengis.net/gml}DefinitionType
    
    # Attribute id inherited from {http://www.opengis.net/gml}DefinitionBaseType

    _ElementMap = DefinitionType._ElementMap.copy()
    _ElementMap.update({
        __definitionRef.name() : __definitionRef
    })
    _AttributeMap = DefinitionType._AttributeMap.copy()
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', u'DefinitionProxyType', DefinitionProxyType)


# Complex type DictionaryType with content type ELEMENT_ONLY
class DictionaryType (DefinitionType):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'DictionaryType')
    # Base type is DefinitionType
    
    # Element descriptionReference inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element metaDataProperty inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element description inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element {http://www.opengis.net/gml}indirectEntry uses Python identifier indirectEntry
    __indirectEntry = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'indirectEntry'), 'indirectEntry', '__DictionaryType_httpwww_opengis_netgmlindirectEntry', True)
    def indirectEntry (self):
        """Get the value of the {http://www.opengis.net/gml}indirectEntry element."""
        return self.__indirectEntry.value(self)
    def setIndirectEntry (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}indirectEntry element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__indirectEntry.set(self, new_value)
    
    def addIndirectEntry (self, new_value):
        """Add the value as another occurrence of the {http://www.opengis.net/gml}indirectEntry element.  Raises
        BadValueTypeException if the new value is not consistent with the
        element's type."""
        return self.__indirectEntry.append(self, new_value)
    
    # Element identifier inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element {http://www.opengis.net/gml}dictionaryEntry uses Python identifier dictionaryEntry
    __dictionaryEntry = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'dictionaryEntry'), 'dictionaryEntry', '__DictionaryType_httpwww_opengis_netgmldictionaryEntry', True)
    def dictionaryEntry (self):
        """Get the value of the {http://www.opengis.net/gml}dictionaryEntry element."""
        return self.__dictionaryEntry.value(self)
    def setDictionaryEntry (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}dictionaryEntry element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__dictionaryEntry.set(self, new_value)
    
    def addDictionaryEntry (self, new_value):
        """Add the value as another occurrence of the {http://www.opengis.net/gml}dictionaryEntry element.  Raises
        BadValueTypeException if the new value is not consistent with the
        element's type."""
        return self.__dictionaryEntry.append(self, new_value)
    
    # Element name inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element remarks inherited from {http://www.opengis.net/gml}DefinitionType
    
    # Attribute aggregationType uses Python identifier aggregationType
    __aggregationType = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'aggregationType'), 'aggregationType', '__DictionaryType_aggregationType', AggregationType)
    def aggregationType (self):
        """Get the attribute value for aggregationType."""
        return self.__aggregationType.value(self)
    def setAggregationType (self, new_value):
        """Set the attribute value for aggregationType.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__aggregationType.set(self, new_value)
    
    # Attribute id inherited from {http://www.opengis.net/gml}DefinitionBaseType

    _ElementMap = DefinitionType._ElementMap.copy()
    _ElementMap.update({
        __indirectEntry.name() : __indirectEntry,
        __dictionaryEntry.name() : __dictionaryEntry
    })
    _AttributeMap = DefinitionType._AttributeMap.copy()
    _AttributeMap.update({
        __aggregationType.name() : __aggregationType
    })
Namespace.addCategoryObject('typeBinding', u'DictionaryType', DictionaryType)


# Complex type DirectedObservationType with content type ELEMENT_ONLY
class DirectedObservationType (ObservationType):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'DirectedObservationType')
    # Base type is ObservationType
    
    # Element descriptionReference inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element target inherited from {http://www.opengis.net/gml}ObservationType
    
    # Element resultOf inherited from {http://www.opengis.net/gml}ObservationType
    
    # Element validTime inherited from {http://www.opengis.net/gml}ObservationType
    
    # Element {http://www.opengis.net/gml}direction uses Python identifier direction
    __direction = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'direction'), 'direction', '__DirectedObservationType_httpwww_opengis_netgmldirection', False)
    def direction (self):
        """Get the value of the {http://www.opengis.net/gml}direction element."""
        return self.__direction.value(self)
    def setDirection (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}direction element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__direction.set(self, new_value)
    
    # Element boundedBy inherited from {http://www.opengis.net/gml}AbstractFeatureType
    
    # Element identifier inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element location inherited from {http://www.opengis.net/gml}AbstractFeatureType
    
    # Element using inherited from {http://www.opengis.net/gml}ObservationType
    
    # Element description inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element metaDataProperty inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element name inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Attribute id inherited from {http://www.opengis.net/gml}AbstractGMLType

    _ElementMap = ObservationType._ElementMap.copy()
    _ElementMap.update({
        __direction.name() : __direction
    })
    _AttributeMap = ObservationType._AttributeMap.copy()
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', u'DirectedObservationType', DirectedObservationType)


# Complex type DynamicFeatureCollectionType with content type ELEMENT_ONLY
class DynamicFeatureCollectionType (DynamicFeatureType):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'DynamicFeatureCollectionType')
    # Base type is DynamicFeatureType
    
    # Element descriptionReference inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element metaDataProperty inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element name inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element history inherited from {http://www.opengis.net/gml}DynamicFeatureType
    
    # Element validTime inherited from {http://www.opengis.net/gml}DynamicFeatureType
    
    # Element boundedBy inherited from {http://www.opengis.net/gml}AbstractFeatureType
    
    # Element identifier inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element dataSourceReference inherited from {http://www.opengis.net/gml}DynamicFeatureType
    
    # Element description inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element location inherited from {http://www.opengis.net/gml}AbstractFeatureType
    
    # Element {http://www.opengis.net/gml}dynamicMembers uses Python identifier dynamicMembers
    __dynamicMembers = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'dynamicMembers'), 'dynamicMembers', '__DynamicFeatureCollectionType_httpwww_opengis_netgmldynamicMembers', False)
    def dynamicMembers (self):
        """Get the value of the {http://www.opengis.net/gml}dynamicMembers element."""
        return self.__dynamicMembers.value(self)
    def setDynamicMembers (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}dynamicMembers element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__dynamicMembers.set(self, new_value)
    
    # Element dataSource inherited from {http://www.opengis.net/gml}DynamicFeatureType
    
    # Attribute id inherited from {http://www.opengis.net/gml}AbstractGMLType

    _ElementMap = DynamicFeatureType._ElementMap.copy()
    _ElementMap.update({
        __dynamicMembers.name() : __dynamicMembers
    })
    _AttributeMap = DynamicFeatureType._AttributeMap.copy()
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', u'DynamicFeatureCollectionType', DynamicFeatureCollectionType)


# Complex type EdgeType with content type ELEMENT_ONLY
class EdgeType (AbstractTopoPrimitiveType):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'EdgeType')
    # Base type is AbstractTopoPrimitiveType
    
    # Element descriptionReference inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element {http://www.opengis.net/gml}curveProperty uses Python identifier curveProperty
    __curveProperty = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'curveProperty'), 'curveProperty', '__EdgeType_httpwww_opengis_netgmlcurveProperty', False)
    def curveProperty (self):
        """Get the value of the {http://www.opengis.net/gml}curveProperty element."""
        return self.__curveProperty.value(self)
    def setCurveProperty (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}curveProperty element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__curveProperty.set(self, new_value)
    
    # Element description inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element {http://www.opengis.net/gml}directedFace uses Python identifier directedFace
    __directedFace = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'directedFace'), 'directedFace', '__EdgeType_httpwww_opengis_netgmldirectedFace', True)
    def directedFace (self):
        """Get the value of the {http://www.opengis.net/gml}directedFace element."""
        return self.__directedFace.value(self)
    def setDirectedFace (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}directedFace element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__directedFace.set(self, new_value)
    
    def addDirectedFace (self, new_value):
        """Add the value as another occurrence of the {http://www.opengis.net/gml}directedFace element.  Raises
        BadValueTypeException if the new value is not consistent with the
        element's type."""
        return self.__directedFace.append(self, new_value)
    
    # Element container inherited from {http://www.opengis.net/gml}AbstractTopoPrimitiveType
    
    # Element identifier inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element {http://www.opengis.net/gml}directedNode uses Python identifier directedNode
    __directedNode = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'directedNode'), 'directedNode', '__EdgeType_httpwww_opengis_netgmldirectedNode', True)
    def directedNode (self):
        """Get the value of the {http://www.opengis.net/gml}directedNode element."""
        return self.__directedNode.value(self)
    def setDirectedNode (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}directedNode element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__directedNode.set(self, new_value)
    
    def addDirectedNode (self, new_value):
        """Add the value as another occurrence of the {http://www.opengis.net/gml}directedNode element.  Raises
        BadValueTypeException if the new value is not consistent with the
        element's type."""
        return self.__directedNode.append(self, new_value)
    
    # Element name inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element metaDataProperty inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element isolated inherited from {http://www.opengis.net/gml}AbstractTopoPrimitiveType
    
    # Attribute aggregationType uses Python identifier aggregationType
    __aggregationType = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'aggregationType'), 'aggregationType', '__EdgeType_aggregationType', AggregationType)
    def aggregationType (self):
        """Get the attribute value for aggregationType."""
        return self.__aggregationType.value(self)
    def setAggregationType (self, new_value):
        """Set the attribute value for aggregationType.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__aggregationType.set(self, new_value)
    
    # Attribute id inherited from {http://www.opengis.net/gml}AbstractGMLType

    _ElementMap = AbstractTopoPrimitiveType._ElementMap.copy()
    _ElementMap.update({
        __curveProperty.name() : __curveProperty,
        __directedFace.name() : __directedFace,
        __directedNode.name() : __directedNode
    })
    _AttributeMap = AbstractTopoPrimitiveType._AttributeMap.copy()
    _AttributeMap.update({
        __aggregationType.name() : __aggregationType
    })
Namespace.addCategoryObject('typeBinding', u'EdgeType', EdgeType)


# Complex type FaceType with content type ELEMENT_ONLY
class FaceType (AbstractTopoPrimitiveType):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'FaceType')
    # Base type is AbstractTopoPrimitiveType
    
    # Element descriptionReference inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element {http://www.opengis.net/gml}directedTopoSolid uses Python identifier directedTopoSolid
    __directedTopoSolid = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'directedTopoSolid'), 'directedTopoSolid', '__FaceType_httpwww_opengis_netgmldirectedTopoSolid', True)
    def directedTopoSolid (self):
        """Get the value of the {http://www.opengis.net/gml}directedTopoSolid element."""
        return self.__directedTopoSolid.value(self)
    def setDirectedTopoSolid (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}directedTopoSolid element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__directedTopoSolid.set(self, new_value)
    
    def addDirectedTopoSolid (self, new_value):
        """Add the value as another occurrence of the {http://www.opengis.net/gml}directedTopoSolid element.  Raises
        BadValueTypeException if the new value is not consistent with the
        element's type."""
        return self.__directedTopoSolid.append(self, new_value)
    
    # Element description inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element container inherited from {http://www.opengis.net/gml}AbstractTopoPrimitiveType
    
    # Element {http://www.opengis.net/gml}surfaceProperty uses Python identifier surfaceProperty
    __surfaceProperty = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'surfaceProperty'), 'surfaceProperty', '__FaceType_httpwww_opengis_netgmlsurfaceProperty', False)
    def surfaceProperty (self):
        """Get the value of the {http://www.opengis.net/gml}surfaceProperty element."""
        return self.__surfaceProperty.value(self)
    def setSurfaceProperty (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}surfaceProperty element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__surfaceProperty.set(self, new_value)
    
    # Element identifier inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element name inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element {http://www.opengis.net/gml}directedEdge uses Python identifier directedEdge
    __directedEdge = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'directedEdge'), 'directedEdge', '__FaceType_httpwww_opengis_netgmldirectedEdge', True)
    def directedEdge (self):
        """Get the value of the {http://www.opengis.net/gml}directedEdge element."""
        return self.__directedEdge.value(self)
    def setDirectedEdge (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}directedEdge element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__directedEdge.set(self, new_value)
    
    def addDirectedEdge (self, new_value):
        """Add the value as another occurrence of the {http://www.opengis.net/gml}directedEdge element.  Raises
        BadValueTypeException if the new value is not consistent with the
        element's type."""
        return self.__directedEdge.append(self, new_value)
    
    # Element metaDataProperty inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element isolated inherited from {http://www.opengis.net/gml}AbstractTopoPrimitiveType
    
    # Attribute aggregationType uses Python identifier aggregationType
    __aggregationType = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'aggregationType'), 'aggregationType', '__FaceType_aggregationType', AggregationType)
    def aggregationType (self):
        """Get the attribute value for aggregationType."""
        return self.__aggregationType.value(self)
    def setAggregationType (self, new_value):
        """Set the attribute value for aggregationType.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__aggregationType.set(self, new_value)
    
    # Attribute id inherited from {http://www.opengis.net/gml}AbstractGMLType

    _ElementMap = AbstractTopoPrimitiveType._ElementMap.copy()
    _ElementMap.update({
        __directedTopoSolid.name() : __directedTopoSolid,
        __surfaceProperty.name() : __surfaceProperty,
        __directedEdge.name() : __directedEdge
    })
    _AttributeMap = AbstractTopoPrimitiveType._AttributeMap.copy()
    _AttributeMap.update({
        __aggregationType.name() : __aggregationType
    })
Namespace.addCategoryObject('typeBinding', u'FaceType', FaceType)


# Complex type FeatureCollectionType with content type ELEMENT_ONLY
class FeatureCollectionType (AbstractFeatureCollectionType):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'FeatureCollectionType')
    # Base type is AbstractFeatureCollectionType
    
    # Element descriptionReference inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element featureMembers inherited from {http://www.opengis.net/gml}AbstractFeatureCollectionType
    
    # Element featureMember inherited from {http://www.opengis.net/gml}AbstractFeatureCollectionType
    
    # Element boundedBy inherited from {http://www.opengis.net/gml}AbstractFeatureType
    
    # Element identifier inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element location inherited from {http://www.opengis.net/gml}AbstractFeatureType
    
    # Element description inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element metaDataProperty inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element name inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Attribute id inherited from {http://www.opengis.net/gml}AbstractGMLType

    _ElementMap = AbstractFeatureCollectionType._ElementMap.copy()
    _ElementMap.update({
        
    })
    _AttributeMap = AbstractFeatureCollectionType._AttributeMap.copy()
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', u'FeatureCollectionType', FeatureCollectionType)


# Complex type IdentifiedObjectType with content type ELEMENT_ONLY
class IdentifiedObjectType (DefinitionType):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = True
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'IdentifiedObjectType')
    # Base type is DefinitionType
    
    # Element descriptionReference inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element metaDataProperty inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element name inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element identifier inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element description inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element remarks inherited from {http://www.opengis.net/gml}DefinitionType
    
    # Attribute id inherited from {http://www.opengis.net/gml}DefinitionBaseType

    _ElementMap = DefinitionType._ElementMap.copy()
    _ElementMap.update({
        
    })
    _AttributeMap = DefinitionType._AttributeMap.copy()
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', u'IdentifiedObjectType', IdentifiedObjectType)


# Complex type MultiCurveType with content type ELEMENT_ONLY
class MultiCurveType (AbstractGeometricAggregateType):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'MultiCurveType')
    # Base type is AbstractGeometricAggregateType
    
    # Element descriptionReference inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element description inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element {http://www.opengis.net/gml}curveMember uses Python identifier curveMember
    __curveMember = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'curveMember'), 'curveMember', '__MultiCurveType_httpwww_opengis_netgmlcurveMember', True)
    def curveMember (self):
        """Get the value of the {http://www.opengis.net/gml}curveMember element."""
        return self.__curveMember.value(self)
    def setCurveMember (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}curveMember element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__curveMember.set(self, new_value)
    
    def addCurveMember (self, new_value):
        """Add the value as another occurrence of the {http://www.opengis.net/gml}curveMember element.  Raises
        BadValueTypeException if the new value is not consistent with the
        element's type."""
        return self.__curveMember.append(self, new_value)
    
    # Element {http://www.opengis.net/gml}curveMembers uses Python identifier curveMembers
    __curveMembers = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'curveMembers'), 'curveMembers', '__MultiCurveType_httpwww_opengis_netgmlcurveMembers', False)
    def curveMembers (self):
        """Get the value of the {http://www.opengis.net/gml}curveMembers element."""
        return self.__curveMembers.value(self)
    def setCurveMembers (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}curveMembers element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__curveMembers.set(self, new_value)
    
    # Element identifier inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element name inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element metaDataProperty inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Attribute uomLabels inherited from {http://www.opengis.net/gml}AbstractGeometryType
    
    # Attribute axisLabels inherited from {http://www.opengis.net/gml}AbstractGeometryType
    
    # Attribute aggregationType inherited from {http://www.opengis.net/gml}AbstractGeometricAggregateType
    
    # Attribute id inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Attribute srsName inherited from {http://www.opengis.net/gml}AbstractGeometryType
    
    # Attribute srsDimension inherited from {http://www.opengis.net/gml}AbstractGeometryType

    _ElementMap = AbstractGeometricAggregateType._ElementMap.copy()
    _ElementMap.update({
        __curveMember.name() : __curveMember,
        __curveMembers.name() : __curveMembers
    })
    _AttributeMap = AbstractGeometricAggregateType._AttributeMap.copy()
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', u'MultiCurveType', MultiCurveType)


# Complex type MultiGeometryType with content type ELEMENT_ONLY
class MultiGeometryType (AbstractGeometricAggregateType):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'MultiGeometryType')
    # Base type is AbstractGeometricAggregateType
    
    # Element descriptionReference inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element {http://www.opengis.net/gml}geometryMember uses Python identifier geometryMember
    __geometryMember = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'geometryMember'), 'geometryMember', '__MultiGeometryType_httpwww_opengis_netgmlgeometryMember', True)
    def geometryMember (self):
        """Get the value of the {http://www.opengis.net/gml}geometryMember element."""
        return self.__geometryMember.value(self)
    def setGeometryMember (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}geometryMember element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__geometryMember.set(self, new_value)
    
    def addGeometryMember (self, new_value):
        """Add the value as another occurrence of the {http://www.opengis.net/gml}geometryMember element.  Raises
        BadValueTypeException if the new value is not consistent with the
        element's type."""
        return self.__geometryMember.append(self, new_value)
    
    # Element description inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element {http://www.opengis.net/gml}geometryMembers uses Python identifier geometryMembers
    __geometryMembers = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'geometryMembers'), 'geometryMembers', '__MultiGeometryType_httpwww_opengis_netgmlgeometryMembers', False)
    def geometryMembers (self):
        """Get the value of the {http://www.opengis.net/gml}geometryMembers element."""
        return self.__geometryMembers.value(self)
    def setGeometryMembers (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}geometryMembers element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__geometryMembers.set(self, new_value)
    
    # Element identifier inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element name inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element metaDataProperty inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Attribute uomLabels inherited from {http://www.opengis.net/gml}AbstractGeometryType
    
    # Attribute axisLabels inherited from {http://www.opengis.net/gml}AbstractGeometryType
    
    # Attribute aggregationType inherited from {http://www.opengis.net/gml}AbstractGeometricAggregateType
    
    # Attribute id inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Attribute srsName inherited from {http://www.opengis.net/gml}AbstractGeometryType
    
    # Attribute srsDimension inherited from {http://www.opengis.net/gml}AbstractGeometryType

    _ElementMap = AbstractGeometricAggregateType._ElementMap.copy()
    _ElementMap.update({
        __geometryMember.name() : __geometryMember,
        __geometryMembers.name() : __geometryMembers
    })
    _AttributeMap = AbstractGeometricAggregateType._AttributeMap.copy()
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', u'MultiGeometryType', MultiGeometryType)


# Complex type MultiPointType with content type ELEMENT_ONLY
class MultiPointType (AbstractGeometricAggregateType):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'MultiPointType')
    # Base type is AbstractGeometricAggregateType
    
    # Element descriptionReference inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element {http://www.opengis.net/gml}pointMember uses Python identifier pointMember
    __pointMember = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'pointMember'), 'pointMember', '__MultiPointType_httpwww_opengis_netgmlpointMember', True)
    def pointMember (self):
        """Get the value of the {http://www.opengis.net/gml}pointMember element."""
        return self.__pointMember.value(self)
    def setPointMember (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}pointMember element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__pointMember.set(self, new_value)
    
    def addPointMember (self, new_value):
        """Add the value as another occurrence of the {http://www.opengis.net/gml}pointMember element.  Raises
        BadValueTypeException if the new value is not consistent with the
        element's type."""
        return self.__pointMember.append(self, new_value)
    
    # Element name inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element {http://www.opengis.net/gml}pointMembers uses Python identifier pointMembers
    __pointMembers = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'pointMembers'), 'pointMembers', '__MultiPointType_httpwww_opengis_netgmlpointMembers', False)
    def pointMembers (self):
        """Get the value of the {http://www.opengis.net/gml}pointMembers element."""
        return self.__pointMembers.value(self)
    def setPointMembers (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}pointMembers element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__pointMembers.set(self, new_value)
    
    # Element identifier inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element description inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element metaDataProperty inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Attribute uomLabels inherited from {http://www.opengis.net/gml}AbstractGeometryType
    
    # Attribute axisLabels inherited from {http://www.opengis.net/gml}AbstractGeometryType
    
    # Attribute aggregationType inherited from {http://www.opengis.net/gml}AbstractGeometricAggregateType
    
    # Attribute id inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Attribute srsName inherited from {http://www.opengis.net/gml}AbstractGeometryType
    
    # Attribute srsDimension inherited from {http://www.opengis.net/gml}AbstractGeometryType

    _ElementMap = AbstractGeometricAggregateType._ElementMap.copy()
    _ElementMap.update({
        __pointMember.name() : __pointMember,
        __pointMembers.name() : __pointMembers
    })
    _AttributeMap = AbstractGeometricAggregateType._AttributeMap.copy()
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', u'MultiPointType', MultiPointType)


# Complex type MultiSolidType with content type ELEMENT_ONLY
class MultiSolidType (AbstractGeometricAggregateType):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'MultiSolidType')
    # Base type is AbstractGeometricAggregateType
    
    # Element descriptionReference inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element name inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element {http://www.opengis.net/gml}solidMembers uses Python identifier solidMembers
    __solidMembers = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'solidMembers'), 'solidMembers', '__MultiSolidType_httpwww_opengis_netgmlsolidMembers', False)
    def solidMembers (self):
        """Get the value of the {http://www.opengis.net/gml}solidMembers element."""
        return self.__solidMembers.value(self)
    def setSolidMembers (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}solidMembers element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__solidMembers.set(self, new_value)
    
    # Element identifier inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element description inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element metaDataProperty inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element {http://www.opengis.net/gml}solidMember uses Python identifier solidMember
    __solidMember = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'solidMember'), 'solidMember', '__MultiSolidType_httpwww_opengis_netgmlsolidMember', True)
    def solidMember (self):
        """Get the value of the {http://www.opengis.net/gml}solidMember element."""
        return self.__solidMember.value(self)
    def setSolidMember (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}solidMember element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__solidMember.set(self, new_value)
    
    def addSolidMember (self, new_value):
        """Add the value as another occurrence of the {http://www.opengis.net/gml}solidMember element.  Raises
        BadValueTypeException if the new value is not consistent with the
        element's type."""
        return self.__solidMember.append(self, new_value)
    
    # Attribute uomLabels inherited from {http://www.opengis.net/gml}AbstractGeometryType
    
    # Attribute axisLabels inherited from {http://www.opengis.net/gml}AbstractGeometryType
    
    # Attribute aggregationType inherited from {http://www.opengis.net/gml}AbstractGeometricAggregateType
    
    # Attribute id inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Attribute srsName inherited from {http://www.opengis.net/gml}AbstractGeometryType
    
    # Attribute srsDimension inherited from {http://www.opengis.net/gml}AbstractGeometryType

    _ElementMap = AbstractGeometricAggregateType._ElementMap.copy()
    _ElementMap.update({
        __solidMembers.name() : __solidMembers,
        __solidMember.name() : __solidMember
    })
    _AttributeMap = AbstractGeometricAggregateType._AttributeMap.copy()
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', u'MultiSolidType', MultiSolidType)


# Complex type MultiSurfaceType with content type ELEMENT_ONLY
class MultiSurfaceType (AbstractGeometricAggregateType):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'MultiSurfaceType')
    # Base type is AbstractGeometricAggregateType
    
    # Element descriptionReference inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element name inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element {http://www.opengis.net/gml}surfaceMembers uses Python identifier surfaceMembers
    __surfaceMembers = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'surfaceMembers'), 'surfaceMembers', '__MultiSurfaceType_httpwww_opengis_netgmlsurfaceMembers', False)
    def surfaceMembers (self):
        """Get the value of the {http://www.opengis.net/gml}surfaceMembers element."""
        return self.__surfaceMembers.value(self)
    def setSurfaceMembers (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}surfaceMembers element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__surfaceMembers.set(self, new_value)
    
    # Element identifier inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element {http://www.opengis.net/gml}surfaceMember uses Python identifier surfaceMember
    __surfaceMember = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'surfaceMember'), 'surfaceMember', '__MultiSurfaceType_httpwww_opengis_netgmlsurfaceMember', True)
    def surfaceMember (self):
        """Get the value of the {http://www.opengis.net/gml}surfaceMember element."""
        return self.__surfaceMember.value(self)
    def setSurfaceMember (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}surfaceMember element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__surfaceMember.set(self, new_value)
    
    def addSurfaceMember (self, new_value):
        """Add the value as another occurrence of the {http://www.opengis.net/gml}surfaceMember element.  Raises
        BadValueTypeException if the new value is not consistent with the
        element's type."""
        return self.__surfaceMember.append(self, new_value)
    
    # Element description inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element metaDataProperty inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Attribute uomLabels inherited from {http://www.opengis.net/gml}AbstractGeometryType
    
    # Attribute axisLabels inherited from {http://www.opengis.net/gml}AbstractGeometryType
    
    # Attribute aggregationType inherited from {http://www.opengis.net/gml}AbstractGeometricAggregateType
    
    # Attribute id inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Attribute srsName inherited from {http://www.opengis.net/gml}AbstractGeometryType
    
    # Attribute srsDimension inherited from {http://www.opengis.net/gml}AbstractGeometryType

    _ElementMap = AbstractGeometricAggregateType._ElementMap.copy()
    _ElementMap.update({
        __surfaceMembers.name() : __surfaceMembers,
        __surfaceMember.name() : __surfaceMember
    })
    _AttributeMap = AbstractGeometricAggregateType._AttributeMap.copy()
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', u'MultiSurfaceType', MultiSurfaceType)


# Complex type NodeType with content type ELEMENT_ONLY
class NodeType (AbstractTopoPrimitiveType):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'NodeType')
    # Base type is AbstractTopoPrimitiveType
    
    # Element descriptionReference inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element name inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element container inherited from {http://www.opengis.net/gml}AbstractTopoPrimitiveType
    
    # Element identifier inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element description inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element {http://www.opengis.net/gml}directedEdge uses Python identifier directedEdge
    __directedEdge = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'directedEdge'), 'directedEdge', '__NodeType_httpwww_opengis_netgmldirectedEdge', True)
    def directedEdge (self):
        """Get the value of the {http://www.opengis.net/gml}directedEdge element."""
        return self.__directedEdge.value(self)
    def setDirectedEdge (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}directedEdge element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__directedEdge.set(self, new_value)
    
    def addDirectedEdge (self, new_value):
        """Add the value as another occurrence of the {http://www.opengis.net/gml}directedEdge element.  Raises
        BadValueTypeException if the new value is not consistent with the
        element's type."""
        return self.__directedEdge.append(self, new_value)
    
    # Element metaDataProperty inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element isolated inherited from {http://www.opengis.net/gml}AbstractTopoPrimitiveType
    
    # Element {http://www.opengis.net/gml}pointProperty uses Python identifier pointProperty
    __pointProperty = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'pointProperty'), 'pointProperty', '__NodeType_httpwww_opengis_netgmlpointProperty', False)
    def pointProperty (self):
        """Get the value of the {http://www.opengis.net/gml}pointProperty element."""
        return self.__pointProperty.value(self)
    def setPointProperty (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}pointProperty element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__pointProperty.set(self, new_value)
    
    # Attribute aggregationType uses Python identifier aggregationType
    __aggregationType = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'aggregationType'), 'aggregationType', '__NodeType_aggregationType', AggregationType)
    def aggregationType (self):
        """Get the attribute value for aggregationType."""
        return self.__aggregationType.value(self)
    def setAggregationType (self, new_value):
        """Set the attribute value for aggregationType.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__aggregationType.set(self, new_value)
    
    # Attribute id inherited from {http://www.opengis.net/gml}AbstractGMLType

    _ElementMap = AbstractTopoPrimitiveType._ElementMap.copy()
    _ElementMap.update({
        __directedEdge.name() : __directedEdge,
        __pointProperty.name() : __pointProperty
    })
    _AttributeMap = AbstractTopoPrimitiveType._AttributeMap.copy()
    _AttributeMap.update({
        __aggregationType.name() : __aggregationType
    })
Namespace.addCategoryObject('typeBinding', u'NodeType', NodeType)


# Complex type PointType with content type ELEMENT_ONLY
class PointType (AbstractGeometricPrimitiveType):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'PointType')
    # Base type is AbstractGeometricPrimitiveType
    
    # Element descriptionReference inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element description inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element name inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element identifier inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element {http://www.opengis.net/gml}coordinates uses Python identifier coordinates
    __coordinates = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'coordinates'), 'coordinates', '__PointType_httpwww_opengis_netgmlcoordinates', False)
    def coordinates (self):
        """Get the value of the {http://www.opengis.net/gml}coordinates element."""
        return self.__coordinates.value(self)
    def setCoordinates (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}coordinates element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__coordinates.set(self, new_value)
    
    # Element metaDataProperty inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element {http://www.opengis.net/gml}pos uses Python identifier pos
    __pos = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'pos'), 'pos', '__PointType_httpwww_opengis_netgmlpos', False)
    def pos (self):
        """Get the value of the {http://www.opengis.net/gml}pos element."""
        return self.__pos.value(self)
    def setPos (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}pos element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__pos.set(self, new_value)
    
    # Attribute srsName inherited from {http://www.opengis.net/gml}AbstractGeometryType
    
    # Attribute axisLabels inherited from {http://www.opengis.net/gml}AbstractGeometryType
    
    # Attribute id inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Attribute uomLabels inherited from {http://www.opengis.net/gml}AbstractGeometryType
    
    # Attribute srsDimension inherited from {http://www.opengis.net/gml}AbstractGeometryType

    _ElementMap = AbstractGeometricPrimitiveType._ElementMap.copy()
    _ElementMap.update({
        __coordinates.name() : __coordinates,
        __pos.name() : __pos
    })
    _AttributeMap = AbstractGeometricPrimitiveType._AttributeMap.copy()
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', u'PointType', PointType)


# Complex type RectifiedGridType with content type ELEMENT_ONLY
class RectifiedGridType (GridType):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'RectifiedGridType')
    # Base type is GridType
    
    # Element descriptionReference inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element limits inherited from {http://www.opengis.net/gml}GridType
    
    # Element axisLabels inherited from {http://www.opengis.net/gml}GridType
    
    # Element description inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element axisName inherited from {http://www.opengis.net/gml}GridType
    
    # Element identifier inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element {http://www.opengis.net/gml}origin uses Python identifier origin
    __origin = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'origin'), 'origin', '__RectifiedGridType_httpwww_opengis_netgmlorigin', True)
    def origin (self):
        """Get the value of the {http://www.opengis.net/gml}origin element."""
        return self.__origin.value(self)
    def setOrigin (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}origin element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__origin.set(self, new_value)
    
    def addOrigin (self, new_value):
        """Add the value as another occurrence of the {http://www.opengis.net/gml}origin element.  Raises
        BadValueTypeException if the new value is not consistent with the
        element's type."""
        return self.__origin.append(self, new_value)
    
    # Element name inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element metaDataProperty inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element {http://www.opengis.net/gml}offsetVector uses Python identifier offsetVector
    __offsetVector = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'offsetVector'), 'offsetVector', '__RectifiedGridType_httpwww_opengis_netgmloffsetVector', True)
    def offsetVector (self):
        """Get the value of the {http://www.opengis.net/gml}offsetVector element."""
        return self.__offsetVector.value(self)
    def setOffsetVector (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}offsetVector element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__offsetVector.set(self, new_value)
    
    def addOffsetVector (self, new_value):
        """Add the value as another occurrence of the {http://www.opengis.net/gml}offsetVector element.  Raises
        BadValueTypeException if the new value is not consistent with the
        element's type."""
        return self.__offsetVector.append(self, new_value)
    
    # Attribute uomLabels inherited from {http://www.opengis.net/gml}AbstractGeometryType
    
    # Attribute axisLabels inherited from {http://www.opengis.net/gml}AbstractGeometryType
    
    # Attribute id inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Attribute dimension inherited from {http://www.opengis.net/gml}GridType
    
    # Attribute srsName inherited from {http://www.opengis.net/gml}AbstractGeometryType
    
    # Attribute srsDimension inherited from {http://www.opengis.net/gml}AbstractGeometryType

    _ElementMap = GridType._ElementMap.copy()
    _ElementMap.update({
        __origin.name() : __origin,
        __offsetVector.name() : __offsetVector
    })
    _AttributeMap = GridType._AttributeMap.copy()
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', u'RectifiedGridType', RectifiedGridType)


# Complex type SphereType with content type ELEMENT_ONLY
class SphereType (AbstractGriddedSurfaceType):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'SphereType')
    # Base type is AbstractGriddedSurfaceType
    
    # Element rows inherited from {http://www.opengis.net/gml}AbstractGriddedSurfaceType
    
    # Attribute aggregationType inherited from {http://www.opengis.net/gml}AbstractParametricCurveSurfaceType
    
    # Attribute horizontalCurveType uses Python identifier horizontalCurveType
    __horizontalCurveType = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'horizontalCurveType'), 'horizontalCurveType', '__SphereType_horizontalCurveType', CurveInterpolationType, fixed=True, unicode_default=u'circularArc3Points')
    def horizontalCurveType (self):
        """Get the attribute value for horizontalCurveType."""
        return self.__horizontalCurveType.value(self)
    def setHorizontalCurveType (self, new_value):
        """Set the attribute value for horizontalCurveType.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__horizontalCurveType.set(self, new_value)
    
    # Attribute columns inherited from {http://www.opengis.net/gml}AbstractGriddedSurfaceType
    
    # Attribute verticalCurveType uses Python identifier verticalCurveType
    __verticalCurveType = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'verticalCurveType'), 'verticalCurveType', '__SphereType_verticalCurveType', CurveInterpolationType, fixed=True, unicode_default=u'circularArc3Points')
    def verticalCurveType (self):
        """Get the attribute value for verticalCurveType."""
        return self.__verticalCurveType.value(self)
    def setVerticalCurveType (self, new_value):
        """Set the attribute value for verticalCurveType.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__verticalCurveType.set(self, new_value)
    
    # Attribute rows_ inherited from {http://www.opengis.net/gml}AbstractGriddedSurfaceType

    _ElementMap = AbstractGriddedSurfaceType._ElementMap.copy()
    _ElementMap.update({
        
    })
    _AttributeMap = AbstractGriddedSurfaceType._AttributeMap.copy()
    _AttributeMap.update({
        __horizontalCurveType.name() : __horizontalCurveType,
        __verticalCurveType.name() : __verticalCurveType
    })
Namespace.addCategoryObject('typeBinding', u'SphereType', SphereType)


# Complex type TimeCalendarEraType with content type ELEMENT_ONLY
class TimeCalendarEraType (DefinitionType):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'TimeCalendarEraType')
    # Base type is DefinitionType
    
    # Element descriptionReference inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element {http://www.opengis.net/gml}referenceDate uses Python identifier referenceDate
    __referenceDate = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'referenceDate'), 'referenceDate', '__TimeCalendarEraType_httpwww_opengis_netgmlreferenceDate', False)
    def referenceDate (self):
        """Get the value of the {http://www.opengis.net/gml}referenceDate element."""
        return self.__referenceDate.value(self)
    def setReferenceDate (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}referenceDate element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__referenceDate.set(self, new_value)
    
    # Element metaDataProperty inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element description inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element {http://www.opengis.net/gml}epochOfUse uses Python identifier epochOfUse
    __epochOfUse = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'epochOfUse'), 'epochOfUse', '__TimeCalendarEraType_httpwww_opengis_netgmlepochOfUse', False)
    def epochOfUse (self):
        """Get the value of the {http://www.opengis.net/gml}epochOfUse element."""
        return self.__epochOfUse.value(self)
    def setEpochOfUse (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}epochOfUse element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__epochOfUse.set(self, new_value)
    
    # Element identifier inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element {http://www.opengis.net/gml}julianReference uses Python identifier julianReference
    __julianReference = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'julianReference'), 'julianReference', '__TimeCalendarEraType_httpwww_opengis_netgmljulianReference', False)
    def julianReference (self):
        """Get the value of the {http://www.opengis.net/gml}julianReference element."""
        return self.__julianReference.value(self)
    def setJulianReference (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}julianReference element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__julianReference.set(self, new_value)
    
    # Element name inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element {http://www.opengis.net/gml}referenceEvent uses Python identifier referenceEvent
    __referenceEvent = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'referenceEvent'), 'referenceEvent', '__TimeCalendarEraType_httpwww_opengis_netgmlreferenceEvent', False)
    def referenceEvent (self):
        """Get the value of the {http://www.opengis.net/gml}referenceEvent element."""
        return self.__referenceEvent.value(self)
    def setReferenceEvent (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}referenceEvent element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__referenceEvent.set(self, new_value)
    
    # Element remarks inherited from {http://www.opengis.net/gml}DefinitionType
    
    # Attribute id inherited from {http://www.opengis.net/gml}DefinitionBaseType

    _ElementMap = DefinitionType._ElementMap.copy()
    _ElementMap.update({
        __referenceDate.name() : __referenceDate,
        __epochOfUse.name() : __epochOfUse,
        __julianReference.name() : __julianReference,
        __referenceEvent.name() : __referenceEvent
    })
    _AttributeMap = DefinitionType._AttributeMap.copy()
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', u'TimeCalendarEraType', TimeCalendarEraType)


# Complex type TimeOrdinalEraType with content type ELEMENT_ONLY
class TimeOrdinalEraType (DefinitionType):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'TimeOrdinalEraType')
    # Base type is DefinitionType
    
    # Element descriptionReference inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element {http://www.opengis.net/gml}start uses Python identifier start
    __start = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'start'), 'start', '__TimeOrdinalEraType_httpwww_opengis_netgmlstart', False)
    def start (self):
        """Get the value of the {http://www.opengis.net/gml}start element."""
        return self.__start.value(self)
    def setStart (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}start element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__start.set(self, new_value)
    
    # Element {http://www.opengis.net/gml}member uses Python identifier member
    __member = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'member'), 'member', '__TimeOrdinalEraType_httpwww_opengis_netgmlmember', True)
    def member (self):
        """Get the value of the {http://www.opengis.net/gml}member element."""
        return self.__member.value(self)
    def setMember (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}member element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__member.set(self, new_value)
    
    def addMember (self, new_value):
        """Add the value as another occurrence of the {http://www.opengis.net/gml}member element.  Raises
        BadValueTypeException if the new value is not consistent with the
        element's type."""
        return self.__member.append(self, new_value)
    
    # Element description inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element {http://www.opengis.net/gml}end uses Python identifier end
    __end = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'end'), 'end', '__TimeOrdinalEraType_httpwww_opengis_netgmlend', False)
    def end (self):
        """Get the value of the {http://www.opengis.net/gml}end element."""
        return self.__end.value(self)
    def setEnd (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}end element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__end.set(self, new_value)
    
    # Element {http://www.opengis.net/gml}group uses Python identifier group
    __group = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'group'), 'group', '__TimeOrdinalEraType_httpwww_opengis_netgmlgroup', False)
    def group (self):
        """Get the value of the {http://www.opengis.net/gml}group element."""
        return self.__group.value(self)
    def setGroup (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}group element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__group.set(self, new_value)
    
    # Element metaDataProperty inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element {http://www.opengis.net/gml}extent uses Python identifier extent
    __extent = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'extent'), 'extent', '__TimeOrdinalEraType_httpwww_opengis_netgmlextent', False)
    def extent (self):
        """Get the value of the {http://www.opengis.net/gml}extent element."""
        return self.__extent.value(self)
    def setExtent (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}extent element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__extent.set(self, new_value)
    
    # Element identifier inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element name inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element remarks inherited from {http://www.opengis.net/gml}DefinitionType
    
    # Element {http://www.opengis.net/gml}relatedTime uses Python identifier relatedTime
    __relatedTime = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'relatedTime'), 'relatedTime', '__TimeOrdinalEraType_httpwww_opengis_netgmlrelatedTime', True)
    def relatedTime (self):
        """Get the value of the {http://www.opengis.net/gml}relatedTime element."""
        return self.__relatedTime.value(self)
    def setRelatedTime (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}relatedTime element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__relatedTime.set(self, new_value)
    
    def addRelatedTime (self, new_value):
        """Add the value as another occurrence of the {http://www.opengis.net/gml}relatedTime element.  Raises
        BadValueTypeException if the new value is not consistent with the
        element's type."""
        return self.__relatedTime.append(self, new_value)
    
    # Attribute id inherited from {http://www.opengis.net/gml}DefinitionBaseType

    _ElementMap = DefinitionType._ElementMap.copy()
    _ElementMap.update({
        __start.name() : __start,
        __member.name() : __member,
        __end.name() : __end,
        __group.name() : __group,
        __extent.name() : __extent,
        __relatedTime.name() : __relatedTime
    })
    _AttributeMap = DefinitionType._AttributeMap.copy()
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', u'TimeOrdinalEraType', TimeOrdinalEraType)


# Complex type TimeReferenceSystemType with content type ELEMENT_ONLY
class TimeReferenceSystemType (DefinitionType):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'TimeReferenceSystemType')
    # Base type is DefinitionType
    
    # Element descriptionReference inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element metaDataProperty inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element name inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element {http://www.opengis.net/gml}domainOfValidity uses Python identifier domainOfValidity
    __domainOfValidity = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'domainOfValidity'), 'domainOfValidity', '__TimeReferenceSystemType_httpwww_opengis_netgmldomainOfValidity', False)
    def domainOfValidity (self):
        """Get the value of the {http://www.opengis.net/gml}domainOfValidity element."""
        return self.__domainOfValidity.value(self)
    def setDomainOfValidity (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}domainOfValidity element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__domainOfValidity.set(self, new_value)
    
    # Element identifier inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element description inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element remarks inherited from {http://www.opengis.net/gml}DefinitionType
    
    # Attribute id inherited from {http://www.opengis.net/gml}DefinitionBaseType

    _ElementMap = DefinitionType._ElementMap.copy()
    _ElementMap.update({
        __domainOfValidity.name() : __domainOfValidity
    })
    _AttributeMap = DefinitionType._AttributeMap.copy()
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', u'TimeReferenceSystemType', TimeReferenceSystemType)


# Complex type TimeTopologyComplexType with content type ELEMENT_ONLY
class TimeTopologyComplexType (AbstractTimeComplexType):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = True
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'TimeTopologyComplexType')
    # Base type is AbstractTimeComplexType
    
    # Element descriptionReference inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element name inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element {http://www.opengis.net/gml}primitive uses Python identifier primitive
    __primitive = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'primitive'), 'primitive', '__TimeTopologyComplexType_httpwww_opengis_netgmlprimitive', True)
    def primitive (self):
        """Get the value of the {http://www.opengis.net/gml}primitive element."""
        return self.__primitive.value(self)
    def setPrimitive (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}primitive element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__primitive.set(self, new_value)
    
    def addPrimitive (self, new_value):
        """Add the value as another occurrence of the {http://www.opengis.net/gml}primitive element.  Raises
        BadValueTypeException if the new value is not consistent with the
        element's type."""
        return self.__primitive.append(self, new_value)
    
    # Element identifier inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element description inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element metaDataProperty inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Attribute id inherited from {http://www.opengis.net/gml}AbstractGMLType

    _ElementMap = AbstractTimeComplexType._ElementMap.copy()
    _ElementMap.update({
        __primitive.name() : __primitive
    })
    _AttributeMap = AbstractTimeComplexType._AttributeMap.copy()
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', u'TimeTopologyComplexType', TimeTopologyComplexType)


# Complex type TopoSolidType with content type ELEMENT_ONLY
class TopoSolidType (AbstractTopoPrimitiveType):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'TopoSolidType')
    # Base type is AbstractTopoPrimitiveType
    
    # Element descriptionReference inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element description inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element {http://www.opengis.net/gml}directedFace uses Python identifier directedFace
    __directedFace = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'directedFace'), 'directedFace', '__TopoSolidType_httpwww_opengis_netgmldirectedFace', True)
    def directedFace (self):
        """Get the value of the {http://www.opengis.net/gml}directedFace element."""
        return self.__directedFace.value(self)
    def setDirectedFace (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}directedFace element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__directedFace.set(self, new_value)
    
    def addDirectedFace (self, new_value):
        """Add the value as another occurrence of the {http://www.opengis.net/gml}directedFace element.  Raises
        BadValueTypeException if the new value is not consistent with the
        element's type."""
        return self.__directedFace.append(self, new_value)
    
    # Element container inherited from {http://www.opengis.net/gml}AbstractTopoPrimitiveType
    
    # Element identifier inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element {http://www.opengis.net/gml}solidProperty uses Python identifier solidProperty
    __solidProperty = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'solidProperty'), 'solidProperty', '__TopoSolidType_httpwww_opengis_netgmlsolidProperty', False)
    def solidProperty (self):
        """Get the value of the {http://www.opengis.net/gml}solidProperty element."""
        return self.__solidProperty.value(self)
    def setSolidProperty (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}solidProperty element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__solidProperty.set(self, new_value)
    
    # Element name inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element metaDataProperty inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element isolated inherited from {http://www.opengis.net/gml}AbstractTopoPrimitiveType
    
    # Attribute aggregationType uses Python identifier aggregationType
    __aggregationType = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'aggregationType'), 'aggregationType', '__TopoSolidType_aggregationType', AggregationType)
    def aggregationType (self):
        """Get the attribute value for aggregationType."""
        return self.__aggregationType.value(self)
    def setAggregationType (self, new_value):
        """Set the attribute value for aggregationType.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__aggregationType.set(self, new_value)
    
    # Attribute id inherited from {http://www.opengis.net/gml}AbstractGMLType

    _ElementMap = AbstractTopoPrimitiveType._ElementMap.copy()
    _ElementMap.update({
        __directedFace.name() : __directedFace,
        __solidProperty.name() : __solidProperty
    })
    _AttributeMap = AbstractTopoPrimitiveType._AttributeMap.copy()
    _AttributeMap.update({
        __aggregationType.name() : __aggregationType
    })
Namespace.addCategoryObject('typeBinding', u'TopoSolidType', TopoSolidType)


# Complex type UnitDefinitionType with content type ELEMENT_ONLY
class UnitDefinitionType (DefinitionType):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'UnitDefinitionType')
    # Base type is DefinitionType
    
    # Element descriptionReference inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element metaDataProperty inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element description inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element {http://www.opengis.net/gml}quantityType uses Python identifier quantityType
    __quantityType = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'quantityType'), 'quantityType', '__UnitDefinitionType_httpwww_opengis_netgmlquantityType', False)
    def quantityType (self):
        """Get the value of the {http://www.opengis.net/gml}quantityType element."""
        return self.__quantityType.value(self)
    def setQuantityType (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}quantityType element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__quantityType.set(self, new_value)
    
    # Element identifier inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element {http://www.opengis.net/gml}catalogSymbol uses Python identifier catalogSymbol
    __catalogSymbol = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'catalogSymbol'), 'catalogSymbol', '__UnitDefinitionType_httpwww_opengis_netgmlcatalogSymbol', False)
    def catalogSymbol (self):
        """Get the value of the {http://www.opengis.net/gml}catalogSymbol element."""
        return self.__catalogSymbol.value(self)
    def setCatalogSymbol (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}catalogSymbol element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__catalogSymbol.set(self, new_value)
    
    # Element name inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element remarks inherited from {http://www.opengis.net/gml}DefinitionType
    
    # Element {http://www.opengis.net/gml}quantityTypeReference uses Python identifier quantityTypeReference
    __quantityTypeReference = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'quantityTypeReference'), 'quantityTypeReference', '__UnitDefinitionType_httpwww_opengis_netgmlquantityTypeReference', False)
    def quantityTypeReference (self):
        """Get the value of the {http://www.opengis.net/gml}quantityTypeReference element."""
        return self.__quantityTypeReference.value(self)
    def setQuantityTypeReference (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}quantityTypeReference element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__quantityTypeReference.set(self, new_value)
    
    # Attribute id inherited from {http://www.opengis.net/gml}DefinitionBaseType

    _ElementMap = DefinitionType._ElementMap.copy()
    _ElementMap.update({
        __quantityType.name() : __quantityType,
        __catalogSymbol.name() : __catalogSymbol,
        __quantityTypeReference.name() : __quantityTypeReference
    })
    _AttributeMap = DefinitionType._AttributeMap.copy()
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', u'UnitDefinitionType', UnitDefinitionType)


# Complex type AbstractCRSType with content type ELEMENT_ONLY
class AbstractCRSType (IdentifiedObjectType):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = True
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'AbstractCRSType')
    # Base type is IdentifiedObjectType
    
    # Element descriptionReference inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element description inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element metaDataProperty inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element name inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element identifier inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element {http://www.opengis.net/gml}scope uses Python identifier scope
    __scope = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'scope'), 'scope', '__AbstractCRSType_httpwww_opengis_netgmlscope', True)
    def scope (self):
        """Get the value of the {http://www.opengis.net/gml}scope element."""
        return self.__scope.value(self)
    def setScope (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}scope element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__scope.set(self, new_value)
    
    def addScope (self, new_value):
        """Add the value as another occurrence of the {http://www.opengis.net/gml}scope element.  Raises
        BadValueTypeException if the new value is not consistent with the
        element's type."""
        return self.__scope.append(self, new_value)
    
    # Element {http://www.opengis.net/gml}domainOfValidity uses Python identifier domainOfValidity
    __domainOfValidity = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'domainOfValidity'), 'domainOfValidity', '__AbstractCRSType_httpwww_opengis_netgmldomainOfValidity', True)
    def domainOfValidity (self):
        """Get the value of the {http://www.opengis.net/gml}domainOfValidity element."""
        return self.__domainOfValidity.value(self)
    def setDomainOfValidity (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}domainOfValidity element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__domainOfValidity.set(self, new_value)
    
    def addDomainOfValidity (self, new_value):
        """Add the value as another occurrence of the {http://www.opengis.net/gml}domainOfValidity element.  Raises
        BadValueTypeException if the new value is not consistent with the
        element's type."""
        return self.__domainOfValidity.append(self, new_value)
    
    # Element remarks inherited from {http://www.opengis.net/gml}DefinitionType
    
    # Attribute id inherited from {http://www.opengis.net/gml}DefinitionBaseType

    _ElementMap = IdentifiedObjectType._ElementMap.copy()
    _ElementMap.update({
        __scope.name() : __scope,
        __domainOfValidity.name() : __domainOfValidity
    })
    _AttributeMap = IdentifiedObjectType._AttributeMap.copy()
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', u'AbstractCRSType', AbstractCRSType)


# Complex type AbstractCoordinateOperationType with content type ELEMENT_ONLY
class AbstractCoordinateOperationType (IdentifiedObjectType):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = True
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'AbstractCoordinateOperationType')
    # Base type is IdentifiedObjectType
    
    # Element {http://www.opengis.net/gml}operationVersion uses Python identifier operationVersion
    __operationVersion = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'operationVersion'), 'operationVersion', '__AbstractCoordinateOperationType_httpwww_opengis_netgmloperationVersion', False)
    def operationVersion (self):
        """Get the value of the {http://www.opengis.net/gml}operationVersion element."""
        return self.__operationVersion.value(self)
    def setOperationVersion (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}operationVersion element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__operationVersion.set(self, new_value)
    
    # Element descriptionReference inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element metaDataProperty inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element {http://www.opengis.net/gml}domainOfValidity uses Python identifier domainOfValidity
    __domainOfValidity = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'domainOfValidity'), 'domainOfValidity', '__AbstractCoordinateOperationType_httpwww_opengis_netgmldomainOfValidity', False)
    def domainOfValidity (self):
        """Get the value of the {http://www.opengis.net/gml}domainOfValidity element."""
        return self.__domainOfValidity.value(self)
    def setDomainOfValidity (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}domainOfValidity element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__domainOfValidity.set(self, new_value)
    
    # Element {http://www.opengis.net/gml}targetCRS uses Python identifier targetCRS
    __targetCRS = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'targetCRS'), 'targetCRS', '__AbstractCoordinateOperationType_httpwww_opengis_netgmltargetCRS', False)
    def targetCRS (self):
        """Get the value of the {http://www.opengis.net/gml}targetCRS element."""
        return self.__targetCRS.value(self)
    def setTargetCRS (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}targetCRS element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__targetCRS.set(self, new_value)
    
    # Element identifier inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element description inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element {http://www.opengis.net/gml}coordinateOperationAccuracy uses Python identifier coordinateOperationAccuracy
    __coordinateOperationAccuracy = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'coordinateOperationAccuracy'), 'coordinateOperationAccuracy', '__AbstractCoordinateOperationType_httpwww_opengis_netgmlcoordinateOperationAccuracy', True)
    def coordinateOperationAccuracy (self):
        """Get the value of the {http://www.opengis.net/gml}coordinateOperationAccuracy element."""
        return self.__coordinateOperationAccuracy.value(self)
    def setCoordinateOperationAccuracy (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}coordinateOperationAccuracy element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__coordinateOperationAccuracy.set(self, new_value)
    
    def addCoordinateOperationAccuracy (self, new_value):
        """Add the value as another occurrence of the {http://www.opengis.net/gml}coordinateOperationAccuracy element.  Raises
        BadValueTypeException if the new value is not consistent with the
        element's type."""
        return self.__coordinateOperationAccuracy.append(self, new_value)
    
    # Element {http://www.opengis.net/gml}sourceCRS uses Python identifier sourceCRS
    __sourceCRS = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'sourceCRS'), 'sourceCRS', '__AbstractCoordinateOperationType_httpwww_opengis_netgmlsourceCRS', False)
    def sourceCRS (self):
        """Get the value of the {http://www.opengis.net/gml}sourceCRS element."""
        return self.__sourceCRS.value(self)
    def setSourceCRS (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}sourceCRS element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__sourceCRS.set(self, new_value)
    
    # Element {http://www.opengis.net/gml}scope uses Python identifier scope
    __scope = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'scope'), 'scope', '__AbstractCoordinateOperationType_httpwww_opengis_netgmlscope', True)
    def scope (self):
        """Get the value of the {http://www.opengis.net/gml}scope element."""
        return self.__scope.value(self)
    def setScope (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}scope element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__scope.set(self, new_value)
    
    def addScope (self, new_value):
        """Add the value as another occurrence of the {http://www.opengis.net/gml}scope element.  Raises
        BadValueTypeException if the new value is not consistent with the
        element's type."""
        return self.__scope.append(self, new_value)
    
    # Element name inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element remarks inherited from {http://www.opengis.net/gml}DefinitionType
    
    # Attribute id inherited from {http://www.opengis.net/gml}DefinitionBaseType

    _ElementMap = IdentifiedObjectType._ElementMap.copy()
    _ElementMap.update({
        __operationVersion.name() : __operationVersion,
        __domainOfValidity.name() : __domainOfValidity,
        __targetCRS.name() : __targetCRS,
        __coordinateOperationAccuracy.name() : __coordinateOperationAccuracy,
        __sourceCRS.name() : __sourceCRS,
        __scope.name() : __scope
    })
    _AttributeMap = IdentifiedObjectType._AttributeMap.copy()
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', u'AbstractCoordinateOperationType', AbstractCoordinateOperationType)


# Complex type AbstractCoordinateSystemType with content type ELEMENT_ONLY
class AbstractCoordinateSystemType (IdentifiedObjectType):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = True
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'AbstractCoordinateSystemType')
    # Base type is IdentifiedObjectType
    
    # Element descriptionReference inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element metaDataProperty inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element name inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element {http://www.opengis.net/gml}axis uses Python identifier axis
    __axis = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'axis'), 'axis', '__AbstractCoordinateSystemType_httpwww_opengis_netgmlaxis', True)
    def axis (self):
        """Get the value of the {http://www.opengis.net/gml}axis element."""
        return self.__axis.value(self)
    def setAxis (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}axis element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__axis.set(self, new_value)
    
    def addAxis (self, new_value):
        """Add the value as another occurrence of the {http://www.opengis.net/gml}axis element.  Raises
        BadValueTypeException if the new value is not consistent with the
        element's type."""
        return self.__axis.append(self, new_value)
    
    # Element identifier inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element description inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element remarks inherited from {http://www.opengis.net/gml}DefinitionType
    
    # Attribute aggregationType uses Python identifier aggregationType
    __aggregationType = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'aggregationType'), 'aggregationType', '__AbstractCoordinateSystemType_aggregationType', AggregationType)
    def aggregationType (self):
        """Get the attribute value for aggregationType."""
        return self.__aggregationType.value(self)
    def setAggregationType (self, new_value):
        """Set the attribute value for aggregationType.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__aggregationType.set(self, new_value)
    
    # Attribute id inherited from {http://www.opengis.net/gml}DefinitionBaseType

    _ElementMap = IdentifiedObjectType._ElementMap.copy()
    _ElementMap.update({
        __axis.name() : __axis
    })
    _AttributeMap = IdentifiedObjectType._AttributeMap.copy()
    _AttributeMap.update({
        __aggregationType.name() : __aggregationType
    })
Namespace.addCategoryObject('typeBinding', u'AbstractCoordinateSystemType', AbstractCoordinateSystemType)


# Complex type AbstractDatumType with content type ELEMENT_ONLY
class AbstractDatumType (IdentifiedObjectType):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = True
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'AbstractDatumType')
    # Base type is IdentifiedObjectType
    
    # Element descriptionReference inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element description inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element {http://www.opengis.net/gml}realizationEpoch uses Python identifier realizationEpoch
    __realizationEpoch = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'realizationEpoch'), 'realizationEpoch', '__AbstractDatumType_httpwww_opengis_netgmlrealizationEpoch', False)
    def realizationEpoch (self):
        """Get the value of the {http://www.opengis.net/gml}realizationEpoch element."""
        return self.__realizationEpoch.value(self)
    def setRealizationEpoch (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}realizationEpoch element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__realizationEpoch.set(self, new_value)
    
    # Element metaDataProperty inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element name inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element identifier inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element {http://www.opengis.net/gml}scope uses Python identifier scope
    __scope = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'scope'), 'scope', '__AbstractDatumType_httpwww_opengis_netgmlscope', True)
    def scope (self):
        """Get the value of the {http://www.opengis.net/gml}scope element."""
        return self.__scope.value(self)
    def setScope (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}scope element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__scope.set(self, new_value)
    
    def addScope (self, new_value):
        """Add the value as another occurrence of the {http://www.opengis.net/gml}scope element.  Raises
        BadValueTypeException if the new value is not consistent with the
        element's type."""
        return self.__scope.append(self, new_value)
    
    # Element {http://www.opengis.net/gml}domainOfValidity uses Python identifier domainOfValidity
    __domainOfValidity = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'domainOfValidity'), 'domainOfValidity', '__AbstractDatumType_httpwww_opengis_netgmldomainOfValidity', False)
    def domainOfValidity (self):
        """Get the value of the {http://www.opengis.net/gml}domainOfValidity element."""
        return self.__domainOfValidity.value(self)
    def setDomainOfValidity (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}domainOfValidity element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__domainOfValidity.set(self, new_value)
    
    # Element remarks inherited from {http://www.opengis.net/gml}DefinitionType
    
    # Element {http://www.opengis.net/gml}anchorDefinition uses Python identifier anchorDefinition
    __anchorDefinition = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'anchorDefinition'), 'anchorDefinition', '__AbstractDatumType_httpwww_opengis_netgmlanchorDefinition', False)
    def anchorDefinition (self):
        """Get the value of the {http://www.opengis.net/gml}anchorDefinition element."""
        return self.__anchorDefinition.value(self)
    def setAnchorDefinition (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}anchorDefinition element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__anchorDefinition.set(self, new_value)
    
    # Attribute id inherited from {http://www.opengis.net/gml}DefinitionBaseType

    _ElementMap = IdentifiedObjectType._ElementMap.copy()
    _ElementMap.update({
        __realizationEpoch.name() : __realizationEpoch,
        __scope.name() : __scope,
        __domainOfValidity.name() : __domainOfValidity,
        __anchorDefinition.name() : __anchorDefinition
    })
    _AttributeMap = IdentifiedObjectType._AttributeMap.copy()
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', u'AbstractDatumType', AbstractDatumType)


# Complex type AbstractGeneralOperationParameterType with content type ELEMENT_ONLY
class AbstractGeneralOperationParameterType (IdentifiedObjectType):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = True
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'AbstractGeneralOperationParameterType')
    # Base type is IdentifiedObjectType
    
    # Element descriptionReference inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element metaDataProperty inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element name inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element identifier inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element description inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element remarks inherited from {http://www.opengis.net/gml}DefinitionType
    
    # Element {http://www.opengis.net/gml}minimumOccurs uses Python identifier minimumOccurs
    __minimumOccurs = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'minimumOccurs'), 'minimumOccurs', '__AbstractGeneralOperationParameterType_httpwww_opengis_netgmlminimumOccurs', False)
    def minimumOccurs (self):
        """Get the value of the {http://www.opengis.net/gml}minimumOccurs element."""
        return self.__minimumOccurs.value(self)
    def setMinimumOccurs (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}minimumOccurs element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__minimumOccurs.set(self, new_value)
    
    # Attribute id inherited from {http://www.opengis.net/gml}DefinitionBaseType

    _ElementMap = IdentifiedObjectType._ElementMap.copy()
    _ElementMap.update({
        __minimumOccurs.name() : __minimumOccurs
    })
    _AttributeMap = IdentifiedObjectType._AttributeMap.copy()
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', u'AbstractGeneralOperationParameterType', AbstractGeneralOperationParameterType)


# Complex type BaseUnitType with content type ELEMENT_ONLY
class BaseUnitType (UnitDefinitionType):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'BaseUnitType')
    # Base type is UnitDefinitionType
    
    # Element descriptionReference inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element metaDataProperty inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element description inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element quantityType inherited from {http://www.opengis.net/gml}UnitDefinitionType
    
    # Element identifier inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element catalogSymbol inherited from {http://www.opengis.net/gml}UnitDefinitionType
    
    # Element {http://www.opengis.net/gml}unitsSystem uses Python identifier unitsSystem
    __unitsSystem = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'unitsSystem'), 'unitsSystem', '__BaseUnitType_httpwww_opengis_netgmlunitsSystem', False)
    def unitsSystem (self):
        """Get the value of the {http://www.opengis.net/gml}unitsSystem element."""
        return self.__unitsSystem.value(self)
    def setUnitsSystem (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}unitsSystem element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__unitsSystem.set(self, new_value)
    
    # Element name inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element remarks inherited from {http://www.opengis.net/gml}DefinitionType
    
    # Element quantityTypeReference inherited from {http://www.opengis.net/gml}UnitDefinitionType
    
    # Attribute id inherited from {http://www.opengis.net/gml}DefinitionBaseType

    _ElementMap = UnitDefinitionType._ElementMap.copy()
    _ElementMap.update({
        __unitsSystem.name() : __unitsSystem
    })
    _AttributeMap = UnitDefinitionType._AttributeMap.copy()
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', u'BaseUnitType', BaseUnitType)


# Complex type CompositeCurveType with content type ELEMENT_ONLY
class CompositeCurveType (AbstractCurveType):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'CompositeCurveType')
    # Base type is AbstractCurveType
    
    # Element descriptionReference inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element name inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element {http://www.opengis.net/gml}curveMember uses Python identifier curveMember
    __curveMember = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'curveMember'), 'curveMember', '__CompositeCurveType_httpwww_opengis_netgmlcurveMember', True)
    def curveMember (self):
        """Get the value of the {http://www.opengis.net/gml}curveMember element."""
        return self.__curveMember.value(self)
    def setCurveMember (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}curveMember element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__curveMember.set(self, new_value)
    
    def addCurveMember (self, new_value):
        """Add the value as another occurrence of the {http://www.opengis.net/gml}curveMember element.  Raises
        BadValueTypeException if the new value is not consistent with the
        element's type."""
        return self.__curveMember.append(self, new_value)
    
    # Element identifier inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element description inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element metaDataProperty inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Attribute uomLabels inherited from {http://www.opengis.net/gml}AbstractGeometryType
    
    # Attribute axisLabels inherited from {http://www.opengis.net/gml}AbstractGeometryType
    
    # Attribute id inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Attribute aggregationType uses Python identifier aggregationType
    __aggregationType = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'aggregationType'), 'aggregationType', '__CompositeCurveType_aggregationType', AggregationType)
    def aggregationType (self):
        """Get the attribute value for aggregationType."""
        return self.__aggregationType.value(self)
    def setAggregationType (self, new_value):
        """Set the attribute value for aggregationType.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__aggregationType.set(self, new_value)
    
    # Attribute srsName inherited from {http://www.opengis.net/gml}AbstractGeometryType
    
    # Attribute srsDimension inherited from {http://www.opengis.net/gml}AbstractGeometryType

    _ElementMap = AbstractCurveType._ElementMap.copy()
    _ElementMap.update({
        __curveMember.name() : __curveMember
    })
    _AttributeMap = AbstractCurveType._AttributeMap.copy()
    _AttributeMap.update({
        __aggregationType.name() : __aggregationType
    })
Namespace.addCategoryObject('typeBinding', u'CompositeCurveType', CompositeCurveType)


# Complex type CompositeSolidType with content type ELEMENT_ONLY
class CompositeSolidType (AbstractSolidType):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'CompositeSolidType')
    # Base type is AbstractSolidType
    
    # Element descriptionReference inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element name inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element identifier inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element description inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element metaDataProperty inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element {http://www.opengis.net/gml}solidMember uses Python identifier solidMember
    __solidMember = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'solidMember'), 'solidMember', '__CompositeSolidType_httpwww_opengis_netgmlsolidMember', True)
    def solidMember (self):
        """Get the value of the {http://www.opengis.net/gml}solidMember element."""
        return self.__solidMember.value(self)
    def setSolidMember (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}solidMember element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__solidMember.set(self, new_value)
    
    def addSolidMember (self, new_value):
        """Add the value as another occurrence of the {http://www.opengis.net/gml}solidMember element.  Raises
        BadValueTypeException if the new value is not consistent with the
        element's type."""
        return self.__solidMember.append(self, new_value)
    
    # Attribute uomLabels inherited from {http://www.opengis.net/gml}AbstractGeometryType
    
    # Attribute axisLabels inherited from {http://www.opengis.net/gml}AbstractGeometryType
    
    # Attribute aggregationType uses Python identifier aggregationType
    __aggregationType = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'aggregationType'), 'aggregationType', '__CompositeSolidType_aggregationType', AggregationType)
    def aggregationType (self):
        """Get the attribute value for aggregationType."""
        return self.__aggregationType.value(self)
    def setAggregationType (self, new_value):
        """Set the attribute value for aggregationType.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__aggregationType.set(self, new_value)
    
    # Attribute id inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Attribute srsName inherited from {http://www.opengis.net/gml}AbstractGeometryType
    
    # Attribute srsDimension inherited from {http://www.opengis.net/gml}AbstractGeometryType

    _ElementMap = AbstractSolidType._ElementMap.copy()
    _ElementMap.update({
        __solidMember.name() : __solidMember
    })
    _AttributeMap = AbstractSolidType._AttributeMap.copy()
    _AttributeMap.update({
        __aggregationType.name() : __aggregationType
    })
Namespace.addCategoryObject('typeBinding', u'CompositeSolidType', CompositeSolidType)


# Complex type CompositeSurfaceType with content type ELEMENT_ONLY
class CompositeSurfaceType (AbstractSurfaceType):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'CompositeSurfaceType')
    # Base type is AbstractSurfaceType
    
    # Element descriptionReference inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element name inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element identifier inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element {http://www.opengis.net/gml}surfaceMember uses Python identifier surfaceMember
    __surfaceMember = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'surfaceMember'), 'surfaceMember', '__CompositeSurfaceType_httpwww_opengis_netgmlsurfaceMember', True)
    def surfaceMember (self):
        """Get the value of the {http://www.opengis.net/gml}surfaceMember element."""
        return self.__surfaceMember.value(self)
    def setSurfaceMember (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}surfaceMember element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__surfaceMember.set(self, new_value)
    
    def addSurfaceMember (self, new_value):
        """Add the value as another occurrence of the {http://www.opengis.net/gml}surfaceMember element.  Raises
        BadValueTypeException if the new value is not consistent with the
        element's type."""
        return self.__surfaceMember.append(self, new_value)
    
    # Element description inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element metaDataProperty inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Attribute aggregationType uses Python identifier aggregationType
    __aggregationType = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'aggregationType'), 'aggregationType', '__CompositeSurfaceType_aggregationType', AggregationType)
    def aggregationType (self):
        """Get the attribute value for aggregationType."""
        return self.__aggregationType.value(self)
    def setAggregationType (self, new_value):
        """Set the attribute value for aggregationType.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__aggregationType.set(self, new_value)
    
    # Attribute uomLabels inherited from {http://www.opengis.net/gml}AbstractGeometryType
    
    # Attribute axisLabels inherited from {http://www.opengis.net/gml}AbstractGeometryType
    
    # Attribute id inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Attribute srsName inherited from {http://www.opengis.net/gml}AbstractGeometryType
    
    # Attribute srsDimension inherited from {http://www.opengis.net/gml}AbstractGeometryType

    _ElementMap = AbstractSurfaceType._ElementMap.copy()
    _ElementMap.update({
        __surfaceMember.name() : __surfaceMember
    })
    _AttributeMap = AbstractSurfaceType._AttributeMap.copy()
    _AttributeMap.update({
        __aggregationType.name() : __aggregationType
    })
Namespace.addCategoryObject('typeBinding', u'CompositeSurfaceType', CompositeSurfaceType)


# Complex type ConventionalUnitType with content type ELEMENT_ONLY
class ConventionalUnitType (UnitDefinitionType):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'ConventionalUnitType')
    # Base type is UnitDefinitionType
    
    # Element descriptionReference inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element metaDataProperty inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element description inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element quantityTypeReference inherited from {http://www.opengis.net/gml}UnitDefinitionType
    
    # Element {http://www.opengis.net/gml}conversionToPreferredUnit uses Python identifier conversionToPreferredUnit
    __conversionToPreferredUnit = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'conversionToPreferredUnit'), 'conversionToPreferredUnit', '__ConventionalUnitType_httpwww_opengis_netgmlconversionToPreferredUnit', False)
    def conversionToPreferredUnit (self):
        """Get the value of the {http://www.opengis.net/gml}conversionToPreferredUnit element."""
        return self.__conversionToPreferredUnit.value(self)
    def setConversionToPreferredUnit (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}conversionToPreferredUnit element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__conversionToPreferredUnit.set(self, new_value)
    
    # Element identifier inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element catalogSymbol inherited from {http://www.opengis.net/gml}UnitDefinitionType
    
    # Element {http://www.opengis.net/gml}derivationUnitTerm uses Python identifier derivationUnitTerm
    __derivationUnitTerm = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'derivationUnitTerm'), 'derivationUnitTerm', '__ConventionalUnitType_httpwww_opengis_netgmlderivationUnitTerm', True)
    def derivationUnitTerm (self):
        """Get the value of the {http://www.opengis.net/gml}derivationUnitTerm element."""
        return self.__derivationUnitTerm.value(self)
    def setDerivationUnitTerm (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}derivationUnitTerm element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__derivationUnitTerm.set(self, new_value)
    
    def addDerivationUnitTerm (self, new_value):
        """Add the value as another occurrence of the {http://www.opengis.net/gml}derivationUnitTerm element.  Raises
        BadValueTypeException if the new value is not consistent with the
        element's type."""
        return self.__derivationUnitTerm.append(self, new_value)
    
    # Element name inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element remarks inherited from {http://www.opengis.net/gml}DefinitionType
    
    # Element quantityType inherited from {http://www.opengis.net/gml}UnitDefinitionType
    
    # Element {http://www.opengis.net/gml}roughConversionToPreferredUnit uses Python identifier roughConversionToPreferredUnit
    __roughConversionToPreferredUnit = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'roughConversionToPreferredUnit'), 'roughConversionToPreferredUnit', '__ConventionalUnitType_httpwww_opengis_netgmlroughConversionToPreferredUnit', False)
    def roughConversionToPreferredUnit (self):
        """Get the value of the {http://www.opengis.net/gml}roughConversionToPreferredUnit element."""
        return self.__roughConversionToPreferredUnit.value(self)
    def setRoughConversionToPreferredUnit (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}roughConversionToPreferredUnit element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__roughConversionToPreferredUnit.set(self, new_value)
    
    # Attribute id inherited from {http://www.opengis.net/gml}DefinitionBaseType

    _ElementMap = UnitDefinitionType._ElementMap.copy()
    _ElementMap.update({
        __conversionToPreferredUnit.name() : __conversionToPreferredUnit,
        __derivationUnitTerm.name() : __derivationUnitTerm,
        __roughConversionToPreferredUnit.name() : __roughConversionToPreferredUnit
    })
    _AttributeMap = UnitDefinitionType._AttributeMap.copy()
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', u'ConventionalUnitType', ConventionalUnitType)


# Complex type CoordinateSystemAxisType with content type ELEMENT_ONLY
class CoordinateSystemAxisType (IdentifiedObjectType):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'CoordinateSystemAxisType')
    # Base type is IdentifiedObjectType
    
    # Element descriptionReference inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element {http://www.opengis.net/gml}axisAbbrev uses Python identifier axisAbbrev
    __axisAbbrev = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'axisAbbrev'), 'axisAbbrev', '__CoordinateSystemAxisType_httpwww_opengis_netgmlaxisAbbrev', False)
    def axisAbbrev (self):
        """Get the value of the {http://www.opengis.net/gml}axisAbbrev element."""
        return self.__axisAbbrev.value(self)
    def setAxisAbbrev (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}axisAbbrev element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__axisAbbrev.set(self, new_value)
    
    # Element {http://www.opengis.net/gml}rangeMeaning uses Python identifier rangeMeaning
    __rangeMeaning = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'rangeMeaning'), 'rangeMeaning', '__CoordinateSystemAxisType_httpwww_opengis_netgmlrangeMeaning', False)
    def rangeMeaning (self):
        """Get the value of the {http://www.opengis.net/gml}rangeMeaning element."""
        return self.__rangeMeaning.value(self)
    def setRangeMeaning (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}rangeMeaning element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__rangeMeaning.set(self, new_value)
    
    # Element description inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element {http://www.opengis.net/gml}axisDirection uses Python identifier axisDirection
    __axisDirection = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'axisDirection'), 'axisDirection', '__CoordinateSystemAxisType_httpwww_opengis_netgmlaxisDirection', False)
    def axisDirection (self):
        """Get the value of the {http://www.opengis.net/gml}axisDirection element."""
        return self.__axisDirection.value(self)
    def setAxisDirection (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}axisDirection element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__axisDirection.set(self, new_value)
    
    # Element {http://www.opengis.net/gml}maximumValue uses Python identifier maximumValue
    __maximumValue = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'maximumValue'), 'maximumValue', '__CoordinateSystemAxisType_httpwww_opengis_netgmlmaximumValue', False)
    def maximumValue (self):
        """Get the value of the {http://www.opengis.net/gml}maximumValue element."""
        return self.__maximumValue.value(self)
    def setMaximumValue (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}maximumValue element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__maximumValue.set(self, new_value)
    
    # Element {http://www.opengis.net/gml}minimumValue uses Python identifier minimumValue
    __minimumValue = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'minimumValue'), 'minimumValue', '__CoordinateSystemAxisType_httpwww_opengis_netgmlminimumValue', False)
    def minimumValue (self):
        """Get the value of the {http://www.opengis.net/gml}minimumValue element."""
        return self.__minimumValue.value(self)
    def setMinimumValue (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}minimumValue element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__minimumValue.set(self, new_value)
    
    # Element metaDataProperty inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element identifier inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element name inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element remarks inherited from {http://www.opengis.net/gml}DefinitionType
    
    # Attribute {http://www.opengis.net/gml}uom uses Python identifier uom
    __uom = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(Namespace, u'uom'), 'uom', '__CoordinateSystemAxisType_httpwww_opengis_netgmluom', pyxb.binding.datatypes.anyURI, required=True)
    def uom (self):
        """Get the attribute value for {http://www.opengis.net/gml}uom."""
        return self.__uom.value(self)
    def setUom (self, new_value):
        """Set the attribute value for {http://www.opengis.net/gml}uom.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__uom.set(self, new_value)
    
    # Attribute id inherited from {http://www.opengis.net/gml}DefinitionBaseType

    _ElementMap = IdentifiedObjectType._ElementMap.copy()
    _ElementMap.update({
        __axisAbbrev.name() : __axisAbbrev,
        __rangeMeaning.name() : __rangeMeaning,
        __axisDirection.name() : __axisDirection,
        __maximumValue.name() : __maximumValue,
        __minimumValue.name() : __minimumValue
    })
    _AttributeMap = IdentifiedObjectType._AttributeMap.copy()
    _AttributeMap.update({
        __uom.name() : __uom
    })
Namespace.addCategoryObject('typeBinding', u'CoordinateSystemAxisType', CoordinateSystemAxisType)


# Complex type CurveType with content type ELEMENT_ONLY
class CurveType (AbstractCurveType):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'CurveType')
    # Base type is AbstractCurveType
    
    # Element descriptionReference inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element name inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element {http://www.opengis.net/gml}segments uses Python identifier segments
    __segments = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'segments'), 'segments', '__CurveType_httpwww_opengis_netgmlsegments', False)
    def segments (self):
        """Get the value of the {http://www.opengis.net/gml}segments element."""
        return self.__segments.value(self)
    def setSegments (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}segments element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__segments.set(self, new_value)
    
    # Element identifier inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element description inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element metaDataProperty inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Attribute srsName inherited from {http://www.opengis.net/gml}AbstractGeometryType
    
    # Attribute axisLabels inherited from {http://www.opengis.net/gml}AbstractGeometryType
    
    # Attribute id inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Attribute uomLabels inherited from {http://www.opengis.net/gml}AbstractGeometryType
    
    # Attribute srsDimension inherited from {http://www.opengis.net/gml}AbstractGeometryType

    _ElementMap = AbstractCurveType._ElementMap.copy()
    _ElementMap.update({
        __segments.name() : __segments
    })
    _AttributeMap = AbstractCurveType._AttributeMap.copy()
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', u'CurveType', CurveType)


# Complex type DerivedUnitType with content type ELEMENT_ONLY
class DerivedUnitType (UnitDefinitionType):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'DerivedUnitType')
    # Base type is UnitDefinitionType
    
    # Element descriptionReference inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element metaDataProperty inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element description inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element quantityType inherited from {http://www.opengis.net/gml}UnitDefinitionType
    
    # Element identifier inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element catalogSymbol inherited from {http://www.opengis.net/gml}UnitDefinitionType
    
    # Element {http://www.opengis.net/gml}derivationUnitTerm uses Python identifier derivationUnitTerm
    __derivationUnitTerm = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'derivationUnitTerm'), 'derivationUnitTerm', '__DerivedUnitType_httpwww_opengis_netgmlderivationUnitTerm', True)
    def derivationUnitTerm (self):
        """Get the value of the {http://www.opengis.net/gml}derivationUnitTerm element."""
        return self.__derivationUnitTerm.value(self)
    def setDerivationUnitTerm (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}derivationUnitTerm element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__derivationUnitTerm.set(self, new_value)
    
    def addDerivationUnitTerm (self, new_value):
        """Add the value as another occurrence of the {http://www.opengis.net/gml}derivationUnitTerm element.  Raises
        BadValueTypeException if the new value is not consistent with the
        element's type."""
        return self.__derivationUnitTerm.append(self, new_value)
    
    # Element name inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element remarks inherited from {http://www.opengis.net/gml}DefinitionType
    
    # Element quantityTypeReference inherited from {http://www.opengis.net/gml}UnitDefinitionType
    
    # Attribute id inherited from {http://www.opengis.net/gml}DefinitionBaseType

    _ElementMap = UnitDefinitionType._ElementMap.copy()
    _ElementMap.update({
        __derivationUnitTerm.name() : __derivationUnitTerm
    })
    _AttributeMap = UnitDefinitionType._AttributeMap.copy()
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', u'DerivedUnitType', DerivedUnitType)


# Complex type DirectedObservationAtDistanceType with content type ELEMENT_ONLY
class DirectedObservationAtDistanceType (DirectedObservationType):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'DirectedObservationAtDistanceType')
    # Base type is DirectedObservationType
    
    # Element descriptionReference inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element boundedBy inherited from {http://www.opengis.net/gml}AbstractFeatureType
    
    # Element target inherited from {http://www.opengis.net/gml}ObservationType
    
    # Element resultOf inherited from {http://www.opengis.net/gml}ObservationType
    
    # Element validTime inherited from {http://www.opengis.net/gml}ObservationType
    
    # Element direction inherited from {http://www.opengis.net/gml}DirectedObservationType
    
    # Element {http://www.opengis.net/gml}distance uses Python identifier distance
    __distance = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'distance'), 'distance', '__DirectedObservationAtDistanceType_httpwww_opengis_netgmldistance', False)
    def distance (self):
        """Get the value of the {http://www.opengis.net/gml}distance element."""
        return self.__distance.value(self)
    def setDistance (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}distance element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__distance.set(self, new_value)
    
    # Element identifier inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element location inherited from {http://www.opengis.net/gml}AbstractFeatureType
    
    # Element using inherited from {http://www.opengis.net/gml}ObservationType
    
    # Element description inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element metaDataProperty inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element name inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Attribute id inherited from {http://www.opengis.net/gml}AbstractGMLType

    _ElementMap = DirectedObservationType._ElementMap.copy()
    _ElementMap.update({
        __distance.name() : __distance
    })
    _AttributeMap = DirectedObservationType._AttributeMap.copy()
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', u'DirectedObservationAtDistanceType', DirectedObservationAtDistanceType)


# Complex type EllipsoidType with content type ELEMENT_ONLY
class EllipsoidType (IdentifiedObjectType):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'EllipsoidType')
    # Base type is IdentifiedObjectType
    
    # Element descriptionReference inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element metaDataProperty inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element name inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element {http://www.opengis.net/gml}secondDefiningParameter uses Python identifier secondDefiningParameter
    __secondDefiningParameter = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'secondDefiningParameter'), 'secondDefiningParameter', '__EllipsoidType_httpwww_opengis_netgmlsecondDefiningParameter', False)
    def secondDefiningParameter (self):
        """Get the value of the {http://www.opengis.net/gml}secondDefiningParameter element."""
        return self.__secondDefiningParameter.value(self)
    def setSecondDefiningParameter (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}secondDefiningParameter element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__secondDefiningParameter.set(self, new_value)
    
    # Element identifier inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element description inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element remarks inherited from {http://www.opengis.net/gml}DefinitionType
    
    # Element {http://www.opengis.net/gml}semiMajorAxis uses Python identifier semiMajorAxis
    __semiMajorAxis = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'semiMajorAxis'), 'semiMajorAxis', '__EllipsoidType_httpwww_opengis_netgmlsemiMajorAxis', False)
    def semiMajorAxis (self):
        """Get the value of the {http://www.opengis.net/gml}semiMajorAxis element."""
        return self.__semiMajorAxis.value(self)
    def setSemiMajorAxis (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}semiMajorAxis element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__semiMajorAxis.set(self, new_value)
    
    # Attribute id inherited from {http://www.opengis.net/gml}DefinitionBaseType

    _ElementMap = IdentifiedObjectType._ElementMap.copy()
    _ElementMap.update({
        __secondDefiningParameter.name() : __secondDefiningParameter,
        __semiMajorAxis.name() : __semiMajorAxis
    })
    _AttributeMap = IdentifiedObjectType._AttributeMap.copy()
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', u'EllipsoidType', EllipsoidType)


# Complex type GridCoverageType with content type ELEMENT_ONLY
class GridCoverageType (AbstractDiscreteCoverageType):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'GridCoverageType')
    # Base type is AbstractDiscreteCoverageType
    
    # Element descriptionReference inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element description inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element rangeSet inherited from {http://www.opengis.net/gml}AbstractCoverageType
    
    # Element {http://www.opengis.net/gml}gridDomain uses Python identifier gridDomain
    __gridDomain = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'gridDomain'), 'gridDomain', '__GridCoverageType_httpwww_opengis_netgmlgridDomain', False)
    def gridDomain (self):
        """Get the value of the {http://www.opengis.net/gml}gridDomain element."""
        return self.__gridDomain.value(self)
    def setGridDomain (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}gridDomain element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__gridDomain.set(self, new_value)
    
    # Element boundedBy inherited from {http://www.opengis.net/gml}AbstractFeatureType
    
    # Element identifier inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element coverageFunction inherited from {http://www.opengis.net/gml}AbstractDiscreteCoverageType
    
    # Element name inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element metaDataProperty inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Attribute id inherited from {http://www.opengis.net/gml}AbstractGMLType

    _ElementMap = AbstractDiscreteCoverageType._ElementMap.copy()
    _ElementMap.update({
        __gridDomain.name() : __gridDomain
    })
    _AttributeMap = AbstractDiscreteCoverageType._AttributeMap.copy()
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', u'GridCoverageType', GridCoverageType)


# Complex type LineStringType with content type ELEMENT_ONLY
class LineStringType (AbstractCurveType):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'LineStringType')
    # Base type is AbstractCurveType
    
    # Element descriptionReference inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element description inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element identifier inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element {http://www.opengis.net/gml}posList uses Python identifier posList
    __posList = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'posList'), 'posList', '__LineStringType_httpwww_opengis_netgmlposList', False)
    def posList (self):
        """Get the value of the {http://www.opengis.net/gml}posList element."""
        return self.__posList.value(self)
    def setPosList (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}posList element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__posList.set(self, new_value)
    
    # Element {http://www.opengis.net/gml}coordinates uses Python identifier coordinates
    __coordinates = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'coordinates'), 'coordinates', '__LineStringType_httpwww_opengis_netgmlcoordinates', False)
    def coordinates (self):
        """Get the value of the {http://www.opengis.net/gml}coordinates element."""
        return self.__coordinates.value(self)
    def setCoordinates (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}coordinates element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__coordinates.set(self, new_value)
    
    # Element name inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element {http://www.opengis.net/gml}pointRep uses Python identifier pointRep
    __pointRep = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'pointRep'), 'pointRep', '__LineStringType_httpwww_opengis_netgmlpointRep', True)
    def pointRep (self):
        """Get the value of the {http://www.opengis.net/gml}pointRep element."""
        return self.__pointRep.value(self)
    def setPointRep (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}pointRep element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__pointRep.set(self, new_value)
    
    def addPointRep (self, new_value):
        """Add the value as another occurrence of the {http://www.opengis.net/gml}pointRep element.  Raises
        BadValueTypeException if the new value is not consistent with the
        element's type."""
        return self.__pointRep.append(self, new_value)
    
    # Element metaDataProperty inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element {http://www.opengis.net/gml}pos uses Python identifier pos
    __pos = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'pos'), 'pos', '__LineStringType_httpwww_opengis_netgmlpos', True)
    def pos (self):
        """Get the value of the {http://www.opengis.net/gml}pos element."""
        return self.__pos.value(self)
    def setPos (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}pos element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__pos.set(self, new_value)
    
    def addPos (self, new_value):
        """Add the value as another occurrence of the {http://www.opengis.net/gml}pos element.  Raises
        BadValueTypeException if the new value is not consistent with the
        element's type."""
        return self.__pos.append(self, new_value)
    
    # Element {http://www.opengis.net/gml}pointProperty uses Python identifier pointProperty
    __pointProperty = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'pointProperty'), 'pointProperty', '__LineStringType_httpwww_opengis_netgmlpointProperty', True)
    def pointProperty (self):
        """Get the value of the {http://www.opengis.net/gml}pointProperty element."""
        return self.__pointProperty.value(self)
    def setPointProperty (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}pointProperty element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__pointProperty.set(self, new_value)
    
    def addPointProperty (self, new_value):
        """Add the value as another occurrence of the {http://www.opengis.net/gml}pointProperty element.  Raises
        BadValueTypeException if the new value is not consistent with the
        element's type."""
        return self.__pointProperty.append(self, new_value)
    
    # Attribute srsName inherited from {http://www.opengis.net/gml}AbstractGeometryType
    
    # Attribute axisLabels inherited from {http://www.opengis.net/gml}AbstractGeometryType
    
    # Attribute id inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Attribute uomLabels inherited from {http://www.opengis.net/gml}AbstractGeometryType
    
    # Attribute srsDimension inherited from {http://www.opengis.net/gml}AbstractGeometryType

    _ElementMap = AbstractCurveType._ElementMap.copy()
    _ElementMap.update({
        __posList.name() : __posList,
        __coordinates.name() : __coordinates,
        __pointRep.name() : __pointRep,
        __pos.name() : __pos,
        __pointProperty.name() : __pointProperty
    })
    _AttributeMap = AbstractCurveType._AttributeMap.copy()
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', u'LineStringType', LineStringType)


# Complex type MultiCurveCoverageType with content type ELEMENT_ONLY
class MultiCurveCoverageType (AbstractDiscreteCoverageType):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'MultiCurveCoverageType')
    # Base type is AbstractDiscreteCoverageType
    
    # Element descriptionReference inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element {http://www.opengis.net/gml}multiCurveDomain uses Python identifier multiCurveDomain
    __multiCurveDomain = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'multiCurveDomain'), 'multiCurveDomain', '__MultiCurveCoverageType_httpwww_opengis_netgmlmultiCurveDomain', False)
    def multiCurveDomain (self):
        """Get the value of the {http://www.opengis.net/gml}multiCurveDomain element."""
        return self.__multiCurveDomain.value(self)
    def setMultiCurveDomain (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}multiCurveDomain element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__multiCurveDomain.set(self, new_value)
    
    # Element description inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element rangeSet inherited from {http://www.opengis.net/gml}AbstractCoverageType
    
    # Element boundedBy inherited from {http://www.opengis.net/gml}AbstractFeatureType
    
    # Element identifier inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element coverageFunction inherited from {http://www.opengis.net/gml}AbstractDiscreteCoverageType
    
    # Element name inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element metaDataProperty inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Attribute id inherited from {http://www.opengis.net/gml}AbstractGMLType

    _ElementMap = AbstractDiscreteCoverageType._ElementMap.copy()
    _ElementMap.update({
        __multiCurveDomain.name() : __multiCurveDomain
    })
    _AttributeMap = AbstractDiscreteCoverageType._AttributeMap.copy()
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', u'MultiCurveCoverageType', MultiCurveCoverageType)


# Complex type MultiPointCoverageType with content type ELEMENT_ONLY
class MultiPointCoverageType (AbstractDiscreteCoverageType):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'MultiPointCoverageType')
    # Base type is AbstractDiscreteCoverageType
    
    # Element descriptionReference inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element name inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element rangeSet inherited from {http://www.opengis.net/gml}AbstractCoverageType
    
    # Element boundedBy inherited from {http://www.opengis.net/gml}AbstractFeatureType
    
    # Element identifier inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element coverageFunction inherited from {http://www.opengis.net/gml}AbstractDiscreteCoverageType
    
    # Element {http://www.opengis.net/gml}multiPointDomain uses Python identifier multiPointDomain
    __multiPointDomain = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'multiPointDomain'), 'multiPointDomain', '__MultiPointCoverageType_httpwww_opengis_netgmlmultiPointDomain', False)
    def multiPointDomain (self):
        """Get the value of the {http://www.opengis.net/gml}multiPointDomain element."""
        return self.__multiPointDomain.value(self)
    def setMultiPointDomain (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}multiPointDomain element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__multiPointDomain.set(self, new_value)
    
    # Element description inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element metaDataProperty inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Attribute id inherited from {http://www.opengis.net/gml}AbstractGMLType

    _ElementMap = AbstractDiscreteCoverageType._ElementMap.copy()
    _ElementMap.update({
        __multiPointDomain.name() : __multiPointDomain
    })
    _AttributeMap = AbstractDiscreteCoverageType._AttributeMap.copy()
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', u'MultiPointCoverageType', MultiPointCoverageType)


# Complex type MultiSolidCoverageType with content type ELEMENT_ONLY
class MultiSolidCoverageType (AbstractDiscreteCoverageType):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'MultiSolidCoverageType')
    # Base type is AbstractDiscreteCoverageType
    
    # Element descriptionReference inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element description inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element rangeSet inherited from {http://www.opengis.net/gml}AbstractCoverageType
    
    # Element boundedBy inherited from {http://www.opengis.net/gml}AbstractFeatureType
    
    # Element identifier inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element {http://www.opengis.net/gml}multiSolidDomain uses Python identifier multiSolidDomain
    __multiSolidDomain = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'multiSolidDomain'), 'multiSolidDomain', '__MultiSolidCoverageType_httpwww_opengis_netgmlmultiSolidDomain', False)
    def multiSolidDomain (self):
        """Get the value of the {http://www.opengis.net/gml}multiSolidDomain element."""
        return self.__multiSolidDomain.value(self)
    def setMultiSolidDomain (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}multiSolidDomain element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__multiSolidDomain.set(self, new_value)
    
    # Element coverageFunction inherited from {http://www.opengis.net/gml}AbstractDiscreteCoverageType
    
    # Element name inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element metaDataProperty inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Attribute id inherited from {http://www.opengis.net/gml}AbstractGMLType

    _ElementMap = AbstractDiscreteCoverageType._ElementMap.copy()
    _ElementMap.update({
        __multiSolidDomain.name() : __multiSolidDomain
    })
    _AttributeMap = AbstractDiscreteCoverageType._AttributeMap.copy()
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', u'MultiSolidCoverageType', MultiSolidCoverageType)


# Complex type MultiSurfaceCoverageType with content type ELEMENT_ONLY
class MultiSurfaceCoverageType (AbstractDiscreteCoverageType):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'MultiSurfaceCoverageType')
    # Base type is AbstractDiscreteCoverageType
    
    # Element descriptionReference inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element name inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element rangeSet inherited from {http://www.opengis.net/gml}AbstractCoverageType
    
    # Element boundedBy inherited from {http://www.opengis.net/gml}AbstractFeatureType
    
    # Element identifier inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element coverageFunction inherited from {http://www.opengis.net/gml}AbstractDiscreteCoverageType
    
    # Element description inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element metaDataProperty inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element {http://www.opengis.net/gml}multiSurfaceDomain uses Python identifier multiSurfaceDomain
    __multiSurfaceDomain = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'multiSurfaceDomain'), 'multiSurfaceDomain', '__MultiSurfaceCoverageType_httpwww_opengis_netgmlmultiSurfaceDomain', False)
    def multiSurfaceDomain (self):
        """Get the value of the {http://www.opengis.net/gml}multiSurfaceDomain element."""
        return self.__multiSurfaceDomain.value(self)
    def setMultiSurfaceDomain (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}multiSurfaceDomain element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__multiSurfaceDomain.set(self, new_value)
    
    # Attribute id inherited from {http://www.opengis.net/gml}AbstractGMLType

    _ElementMap = AbstractDiscreteCoverageType._ElementMap.copy()
    _ElementMap.update({
        __multiSurfaceDomain.name() : __multiSurfaceDomain
    })
    _AttributeMap = AbstractDiscreteCoverageType._AttributeMap.copy()
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', u'MultiSurfaceCoverageType', MultiSurfaceCoverageType)


# Complex type OperationMethodType with content type ELEMENT_ONLY
class OperationMethodType (IdentifiedObjectType):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'OperationMethodType')
    # Base type is IdentifiedObjectType
    
    # Element descriptionReference inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element metaDataProperty inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element {http://www.opengis.net/gml}sourceDimensions uses Python identifier sourceDimensions
    __sourceDimensions = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'sourceDimensions'), 'sourceDimensions', '__OperationMethodType_httpwww_opengis_netgmlsourceDimensions', False)
    def sourceDimensions (self):
        """Get the value of the {http://www.opengis.net/gml}sourceDimensions element."""
        return self.__sourceDimensions.value(self)
    def setSourceDimensions (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}sourceDimensions element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__sourceDimensions.set(self, new_value)
    
    # Element name inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element identifier inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element {http://www.opengis.net/gml}generalOperationParameter uses Python identifier generalOperationParameter
    __generalOperationParameter = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'generalOperationParameter'), 'generalOperationParameter', '__OperationMethodType_httpwww_opengis_netgmlgeneralOperationParameter', True)
    def generalOperationParameter (self):
        """Get the value of the {http://www.opengis.net/gml}generalOperationParameter element."""
        return self.__generalOperationParameter.value(self)
    def setGeneralOperationParameter (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}generalOperationParameter element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__generalOperationParameter.set(self, new_value)
    
    def addGeneralOperationParameter (self, new_value):
        """Add the value as another occurrence of the {http://www.opengis.net/gml}generalOperationParameter element.  Raises
        BadValueTypeException if the new value is not consistent with the
        element's type."""
        return self.__generalOperationParameter.append(self, new_value)
    
    # Element {http://www.opengis.net/gml}formula uses Python identifier formula
    __formula = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'formula'), 'formula', '__OperationMethodType_httpwww_opengis_netgmlformula', False)
    def formula (self):
        """Get the value of the {http://www.opengis.net/gml}formula element."""
        return self.__formula.value(self)
    def setFormula (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}formula element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__formula.set(self, new_value)
    
    # Element description inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element remarks inherited from {http://www.opengis.net/gml}DefinitionType
    
    # Element {http://www.opengis.net/gml}targetDimensions uses Python identifier targetDimensions
    __targetDimensions = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'targetDimensions'), 'targetDimensions', '__OperationMethodType_httpwww_opengis_netgmltargetDimensions', False)
    def targetDimensions (self):
        """Get the value of the {http://www.opengis.net/gml}targetDimensions element."""
        return self.__targetDimensions.value(self)
    def setTargetDimensions (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}targetDimensions element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__targetDimensions.set(self, new_value)
    
    # Attribute id inherited from {http://www.opengis.net/gml}DefinitionBaseType

    _ElementMap = IdentifiedObjectType._ElementMap.copy()
    _ElementMap.update({
        __sourceDimensions.name() : __sourceDimensions,
        __generalOperationParameter.name() : __generalOperationParameter,
        __formula.name() : __formula,
        __targetDimensions.name() : __targetDimensions
    })
    _AttributeMap = IdentifiedObjectType._AttributeMap.copy()
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', u'OperationMethodType', OperationMethodType)


# Complex type OrientableCurveType with content type ELEMENT_ONLY
class OrientableCurveType (AbstractCurveType):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'OrientableCurveType')
    # Base type is AbstractCurveType
    
    # Element descriptionReference inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element name inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element identifier inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element {http://www.opengis.net/gml}baseCurve uses Python identifier baseCurve
    __baseCurve = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'baseCurve'), 'baseCurve', '__OrientableCurveType_httpwww_opengis_netgmlbaseCurve', False)
    def baseCurve (self):
        """Get the value of the {http://www.opengis.net/gml}baseCurve element."""
        return self.__baseCurve.value(self)
    def setBaseCurve (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}baseCurve element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__baseCurve.set(self, new_value)
    
    # Element description inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element metaDataProperty inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Attribute orientation uses Python identifier orientation
    __orientation = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'orientation'), 'orientation', '__OrientableCurveType_orientation', SignType, unicode_default=u'+')
    def orientation (self):
        """Get the attribute value for orientation."""
        return self.__orientation.value(self)
    def setOrientation (self, new_value):
        """Set the attribute value for orientation.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__orientation.set(self, new_value)
    
    # Attribute axisLabels inherited from {http://www.opengis.net/gml}AbstractGeometryType
    
    # Attribute id inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Attribute srsName inherited from {http://www.opengis.net/gml}AbstractGeometryType
    
    # Attribute srsDimension inherited from {http://www.opengis.net/gml}AbstractGeometryType
    
    # Attribute uomLabels inherited from {http://www.opengis.net/gml}AbstractGeometryType

    _ElementMap = AbstractCurveType._ElementMap.copy()
    _ElementMap.update({
        __baseCurve.name() : __baseCurve
    })
    _AttributeMap = AbstractCurveType._AttributeMap.copy()
    _AttributeMap.update({
        __orientation.name() : __orientation
    })
Namespace.addCategoryObject('typeBinding', u'OrientableCurveType', OrientableCurveType)


# Complex type OrientableSurfaceType with content type ELEMENT_ONLY
class OrientableSurfaceType (AbstractSurfaceType):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'OrientableSurfaceType')
    # Base type is AbstractSurfaceType
    
    # Element descriptionReference inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element name inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element {http://www.opengis.net/gml}baseSurface uses Python identifier baseSurface
    __baseSurface = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'baseSurface'), 'baseSurface', '__OrientableSurfaceType_httpwww_opengis_netgmlbaseSurface', False)
    def baseSurface (self):
        """Get the value of the {http://www.opengis.net/gml}baseSurface element."""
        return self.__baseSurface.value(self)
    def setBaseSurface (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}baseSurface element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__baseSurface.set(self, new_value)
    
    # Element identifier inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element description inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element metaDataProperty inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Attribute orientation uses Python identifier orientation
    __orientation = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'orientation'), 'orientation', '__OrientableSurfaceType_orientation', SignType, unicode_default=u'+')
    def orientation (self):
        """Get the attribute value for orientation."""
        return self.__orientation.value(self)
    def setOrientation (self, new_value):
        """Set the attribute value for orientation.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__orientation.set(self, new_value)
    
    # Attribute axisLabels inherited from {http://www.opengis.net/gml}AbstractGeometryType
    
    # Attribute id inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Attribute srsName inherited from {http://www.opengis.net/gml}AbstractGeometryType
    
    # Attribute srsDimension inherited from {http://www.opengis.net/gml}AbstractGeometryType
    
    # Attribute uomLabels inherited from {http://www.opengis.net/gml}AbstractGeometryType

    _ElementMap = AbstractSurfaceType._ElementMap.copy()
    _ElementMap.update({
        __baseSurface.name() : __baseSurface
    })
    _AttributeMap = AbstractSurfaceType._AttributeMap.copy()
    _AttributeMap.update({
        __orientation.name() : __orientation
    })
Namespace.addCategoryObject('typeBinding', u'OrientableSurfaceType', OrientableSurfaceType)


# Complex type PolygonType with content type ELEMENT_ONLY
class PolygonType (AbstractSurfaceType):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'PolygonType')
    # Base type is AbstractSurfaceType
    
    # Element descriptionReference inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element {http://www.opengis.net/gml}interior uses Python identifier interior
    __interior = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'interior'), 'interior', '__PolygonType_httpwww_opengis_netgmlinterior', True)
    def interior (self):
        """Get the value of the {http://www.opengis.net/gml}interior element."""
        return self.__interior.value(self)
    def setInterior (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}interior element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__interior.set(self, new_value)
    
    def addInterior (self, new_value):
        """Add the value as another occurrence of the {http://www.opengis.net/gml}interior element.  Raises
        BadValueTypeException if the new value is not consistent with the
        element's type."""
        return self.__interior.append(self, new_value)
    
    # Element description inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element {http://www.opengis.net/gml}exterior uses Python identifier exterior
    __exterior = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'exterior'), 'exterior', '__PolygonType_httpwww_opengis_netgmlexterior', False)
    def exterior (self):
        """Get the value of the {http://www.opengis.net/gml}exterior element."""
        return self.__exterior.value(self)
    def setExterior (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}exterior element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__exterior.set(self, new_value)
    
    # Element identifier inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element name inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element metaDataProperty inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Attribute srsName inherited from {http://www.opengis.net/gml}AbstractGeometryType
    
    # Attribute axisLabels inherited from {http://www.opengis.net/gml}AbstractGeometryType
    
    # Attribute id inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Attribute uomLabels inherited from {http://www.opengis.net/gml}AbstractGeometryType
    
    # Attribute srsDimension inherited from {http://www.opengis.net/gml}AbstractGeometryType

    _ElementMap = AbstractSurfaceType._ElementMap.copy()
    _ElementMap.update({
        __interior.name() : __interior,
        __exterior.name() : __exterior
    })
    _AttributeMap = AbstractSurfaceType._AttributeMap.copy()
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', u'PolygonType', PolygonType)


# Complex type PrimeMeridianType with content type ELEMENT_ONLY
class PrimeMeridianType (IdentifiedObjectType):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'PrimeMeridianType')
    # Base type is IdentifiedObjectType
    
    # Element descriptionReference inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element metaDataProperty inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element description inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element {http://www.opengis.net/gml}greenwichLongitude uses Python identifier greenwichLongitude
    __greenwichLongitude = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'greenwichLongitude'), 'greenwichLongitude', '__PrimeMeridianType_httpwww_opengis_netgmlgreenwichLongitude', False)
    def greenwichLongitude (self):
        """Get the value of the {http://www.opengis.net/gml}greenwichLongitude element."""
        return self.__greenwichLongitude.value(self)
    def setGreenwichLongitude (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}greenwichLongitude element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__greenwichLongitude.set(self, new_value)
    
    # Element identifier inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element name inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element remarks inherited from {http://www.opengis.net/gml}DefinitionType
    
    # Attribute id inherited from {http://www.opengis.net/gml}DefinitionBaseType

    _ElementMap = IdentifiedObjectType._ElementMap.copy()
    _ElementMap.update({
        __greenwichLongitude.name() : __greenwichLongitude
    })
    _AttributeMap = IdentifiedObjectType._AttributeMap.copy()
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', u'PrimeMeridianType', PrimeMeridianType)


# Complex type RectifiedGridCoverageType with content type ELEMENT_ONLY
class RectifiedGridCoverageType (AbstractDiscreteCoverageType):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'RectifiedGridCoverageType')
    # Base type is AbstractDiscreteCoverageType
    
    # Element descriptionReference inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element description inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element rangeSet inherited from {http://www.opengis.net/gml}AbstractCoverageType
    
    # Element boundedBy inherited from {http://www.opengis.net/gml}AbstractFeatureType
    
    # Element identifier inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element {http://www.opengis.net/gml}rectifiedGridDomain uses Python identifier rectifiedGridDomain
    __rectifiedGridDomain = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'rectifiedGridDomain'), 'rectifiedGridDomain', '__RectifiedGridCoverageType_httpwww_opengis_netgmlrectifiedGridDomain', False)
    def rectifiedGridDomain (self):
        """Get the value of the {http://www.opengis.net/gml}rectifiedGridDomain element."""
        return self.__rectifiedGridDomain.value(self)
    def setRectifiedGridDomain (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}rectifiedGridDomain element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__rectifiedGridDomain.set(self, new_value)
    
    # Element coverageFunction inherited from {http://www.opengis.net/gml}AbstractDiscreteCoverageType
    
    # Element name inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element metaDataProperty inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Attribute id inherited from {http://www.opengis.net/gml}AbstractGMLType

    _ElementMap = AbstractDiscreteCoverageType._ElementMap.copy()
    _ElementMap.update({
        __rectifiedGridDomain.name() : __rectifiedGridDomain
    })
    _AttributeMap = AbstractDiscreteCoverageType._AttributeMap.copy()
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', u'RectifiedGridCoverageType', RectifiedGridCoverageType)


# Complex type SolidType with content type ELEMENT_ONLY
class SolidType (AbstractSolidType):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'SolidType')
    # Base type is AbstractSolidType
    
    # Element descriptionReference inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element {http://www.opengis.net/gml}interior uses Python identifier interior
    __interior = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'interior'), 'interior', '__SolidType_httpwww_opengis_netgmlinterior', True)
    def interior (self):
        """Get the value of the {http://www.opengis.net/gml}interior element."""
        return self.__interior.value(self)
    def setInterior (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}interior element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__interior.set(self, new_value)
    
    def addInterior (self, new_value):
        """Add the value as another occurrence of the {http://www.opengis.net/gml}interior element.  Raises
        BadValueTypeException if the new value is not consistent with the
        element's type."""
        return self.__interior.append(self, new_value)
    
    # Element description inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element {http://www.opengis.net/gml}exterior uses Python identifier exterior
    __exterior = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'exterior'), 'exterior', '__SolidType_httpwww_opengis_netgmlexterior', False)
    def exterior (self):
        """Get the value of the {http://www.opengis.net/gml}exterior element."""
        return self.__exterior.value(self)
    def setExterior (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}exterior element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__exterior.set(self, new_value)
    
    # Element identifier inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element name inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element metaDataProperty inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Attribute srsName inherited from {http://www.opengis.net/gml}AbstractGeometryType
    
    # Attribute axisLabels inherited from {http://www.opengis.net/gml}AbstractGeometryType
    
    # Attribute id inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Attribute uomLabels inherited from {http://www.opengis.net/gml}AbstractGeometryType
    
    # Attribute srsDimension inherited from {http://www.opengis.net/gml}AbstractGeometryType

    _ElementMap = AbstractSolidType._ElementMap.copy()
    _ElementMap.update({
        __interior.name() : __interior,
        __exterior.name() : __exterior
    })
    _AttributeMap = AbstractSolidType._AttributeMap.copy()
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', u'SolidType', SolidType)


# Complex type SurfaceType with content type ELEMENT_ONLY
class SurfaceType (AbstractSurfaceType):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'SurfaceType')
    # Base type is AbstractSurfaceType
    
    # Element descriptionReference inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element name inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element identifier inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element description inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element {http://www.opengis.net/gml}patches uses Python identifier patches
    __patches = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'patches'), 'patches', '__SurfaceType_httpwww_opengis_netgmlpatches', False)
    def patches (self):
        """Get the value of the {http://www.opengis.net/gml}patches element."""
        return self.__patches.value(self)
    def setPatches (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}patches element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__patches.set(self, new_value)
    
    # Element metaDataProperty inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Attribute srsName inherited from {http://www.opengis.net/gml}AbstractGeometryType
    
    # Attribute axisLabels inherited from {http://www.opengis.net/gml}AbstractGeometryType
    
    # Attribute id inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Attribute uomLabels inherited from {http://www.opengis.net/gml}AbstractGeometryType
    
    # Attribute srsDimension inherited from {http://www.opengis.net/gml}AbstractGeometryType

    _ElementMap = AbstractSurfaceType._ElementMap.copy()
    _ElementMap.update({
        __patches.name() : __patches
    })
    _AttributeMap = AbstractSurfaceType._AttributeMap.copy()
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', u'SurfaceType', SurfaceType)


# Complex type TimeCalendarType with content type ELEMENT_ONLY
class TimeCalendarType (TimeReferenceSystemType):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'TimeCalendarType')
    # Base type is TimeReferenceSystemType
    
    # Element descriptionReference inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element description inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element metaDataProperty inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element name inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element {http://www.opengis.net/gml}referenceFrame uses Python identifier referenceFrame
    __referenceFrame = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'referenceFrame'), 'referenceFrame', '__TimeCalendarType_httpwww_opengis_netgmlreferenceFrame', True)
    def referenceFrame (self):
        """Get the value of the {http://www.opengis.net/gml}referenceFrame element."""
        return self.__referenceFrame.value(self)
    def setReferenceFrame (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}referenceFrame element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__referenceFrame.set(self, new_value)
    
    def addReferenceFrame (self, new_value):
        """Add the value as another occurrence of the {http://www.opengis.net/gml}referenceFrame element.  Raises
        BadValueTypeException if the new value is not consistent with the
        element's type."""
        return self.__referenceFrame.append(self, new_value)
    
    # Element identifier inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element domainOfValidity inherited from {http://www.opengis.net/gml}TimeReferenceSystemType
    
    # Element remarks inherited from {http://www.opengis.net/gml}DefinitionType
    
    # Attribute id inherited from {http://www.opengis.net/gml}DefinitionBaseType

    _ElementMap = TimeReferenceSystemType._ElementMap.copy()
    _ElementMap.update({
        __referenceFrame.name() : __referenceFrame
    })
    _AttributeMap = TimeReferenceSystemType._AttributeMap.copy()
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', u'TimeCalendarType', TimeCalendarType)


# Complex type TimeClockType with content type ELEMENT_ONLY
class TimeClockType (TimeReferenceSystemType):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'TimeClockType')
    # Base type is TimeReferenceSystemType
    
    # Element descriptionReference inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element description inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element metaDataProperty inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element domainOfValidity inherited from {http://www.opengis.net/gml}TimeReferenceSystemType
    
    # Element {http://www.opengis.net/gml}referenceTime uses Python identifier referenceTime
    __referenceTime = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'referenceTime'), 'referenceTime', '__TimeClockType_httpwww_opengis_netgmlreferenceTime', False)
    def referenceTime (self):
        """Get the value of the {http://www.opengis.net/gml}referenceTime element."""
        return self.__referenceTime.value(self)
    def setReferenceTime (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}referenceTime element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__referenceTime.set(self, new_value)
    
    # Element identifier inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element {http://www.opengis.net/gml}dateBasis uses Python identifier dateBasis
    __dateBasis = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'dateBasis'), 'dateBasis', '__TimeClockType_httpwww_opengis_netgmldateBasis', True)
    def dateBasis (self):
        """Get the value of the {http://www.opengis.net/gml}dateBasis element."""
        return self.__dateBasis.value(self)
    def setDateBasis (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}dateBasis element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__dateBasis.set(self, new_value)
    
    def addDateBasis (self, new_value):
        """Add the value as another occurrence of the {http://www.opengis.net/gml}dateBasis element.  Raises
        BadValueTypeException if the new value is not consistent with the
        element's type."""
        return self.__dateBasis.append(self, new_value)
    
    # Element name inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element {http://www.opengis.net/gml}referenceEvent uses Python identifier referenceEvent
    __referenceEvent = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'referenceEvent'), 'referenceEvent', '__TimeClockType_httpwww_opengis_netgmlreferenceEvent', False)
    def referenceEvent (self):
        """Get the value of the {http://www.opengis.net/gml}referenceEvent element."""
        return self.__referenceEvent.value(self)
    def setReferenceEvent (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}referenceEvent element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__referenceEvent.set(self, new_value)
    
    # Element remarks inherited from {http://www.opengis.net/gml}DefinitionType
    
    # Element {http://www.opengis.net/gml}utcReference uses Python identifier utcReference
    __utcReference = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'utcReference'), 'utcReference', '__TimeClockType_httpwww_opengis_netgmlutcReference', False)
    def utcReference (self):
        """Get the value of the {http://www.opengis.net/gml}utcReference element."""
        return self.__utcReference.value(self)
    def setUtcReference (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}utcReference element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__utcReference.set(self, new_value)
    
    # Attribute id inherited from {http://www.opengis.net/gml}DefinitionBaseType

    _ElementMap = TimeReferenceSystemType._ElementMap.copy()
    _ElementMap.update({
        __referenceTime.name() : __referenceTime,
        __dateBasis.name() : __dateBasis,
        __referenceEvent.name() : __referenceEvent,
        __utcReference.name() : __utcReference
    })
    _AttributeMap = TimeReferenceSystemType._AttributeMap.copy()
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', u'TimeClockType', TimeClockType)


# Complex type TimeCoordinateSystemType with content type ELEMENT_ONLY
class TimeCoordinateSystemType (TimeReferenceSystemType):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'TimeCoordinateSystemType')
    # Base type is TimeReferenceSystemType
    
    # Element descriptionReference inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element {http://www.opengis.net/gml}originPosition uses Python identifier originPosition
    __originPosition = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'originPosition'), 'originPosition', '__TimeCoordinateSystemType_httpwww_opengis_netgmloriginPosition', False)
    def originPosition (self):
        """Get the value of the {http://www.opengis.net/gml}originPosition element."""
        return self.__originPosition.value(self)
    def setOriginPosition (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}originPosition element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__originPosition.set(self, new_value)
    
    # Element {http://www.opengis.net/gml}interval uses Python identifier interval
    __interval = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'interval'), 'interval', '__TimeCoordinateSystemType_httpwww_opengis_netgmlinterval', True)
    def interval (self):
        """Get the value of the {http://www.opengis.net/gml}interval element."""
        return self.__interval.value(self)
    def setInterval (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}interval element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__interval.set(self, new_value)
    
    def addInterval (self, new_value):
        """Add the value as another occurrence of the {http://www.opengis.net/gml}interval element.  Raises
        BadValueTypeException if the new value is not consistent with the
        element's type."""
        return self.__interval.append(self, new_value)
    
    # Element metaDataProperty inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element domainOfValidity inherited from {http://www.opengis.net/gml}TimeReferenceSystemType
    
    # Element identifier inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element {http://www.opengis.net/gml}origin uses Python identifier origin
    __origin = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'origin'), 'origin', '__TimeCoordinateSystemType_httpwww_opengis_netgmlorigin', False)
    def origin (self):
        """Get the value of the {http://www.opengis.net/gml}origin element."""
        return self.__origin.value(self)
    def setOrigin (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}origin element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__origin.set(self, new_value)
    
    # Element name inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element remarks inherited from {http://www.opengis.net/gml}DefinitionType
    
    # Element description inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Attribute id inherited from {http://www.opengis.net/gml}DefinitionBaseType

    _ElementMap = TimeReferenceSystemType._ElementMap.copy()
    _ElementMap.update({
        __originPosition.name() : __originPosition,
        __interval.name() : __interval,
        __origin.name() : __origin
    })
    _AttributeMap = TimeReferenceSystemType._AttributeMap.copy()
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', u'TimeCoordinateSystemType', TimeCoordinateSystemType)


# Complex type TimeEdgeType with content type ELEMENT_ONLY
class TimeEdgeType (AbstractTimeTopologyPrimitiveType):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'TimeEdgeType')
    # Base type is AbstractTimeTopologyPrimitiveType
    
    # Element {http://www.opengis.net/gml}start uses Python identifier start
    __start = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'start'), 'start', '__TimeEdgeType_httpwww_opengis_netgmlstart', False)
    def start (self):
        """Get the value of the {http://www.opengis.net/gml}start element."""
        return self.__start.value(self)
    def setStart (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}start element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__start.set(self, new_value)
    
    # Element descriptionReference inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element name inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element {http://www.opengis.net/gml}end uses Python identifier end
    __end = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'end'), 'end', '__TimeEdgeType_httpwww_opengis_netgmlend', False)
    def end (self):
        """Get the value of the {http://www.opengis.net/gml}end element."""
        return self.__end.value(self)
    def setEnd (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}end element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__end.set(self, new_value)
    
    # Element {http://www.opengis.net/gml}extent uses Python identifier extent
    __extent = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'extent'), 'extent', '__TimeEdgeType_httpwww_opengis_netgmlextent', False)
    def extent (self):
        """Get the value of the {http://www.opengis.net/gml}extent element."""
        return self.__extent.value(self)
    def setExtent (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}extent element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__extent.set(self, new_value)
    
    # Element identifier inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element description inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element complex inherited from {http://www.opengis.net/gml}AbstractTimeTopologyPrimitiveType
    
    # Element metaDataProperty inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element relatedTime inherited from {http://www.opengis.net/gml}AbstractTimePrimitiveType
    
    # Attribute id inherited from {http://www.opengis.net/gml}AbstractGMLType

    _ElementMap = AbstractTimeTopologyPrimitiveType._ElementMap.copy()
    _ElementMap.update({
        __start.name() : __start,
        __end.name() : __end,
        __extent.name() : __extent
    })
    _AttributeMap = AbstractTimeTopologyPrimitiveType._AttributeMap.copy()
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', u'TimeEdgeType', TimeEdgeType)


# Complex type TimeInstantType with content type ELEMENT_ONLY
class TimeInstantType (AbstractTimeGeometricPrimitiveType):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'TimeInstantType')
    # Base type is AbstractTimeGeometricPrimitiveType
    
    # Element descriptionReference inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element {http://www.opengis.net/gml}timePosition uses Python identifier timePosition
    __timePosition = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'timePosition'), 'timePosition', '__TimeInstantType_httpwww_opengis_netgmltimePosition', False)
    def timePosition (self):
        """Get the value of the {http://www.opengis.net/gml}timePosition element."""
        return self.__timePosition.value(self)
    def setTimePosition (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}timePosition element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__timePosition.set(self, new_value)
    
    # Element description inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element identifier inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element name inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element metaDataProperty inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element relatedTime inherited from {http://www.opengis.net/gml}AbstractTimePrimitiveType
    
    # Attribute frame inherited from {http://www.opengis.net/gml}AbstractTimeGeometricPrimitiveType
    
    # Attribute id inherited from {http://www.opengis.net/gml}AbstractGMLType

    _ElementMap = AbstractTimeGeometricPrimitiveType._ElementMap.copy()
    _ElementMap.update({
        __timePosition.name() : __timePosition
    })
    _AttributeMap = AbstractTimeGeometricPrimitiveType._AttributeMap.copy()
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', u'TimeInstantType', TimeInstantType)


# Complex type TimeNodeType with content type ELEMENT_ONLY
class TimeNodeType (AbstractTimeTopologyPrimitiveType):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'TimeNodeType')
    # Base type is AbstractTimeTopologyPrimitiveType
    
    # Element descriptionReference inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element {http://www.opengis.net/gml}nextEdge uses Python identifier nextEdge
    __nextEdge = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'nextEdge'), 'nextEdge', '__TimeNodeType_httpwww_opengis_netgmlnextEdge', True)
    def nextEdge (self):
        """Get the value of the {http://www.opengis.net/gml}nextEdge element."""
        return self.__nextEdge.value(self)
    def setNextEdge (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}nextEdge element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__nextEdge.set(self, new_value)
    
    def addNextEdge (self, new_value):
        """Add the value as another occurrence of the {http://www.opengis.net/gml}nextEdge element.  Raises
        BadValueTypeException if the new value is not consistent with the
        element's type."""
        return self.__nextEdge.append(self, new_value)
    
    # Element name inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element {http://www.opengis.net/gml}previousEdge uses Python identifier previousEdge
    __previousEdge = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'previousEdge'), 'previousEdge', '__TimeNodeType_httpwww_opengis_netgmlpreviousEdge', True)
    def previousEdge (self):
        """Get the value of the {http://www.opengis.net/gml}previousEdge element."""
        return self.__previousEdge.value(self)
    def setPreviousEdge (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}previousEdge element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__previousEdge.set(self, new_value)
    
    def addPreviousEdge (self, new_value):
        """Add the value as another occurrence of the {http://www.opengis.net/gml}previousEdge element.  Raises
        BadValueTypeException if the new value is not consistent with the
        element's type."""
        return self.__previousEdge.append(self, new_value)
    
    # Element identifier inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element {http://www.opengis.net/gml}position uses Python identifier position
    __position = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'position'), 'position', '__TimeNodeType_httpwww_opengis_netgmlposition', False)
    def position (self):
        """Get the value of the {http://www.opengis.net/gml}position element."""
        return self.__position.value(self)
    def setPosition (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}position element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__position.set(self, new_value)
    
    # Element description inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element complex inherited from {http://www.opengis.net/gml}AbstractTimeTopologyPrimitiveType
    
    # Element metaDataProperty inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element relatedTime inherited from {http://www.opengis.net/gml}AbstractTimePrimitiveType
    
    # Attribute id inherited from {http://www.opengis.net/gml}AbstractGMLType

    _ElementMap = AbstractTimeTopologyPrimitiveType._ElementMap.copy()
    _ElementMap.update({
        __nextEdge.name() : __nextEdge,
        __previousEdge.name() : __previousEdge,
        __position.name() : __position
    })
    _AttributeMap = AbstractTimeTopologyPrimitiveType._AttributeMap.copy()
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', u'TimeNodeType', TimeNodeType)


# Complex type TimeOrdinalReferenceSystemType with content type ELEMENT_ONLY
class TimeOrdinalReferenceSystemType (TimeReferenceSystemType):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'TimeOrdinalReferenceSystemType')
    # Base type is TimeReferenceSystemType
    
    # Element descriptionReference inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element metaDataProperty inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element name inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element domainOfValidity inherited from {http://www.opengis.net/gml}TimeReferenceSystemType
    
    # Element identifier inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element description inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element remarks inherited from {http://www.opengis.net/gml}DefinitionType
    
    # Element {http://www.opengis.net/gml}component uses Python identifier component
    __component = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'component'), 'component', '__TimeOrdinalReferenceSystemType_httpwww_opengis_netgmlcomponent', True)
    def component (self):
        """Get the value of the {http://www.opengis.net/gml}component element."""
        return self.__component.value(self)
    def setComponent (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}component element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__component.set(self, new_value)
    
    def addComponent (self, new_value):
        """Add the value as another occurrence of the {http://www.opengis.net/gml}component element.  Raises
        BadValueTypeException if the new value is not consistent with the
        element's type."""
        return self.__component.append(self, new_value)
    
    # Attribute id inherited from {http://www.opengis.net/gml}DefinitionBaseType

    _ElementMap = TimeReferenceSystemType._ElementMap.copy()
    _ElementMap.update({
        __component.name() : __component
    })
    _AttributeMap = TimeReferenceSystemType._AttributeMap.copy()
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', u'TimeOrdinalReferenceSystemType', TimeOrdinalReferenceSystemType)


# Complex type TimePeriodType with content type ELEMENT_ONLY
class TimePeriodType (AbstractTimeGeometricPrimitiveType):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'TimePeriodType')
    # Base type is AbstractTimeGeometricPrimitiveType
    
    # Element descriptionReference inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element {http://www.opengis.net/gml}endPosition uses Python identifier endPosition
    __endPosition = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'endPosition'), 'endPosition', '__TimePeriodType_httpwww_opengis_netgmlendPosition', True)
    def endPosition (self):
        """Get the value of the {http://www.opengis.net/gml}endPosition element."""
        return self.__endPosition.value(self)
    def setEndPosition (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}endPosition element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__endPosition.set(self, new_value)
    
    def addEndPosition (self, new_value):
        """Add the value as another occurrence of the {http://www.opengis.net/gml}endPosition element.  Raises
        BadValueTypeException if the new value is not consistent with the
        element's type."""
        return self.__endPosition.append(self, new_value)
    
    # Element name inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element {http://www.opengis.net/gml}end uses Python identifier end
    __end = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'end'), 'end', '__TimePeriodType_httpwww_opengis_netgmlend', True)
    def end (self):
        """Get the value of the {http://www.opengis.net/gml}end element."""
        return self.__end.value(self)
    def setEnd (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}end element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__end.set(self, new_value)
    
    def addEnd (self, new_value):
        """Add the value as another occurrence of the {http://www.opengis.net/gml}end element.  Raises
        BadValueTypeException if the new value is not consistent with the
        element's type."""
        return self.__end.append(self, new_value)
    
    # Element {http://www.opengis.net/gml}beginPosition uses Python identifier beginPosition
    __beginPosition = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'beginPosition'), 'beginPosition', '__TimePeriodType_httpwww_opengis_netgmlbeginPosition', True)
    def beginPosition (self):
        """Get the value of the {http://www.opengis.net/gml}beginPosition element."""
        return self.__beginPosition.value(self)
    def setBeginPosition (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}beginPosition element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__beginPosition.set(self, new_value)
    
    def addBeginPosition (self, new_value):
        """Add the value as another occurrence of the {http://www.opengis.net/gml}beginPosition element.  Raises
        BadValueTypeException if the new value is not consistent with the
        element's type."""
        return self.__beginPosition.append(self, new_value)
    
    # Element {http://www.opengis.net/gml}begin uses Python identifier begin
    __begin = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'begin'), 'begin', '__TimePeriodType_httpwww_opengis_netgmlbegin', True)
    def begin (self):
        """Get the value of the {http://www.opengis.net/gml}begin element."""
        return self.__begin.value(self)
    def setBegin (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}begin element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__begin.set(self, new_value)
    
    def addBegin (self, new_value):
        """Add the value as another occurrence of the {http://www.opengis.net/gml}begin element.  Raises
        BadValueTypeException if the new value is not consistent with the
        element's type."""
        return self.__begin.append(self, new_value)
    
    # Element identifier inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element {http://www.opengis.net/gml}timeInterval uses Python identifier timeInterval
    __timeInterval = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'timeInterval'), 'timeInterval', '__TimePeriodType_httpwww_opengis_netgmltimeInterval', True)
    def timeInterval (self):
        """Get the value of the {http://www.opengis.net/gml}timeInterval element."""
        return self.__timeInterval.value(self)
    def setTimeInterval (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}timeInterval element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__timeInterval.set(self, new_value)
    
    def addTimeInterval (self, new_value):
        """Add the value as another occurrence of the {http://www.opengis.net/gml}timeInterval element.  Raises
        BadValueTypeException if the new value is not consistent with the
        element's type."""
        return self.__timeInterval.append(self, new_value)
    
    # Element {http://www.opengis.net/gml}duration uses Python identifier duration
    __duration = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'duration'), 'duration', '__TimePeriodType_httpwww_opengis_netgmlduration', True)
    def duration (self):
        """Get the value of the {http://www.opengis.net/gml}duration element."""
        return self.__duration.value(self)
    def setDuration (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}duration element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__duration.set(self, new_value)
    
    def addDuration (self, new_value):
        """Add the value as another occurrence of the {http://www.opengis.net/gml}duration element.  Raises
        BadValueTypeException if the new value is not consistent with the
        element's type."""
        return self.__duration.append(self, new_value)
    
    # Element description inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element metaDataProperty inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element relatedTime inherited from {http://www.opengis.net/gml}AbstractTimePrimitiveType
    
    # Attribute frame inherited from {http://www.opengis.net/gml}AbstractTimeGeometricPrimitiveType
    
    # Attribute id inherited from {http://www.opengis.net/gml}AbstractGMLType

    _ElementMap = AbstractTimeGeometricPrimitiveType._ElementMap.copy()
    _ElementMap.update({
        __endPosition.name() : __endPosition,
        __end.name() : __end,
        __beginPosition.name() : __beginPosition,
        __begin.name() : __begin,
        __timeInterval.name() : __timeInterval,
        __duration.name() : __duration
    })
    _AttributeMap = AbstractTimeGeometricPrimitiveType._AttributeMap.copy()
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', u'TimePeriodType', TimePeriodType)


# Complex type AbstractGeneralConversionType with content type ELEMENT_ONLY
class AbstractGeneralConversionType (AbstractCoordinateOperationType):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = True
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'AbstractGeneralConversionType')
    # Base type is AbstractCoordinateOperationType
    
    # Element descriptionReference inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element metaDataProperty inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element name inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element domainOfValidity inherited from {http://www.opengis.net/gml}AbstractCoordinateOperationType
    
    # Element identifier inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element coordinateOperationAccuracy inherited from {http://www.opengis.net/gml}AbstractCoordinateOperationType
    
    # Element scope inherited from {http://www.opengis.net/gml}AbstractCoordinateOperationType
    
    # Element description inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element remarks inherited from {http://www.opengis.net/gml}DefinitionType
    
    # Attribute {http://www.opengis.net/gml}id uses Python identifier id
    __id = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(Namespace, u'id'), 'id', '__AbstractGeneralConversionType_httpwww_opengis_netgmlid', pyxb.binding.datatypes.ID, required=True)
    def id (self):
        """Get the attribute value for {http://www.opengis.net/gml}id."""
        return self.__id.value(self)
    def setId (self, new_value):
        """Set the attribute value for {http://www.opengis.net/gml}id.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__id.set(self, new_value)

    _ElementMap = AbstractCoordinateOperationType._ElementMap.copy()
    _ElementMap.update({
        
    })
    _AttributeMap = AbstractCoordinateOperationType._AttributeMap.copy()
    _AttributeMap.update({
        __id.name() : __id
    })
Namespace.addCategoryObject('typeBinding', u'AbstractGeneralConversionType', AbstractGeneralConversionType)


# Complex type AbstractGeneralDerivedCRSType with content type ELEMENT_ONLY
class AbstractGeneralDerivedCRSType (AbstractCRSType):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = True
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'AbstractGeneralDerivedCRSType')
    # Base type is AbstractCRSType
    
    # Element descriptionReference inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element metaDataProperty inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element name inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element {http://www.opengis.net/gml}conversion uses Python identifier conversion
    __conversion = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'conversion'), 'conversion', '__AbstractGeneralDerivedCRSType_httpwww_opengis_netgmlconversion', False)
    def conversion (self):
        """Get the value of the {http://www.opengis.net/gml}conversion element."""
        return self.__conversion.value(self)
    def setConversion (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}conversion element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__conversion.set(self, new_value)
    
    # Element identifier inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element domainOfValidity inherited from {http://www.opengis.net/gml}AbstractCRSType
    
    # Element scope inherited from {http://www.opengis.net/gml}AbstractCRSType
    
    # Element description inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element remarks inherited from {http://www.opengis.net/gml}DefinitionType
    
    # Attribute id inherited from {http://www.opengis.net/gml}DefinitionBaseType

    _ElementMap = AbstractCRSType._ElementMap.copy()
    _ElementMap.update({
        __conversion.name() : __conversion
    })
    _AttributeMap = AbstractCRSType._AttributeMap.copy()
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', u'AbstractGeneralDerivedCRSType', AbstractGeneralDerivedCRSType)


# Complex type AbstractGeneralTransformationType with content type ELEMENT_ONLY
class AbstractGeneralTransformationType (AbstractCoordinateOperationType):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = True
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'AbstractGeneralTransformationType')
    # Base type is AbstractCoordinateOperationType
    
    # Element descriptionReference inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element operationVersion inherited from {http://www.opengis.net/gml}AbstractCoordinateOperationType
    
    # Element metaDataProperty inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element name inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element targetCRS inherited from {http://www.opengis.net/gml}AbstractCoordinateOperationType
    
    # Element domainOfValidity inherited from {http://www.opengis.net/gml}AbstractCoordinateOperationType
    
    # Element identifier inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element coordinateOperationAccuracy inherited from {http://www.opengis.net/gml}AbstractCoordinateOperationType
    
    # Element sourceCRS inherited from {http://www.opengis.net/gml}AbstractCoordinateOperationType
    
    # Element scope inherited from {http://www.opengis.net/gml}AbstractCoordinateOperationType
    
    # Element description inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element remarks inherited from {http://www.opengis.net/gml}DefinitionType
    
    # Attribute {http://www.opengis.net/gml}id uses Python identifier id
    __id = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(Namespace, u'id'), 'id', '__AbstractGeneralTransformationType_httpwww_opengis_netgmlid', pyxb.binding.datatypes.ID, required=True)
    def id (self):
        """Get the attribute value for {http://www.opengis.net/gml}id."""
        return self.__id.value(self)
    def setId (self, new_value):
        """Set the attribute value for {http://www.opengis.net/gml}id.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__id.set(self, new_value)

    _ElementMap = AbstractCoordinateOperationType._ElementMap.copy()
    _ElementMap.update({
        
    })
    _AttributeMap = AbstractCoordinateOperationType._AttributeMap.copy()
    _AttributeMap.update({
        __id.name() : __id
    })
Namespace.addCategoryObject('typeBinding', u'AbstractGeneralTransformationType', AbstractGeneralTransformationType)


# Complex type AffineCSType with content type ELEMENT_ONLY
class AffineCSType (AbstractCoordinateSystemType):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'AffineCSType')
    # Base type is AbstractCoordinateSystemType
    
    # Element descriptionReference inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element metaDataProperty inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element name inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element axis inherited from {http://www.opengis.net/gml}AbstractCoordinateSystemType
    
    # Element identifier inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element description inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element remarks inherited from {http://www.opengis.net/gml}DefinitionType
    
    # Attribute aggregationType inherited from {http://www.opengis.net/gml}AbstractCoordinateSystemType
    
    # Attribute id inherited from {http://www.opengis.net/gml}DefinitionBaseType

    _ElementMap = AbstractCoordinateSystemType._ElementMap.copy()
    _ElementMap.update({
        
    })
    _AttributeMap = AbstractCoordinateSystemType._AttributeMap.copy()
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', u'AffineCSType', AffineCSType)


# Complex type CartesianCSType with content type ELEMENT_ONLY
class CartesianCSType (AbstractCoordinateSystemType):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'CartesianCSType')
    # Base type is AbstractCoordinateSystemType
    
    # Element descriptionReference inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element metaDataProperty inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element name inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element axis inherited from {http://www.opengis.net/gml}AbstractCoordinateSystemType
    
    # Element identifier inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element description inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element remarks inherited from {http://www.opengis.net/gml}DefinitionType
    
    # Attribute aggregationType inherited from {http://www.opengis.net/gml}AbstractCoordinateSystemType
    
    # Attribute id inherited from {http://www.opengis.net/gml}DefinitionBaseType

    _ElementMap = AbstractCoordinateSystemType._ElementMap.copy()
    _ElementMap.update({
        
    })
    _AttributeMap = AbstractCoordinateSystemType._AttributeMap.copy()
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', u'CartesianCSType', CartesianCSType)


# Complex type CompoundCRSType with content type ELEMENT_ONLY
class CompoundCRSType (AbstractCRSType):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'CompoundCRSType')
    # Base type is AbstractCRSType
    
    # Element descriptionReference inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element metaDataProperty inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element name inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element {http://www.opengis.net/gml}componentReferenceSystem uses Python identifier componentReferenceSystem
    __componentReferenceSystem = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'componentReferenceSystem'), 'componentReferenceSystem', '__CompoundCRSType_httpwww_opengis_netgmlcomponentReferenceSystem', True)
    def componentReferenceSystem (self):
        """Get the value of the {http://www.opengis.net/gml}componentReferenceSystem element."""
        return self.__componentReferenceSystem.value(self)
    def setComponentReferenceSystem (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}componentReferenceSystem element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__componentReferenceSystem.set(self, new_value)
    
    def addComponentReferenceSystem (self, new_value):
        """Add the value as another occurrence of the {http://www.opengis.net/gml}componentReferenceSystem element.  Raises
        BadValueTypeException if the new value is not consistent with the
        element's type."""
        return self.__componentReferenceSystem.append(self, new_value)
    
    # Element domainOfValidity inherited from {http://www.opengis.net/gml}AbstractCRSType
    
    # Element identifier inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element scope inherited from {http://www.opengis.net/gml}AbstractCRSType
    
    # Element description inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element remarks inherited from {http://www.opengis.net/gml}DefinitionType
    
    # Attribute aggregationType uses Python identifier aggregationType
    __aggregationType = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'aggregationType'), 'aggregationType', '__CompoundCRSType_aggregationType', AggregationType)
    def aggregationType (self):
        """Get the attribute value for aggregationType."""
        return self.__aggregationType.value(self)
    def setAggregationType (self, new_value):
        """Set the attribute value for aggregationType.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__aggregationType.set(self, new_value)
    
    # Attribute id inherited from {http://www.opengis.net/gml}DefinitionBaseType

    _ElementMap = AbstractCRSType._ElementMap.copy()
    _ElementMap.update({
        __componentReferenceSystem.name() : __componentReferenceSystem
    })
    _AttributeMap = AbstractCRSType._AttributeMap.copy()
    _AttributeMap.update({
        __aggregationType.name() : __aggregationType
    })
Namespace.addCategoryObject('typeBinding', u'CompoundCRSType', CompoundCRSType)


# Complex type ConcatenatedOperationType with content type ELEMENT_ONLY
class ConcatenatedOperationType (AbstractCoordinateOperationType):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'ConcatenatedOperationType')
    # Base type is AbstractCoordinateOperationType
    
    # Element descriptionReference inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element operationVersion inherited from {http://www.opengis.net/gml}AbstractCoordinateOperationType
    
    # Element metaDataProperty inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element domainOfValidity inherited from {http://www.opengis.net/gml}AbstractCoordinateOperationType
    
    # Element targetCRS inherited from {http://www.opengis.net/gml}AbstractCoordinateOperationType
    
    # Element {http://www.opengis.net/gml}coordOperation uses Python identifier coordOperation
    __coordOperation = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'coordOperation'), 'coordOperation', '__ConcatenatedOperationType_httpwww_opengis_netgmlcoordOperation', True)
    def coordOperation (self):
        """Get the value of the {http://www.opengis.net/gml}coordOperation element."""
        return self.__coordOperation.value(self)
    def setCoordOperation (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}coordOperation element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__coordOperation.set(self, new_value)
    
    def addCoordOperation (self, new_value):
        """Add the value as another occurrence of the {http://www.opengis.net/gml}coordOperation element.  Raises
        BadValueTypeException if the new value is not consistent with the
        element's type."""
        return self.__coordOperation.append(self, new_value)
    
    # Element identifier inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element description inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element coordinateOperationAccuracy inherited from {http://www.opengis.net/gml}AbstractCoordinateOperationType
    
    # Element sourceCRS inherited from {http://www.opengis.net/gml}AbstractCoordinateOperationType
    
    # Element scope inherited from {http://www.opengis.net/gml}AbstractCoordinateOperationType
    
    # Element name inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element remarks inherited from {http://www.opengis.net/gml}DefinitionType
    
    # Attribute aggregationType uses Python identifier aggregationType
    __aggregationType = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'aggregationType'), 'aggregationType', '__ConcatenatedOperationType_aggregationType', AggregationType)
    def aggregationType (self):
        """Get the attribute value for aggregationType."""
        return self.__aggregationType.value(self)
    def setAggregationType (self, new_value):
        """Set the attribute value for aggregationType.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__aggregationType.set(self, new_value)
    
    # Attribute id inherited from {http://www.opengis.net/gml}DefinitionBaseType

    _ElementMap = AbstractCoordinateOperationType._ElementMap.copy()
    _ElementMap.update({
        __coordOperation.name() : __coordOperation
    })
    _AttributeMap = AbstractCoordinateOperationType._AttributeMap.copy()
    _AttributeMap.update({
        __aggregationType.name() : __aggregationType
    })
Namespace.addCategoryObject('typeBinding', u'ConcatenatedOperationType', ConcatenatedOperationType)


# Complex type CylindricalCSType with content type ELEMENT_ONLY
class CylindricalCSType (AbstractCoordinateSystemType):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'CylindricalCSType')
    # Base type is AbstractCoordinateSystemType
    
    # Element descriptionReference inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element metaDataProperty inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element name inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element axis inherited from {http://www.opengis.net/gml}AbstractCoordinateSystemType
    
    # Element identifier inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element description inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element remarks inherited from {http://www.opengis.net/gml}DefinitionType
    
    # Attribute aggregationType inherited from {http://www.opengis.net/gml}AbstractCoordinateSystemType
    
    # Attribute id inherited from {http://www.opengis.net/gml}DefinitionBaseType

    _ElementMap = AbstractCoordinateSystemType._ElementMap.copy()
    _ElementMap.update({
        
    })
    _AttributeMap = AbstractCoordinateSystemType._AttributeMap.copy()
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', u'CylindricalCSType', CylindricalCSType)


# Complex type EllipsoidalCSType with content type ELEMENT_ONLY
class EllipsoidalCSType (AbstractCoordinateSystemType):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'EllipsoidalCSType')
    # Base type is AbstractCoordinateSystemType
    
    # Element descriptionReference inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element metaDataProperty inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element name inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element axis inherited from {http://www.opengis.net/gml}AbstractCoordinateSystemType
    
    # Element identifier inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element description inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element remarks inherited from {http://www.opengis.net/gml}DefinitionType
    
    # Attribute aggregationType inherited from {http://www.opengis.net/gml}AbstractCoordinateSystemType
    
    # Attribute id inherited from {http://www.opengis.net/gml}DefinitionBaseType

    _ElementMap = AbstractCoordinateSystemType._ElementMap.copy()
    _ElementMap.update({
        
    })
    _AttributeMap = AbstractCoordinateSystemType._AttributeMap.copy()
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', u'EllipsoidalCSType', EllipsoidalCSType)


# Complex type EngineeringCRSType with content type ELEMENT_ONLY
class EngineeringCRSType (AbstractCRSType):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'EngineeringCRSType')
    # Base type is AbstractCRSType
    
    # Element descriptionReference inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element metaDataProperty inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element name inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element domainOfValidity inherited from {http://www.opengis.net/gml}AbstractCRSType
    
    # Element identifier inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element scope inherited from {http://www.opengis.net/gml}AbstractCRSType
    
    # Element description inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element remarks inherited from {http://www.opengis.net/gml}DefinitionType
    
    # Element {http://www.opengis.net/gml}coordinateSystem uses Python identifier coordinateSystem
    __coordinateSystem = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'coordinateSystem'), 'coordinateSystem', '__EngineeringCRSType_httpwww_opengis_netgmlcoordinateSystem', False)
    def coordinateSystem (self):
        """Get the value of the {http://www.opengis.net/gml}coordinateSystem element."""
        return self.__coordinateSystem.value(self)
    def setCoordinateSystem (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}coordinateSystem element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__coordinateSystem.set(self, new_value)
    
    # Element {http://www.opengis.net/gml}engineeringDatum uses Python identifier engineeringDatum
    __engineeringDatum = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'engineeringDatum'), 'engineeringDatum', '__EngineeringCRSType_httpwww_opengis_netgmlengineeringDatum', False)
    def engineeringDatum (self):
        """Get the value of the {http://www.opengis.net/gml}engineeringDatum element."""
        return self.__engineeringDatum.value(self)
    def setEngineeringDatum (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}engineeringDatum element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__engineeringDatum.set(self, new_value)
    
    # Attribute id inherited from {http://www.opengis.net/gml}DefinitionBaseType

    _ElementMap = AbstractCRSType._ElementMap.copy()
    _ElementMap.update({
        __coordinateSystem.name() : __coordinateSystem,
        __engineeringDatum.name() : __engineeringDatum
    })
    _AttributeMap = AbstractCRSType._AttributeMap.copy()
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', u'EngineeringCRSType', EngineeringCRSType)


# Complex type EngineeringDatumType with content type ELEMENT_ONLY
class EngineeringDatumType (AbstractDatumType):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'EngineeringDatumType')
    # Base type is AbstractDatumType
    
    # Element descriptionReference inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element description inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element realizationEpoch inherited from {http://www.opengis.net/gml}AbstractDatumType
    
    # Element metaDataProperty inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element name inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element identifier inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element scope inherited from {http://www.opengis.net/gml}AbstractDatumType
    
    # Element domainOfValidity inherited from {http://www.opengis.net/gml}AbstractDatumType
    
    # Element remarks inherited from {http://www.opengis.net/gml}DefinitionType
    
    # Element anchorDefinition inherited from {http://www.opengis.net/gml}AbstractDatumType
    
    # Attribute id inherited from {http://www.opengis.net/gml}DefinitionBaseType

    _ElementMap = AbstractDatumType._ElementMap.copy()
    _ElementMap.update({
        
    })
    _AttributeMap = AbstractDatumType._AttributeMap.copy()
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', u'EngineeringDatumType', EngineeringDatumType)


# Complex type GeocentricCRSType with content type ELEMENT_ONLY
class GeocentricCRSType (AbstractCRSType):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'GeocentricCRSType')
    # Base type is AbstractCRSType
    
    # Element descriptionReference inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element {http://www.opengis.net/gml}usesGeodeticDatum uses Python identifier usesGeodeticDatum
    __usesGeodeticDatum = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'usesGeodeticDatum'), 'usesGeodeticDatum', '__GeocentricCRSType_httpwww_opengis_netgmlusesGeodeticDatum', True)
    def usesGeodeticDatum (self):
        """Get the value of the {http://www.opengis.net/gml}usesGeodeticDatum element."""
        return self.__usesGeodeticDatum.value(self)
    def setUsesGeodeticDatum (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}usesGeodeticDatum element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__usesGeodeticDatum.set(self, new_value)
    
    def addUsesGeodeticDatum (self, new_value):
        """Add the value as another occurrence of the {http://www.opengis.net/gml}usesGeodeticDatum element.  Raises
        BadValueTypeException if the new value is not consistent with the
        element's type."""
        return self.__usesGeodeticDatum.append(self, new_value)
    
    # Element metaDataProperty inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element description inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element {http://www.opengis.net/gml}usesSphericalCS uses Python identifier usesSphericalCS
    __usesSphericalCS = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'usesSphericalCS'), 'usesSphericalCS', '__GeocentricCRSType_httpwww_opengis_netgmlusesSphericalCS', False)
    def usesSphericalCS (self):
        """Get the value of the {http://www.opengis.net/gml}usesSphericalCS element."""
        return self.__usesSphericalCS.value(self)
    def setUsesSphericalCS (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}usesSphericalCS element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__usesSphericalCS.set(self, new_value)
    
    # Element {http://www.opengis.net/gml}usesCartesianCS uses Python identifier usesCartesianCS
    __usesCartesianCS = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'usesCartesianCS'), 'usesCartesianCS', '__GeocentricCRSType_httpwww_opengis_netgmlusesCartesianCS', False)
    def usesCartesianCS (self):
        """Get the value of the {http://www.opengis.net/gml}usesCartesianCS element."""
        return self.__usesCartesianCS.value(self)
    def setUsesCartesianCS (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}usesCartesianCS element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__usesCartesianCS.set(self, new_value)
    
    # Element identifier inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element domainOfValidity inherited from {http://www.opengis.net/gml}AbstractCRSType
    
    # Element scope inherited from {http://www.opengis.net/gml}AbstractCRSType
    
    # Element name inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element remarks inherited from {http://www.opengis.net/gml}DefinitionType
    
    # Attribute id inherited from {http://www.opengis.net/gml}DefinitionBaseType

    _ElementMap = AbstractCRSType._ElementMap.copy()
    _ElementMap.update({
        __usesGeodeticDatum.name() : __usesGeodeticDatum,
        __usesSphericalCS.name() : __usesSphericalCS,
        __usesCartesianCS.name() : __usesCartesianCS
    })
    _AttributeMap = AbstractCRSType._AttributeMap.copy()
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', u'GeocentricCRSType', GeocentricCRSType)


# Complex type GeodeticCRSType with content type ELEMENT_ONLY
class GeodeticCRSType (AbstractCRSType):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'GeodeticCRSType')
    # Base type is AbstractCRSType
    
    # Element descriptionReference inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element metaDataProperty inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element {http://www.opengis.net/gml}sphericalCS uses Python identifier sphericalCS
    __sphericalCS = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'sphericalCS'), 'sphericalCS', '__GeodeticCRSType_httpwww_opengis_netgmlsphericalCS', False)
    def sphericalCS (self):
        """Get the value of the {http://www.opengis.net/gml}sphericalCS element."""
        return self.__sphericalCS.value(self)
    def setSphericalCS (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}sphericalCS element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__sphericalCS.set(self, new_value)
    
    # Element name inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element {http://www.opengis.net/gml}geodeticDatum uses Python identifier geodeticDatum
    __geodeticDatum = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'geodeticDatum'), 'geodeticDatum', '__GeodeticCRSType_httpwww_opengis_netgmlgeodeticDatum', True)
    def geodeticDatum (self):
        """Get the value of the {http://www.opengis.net/gml}geodeticDatum element."""
        return self.__geodeticDatum.value(self)
    def setGeodeticDatum (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}geodeticDatum element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__geodeticDatum.set(self, new_value)
    
    def addGeodeticDatum (self, new_value):
        """Add the value as another occurrence of the {http://www.opengis.net/gml}geodeticDatum element.  Raises
        BadValueTypeException if the new value is not consistent with the
        element's type."""
        return self.__geodeticDatum.append(self, new_value)
    
    # Element {http://www.opengis.net/gml}ellipsoidalCS uses Python identifier ellipsoidalCS
    __ellipsoidalCS = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'ellipsoidalCS'), 'ellipsoidalCS', '__GeodeticCRSType_httpwww_opengis_netgmlellipsoidalCS', False)
    def ellipsoidalCS (self):
        """Get the value of the {http://www.opengis.net/gml}ellipsoidalCS element."""
        return self.__ellipsoidalCS.value(self)
    def setEllipsoidalCS (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}ellipsoidalCS element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__ellipsoidalCS.set(self, new_value)
    
    # Element domainOfValidity inherited from {http://www.opengis.net/gml}AbstractCRSType
    
    # Element identifier inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element {http://www.opengis.net/gml}cartesianCS uses Python identifier cartesianCS
    __cartesianCS = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'cartesianCS'), 'cartesianCS', '__GeodeticCRSType_httpwww_opengis_netgmlcartesianCS', False)
    def cartesianCS (self):
        """Get the value of the {http://www.opengis.net/gml}cartesianCS element."""
        return self.__cartesianCS.value(self)
    def setCartesianCS (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}cartesianCS element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__cartesianCS.set(self, new_value)
    
    # Element scope inherited from {http://www.opengis.net/gml}AbstractCRSType
    
    # Element description inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element remarks inherited from {http://www.opengis.net/gml}DefinitionType
    
    # Attribute id inherited from {http://www.opengis.net/gml}DefinitionBaseType

    _ElementMap = AbstractCRSType._ElementMap.copy()
    _ElementMap.update({
        __sphericalCS.name() : __sphericalCS,
        __geodeticDatum.name() : __geodeticDatum,
        __ellipsoidalCS.name() : __ellipsoidalCS,
        __cartesianCS.name() : __cartesianCS
    })
    _AttributeMap = AbstractCRSType._AttributeMap.copy()
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', u'GeodeticCRSType', GeodeticCRSType)


# Complex type GeodeticDatumType with content type ELEMENT_ONLY
class GeodeticDatumType (AbstractDatumType):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'GeodeticDatumType')
    # Base type is AbstractDatumType
    
    # Element descriptionReference inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element {http://www.opengis.net/gml}primeMeridian uses Python identifier primeMeridian
    __primeMeridian = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'primeMeridian'), 'primeMeridian', '__GeodeticDatumType_httpwww_opengis_netgmlprimeMeridian', False)
    def primeMeridian (self):
        """Get the value of the {http://www.opengis.net/gml}primeMeridian element."""
        return self.__primeMeridian.value(self)
    def setPrimeMeridian (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}primeMeridian element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__primeMeridian.set(self, new_value)
    
    # Element realizationEpoch inherited from {http://www.opengis.net/gml}AbstractDatumType
    
    # Element metaDataProperty inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element domainOfValidity inherited from {http://www.opengis.net/gml}AbstractDatumType
    
    # Element {http://www.opengis.net/gml}ellipsoid uses Python identifier ellipsoid
    __ellipsoid = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'ellipsoid'), 'ellipsoid', '__GeodeticDatumType_httpwww_opengis_netgmlellipsoid', False)
    def ellipsoid (self):
        """Get the value of the {http://www.opengis.net/gml}ellipsoid element."""
        return self.__ellipsoid.value(self)
    def setEllipsoid (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}ellipsoid element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__ellipsoid.set(self, new_value)
    
    # Element identifier inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element description inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element scope inherited from {http://www.opengis.net/gml}AbstractDatumType
    
    # Element name inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element remarks inherited from {http://www.opengis.net/gml}DefinitionType
    
    # Element anchorDefinition inherited from {http://www.opengis.net/gml}AbstractDatumType
    
    # Attribute id inherited from {http://www.opengis.net/gml}DefinitionBaseType

    _ElementMap = AbstractDatumType._ElementMap.copy()
    _ElementMap.update({
        __primeMeridian.name() : __primeMeridian,
        __ellipsoid.name() : __ellipsoid
    })
    _AttributeMap = AbstractDatumType._AttributeMap.copy()
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', u'GeodeticDatumType', GeodeticDatumType)


# Complex type GeographicCRSType with content type ELEMENT_ONLY
class GeographicCRSType (AbstractCRSType):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'GeographicCRSType')
    # Base type is AbstractCRSType
    
    # Element descriptionReference inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element {http://www.opengis.net/gml}usesGeodeticDatum uses Python identifier usesGeodeticDatum
    __usesGeodeticDatum = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'usesGeodeticDatum'), 'usesGeodeticDatum', '__GeographicCRSType_httpwww_opengis_netgmlusesGeodeticDatum', False)
    def usesGeodeticDatum (self):
        """Get the value of the {http://www.opengis.net/gml}usesGeodeticDatum element."""
        return self.__usesGeodeticDatum.value(self)
    def setUsesGeodeticDatum (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}usesGeodeticDatum element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__usesGeodeticDatum.set(self, new_value)
    
    # Element metaDataProperty inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element description inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element {http://www.opengis.net/gml}usesEllipsoidalCS uses Python identifier usesEllipsoidalCS
    __usesEllipsoidalCS = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'usesEllipsoidalCS'), 'usesEllipsoidalCS', '__GeographicCRSType_httpwww_opengis_netgmlusesEllipsoidalCS', False)
    def usesEllipsoidalCS (self):
        """Get the value of the {http://www.opengis.net/gml}usesEllipsoidalCS element."""
        return self.__usesEllipsoidalCS.value(self)
    def setUsesEllipsoidalCS (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}usesEllipsoidalCS element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__usesEllipsoidalCS.set(self, new_value)
    
    # Element domainOfValidity inherited from {http://www.opengis.net/gml}AbstractCRSType
    
    # Element identifier inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element scope inherited from {http://www.opengis.net/gml}AbstractCRSType
    
    # Element name inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element remarks inherited from {http://www.opengis.net/gml}DefinitionType
    
    # Attribute id inherited from {http://www.opengis.net/gml}DefinitionBaseType

    _ElementMap = AbstractCRSType._ElementMap.copy()
    _ElementMap.update({
        __usesGeodeticDatum.name() : __usesGeodeticDatum,
        __usesEllipsoidalCS.name() : __usesEllipsoidalCS
    })
    _AttributeMap = AbstractCRSType._AttributeMap.copy()
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', u'GeographicCRSType', GeographicCRSType)


# Complex type ImageCRSType with content type ELEMENT_ONLY
class ImageCRSType (AbstractCRSType):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'ImageCRSType')
    # Base type is AbstractCRSType
    
    # Element descriptionReference inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element metaDataProperty inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element name inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element domainOfValidity inherited from {http://www.opengis.net/gml}AbstractCRSType
    
    # Element {http://www.opengis.net/gml}affineCS uses Python identifier affineCS
    __affineCS = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'affineCS'), 'affineCS', '__ImageCRSType_httpwww_opengis_netgmlaffineCS', False)
    def affineCS (self):
        """Get the value of the {http://www.opengis.net/gml}affineCS element."""
        return self.__affineCS.value(self)
    def setAffineCS (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}affineCS element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__affineCS.set(self, new_value)
    
    # Element {http://www.opengis.net/gml}imageDatum uses Python identifier imageDatum
    __imageDatum = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'imageDatum'), 'imageDatum', '__ImageCRSType_httpwww_opengis_netgmlimageDatum', True)
    def imageDatum (self):
        """Get the value of the {http://www.opengis.net/gml}imageDatum element."""
        return self.__imageDatum.value(self)
    def setImageDatum (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}imageDatum element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__imageDatum.set(self, new_value)
    
    def addImageDatum (self, new_value):
        """Add the value as another occurrence of the {http://www.opengis.net/gml}imageDatum element.  Raises
        BadValueTypeException if the new value is not consistent with the
        element's type."""
        return self.__imageDatum.append(self, new_value)
    
    # Element identifier inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element {http://www.opengis.net/gml}cartesianCS uses Python identifier cartesianCS
    __cartesianCS = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'cartesianCS'), 'cartesianCS', '__ImageCRSType_httpwww_opengis_netgmlcartesianCS', False)
    def cartesianCS (self):
        """Get the value of the {http://www.opengis.net/gml}cartesianCS element."""
        return self.__cartesianCS.value(self)
    def setCartesianCS (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}cartesianCS element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__cartesianCS.set(self, new_value)
    
    # Element scope inherited from {http://www.opengis.net/gml}AbstractCRSType
    
    # Element description inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element remarks inherited from {http://www.opengis.net/gml}DefinitionType
    
    # Element {http://www.opengis.net/gml}usesObliqueCartesianCS uses Python identifier usesObliqueCartesianCS
    __usesObliqueCartesianCS = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'usesObliqueCartesianCS'), 'usesObliqueCartesianCS', '__ImageCRSType_httpwww_opengis_netgmlusesObliqueCartesianCS', False)
    def usesObliqueCartesianCS (self):
        """Get the value of the {http://www.opengis.net/gml}usesObliqueCartesianCS element."""
        return self.__usesObliqueCartesianCS.value(self)
    def setUsesObliqueCartesianCS (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}usesObliqueCartesianCS element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__usesObliqueCartesianCS.set(self, new_value)
    
    # Attribute id inherited from {http://www.opengis.net/gml}DefinitionBaseType

    _ElementMap = AbstractCRSType._ElementMap.copy()
    _ElementMap.update({
        __affineCS.name() : __affineCS,
        __imageDatum.name() : __imageDatum,
        __cartesianCS.name() : __cartesianCS,
        __usesObliqueCartesianCS.name() : __usesObliqueCartesianCS
    })
    _AttributeMap = AbstractCRSType._AttributeMap.copy()
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', u'ImageCRSType', ImageCRSType)


# Complex type ImageDatumType with content type ELEMENT_ONLY
class ImageDatumType (AbstractDatumType):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'ImageDatumType')
    # Base type is AbstractDatumType
    
    # Element descriptionReference inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element description inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element realizationEpoch inherited from {http://www.opengis.net/gml}AbstractDatumType
    
    # Element metaDataProperty inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element name inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element {http://www.opengis.net/gml}pixelInCell uses Python identifier pixelInCell
    __pixelInCell = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'pixelInCell'), 'pixelInCell', '__ImageDatumType_httpwww_opengis_netgmlpixelInCell', False)
    def pixelInCell (self):
        """Get the value of the {http://www.opengis.net/gml}pixelInCell element."""
        return self.__pixelInCell.value(self)
    def setPixelInCell (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}pixelInCell element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__pixelInCell.set(self, new_value)
    
    # Element identifier inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element scope inherited from {http://www.opengis.net/gml}AbstractDatumType
    
    # Element domainOfValidity inherited from {http://www.opengis.net/gml}AbstractDatumType
    
    # Element remarks inherited from {http://www.opengis.net/gml}DefinitionType
    
    # Element anchorDefinition inherited from {http://www.opengis.net/gml}AbstractDatumType
    
    # Attribute id inherited from {http://www.opengis.net/gml}DefinitionBaseType

    _ElementMap = AbstractDatumType._ElementMap.copy()
    _ElementMap.update({
        __pixelInCell.name() : __pixelInCell
    })
    _AttributeMap = AbstractDatumType._AttributeMap.copy()
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', u'ImageDatumType', ImageDatumType)


# Complex type LinearCSType with content type ELEMENT_ONLY
class LinearCSType (AbstractCoordinateSystemType):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'LinearCSType')
    # Base type is AbstractCoordinateSystemType
    
    # Element descriptionReference inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element metaDataProperty inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element name inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element axis inherited from {http://www.opengis.net/gml}AbstractCoordinateSystemType
    
    # Element identifier inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element description inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element remarks inherited from {http://www.opengis.net/gml}DefinitionType
    
    # Attribute aggregationType inherited from {http://www.opengis.net/gml}AbstractCoordinateSystemType
    
    # Attribute id inherited from {http://www.opengis.net/gml}DefinitionBaseType

    _ElementMap = AbstractCoordinateSystemType._ElementMap.copy()
    _ElementMap.update({
        
    })
    _AttributeMap = AbstractCoordinateSystemType._AttributeMap.copy()
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', u'LinearCSType', LinearCSType)


# Complex type ObliqueCartesianCSType with content type ELEMENT_ONLY
class ObliqueCartesianCSType (AbstractCoordinateSystemType):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'ObliqueCartesianCSType')
    # Base type is AbstractCoordinateSystemType
    
    # Element descriptionReference inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element metaDataProperty inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element name inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element axis inherited from {http://www.opengis.net/gml}AbstractCoordinateSystemType
    
    # Element identifier inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element description inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element remarks inherited from {http://www.opengis.net/gml}DefinitionType
    
    # Attribute aggregationType inherited from {http://www.opengis.net/gml}AbstractCoordinateSystemType
    
    # Attribute id inherited from {http://www.opengis.net/gml}DefinitionBaseType

    _ElementMap = AbstractCoordinateSystemType._ElementMap.copy()
    _ElementMap.update({
        
    })
    _AttributeMap = AbstractCoordinateSystemType._AttributeMap.copy()
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', u'ObliqueCartesianCSType', ObliqueCartesianCSType)


# Complex type OperationParameterGroupType with content type ELEMENT_ONLY
class OperationParameterGroupType (AbstractGeneralOperationParameterType):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'OperationParameterGroupType')
    # Base type is AbstractGeneralOperationParameterType
    
    # Element descriptionReference inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element metaDataProperty inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element description inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element {http://www.opengis.net/gml}maximumOccurs uses Python identifier maximumOccurs
    __maximumOccurs = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'maximumOccurs'), 'maximumOccurs', '__OperationParameterGroupType_httpwww_opengis_netgmlmaximumOccurs', False)
    def maximumOccurs (self):
        """Get the value of the {http://www.opengis.net/gml}maximumOccurs element."""
        return self.__maximumOccurs.value(self)
    def setMaximumOccurs (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}maximumOccurs element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__maximumOccurs.set(self, new_value)
    
    # Element identifier inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element {http://www.opengis.net/gml}generalOperationParameter uses Python identifier generalOperationParameter
    __generalOperationParameter = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'generalOperationParameter'), 'generalOperationParameter', '__OperationParameterGroupType_httpwww_opengis_netgmlgeneralOperationParameter', True)
    def generalOperationParameter (self):
        """Get the value of the {http://www.opengis.net/gml}generalOperationParameter element."""
        return self.__generalOperationParameter.value(self)
    def setGeneralOperationParameter (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}generalOperationParameter element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__generalOperationParameter.set(self, new_value)
    
    def addGeneralOperationParameter (self, new_value):
        """Add the value as another occurrence of the {http://www.opengis.net/gml}generalOperationParameter element.  Raises
        BadValueTypeException if the new value is not consistent with the
        element's type."""
        return self.__generalOperationParameter.append(self, new_value)
    
    # Element name inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element remarks inherited from {http://www.opengis.net/gml}DefinitionType
    
    # Element minimumOccurs inherited from {http://www.opengis.net/gml}AbstractGeneralOperationParameterType
    
    # Attribute id inherited from {http://www.opengis.net/gml}DefinitionBaseType

    _ElementMap = AbstractGeneralOperationParameterType._ElementMap.copy()
    _ElementMap.update({
        __maximumOccurs.name() : __maximumOccurs,
        __generalOperationParameter.name() : __generalOperationParameter
    })
    _AttributeMap = AbstractGeneralOperationParameterType._AttributeMap.copy()
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', u'OperationParameterGroupType', OperationParameterGroupType)


# Complex type OperationParameterType with content type ELEMENT_ONLY
class OperationParameterType (AbstractGeneralOperationParameterType):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'OperationParameterType')
    # Base type is AbstractGeneralOperationParameterType
    
    # Element descriptionReference inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element metaDataProperty inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element name inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element identifier inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element description inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element remarks inherited from {http://www.opengis.net/gml}DefinitionType
    
    # Element minimumOccurs inherited from {http://www.opengis.net/gml}AbstractGeneralOperationParameterType
    
    # Attribute id inherited from {http://www.opengis.net/gml}DefinitionBaseType

    _ElementMap = AbstractGeneralOperationParameterType._ElementMap.copy()
    _ElementMap.update({
        
    })
    _AttributeMap = AbstractGeneralOperationParameterType._AttributeMap.copy()
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', u'OperationParameterType', OperationParameterType)


# Complex type PassThroughOperationType with content type ELEMENT_ONLY
class PassThroughOperationType (AbstractCoordinateOperationType):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'PassThroughOperationType')
    # Base type is AbstractCoordinateOperationType
    
    # Element descriptionReference inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element operationVersion inherited from {http://www.opengis.net/gml}AbstractCoordinateOperationType
    
    # Element metaDataProperty inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element domainOfValidity inherited from {http://www.opengis.net/gml}AbstractCoordinateOperationType
    
    # Element targetCRS inherited from {http://www.opengis.net/gml}AbstractCoordinateOperationType
    
    # Element {http://www.opengis.net/gml}coordOperation uses Python identifier coordOperation
    __coordOperation = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'coordOperation'), 'coordOperation', '__PassThroughOperationType_httpwww_opengis_netgmlcoordOperation', False)
    def coordOperation (self):
        """Get the value of the {http://www.opengis.net/gml}coordOperation element."""
        return self.__coordOperation.value(self)
    def setCoordOperation (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}coordOperation element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__coordOperation.set(self, new_value)
    
    # Element {http://www.opengis.net/gml}modifiedCoordinate uses Python identifier modifiedCoordinate
    __modifiedCoordinate = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'modifiedCoordinate'), 'modifiedCoordinate', '__PassThroughOperationType_httpwww_opengis_netgmlmodifiedCoordinate', True)
    def modifiedCoordinate (self):
        """Get the value of the {http://www.opengis.net/gml}modifiedCoordinate element."""
        return self.__modifiedCoordinate.value(self)
    def setModifiedCoordinate (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}modifiedCoordinate element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__modifiedCoordinate.set(self, new_value)
    
    def addModifiedCoordinate (self, new_value):
        """Add the value as another occurrence of the {http://www.opengis.net/gml}modifiedCoordinate element.  Raises
        BadValueTypeException if the new value is not consistent with the
        element's type."""
        return self.__modifiedCoordinate.append(self, new_value)
    
    # Element identifier inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element description inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element coordinateOperationAccuracy inherited from {http://www.opengis.net/gml}AbstractCoordinateOperationType
    
    # Element sourceCRS inherited from {http://www.opengis.net/gml}AbstractCoordinateOperationType
    
    # Element scope inherited from {http://www.opengis.net/gml}AbstractCoordinateOperationType
    
    # Element name inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element remarks inherited from {http://www.opengis.net/gml}DefinitionType
    
    # Attribute aggregationType uses Python identifier aggregationType
    __aggregationType = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'aggregationType'), 'aggregationType', '__PassThroughOperationType_aggregationType', AggregationType)
    def aggregationType (self):
        """Get the attribute value for aggregationType."""
        return self.__aggregationType.value(self)
    def setAggregationType (self, new_value):
        """Set the attribute value for aggregationType.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__aggregationType.set(self, new_value)
    
    # Attribute id inherited from {http://www.opengis.net/gml}DefinitionBaseType

    _ElementMap = AbstractCoordinateOperationType._ElementMap.copy()
    _ElementMap.update({
        __coordOperation.name() : __coordOperation,
        __modifiedCoordinate.name() : __modifiedCoordinate
    })
    _AttributeMap = AbstractCoordinateOperationType._AttributeMap.copy()
    _AttributeMap.update({
        __aggregationType.name() : __aggregationType
    })
Namespace.addCategoryObject('typeBinding', u'PassThroughOperationType', PassThroughOperationType)


# Complex type PolarCSType with content type ELEMENT_ONLY
class PolarCSType (AbstractCoordinateSystemType):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'PolarCSType')
    # Base type is AbstractCoordinateSystemType
    
    # Element descriptionReference inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element metaDataProperty inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element name inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element axis inherited from {http://www.opengis.net/gml}AbstractCoordinateSystemType
    
    # Element identifier inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element description inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element remarks inherited from {http://www.opengis.net/gml}DefinitionType
    
    # Attribute aggregationType inherited from {http://www.opengis.net/gml}AbstractCoordinateSystemType
    
    # Attribute id inherited from {http://www.opengis.net/gml}DefinitionBaseType

    _ElementMap = AbstractCoordinateSystemType._ElementMap.copy()
    _ElementMap.update({
        
    })
    _AttributeMap = AbstractCoordinateSystemType._AttributeMap.copy()
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', u'PolarCSType', PolarCSType)


# Complex type PolyhedralSurfaceType with content type ELEMENT_ONLY
class PolyhedralSurfaceType (SurfaceType):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'PolyhedralSurfaceType')
    # Base type is SurfaceType
    
    # Element descriptionReference inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element description inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element {http://www.opengis.net/gml}polygonPatches uses Python identifier polygonPatches
    __polygonPatches = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'polygonPatches'), 'polygonPatches', '__PolyhedralSurfaceType_httpwww_opengis_netgmlpolygonPatches', False)
    def polygonPatches (self):
        """Get the value of the {http://www.opengis.net/gml}polygonPatches element."""
        return self.__polygonPatches.value(self)
    def setPolygonPatches (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}polygonPatches element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__polygonPatches.set(self, new_value)
    
    # Element identifier inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element name inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element metaDataProperty inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Attribute srsName inherited from {http://www.opengis.net/gml}AbstractGeometryType
    
    # Attribute axisLabels inherited from {http://www.opengis.net/gml}AbstractGeometryType
    
    # Attribute id inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Attribute uomLabels inherited from {http://www.opengis.net/gml}AbstractGeometryType
    
    # Attribute srsDimension inherited from {http://www.opengis.net/gml}AbstractGeometryType

    _ElementMap = SurfaceType._ElementMap.copy()
    _ElementMap.update({
        __polygonPatches.name() : __polygonPatches
    })
    _AttributeMap = SurfaceType._AttributeMap.copy()
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', u'PolyhedralSurfaceType', PolyhedralSurfaceType)


# Complex type SphericalCSType with content type ELEMENT_ONLY
class SphericalCSType (AbstractCoordinateSystemType):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'SphericalCSType')
    # Base type is AbstractCoordinateSystemType
    
    # Element descriptionReference inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element metaDataProperty inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element name inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element axis inherited from {http://www.opengis.net/gml}AbstractCoordinateSystemType
    
    # Element identifier inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element description inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element remarks inherited from {http://www.opengis.net/gml}DefinitionType
    
    # Attribute aggregationType inherited from {http://www.opengis.net/gml}AbstractCoordinateSystemType
    
    # Attribute id inherited from {http://www.opengis.net/gml}DefinitionBaseType

    _ElementMap = AbstractCoordinateSystemType._ElementMap.copy()
    _ElementMap.update({
        
    })
    _AttributeMap = AbstractCoordinateSystemType._AttributeMap.copy()
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', u'SphericalCSType', SphericalCSType)


# Complex type TemporalCRSType with content type ELEMENT_ONLY
class TemporalCRSType (AbstractCRSType):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'TemporalCRSType')
    # Base type is AbstractCRSType
    
    # Element descriptionReference inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element metaDataProperty inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element name inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element {http://www.opengis.net/gml}temporalDatum uses Python identifier temporalDatum
    __temporalDatum = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'temporalDatum'), 'temporalDatum', '__TemporalCRSType_httpwww_opengis_netgmltemporalDatum', True)
    def temporalDatum (self):
        """Get the value of the {http://www.opengis.net/gml}temporalDatum element."""
        return self.__temporalDatum.value(self)
    def setTemporalDatum (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}temporalDatum element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__temporalDatum.set(self, new_value)
    
    def addTemporalDatum (self, new_value):
        """Add the value as another occurrence of the {http://www.opengis.net/gml}temporalDatum element.  Raises
        BadValueTypeException if the new value is not consistent with the
        element's type."""
        return self.__temporalDatum.append(self, new_value)
    
    # Element {http://www.opengis.net/gml}usesTemporalCS uses Python identifier usesTemporalCS
    __usesTemporalCS = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'usesTemporalCS'), 'usesTemporalCS', '__TemporalCRSType_httpwww_opengis_netgmlusesTemporalCS', False)
    def usesTemporalCS (self):
        """Get the value of the {http://www.opengis.net/gml}usesTemporalCS element."""
        return self.__usesTemporalCS.value(self)
    def setUsesTemporalCS (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}usesTemporalCS element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__usesTemporalCS.set(self, new_value)
    
    # Element {http://www.opengis.net/gml}timeCS uses Python identifier timeCS
    __timeCS = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'timeCS'), 'timeCS', '__TemporalCRSType_httpwww_opengis_netgmltimeCS', False)
    def timeCS (self):
        """Get the value of the {http://www.opengis.net/gml}timeCS element."""
        return self.__timeCS.value(self)
    def setTimeCS (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}timeCS element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__timeCS.set(self, new_value)
    
    # Element identifier inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element domainOfValidity inherited from {http://www.opengis.net/gml}AbstractCRSType
    
    # Element scope inherited from {http://www.opengis.net/gml}AbstractCRSType
    
    # Element description inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element remarks inherited from {http://www.opengis.net/gml}DefinitionType
    
    # Attribute id inherited from {http://www.opengis.net/gml}DefinitionBaseType

    _ElementMap = AbstractCRSType._ElementMap.copy()
    _ElementMap.update({
        __temporalDatum.name() : __temporalDatum,
        __usesTemporalCS.name() : __usesTemporalCS,
        __timeCS.name() : __timeCS
    })
    _AttributeMap = AbstractCRSType._AttributeMap.copy()
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', u'TemporalCRSType', TemporalCRSType)


# Complex type TemporalCSType with content type ELEMENT_ONLY
class TemporalCSType (AbstractCoordinateSystemType):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'TemporalCSType')
    # Base type is AbstractCoordinateSystemType
    
    # Element descriptionReference inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element metaDataProperty inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element name inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element axis inherited from {http://www.opengis.net/gml}AbstractCoordinateSystemType
    
    # Element identifier inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element description inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element remarks inherited from {http://www.opengis.net/gml}DefinitionType
    
    # Attribute aggregationType inherited from {http://www.opengis.net/gml}AbstractCoordinateSystemType
    
    # Attribute id inherited from {http://www.opengis.net/gml}DefinitionBaseType

    _ElementMap = AbstractCoordinateSystemType._ElementMap.copy()
    _ElementMap.update({
        
    })
    _AttributeMap = AbstractCoordinateSystemType._AttributeMap.copy()
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', u'TemporalCSType', TemporalCSType)


# Complex type TemporalDatumBaseType with content type ELEMENT_ONLY
class TemporalDatumBaseType (AbstractDatumType):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = True
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'TemporalDatumBaseType')
    # Base type is AbstractDatumType
    
    # Element descriptionReference inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element metaDataProperty inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element name inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element domainOfValidity inherited from {http://www.opengis.net/gml}AbstractDatumType
    
    # Element identifier inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element scope inherited from {http://www.opengis.net/gml}AbstractDatumType
    
    # Element description inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element remarks inherited from {http://www.opengis.net/gml}DefinitionType
    
    # Attribute {http://www.opengis.net/gml}id uses Python identifier id
    __id = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(Namespace, u'id'), 'id', '__TemporalDatumBaseType_httpwww_opengis_netgmlid', pyxb.binding.datatypes.ID, required=True)
    def id (self):
        """Get the attribute value for {http://www.opengis.net/gml}id."""
        return self.__id.value(self)
    def setId (self, new_value):
        """Set the attribute value for {http://www.opengis.net/gml}id.  Raises BadValueTypeException
        if the new value is not consistent with the attribute's type."""
        return self.__id.set(self, new_value)

    _ElementMap = AbstractDatumType._ElementMap.copy()
    _ElementMap.update({
        
    })
    _AttributeMap = AbstractDatumType._AttributeMap.copy()
    _AttributeMap.update({
        __id.name() : __id
    })
Namespace.addCategoryObject('typeBinding', u'TemporalDatumBaseType', TemporalDatumBaseType)


# Complex type TimeCSType with content type ELEMENT_ONLY
class TimeCSType (AbstractCoordinateSystemType):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'TimeCSType')
    # Base type is AbstractCoordinateSystemType
    
    # Element descriptionReference inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element metaDataProperty inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element name inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element axis inherited from {http://www.opengis.net/gml}AbstractCoordinateSystemType
    
    # Element identifier inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element description inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element remarks inherited from {http://www.opengis.net/gml}DefinitionType
    
    # Attribute aggregationType inherited from {http://www.opengis.net/gml}AbstractCoordinateSystemType
    
    # Attribute id inherited from {http://www.opengis.net/gml}DefinitionBaseType

    _ElementMap = AbstractCoordinateSystemType._ElementMap.copy()
    _ElementMap.update({
        
    })
    _AttributeMap = AbstractCoordinateSystemType._AttributeMap.copy()
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', u'TimeCSType', TimeCSType)


# Complex type TriangulatedSurfaceType with content type ELEMENT_ONLY
class TriangulatedSurfaceType (SurfaceType):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'TriangulatedSurfaceType')
    # Base type is SurfaceType
    
    # Element descriptionReference inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element description inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element {http://www.opengis.net/gml}trianglePatches uses Python identifier trianglePatches
    __trianglePatches = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'trianglePatches'), 'trianglePatches', '__TriangulatedSurfaceType_httpwww_opengis_netgmltrianglePatches', False)
    def trianglePatches (self):
        """Get the value of the {http://www.opengis.net/gml}trianglePatches element."""
        return self.__trianglePatches.value(self)
    def setTrianglePatches (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}trianglePatches element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__trianglePatches.set(self, new_value)
    
    # Element identifier inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element name inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element metaDataProperty inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Attribute srsName inherited from {http://www.opengis.net/gml}AbstractGeometryType
    
    # Attribute axisLabels inherited from {http://www.opengis.net/gml}AbstractGeometryType
    
    # Attribute id inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Attribute uomLabels inherited from {http://www.opengis.net/gml}AbstractGeometryType
    
    # Attribute srsDimension inherited from {http://www.opengis.net/gml}AbstractGeometryType

    _ElementMap = SurfaceType._ElementMap.copy()
    _ElementMap.update({
        __trianglePatches.name() : __trianglePatches
    })
    _AttributeMap = SurfaceType._AttributeMap.copy()
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', u'TriangulatedSurfaceType', TriangulatedSurfaceType)


# Complex type UserDefinedCSType with content type ELEMENT_ONLY
class UserDefinedCSType (AbstractCoordinateSystemType):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'UserDefinedCSType')
    # Base type is AbstractCoordinateSystemType
    
    # Element descriptionReference inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element metaDataProperty inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element name inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element axis inherited from {http://www.opengis.net/gml}AbstractCoordinateSystemType
    
    # Element identifier inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element description inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element remarks inherited from {http://www.opengis.net/gml}DefinitionType
    
    # Attribute aggregationType inherited from {http://www.opengis.net/gml}AbstractCoordinateSystemType
    
    # Attribute id inherited from {http://www.opengis.net/gml}DefinitionBaseType

    _ElementMap = AbstractCoordinateSystemType._ElementMap.copy()
    _ElementMap.update({
        
    })
    _AttributeMap = AbstractCoordinateSystemType._AttributeMap.copy()
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', u'UserDefinedCSType', UserDefinedCSType)


# Complex type VerticalCRSType with content type ELEMENT_ONLY
class VerticalCRSType (AbstractCRSType):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'VerticalCRSType')
    # Base type is AbstractCRSType
    
    # Element descriptionReference inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element metaDataProperty inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element description inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element {http://www.opengis.net/gml}verticalDatum uses Python identifier verticalDatum
    __verticalDatum = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'verticalDatum'), 'verticalDatum', '__VerticalCRSType_httpwww_opengis_netgmlverticalDatum', False)
    def verticalDatum (self):
        """Get the value of the {http://www.opengis.net/gml}verticalDatum element."""
        return self.__verticalDatum.value(self)
    def setVerticalDatum (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}verticalDatum element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__verticalDatum.set(self, new_value)
    
    # Element {http://www.opengis.net/gml}verticalCS uses Python identifier verticalCS
    __verticalCS = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'verticalCS'), 'verticalCS', '__VerticalCRSType_httpwww_opengis_netgmlverticalCS', False)
    def verticalCS (self):
        """Get the value of the {http://www.opengis.net/gml}verticalCS element."""
        return self.__verticalCS.value(self)
    def setVerticalCS (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}verticalCS element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__verticalCS.set(self, new_value)
    
    # Element identifier inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element domainOfValidity inherited from {http://www.opengis.net/gml}AbstractCRSType
    
    # Element scope inherited from {http://www.opengis.net/gml}AbstractCRSType
    
    # Element name inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element remarks inherited from {http://www.opengis.net/gml}DefinitionType
    
    # Attribute id inherited from {http://www.opengis.net/gml}DefinitionBaseType

    _ElementMap = AbstractCRSType._ElementMap.copy()
    _ElementMap.update({
        __verticalDatum.name() : __verticalDatum,
        __verticalCS.name() : __verticalCS
    })
    _AttributeMap = AbstractCRSType._AttributeMap.copy()
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', u'VerticalCRSType', VerticalCRSType)


# Complex type VerticalCSType with content type ELEMENT_ONLY
class VerticalCSType (AbstractCoordinateSystemType):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'VerticalCSType')
    # Base type is AbstractCoordinateSystemType
    
    # Element descriptionReference inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element metaDataProperty inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element name inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element axis inherited from {http://www.opengis.net/gml}AbstractCoordinateSystemType
    
    # Element identifier inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element description inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element remarks inherited from {http://www.opengis.net/gml}DefinitionType
    
    # Attribute aggregationType inherited from {http://www.opengis.net/gml}AbstractCoordinateSystemType
    
    # Attribute id inherited from {http://www.opengis.net/gml}DefinitionBaseType

    _ElementMap = AbstractCoordinateSystemType._ElementMap.copy()
    _ElementMap.update({
        
    })
    _AttributeMap = AbstractCoordinateSystemType._AttributeMap.copy()
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', u'VerticalCSType', VerticalCSType)


# Complex type VerticalDatumType with content type ELEMENT_ONLY
class VerticalDatumType (AbstractDatumType):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'VerticalDatumType')
    # Base type is AbstractDatumType
    
    # Element descriptionReference inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element description inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element realizationEpoch inherited from {http://www.opengis.net/gml}AbstractDatumType
    
    # Element metaDataProperty inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element name inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element identifier inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element scope inherited from {http://www.opengis.net/gml}AbstractDatumType
    
    # Element domainOfValidity inherited from {http://www.opengis.net/gml}AbstractDatumType
    
    # Element remarks inherited from {http://www.opengis.net/gml}DefinitionType
    
    # Element anchorDefinition inherited from {http://www.opengis.net/gml}AbstractDatumType
    
    # Attribute id inherited from {http://www.opengis.net/gml}DefinitionBaseType

    _ElementMap = AbstractDatumType._ElementMap.copy()
    _ElementMap.update({
        
    })
    _AttributeMap = AbstractDatumType._AttributeMap.copy()
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', u'VerticalDatumType', VerticalDatumType)


# Complex type ConversionType with content type ELEMENT_ONLY
class ConversionType (AbstractGeneralConversionType):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'ConversionType')
    # Base type is AbstractGeneralConversionType
    
    # Element descriptionReference inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element metaDataProperty inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element description inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element {http://www.opengis.net/gml}method uses Python identifier method
    __method = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'method'), 'method', '__ConversionType_httpwww_opengis_netgmlmethod', False)
    def method (self):
        """Get the value of the {http://www.opengis.net/gml}method element."""
        return self.__method.value(self)
    def setMethod (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}method element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__method.set(self, new_value)
    
    # Element domainOfValidity inherited from {http://www.opengis.net/gml}AbstractCoordinateOperationType
    
    # Element identifier inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element coordinateOperationAccuracy inherited from {http://www.opengis.net/gml}AbstractCoordinateOperationType
    
    # Element scope inherited from {http://www.opengis.net/gml}AbstractCoordinateOperationType
    
    # Element name inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element remarks inherited from {http://www.opengis.net/gml}DefinitionType
    
    # Element {http://www.opengis.net/gml}parameterValue uses Python identifier parameterValue
    __parameterValue = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'parameterValue'), 'parameterValue', '__ConversionType_httpwww_opengis_netgmlparameterValue', True)
    def parameterValue (self):
        """Get the value of the {http://www.opengis.net/gml}parameterValue element."""
        return self.__parameterValue.value(self)
    def setParameterValue (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}parameterValue element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__parameterValue.set(self, new_value)
    
    def addParameterValue (self, new_value):
        """Add the value as another occurrence of the {http://www.opengis.net/gml}parameterValue element.  Raises
        BadValueTypeException if the new value is not consistent with the
        element's type."""
        return self.__parameterValue.append(self, new_value)
    
    # Attribute id inherited from {http://www.opengis.net/gml}AbstractGeneralConversionType

    _ElementMap = AbstractGeneralConversionType._ElementMap.copy()
    _ElementMap.update({
        __method.name() : __method,
        __parameterValue.name() : __parameterValue
    })
    _AttributeMap = AbstractGeneralConversionType._AttributeMap.copy()
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', u'ConversionType', ConversionType)


# Complex type DerivedCRSType with content type ELEMENT_ONLY
class DerivedCRSType (AbstractGeneralDerivedCRSType):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'DerivedCRSType')
    # Base type is AbstractGeneralDerivedCRSType
    
    # Element descriptionReference inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element metaDataProperty inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element name inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element conversion inherited from {http://www.opengis.net/gml}AbstractGeneralDerivedCRSType
    
    # Element scope inherited from {http://www.opengis.net/gml}AbstractCRSType
    
    # Element identifier inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element {http://www.opengis.net/gml}baseCRS uses Python identifier baseCRS
    __baseCRS = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'baseCRS'), 'baseCRS', '__DerivedCRSType_httpwww_opengis_netgmlbaseCRS', False)
    def baseCRS (self):
        """Get the value of the {http://www.opengis.net/gml}baseCRS element."""
        return self.__baseCRS.value(self)
    def setBaseCRS (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}baseCRS element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__baseCRS.set(self, new_value)
    
    # Element {http://www.opengis.net/gml}derivedCRSType uses Python identifier derivedCRSType
    __derivedCRSType = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'derivedCRSType'), 'derivedCRSType', '__DerivedCRSType_httpwww_opengis_netgmlderivedCRSType', False)
    def derivedCRSType (self):
        """Get the value of the {http://www.opengis.net/gml}derivedCRSType element."""
        return self.__derivedCRSType.value(self)
    def setDerivedCRSType (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}derivedCRSType element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__derivedCRSType.set(self, new_value)
    
    # Element description inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element remarks inherited from {http://www.opengis.net/gml}DefinitionType
    
    # Element {http://www.opengis.net/gml}coordinateSystem uses Python identifier coordinateSystem
    __coordinateSystem = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'coordinateSystem'), 'coordinateSystem', '__DerivedCRSType_httpwww_opengis_netgmlcoordinateSystem', False)
    def coordinateSystem (self):
        """Get the value of the {http://www.opengis.net/gml}coordinateSystem element."""
        return self.__coordinateSystem.value(self)
    def setCoordinateSystem (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}coordinateSystem element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__coordinateSystem.set(self, new_value)
    
    # Element domainOfValidity inherited from {http://www.opengis.net/gml}AbstractCRSType
    
    # Attribute id inherited from {http://www.opengis.net/gml}DefinitionBaseType

    _ElementMap = AbstractGeneralDerivedCRSType._ElementMap.copy()
    _ElementMap.update({
        __baseCRS.name() : __baseCRS,
        __derivedCRSType.name() : __derivedCRSType,
        __coordinateSystem.name() : __coordinateSystem
    })
    _AttributeMap = AbstractGeneralDerivedCRSType._AttributeMap.copy()
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', u'DerivedCRSType', DerivedCRSType)


# Complex type ProjectedCRSType with content type ELEMENT_ONLY
class ProjectedCRSType (AbstractGeneralDerivedCRSType):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'ProjectedCRSType')
    # Base type is AbstractGeneralDerivedCRSType
    
    # Element descriptionReference inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element metaDataProperty inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element name inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element conversion inherited from {http://www.opengis.net/gml}AbstractGeneralDerivedCRSType
    
    # Element {http://www.opengis.net/gml}baseGeodeticCRS uses Python identifier baseGeodeticCRS
    __baseGeodeticCRS = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'baseGeodeticCRS'), 'baseGeodeticCRS', '__ProjectedCRSType_httpwww_opengis_netgmlbaseGeodeticCRS', False)
    def baseGeodeticCRS (self):
        """Get the value of the {http://www.opengis.net/gml}baseGeodeticCRS element."""
        return self.__baseGeodeticCRS.value(self)
    def setBaseGeodeticCRS (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}baseGeodeticCRS element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__baseGeodeticCRS.set(self, new_value)
    
    # Element identifier inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element {http://www.opengis.net/gml}cartesianCS uses Python identifier cartesianCS
    __cartesianCS = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'cartesianCS'), 'cartesianCS', '__ProjectedCRSType_httpwww_opengis_netgmlcartesianCS', True)
    def cartesianCS (self):
        """Get the value of the {http://www.opengis.net/gml}cartesianCS element."""
        return self.__cartesianCS.value(self)
    def setCartesianCS (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}cartesianCS element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__cartesianCS.set(self, new_value)
    
    def addCartesianCS (self, new_value):
        """Add the value as another occurrence of the {http://www.opengis.net/gml}cartesianCS element.  Raises
        BadValueTypeException if the new value is not consistent with the
        element's type."""
        return self.__cartesianCS.append(self, new_value)
    
    # Element domainOfValidity inherited from {http://www.opengis.net/gml}AbstractCRSType
    
    # Element scope inherited from {http://www.opengis.net/gml}AbstractCRSType
    
    # Element description inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element remarks inherited from {http://www.opengis.net/gml}DefinitionType
    
    # Element {http://www.opengis.net/gml}baseGeographicCRS uses Python identifier baseGeographicCRS
    __baseGeographicCRS = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'baseGeographicCRS'), 'baseGeographicCRS', '__ProjectedCRSType_httpwww_opengis_netgmlbaseGeographicCRS', False)
    def baseGeographicCRS (self):
        """Get the value of the {http://www.opengis.net/gml}baseGeographicCRS element."""
        return self.__baseGeographicCRS.value(self)
    def setBaseGeographicCRS (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}baseGeographicCRS element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__baseGeographicCRS.set(self, new_value)
    
    # Attribute id inherited from {http://www.opengis.net/gml}DefinitionBaseType

    _ElementMap = AbstractGeneralDerivedCRSType._ElementMap.copy()
    _ElementMap.update({
        __baseGeodeticCRS.name() : __baseGeodeticCRS,
        __cartesianCS.name() : __cartesianCS,
        __baseGeographicCRS.name() : __baseGeographicCRS
    })
    _AttributeMap = AbstractGeneralDerivedCRSType._AttributeMap.copy()
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', u'ProjectedCRSType', ProjectedCRSType)


# Complex type TemporalDatumType with content type ELEMENT_ONLY
class TemporalDatumType (TemporalDatumBaseType):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'TemporalDatumType')
    # Base type is TemporalDatumBaseType
    
    # Element descriptionReference inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element metaDataProperty inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element name inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element domainOfValidity inherited from {http://www.opengis.net/gml}AbstractDatumType
    
    # Element identifier inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element {http://www.opengis.net/gml}origin uses Python identifier origin
    __origin = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'origin'), 'origin', '__TemporalDatumType_httpwww_opengis_netgmlorigin', False)
    def origin (self):
        """Get the value of the {http://www.opengis.net/gml}origin element."""
        return self.__origin.value(self)
    def setOrigin (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}origin element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__origin.set(self, new_value)
    
    # Element scope inherited from {http://www.opengis.net/gml}AbstractDatumType
    
    # Element description inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element remarks inherited from {http://www.opengis.net/gml}DefinitionType
    
    # Attribute id inherited from {http://www.opengis.net/gml}TemporalDatumBaseType

    _ElementMap = TemporalDatumBaseType._ElementMap.copy()
    _ElementMap.update({
        __origin.name() : __origin
    })
    _AttributeMap = TemporalDatumBaseType._AttributeMap.copy()
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', u'TemporalDatumType', TemporalDatumType)


# Complex type TinType with content type ELEMENT_ONLY
class TinType (TriangulatedSurfaceType):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'TinType')
    # Base type is TriangulatedSurfaceType
    
    # Element descriptionReference inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element {http://www.opengis.net/gml}stopLines uses Python identifier stopLines
    __stopLines = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'stopLines'), 'stopLines', '__TinType_httpwww_opengis_netgmlstopLines', True)
    def stopLines (self):
        """Get the value of the {http://www.opengis.net/gml}stopLines element."""
        return self.__stopLines.value(self)
    def setStopLines (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}stopLines element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__stopLines.set(self, new_value)
    
    def addStopLines (self, new_value):
        """Add the value as another occurrence of the {http://www.opengis.net/gml}stopLines element.  Raises
        BadValueTypeException if the new value is not consistent with the
        element's type."""
        return self.__stopLines.append(self, new_value)
    
    # Element description inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element {http://www.opengis.net/gml}breakLines uses Python identifier breakLines
    __breakLines = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'breakLines'), 'breakLines', '__TinType_httpwww_opengis_netgmlbreakLines', True)
    def breakLines (self):
        """Get the value of the {http://www.opengis.net/gml}breakLines element."""
        return self.__breakLines.value(self)
    def setBreakLines (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}breakLines element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__breakLines.set(self, new_value)
    
    def addBreakLines (self, new_value):
        """Add the value as another occurrence of the {http://www.opengis.net/gml}breakLines element.  Raises
        BadValueTypeException if the new value is not consistent with the
        element's type."""
        return self.__breakLines.append(self, new_value)
    
    # Element trianglePatches inherited from {http://www.opengis.net/gml}TriangulatedSurfaceType
    
    # Element {http://www.opengis.net/gml}maxLength uses Python identifier maxLength
    __maxLength = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'maxLength'), 'maxLength', '__TinType_httpwww_opengis_netgmlmaxLength', False)
    def maxLength (self):
        """Get the value of the {http://www.opengis.net/gml}maxLength element."""
        return self.__maxLength.value(self)
    def setMaxLength (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}maxLength element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__maxLength.set(self, new_value)
    
    # Element identifier inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element name inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element metaDataProperty inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element {http://www.opengis.net/gml}controlPoint uses Python identifier controlPoint
    __controlPoint = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'controlPoint'), 'controlPoint', '__TinType_httpwww_opengis_netgmlcontrolPoint', False)
    def controlPoint (self):
        """Get the value of the {http://www.opengis.net/gml}controlPoint element."""
        return self.__controlPoint.value(self)
    def setControlPoint (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}controlPoint element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__controlPoint.set(self, new_value)
    
    # Attribute srsName inherited from {http://www.opengis.net/gml}AbstractGeometryType
    
    # Attribute axisLabels inherited from {http://www.opengis.net/gml}AbstractGeometryType
    
    # Attribute id inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Attribute uomLabels inherited from {http://www.opengis.net/gml}AbstractGeometryType
    
    # Attribute srsDimension inherited from {http://www.opengis.net/gml}AbstractGeometryType

    _ElementMap = TriangulatedSurfaceType._ElementMap.copy()
    _ElementMap.update({
        __stopLines.name() : __stopLines,
        __breakLines.name() : __breakLines,
        __maxLength.name() : __maxLength,
        __controlPoint.name() : __controlPoint
    })
    _AttributeMap = TriangulatedSurfaceType._AttributeMap.copy()
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', u'TinType', TinType)


# Complex type TransformationType with content type ELEMENT_ONLY
class TransformationType (AbstractGeneralTransformationType):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'TransformationType')
    # Base type is AbstractGeneralTransformationType
    
    # Element descriptionReference inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element operationVersion inherited from {http://www.opengis.net/gml}AbstractCoordinateOperationType
    
    # Element remarks inherited from {http://www.opengis.net/gml}DefinitionType
    
    # Element name inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element targetCRS inherited from {http://www.opengis.net/gml}AbstractCoordinateOperationType
    
    # Element {http://www.opengis.net/gml}method uses Python identifier method
    __method = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'method'), 'method', '__TransformationType_httpwww_opengis_netgmlmethod', False)
    def method (self):
        """Get the value of the {http://www.opengis.net/gml}method element."""
        return self.__method.value(self)
    def setMethod (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}method element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__method.set(self, new_value)
    
    # Element domainOfValidity inherited from {http://www.opengis.net/gml}AbstractCoordinateOperationType
    
    # Element identifier inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element coordinateOperationAccuracy inherited from {http://www.opengis.net/gml}AbstractCoordinateOperationType
    
    # Element sourceCRS inherited from {http://www.opengis.net/gml}AbstractCoordinateOperationType
    
    # Element scope inherited from {http://www.opengis.net/gml}AbstractCoordinateOperationType
    
    # Element description inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element metaDataProperty inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element {http://www.opengis.net/gml}parameterValue uses Python identifier parameterValue
    __parameterValue = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'parameterValue'), 'parameterValue', '__TransformationType_httpwww_opengis_netgmlparameterValue', True)
    def parameterValue (self):
        """Get the value of the {http://www.opengis.net/gml}parameterValue element."""
        return self.__parameterValue.value(self)
    def setParameterValue (self, new_value):
        """Set the value of the {http://www.opengis.net/gml}parameterValue element.  Raises BadValueTypeException
        if the new value is not consistent with the element's type."""
        return self.__parameterValue.set(self, new_value)
    
    def addParameterValue (self, new_value):
        """Add the value as another occurrence of the {http://www.opengis.net/gml}parameterValue element.  Raises
        BadValueTypeException if the new value is not consistent with the
        element's type."""
        return self.__parameterValue.append(self, new_value)
    
    # Attribute id inherited from {http://www.opengis.net/gml}AbstractGeneralTransformationType

    _ElementMap = AbstractGeneralTransformationType._ElementMap.copy()
    _ElementMap.update({
        __method.name() : __method,
        __parameterValue.name() : __parameterValue
    })
    _AttributeMap = AbstractGeneralTransformationType._AttributeMap.copy()
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', u'TransformationType', TransformationType)


AbstractCRS = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'AbstractCRS'), AbstractCRSType, abstract=pyxb.binding.datatypes.boolean(1))
Namespace.addCategoryObject('elementBinding', AbstractCRS.name().localName(), AbstractCRS)

AbstractContinuousCoverage = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'AbstractContinuousCoverage'), AbstractContinuousCoverageType, abstract=pyxb.binding.datatypes.boolean(1))
Namespace.addCategoryObject('elementBinding', AbstractContinuousCoverage.name().localName(), AbstractContinuousCoverage)

AbstractCoordinateOperation = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'AbstractCoordinateOperation'), AbstractCoordinateOperationType, abstract=pyxb.binding.datatypes.boolean(1))
Namespace.addCategoryObject('elementBinding', AbstractCoordinateOperation.name().localName(), AbstractCoordinateOperation)

AbstractCoordinateSystem = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'AbstractCoordinateSystem'), AbstractCoordinateSystemType, abstract=pyxb.binding.datatypes.boolean(1))
Namespace.addCategoryObject('elementBinding', AbstractCoordinateSystem.name().localName(), AbstractCoordinateSystem)

AbstractCoverage = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'AbstractCoverage'), AbstractCoverageType, abstract=pyxb.binding.datatypes.boolean(1))
Namespace.addCategoryObject('elementBinding', AbstractCoverage.name().localName(), AbstractCoverage)

AbstractCurve = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'AbstractCurve'), AbstractCurveType, abstract=pyxb.binding.datatypes.boolean(1))
Namespace.addCategoryObject('elementBinding', AbstractCurve.name().localName(), AbstractCurve)

AbstractCurveSegment = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'AbstractCurveSegment'), AbstractCurveSegmentType, abstract=pyxb.binding.datatypes.boolean(1))
Namespace.addCategoryObject('elementBinding', AbstractCurveSegment.name().localName(), AbstractCurveSegment)

AbstractDatum = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'AbstractDatum'), AbstractDatumType, abstract=pyxb.binding.datatypes.boolean(1))
Namespace.addCategoryObject('elementBinding', AbstractDatum.name().localName(), AbstractDatum)

AbstractDiscreteCoverage = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'AbstractDiscreteCoverage'), AbstractDiscreteCoverageType, abstract=pyxb.binding.datatypes.boolean(1))
Namespace.addCategoryObject('elementBinding', AbstractDiscreteCoverage.name().localName(), AbstractDiscreteCoverage)

AbstractFeature = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'AbstractFeature'), AbstractFeatureType, abstract=pyxb.binding.datatypes.boolean(1))
Namespace.addCategoryObject('elementBinding', AbstractFeature.name().localName(), AbstractFeature)

AbstractFeatureCollection = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'AbstractFeatureCollection'), AbstractFeatureCollectionType, abstract=pyxb.binding.datatypes.boolean(1))
Namespace.addCategoryObject('elementBinding', AbstractFeatureCollection.name().localName(), AbstractFeatureCollection)

AbstractGML = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'AbstractGML'), AbstractGMLType, abstract=pyxb.binding.datatypes.boolean(1))
Namespace.addCategoryObject('elementBinding', AbstractGML.name().localName(), AbstractGML)

AbstractGeneralConversion = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'AbstractGeneralConversion'), AbstractGeneralConversionType, abstract=pyxb.binding.datatypes.boolean(1))
Namespace.addCategoryObject('elementBinding', AbstractGeneralConversion.name().localName(), AbstractGeneralConversion)

AbstractGeneralDerivedCRS = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'AbstractGeneralDerivedCRS'), AbstractGeneralDerivedCRSType, abstract=pyxb.binding.datatypes.boolean(1))
Namespace.addCategoryObject('elementBinding', AbstractGeneralDerivedCRS.name().localName(), AbstractGeneralDerivedCRS)

AbstractGeneralOperationParameter = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'AbstractGeneralOperationParameter'), AbstractGeneralOperationParameterType, abstract=pyxb.binding.datatypes.boolean(1))
Namespace.addCategoryObject('elementBinding', AbstractGeneralOperationParameter.name().localName(), AbstractGeneralOperationParameter)

AbstractGeneralParameterValue = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'AbstractGeneralParameterValue'), AbstractGeneralParameterValueType, abstract=pyxb.binding.datatypes.boolean(1))
Namespace.addCategoryObject('elementBinding', AbstractGeneralParameterValue.name().localName(), AbstractGeneralParameterValue)

AbstractGeneralTransformation = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'AbstractGeneralTransformation'), AbstractGeneralTransformationType, abstract=pyxb.binding.datatypes.boolean(1))
Namespace.addCategoryObject('elementBinding', AbstractGeneralTransformation.name().localName(), AbstractGeneralTransformation)

AbstractGeometricAggregate = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'AbstractGeometricAggregate'), AbstractGeometricAggregateType, abstract=pyxb.binding.datatypes.boolean(1))
Namespace.addCategoryObject('elementBinding', AbstractGeometricAggregate.name().localName(), AbstractGeometricAggregate)

AbstractGeometricPrimitive = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'AbstractGeometricPrimitive'), AbstractGeometricPrimitiveType, abstract=pyxb.binding.datatypes.boolean(1))
Namespace.addCategoryObject('elementBinding', AbstractGeometricPrimitive.name().localName(), AbstractGeometricPrimitive)

AbstractGeometry = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'AbstractGeometry'), AbstractGeometryType, abstract=pyxb.binding.datatypes.boolean(1))
Namespace.addCategoryObject('elementBinding', AbstractGeometry.name().localName(), AbstractGeometry)

AbstractGriddedSurface = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'AbstractGriddedSurface'), AbstractGriddedSurfaceType, abstract=pyxb.binding.datatypes.boolean(1))
Namespace.addCategoryObject('elementBinding', AbstractGriddedSurface.name().localName(), AbstractGriddedSurface)

AbstractImplicitGeometry = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'AbstractImplicitGeometry'), AbstractGeometryType, abstract=pyxb.binding.datatypes.boolean(1))
Namespace.addCategoryObject('elementBinding', AbstractImplicitGeometry.name().localName(), AbstractImplicitGeometry)

AbstractMetaData = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'AbstractMetaData'), AbstractMetaDataType, abstract=pyxb.binding.datatypes.boolean(1))
Namespace.addCategoryObject('elementBinding', AbstractMetaData.name().localName(), AbstractMetaData)

AbstractObject = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'AbstractObject'), pyxb.binding.datatypes.anyType, abstract=pyxb.binding.datatypes.boolean(1))
Namespace.addCategoryObject('elementBinding', AbstractObject.name().localName(), AbstractObject)

AbstractOperation = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'AbstractOperation'), AbstractCoordinateOperationType, abstract=pyxb.binding.datatypes.boolean(1))
Namespace.addCategoryObject('elementBinding', AbstractOperation.name().localName(), AbstractOperation)

AbstractParametricCurveSurface = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'AbstractParametricCurveSurface'), AbstractParametricCurveSurfaceType, abstract=pyxb.binding.datatypes.boolean(1))
Namespace.addCategoryObject('elementBinding', AbstractParametricCurveSurface.name().localName(), AbstractParametricCurveSurface)

AbstractRing = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'AbstractRing'), AbstractRingType, abstract=pyxb.binding.datatypes.boolean(1))
Namespace.addCategoryObject('elementBinding', AbstractRing.name().localName(), AbstractRing)

AbstractScalarValue = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'AbstractScalarValue'), pyxb.binding.datatypes.anyType, abstract=pyxb.binding.datatypes.boolean(1))
Namespace.addCategoryObject('elementBinding', AbstractScalarValue.name().localName(), AbstractScalarValue)

AbstractScalarValueList = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'AbstractScalarValueList'), pyxb.binding.datatypes.anyType, abstract=pyxb.binding.datatypes.boolean(1))
Namespace.addCategoryObject('elementBinding', AbstractScalarValueList.name().localName(), AbstractScalarValueList)

AbstractSingleCRS = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'AbstractSingleCRS'), AbstractCRSType, abstract=pyxb.binding.datatypes.boolean(1))
Namespace.addCategoryObject('elementBinding', AbstractSingleCRS.name().localName(), AbstractSingleCRS)

AbstractSingleOperation = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'AbstractSingleOperation'), AbstractCoordinateOperationType, abstract=pyxb.binding.datatypes.boolean(1))
Namespace.addCategoryObject('elementBinding', AbstractSingleOperation.name().localName(), AbstractSingleOperation)

AbstractSolid = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'AbstractSolid'), AbstractSolidType, abstract=pyxb.binding.datatypes.boolean(1))
Namespace.addCategoryObject('elementBinding', AbstractSolid.name().localName(), AbstractSolid)

AbstractSurface = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'AbstractSurface'), AbstractSurfaceType, abstract=pyxb.binding.datatypes.boolean(1))
Namespace.addCategoryObject('elementBinding', AbstractSurface.name().localName(), AbstractSurface)

AbstractSurfacePatch = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'AbstractSurfacePatch'), AbstractSurfacePatchType, abstract=pyxb.binding.datatypes.boolean(1))
Namespace.addCategoryObject('elementBinding', AbstractSurfacePatch.name().localName(), AbstractSurfacePatch)

AbstractTimeComplex = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'AbstractTimeComplex'), AbstractTimeComplexType, abstract=pyxb.binding.datatypes.boolean(1))
Namespace.addCategoryObject('elementBinding', AbstractTimeComplex.name().localName(), AbstractTimeComplex)

AbstractTimeGeometricPrimitive = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'AbstractTimeGeometricPrimitive'), AbstractTimeGeometricPrimitiveType, abstract=pyxb.binding.datatypes.boolean(1))
Namespace.addCategoryObject('elementBinding', AbstractTimeGeometricPrimitive.name().localName(), AbstractTimeGeometricPrimitive)

AbstractTimeObject = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'AbstractTimeObject'), AbstractTimeObjectType, abstract=pyxb.binding.datatypes.boolean(1))
Namespace.addCategoryObject('elementBinding', AbstractTimeObject.name().localName(), AbstractTimeObject)

AbstractTimePrimitive = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'AbstractTimePrimitive'), AbstractTimePrimitiveType, abstract=pyxb.binding.datatypes.boolean(1))
Namespace.addCategoryObject('elementBinding', AbstractTimePrimitive.name().localName(), AbstractTimePrimitive)

AbstractTimeSlice = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'AbstractTimeSlice'), AbstractTimeSliceType, abstract=pyxb.binding.datatypes.boolean(1))
Namespace.addCategoryObject('elementBinding', AbstractTimeSlice.name().localName(), AbstractTimeSlice)

AbstractTimeTopologyPrimitive = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'AbstractTimeTopologyPrimitive'), AbstractTimeTopologyPrimitiveType, abstract=pyxb.binding.datatypes.boolean(1))
Namespace.addCategoryObject('elementBinding', AbstractTimeTopologyPrimitive.name().localName(), AbstractTimeTopologyPrimitive)

AbstractTopoPrimitive = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'AbstractTopoPrimitive'), AbstractTopoPrimitiveType, abstract=pyxb.binding.datatypes.boolean(1))
Namespace.addCategoryObject('elementBinding', AbstractTopoPrimitive.name().localName(), AbstractTopoPrimitive)

AbstractTopology = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'AbstractTopology'), AbstractTopologyType, abstract=pyxb.binding.datatypes.boolean(1))
Namespace.addCategoryObject('elementBinding', AbstractTopology.name().localName(), AbstractTopology)

AbstractValue = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'AbstractValue'), pyxb.binding.datatypes.anyType, abstract=pyxb.binding.datatypes.boolean(1))
Namespace.addCategoryObject('elementBinding', AbstractValue.name().localName(), AbstractValue)

AffineCS = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'AffineCS'), AffineCSType)
Namespace.addCategoryObject('elementBinding', AffineCS.name().localName(), AffineCS)

AffinePlacement = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'AffinePlacement'), AffinePlacementType)
Namespace.addCategoryObject('elementBinding', AffinePlacement.name().localName(), AffinePlacement)

Arc = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'Arc'), ArcType)
Namespace.addCategoryObject('elementBinding', Arc.name().localName(), Arc)

ArcByBulge = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'ArcByBulge'), ArcByBulgeType)
Namespace.addCategoryObject('elementBinding', ArcByBulge.name().localName(), ArcByBulge)

ArcByCenterPoint = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'ArcByCenterPoint'), ArcByCenterPointType)
Namespace.addCategoryObject('elementBinding', ArcByCenterPoint.name().localName(), ArcByCenterPoint)

ArcString = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'ArcString'), ArcStringType)
Namespace.addCategoryObject('elementBinding', ArcString.name().localName(), ArcString)

ArcStringByBulge = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'ArcStringByBulge'), ArcStringByBulgeType)
Namespace.addCategoryObject('elementBinding', ArcStringByBulge.name().localName(), ArcStringByBulge)

Array = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'Array'), ArrayType)
Namespace.addCategoryObject('elementBinding', Array.name().localName(), Array)

BSpline = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'BSpline'), BSplineType)
Namespace.addCategoryObject('elementBinding', BSpline.name().localName(), BSpline)

Bag = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'Bag'), BagType)
Namespace.addCategoryObject('elementBinding', Bag.name().localName(), Bag)

BaseUnit = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'BaseUnit'), BaseUnitType)
Namespace.addCategoryObject('elementBinding', BaseUnit.name().localName(), BaseUnit)

Bezier = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'Bezier'), BezierType)
Namespace.addCategoryObject('elementBinding', Bezier.name().localName(), Bezier)

Boolean = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'Boolean'), _CTD_ANON_20, nillable=pyxb.binding.datatypes.boolean(1))
Namespace.addCategoryObject('elementBinding', Boolean.name().localName(), Boolean)

BooleanList = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'BooleanList'), booleanOrNilReasonList)
Namespace.addCategoryObject('elementBinding', BooleanList.name().localName(), BooleanList)

CartesianCS = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'CartesianCS'), CartesianCSType)
Namespace.addCategoryObject('elementBinding', CartesianCS.name().localName(), CartesianCS)

Category = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'Category'), _CTD_ANON_26, nillable=pyxb.binding.datatypes.boolean(1))
Namespace.addCategoryObject('elementBinding', Category.name().localName(), Category)

CategoryExtent = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'CategoryExtent'), CategoryExtentType)
Namespace.addCategoryObject('elementBinding', CategoryExtent.name().localName(), CategoryExtent)

CategoryList = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'CategoryList'), CodeOrNilReasonListType)
Namespace.addCategoryObject('elementBinding', CategoryList.name().localName(), CategoryList)

Circle = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'Circle'), CircleType)
Namespace.addCategoryObject('elementBinding', Circle.name().localName(), Circle)

CircleByCenterPoint = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'CircleByCenterPoint'), CircleByCenterPointType)
Namespace.addCategoryObject('elementBinding', CircleByCenterPoint.name().localName(), CircleByCenterPoint)

Clothoid = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'Clothoid'), ClothoidType)
Namespace.addCategoryObject('elementBinding', Clothoid.name().localName(), Clothoid)

CompositeCurve = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'CompositeCurve'), CompositeCurveType)
Namespace.addCategoryObject('elementBinding', CompositeCurve.name().localName(), CompositeCurve)

CompositeSolid = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'CompositeSolid'), CompositeSolidType)
Namespace.addCategoryObject('elementBinding', CompositeSolid.name().localName(), CompositeSolid)

CompositeSurface = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'CompositeSurface'), CompositeSurfaceType)
Namespace.addCategoryObject('elementBinding', CompositeSurface.name().localName(), CompositeSurface)

CompositeValue = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'CompositeValue'), CompositeValueType)
Namespace.addCategoryObject('elementBinding', CompositeValue.name().localName(), CompositeValue)

CompoundCRS = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'CompoundCRS'), CompoundCRSType)
Namespace.addCategoryObject('elementBinding', CompoundCRS.name().localName(), CompoundCRS)

ConcatenatedOperation = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'ConcatenatedOperation'), ConcatenatedOperationType)
Namespace.addCategoryObject('elementBinding', ConcatenatedOperation.name().localName(), ConcatenatedOperation)

Cone = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'Cone'), ConeType)
Namespace.addCategoryObject('elementBinding', Cone.name().localName(), Cone)

ConventionalUnit = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'ConventionalUnit'), ConventionalUnitType)
Namespace.addCategoryObject('elementBinding', ConventionalUnit.name().localName(), ConventionalUnit)

Conversion = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'Conversion'), ConversionType)
Namespace.addCategoryObject('elementBinding', Conversion.name().localName(), Conversion)

CoordinateSystemAxis = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'CoordinateSystemAxis'), CoordinateSystemAxisType)
Namespace.addCategoryObject('elementBinding', CoordinateSystemAxis.name().localName(), CoordinateSystemAxis)

Count = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'Count'), _CTD_ANON_23, nillable=pyxb.binding.datatypes.boolean(1))
Namespace.addCategoryObject('elementBinding', Count.name().localName(), Count)

CountExtent = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'CountExtent'), CountExtentType)
Namespace.addCategoryObject('elementBinding', CountExtent.name().localName(), CountExtent)

CountList = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'CountList'), integerOrNilReasonList)
Namespace.addCategoryObject('elementBinding', CountList.name().localName(), CountList)

CoverageMappingRule = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'CoverageMappingRule'), MappingRuleType)
Namespace.addCategoryObject('elementBinding', CoverageMappingRule.name().localName(), CoverageMappingRule)

CubicSpline = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'CubicSpline'), CubicSplineType)
Namespace.addCategoryObject('elementBinding', CubicSpline.name().localName(), CubicSpline)

Curve = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'Curve'), CurveType)
Namespace.addCategoryObject('elementBinding', Curve.name().localName(), Curve)

Cylinder = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'Cylinder'), CylinderType)
Namespace.addCategoryObject('elementBinding', Cylinder.name().localName(), Cylinder)

CylindricalCS = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'CylindricalCS'), CylindricalCSType)
Namespace.addCategoryObject('elementBinding', CylindricalCS.name().localName(), CylindricalCS)

DataBlock = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'DataBlock'), DataBlockType)
Namespace.addCategoryObject('elementBinding', DataBlock.name().localName(), DataBlock)

Definition = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'Definition'), DefinitionType)
Namespace.addCategoryObject('elementBinding', Definition.name().localName(), Definition)

DefinitionCollection = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'DefinitionCollection'), DictionaryType)
Namespace.addCategoryObject('elementBinding', DefinitionCollection.name().localName(), DefinitionCollection)

DefinitionProxy = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'DefinitionProxy'), DefinitionProxyType)
Namespace.addCategoryObject('elementBinding', DefinitionProxy.name().localName(), DefinitionProxy)

DerivedCRS = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'DerivedCRS'), DerivedCRSType)
Namespace.addCategoryObject('elementBinding', DerivedCRS.name().localName(), DerivedCRS)

DerivedUnit = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'DerivedUnit'), DerivedUnitType)
Namespace.addCategoryObject('elementBinding', DerivedUnit.name().localName(), DerivedUnit)

Dictionary = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'Dictionary'), DictionaryType)
Namespace.addCategoryObject('elementBinding', Dictionary.name().localName(), Dictionary)

DirectedObservation = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'DirectedObservation'), DirectedObservationType)
Namespace.addCategoryObject('elementBinding', DirectedObservation.name().localName(), DirectedObservation)

DirectedObservationAtDistance = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'DirectedObservationAtDistance'), DirectedObservationAtDistanceType)
Namespace.addCategoryObject('elementBinding', DirectedObservationAtDistance.name().localName(), DirectedObservationAtDistance)

DynamicFeature = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'DynamicFeature'), DynamicFeatureType)
Namespace.addCategoryObject('elementBinding', DynamicFeature.name().localName(), DynamicFeature)

DynamicFeatureCollection = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'DynamicFeatureCollection'), DynamicFeatureCollectionType)
Namespace.addCategoryObject('elementBinding', DynamicFeatureCollection.name().localName(), DynamicFeatureCollection)

Edge = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'Edge'), EdgeType)
Namespace.addCategoryObject('elementBinding', Edge.name().localName(), Edge)

Ellipsoid = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'Ellipsoid'), EllipsoidType)
Namespace.addCategoryObject('elementBinding', Ellipsoid.name().localName(), Ellipsoid)

EllipsoidalCS = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'EllipsoidalCS'), EllipsoidalCSType)
Namespace.addCategoryObject('elementBinding', EllipsoidalCS.name().localName(), EllipsoidalCS)

EngineeringCRS = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'EngineeringCRS'), EngineeringCRSType)
Namespace.addCategoryObject('elementBinding', EngineeringCRS.name().localName(), EngineeringCRS)

EngineeringDatum = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'EngineeringDatum'), EngineeringDatumType)
Namespace.addCategoryObject('elementBinding', EngineeringDatum.name().localName(), EngineeringDatum)

Envelope = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'Envelope'), EnvelopeType)
Namespace.addCategoryObject('elementBinding', Envelope.name().localName(), Envelope)

EnvelopeWithTimePeriod = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'EnvelopeWithTimePeriod'), EnvelopeWithTimePeriodType)
Namespace.addCategoryObject('elementBinding', EnvelopeWithTimePeriod.name().localName(), EnvelopeWithTimePeriod)

Face = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'Face'), FaceType)
Namespace.addCategoryObject('elementBinding', Face.name().localName(), Face)

FeatureCollection = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'FeatureCollection'), FeatureCollectionType)
Namespace.addCategoryObject('elementBinding', FeatureCollection.name().localName(), FeatureCollection)

File = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'File'), FileType)
Namespace.addCategoryObject('elementBinding', File.name().localName(), File)

GenericMetaData = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'GenericMetaData'), GenericMetaDataType)
Namespace.addCategoryObject('elementBinding', GenericMetaData.name().localName(), GenericMetaData)

GeocentricCRS = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'GeocentricCRS'), GeocentricCRSType)
Namespace.addCategoryObject('elementBinding', GeocentricCRS.name().localName(), GeocentricCRS)

Geodesic = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'Geodesic'), GeodesicType)
Namespace.addCategoryObject('elementBinding', Geodesic.name().localName(), Geodesic)

GeodesicString = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'GeodesicString'), GeodesicStringType)
Namespace.addCategoryObject('elementBinding', GeodesicString.name().localName(), GeodesicString)

GeodeticCRS = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'GeodeticCRS'), GeodeticCRSType)
Namespace.addCategoryObject('elementBinding', GeodeticCRS.name().localName(), GeodeticCRS)

GeodeticDatum = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'GeodeticDatum'), GeodeticDatumType)
Namespace.addCategoryObject('elementBinding', GeodeticDatum.name().localName(), GeodeticDatum)

GeographicCRS = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'GeographicCRS'), GeographicCRSType)
Namespace.addCategoryObject('elementBinding', GeographicCRS.name().localName(), GeographicCRS)

GeometricComplex = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'GeometricComplex'), GeometricComplexType)
Namespace.addCategoryObject('elementBinding', GeometricComplex.name().localName(), GeometricComplex)

Grid = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'Grid'), GridType)
Namespace.addCategoryObject('elementBinding', Grid.name().localName(), Grid)

GridCoverage = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'GridCoverage'), GridCoverageType)
Namespace.addCategoryObject('elementBinding', GridCoverage.name().localName(), GridCoverage)

GridFunction = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'GridFunction'), GridFunctionType)
Namespace.addCategoryObject('elementBinding', GridFunction.name().localName(), GridFunction)

ImageCRS = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'ImageCRS'), ImageCRSType)
Namespace.addCategoryObject('elementBinding', ImageCRS.name().localName(), ImageCRS)

ImageDatum = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'ImageDatum'), ImageDatumType)
Namespace.addCategoryObject('elementBinding', ImageDatum.name().localName(), ImageDatum)

LineString = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'LineString'), LineStringType)
Namespace.addCategoryObject('elementBinding', LineString.name().localName(), LineString)

LineStringSegment = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'LineStringSegment'), LineStringSegmentType)
Namespace.addCategoryObject('elementBinding', LineStringSegment.name().localName(), LineStringSegment)

LinearCS = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'LinearCS'), LinearCSType)
Namespace.addCategoryObject('elementBinding', LinearCS.name().localName(), LinearCS)

LinearRing = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'LinearRing'), LinearRingType)
Namespace.addCategoryObject('elementBinding', LinearRing.name().localName(), LinearRing)

LocationKeyWord = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'LocationKeyWord'), CodeType)
Namespace.addCategoryObject('elementBinding', LocationKeyWord.name().localName(), LocationKeyWord)

LocationString = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'LocationString'), StringOrRefType)
Namespace.addCategoryObject('elementBinding', LocationString.name().localName(), LocationString)

MappingRule = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'MappingRule'), StringOrRefType)
Namespace.addCategoryObject('elementBinding', MappingRule.name().localName(), MappingRule)

MovingObjectStatus = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'MovingObjectStatus'), MovingObjectStatusType)
Namespace.addCategoryObject('elementBinding', MovingObjectStatus.name().localName(), MovingObjectStatus)

MultiCurve = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'MultiCurve'), MultiCurveType)
Namespace.addCategoryObject('elementBinding', MultiCurve.name().localName(), MultiCurve)

MultiCurveCoverage = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'MultiCurveCoverage'), MultiCurveCoverageType)
Namespace.addCategoryObject('elementBinding', MultiCurveCoverage.name().localName(), MultiCurveCoverage)

MultiGeometry = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'MultiGeometry'), MultiGeometryType)
Namespace.addCategoryObject('elementBinding', MultiGeometry.name().localName(), MultiGeometry)

MultiPoint = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'MultiPoint'), MultiPointType)
Namespace.addCategoryObject('elementBinding', MultiPoint.name().localName(), MultiPoint)

MultiPointCoverage = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'MultiPointCoverage'), MultiPointCoverageType)
Namespace.addCategoryObject('elementBinding', MultiPointCoverage.name().localName(), MultiPointCoverage)

MultiSolid = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'MultiSolid'), MultiSolidType)
Namespace.addCategoryObject('elementBinding', MultiSolid.name().localName(), MultiSolid)

MultiSolidCoverage = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'MultiSolidCoverage'), MultiSolidCoverageType)
Namespace.addCategoryObject('elementBinding', MultiSolidCoverage.name().localName(), MultiSolidCoverage)

MultiSurface = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'MultiSurface'), MultiSurfaceType)
Namespace.addCategoryObject('elementBinding', MultiSurface.name().localName(), MultiSurface)

MultiSurfaceCoverage = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'MultiSurfaceCoverage'), MultiSurfaceCoverageType)
Namespace.addCategoryObject('elementBinding', MultiSurfaceCoverage.name().localName(), MultiSurfaceCoverage)

Node = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'Node'), NodeType)
Namespace.addCategoryObject('elementBinding', Node.name().localName(), Node)

Null = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'Null'), NilReasonType)
Namespace.addCategoryObject('elementBinding', Null.name().localName(), Null)

ObliqueCartesianCS = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'ObliqueCartesianCS'), ObliqueCartesianCSType)
Namespace.addCategoryObject('elementBinding', ObliqueCartesianCS.name().localName(), ObliqueCartesianCS)

Observation = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'Observation'), ObservationType)
Namespace.addCategoryObject('elementBinding', Observation.name().localName(), Observation)

OffsetCurve = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'OffsetCurve'), OffsetCurveType)
Namespace.addCategoryObject('elementBinding', OffsetCurve.name().localName(), OffsetCurve)

OperationMethod = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'OperationMethod'), OperationMethodType)
Namespace.addCategoryObject('elementBinding', OperationMethod.name().localName(), OperationMethod)

OperationParameter = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'OperationParameter'), OperationParameterType)
Namespace.addCategoryObject('elementBinding', OperationParameter.name().localName(), OperationParameter)

OperationParameterGroup = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'OperationParameterGroup'), OperationParameterGroupType)
Namespace.addCategoryObject('elementBinding', OperationParameterGroup.name().localName(), OperationParameterGroup)

OrientableCurve = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'OrientableCurve'), OrientableCurveType)
Namespace.addCategoryObject('elementBinding', OrientableCurve.name().localName(), OrientableCurve)

OrientableSurface = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'OrientableSurface'), OrientableSurfaceType)
Namespace.addCategoryObject('elementBinding', OrientableSurface.name().localName(), OrientableSurface)

ParameterValue = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'ParameterValue'), ParameterValueType)
Namespace.addCategoryObject('elementBinding', ParameterValue.name().localName(), ParameterValue)

ParameterValueGroup = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'ParameterValueGroup'), ParameterValueGroupType)
Namespace.addCategoryObject('elementBinding', ParameterValueGroup.name().localName(), ParameterValueGroup)

PassThroughOperation = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'PassThroughOperation'), PassThroughOperationType)
Namespace.addCategoryObject('elementBinding', PassThroughOperation.name().localName(), PassThroughOperation)

Point = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'Point'), PointType)
Namespace.addCategoryObject('elementBinding', Point.name().localName(), Point)

PolarCS = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'PolarCS'), PolarCSType)
Namespace.addCategoryObject('elementBinding', PolarCS.name().localName(), PolarCS)

Polygon = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'Polygon'), PolygonType)
Namespace.addCategoryObject('elementBinding', Polygon.name().localName(), Polygon)

PolygonPatch = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'PolygonPatch'), PolygonPatchType)
Namespace.addCategoryObject('elementBinding', PolygonPatch.name().localName(), PolygonPatch)

PolyhedralSurface = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'PolyhedralSurface'), PolyhedralSurfaceType)
Namespace.addCategoryObject('elementBinding', PolyhedralSurface.name().localName(), PolyhedralSurface)

PrimeMeridian = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'PrimeMeridian'), PrimeMeridianType)
Namespace.addCategoryObject('elementBinding', PrimeMeridian.name().localName(), PrimeMeridian)

ProjectedCRS = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'ProjectedCRS'), ProjectedCRSType)
Namespace.addCategoryObject('elementBinding', ProjectedCRS.name().localName(), ProjectedCRS)

Quantity = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'Quantity'), _CTD_ANON_27, nillable=pyxb.binding.datatypes.boolean(1))
Namespace.addCategoryObject('elementBinding', Quantity.name().localName(), Quantity)

QuantityExtent = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'QuantityExtent'), QuantityExtentType)
Namespace.addCategoryObject('elementBinding', QuantityExtent.name().localName(), QuantityExtent)

QuantityList = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'QuantityList'), MeasureOrNilReasonListType)
Namespace.addCategoryObject('elementBinding', QuantityList.name().localName(), QuantityList)

Rectangle = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'Rectangle'), RectangleType)
Namespace.addCategoryObject('elementBinding', Rectangle.name().localName(), Rectangle)

RectifiedGrid = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'RectifiedGrid'), RectifiedGridType)
Namespace.addCategoryObject('elementBinding', RectifiedGrid.name().localName(), RectifiedGrid)

RectifiedGridCoverage = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'RectifiedGridCoverage'), RectifiedGridCoverageType)
Namespace.addCategoryObject('elementBinding', RectifiedGridCoverage.name().localName(), RectifiedGridCoverage)

Ring = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'Ring'), RingType)
Namespace.addCategoryObject('elementBinding', Ring.name().localName(), Ring)

SecondDefiningParameter = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'SecondDefiningParameter'), _CTD_ANON_16)
Namespace.addCategoryObject('elementBinding', SecondDefiningParameter.name().localName(), SecondDefiningParameter)

Shell = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'Shell'), ShellType)
Namespace.addCategoryObject('elementBinding', Shell.name().localName(), Shell)

Solid = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'Solid'), SolidType)
Namespace.addCategoryObject('elementBinding', Solid.name().localName(), Solid)

Sphere = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'Sphere'), SphereType)
Namespace.addCategoryObject('elementBinding', Sphere.name().localName(), Sphere)

SphericalCS = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'SphericalCS'), SphericalCSType)
Namespace.addCategoryObject('elementBinding', SphericalCS.name().localName(), SphericalCS)

Surface = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'Surface'), SurfaceType)
Namespace.addCategoryObject('elementBinding', Surface.name().localName(), Surface)

TemporalCRS = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'TemporalCRS'), TemporalCRSType)
Namespace.addCategoryObject('elementBinding', TemporalCRS.name().localName(), TemporalCRS)

TemporalCS = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'TemporalCS'), TemporalCSType)
Namespace.addCategoryObject('elementBinding', TemporalCS.name().localName(), TemporalCS)

TemporalDatum = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'TemporalDatum'), TemporalDatumType)
Namespace.addCategoryObject('elementBinding', TemporalDatum.name().localName(), TemporalDatum)

TimeCS = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'TimeCS'), TimeCSType)
Namespace.addCategoryObject('elementBinding', TimeCS.name().localName(), TimeCS)

TimeCalendar = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'TimeCalendar'), TimeCalendarType)
Namespace.addCategoryObject('elementBinding', TimeCalendar.name().localName(), TimeCalendar)

TimeCalendarEra = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'TimeCalendarEra'), TimeCalendarEraType)
Namespace.addCategoryObject('elementBinding', TimeCalendarEra.name().localName(), TimeCalendarEra)

TimeClock = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'TimeClock'), TimeClockType)
Namespace.addCategoryObject('elementBinding', TimeClock.name().localName(), TimeClock)

TimeCoordinateSystem = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'TimeCoordinateSystem'), TimeCoordinateSystemType)
Namespace.addCategoryObject('elementBinding', TimeCoordinateSystem.name().localName(), TimeCoordinateSystem)

TimeEdge = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'TimeEdge'), TimeEdgeType)
Namespace.addCategoryObject('elementBinding', TimeEdge.name().localName(), TimeEdge)

TimeInstant = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'TimeInstant'), TimeInstantType)
Namespace.addCategoryObject('elementBinding', TimeInstant.name().localName(), TimeInstant)

TimeNode = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'TimeNode'), TimeNodeType)
Namespace.addCategoryObject('elementBinding', TimeNode.name().localName(), TimeNode)

TimeOrdinalEra = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'TimeOrdinalEra'), TimeOrdinalEraType)
Namespace.addCategoryObject('elementBinding', TimeOrdinalEra.name().localName(), TimeOrdinalEra)

TimeOrdinalReferenceSystem = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'TimeOrdinalReferenceSystem'), TimeOrdinalReferenceSystemType)
Namespace.addCategoryObject('elementBinding', TimeOrdinalReferenceSystem.name().localName(), TimeOrdinalReferenceSystem)

TimePeriod = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'TimePeriod'), TimePeriodType)
Namespace.addCategoryObject('elementBinding', TimePeriod.name().localName(), TimePeriod)

TimeReferenceSystem = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'TimeReferenceSystem'), TimeReferenceSystemType)
Namespace.addCategoryObject('elementBinding', TimeReferenceSystem.name().localName(), TimeReferenceSystem)

TimeTopologyComplex = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'TimeTopologyComplex'), TimeTopologyComplexType)
Namespace.addCategoryObject('elementBinding', TimeTopologyComplex.name().localName(), TimeTopologyComplex)

Tin = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'Tin'), TinType)
Namespace.addCategoryObject('elementBinding', Tin.name().localName(), Tin)

TopoComplex = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'TopoComplex'), TopoComplexType)
Namespace.addCategoryObject('elementBinding', TopoComplex.name().localName(), TopoComplex)

TopoCurve = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'TopoCurve'), TopoCurveType)
Namespace.addCategoryObject('elementBinding', TopoCurve.name().localName(), TopoCurve)

TopoPoint = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'TopoPoint'), TopoPointType)
Namespace.addCategoryObject('elementBinding', TopoPoint.name().localName(), TopoPoint)

TopoSolid = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'TopoSolid'), TopoSolidType)
Namespace.addCategoryObject('elementBinding', TopoSolid.name().localName(), TopoSolid)

TopoSurface = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'TopoSurface'), TopoSurfaceType)
Namespace.addCategoryObject('elementBinding', TopoSurface.name().localName(), TopoSurface)

TopoVolume = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'TopoVolume'), TopoVolumeType)
Namespace.addCategoryObject('elementBinding', TopoVolume.name().localName(), TopoVolume)

Transformation = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'Transformation'), TransformationType)
Namespace.addCategoryObject('elementBinding', Transformation.name().localName(), Transformation)

Triangle = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'Triangle'), TriangleType)
Namespace.addCategoryObject('elementBinding', Triangle.name().localName(), Triangle)

TriangulatedSurface = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'TriangulatedSurface'), TriangulatedSurfaceType)
Namespace.addCategoryObject('elementBinding', TriangulatedSurface.name().localName(), TriangulatedSurface)

UnitDefinition = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'UnitDefinition'), UnitDefinitionType)
Namespace.addCategoryObject('elementBinding', UnitDefinition.name().localName(), UnitDefinition)

UserDefinedCS = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'UserDefinedCS'), UserDefinedCSType)
Namespace.addCategoryObject('elementBinding', UserDefinedCS.name().localName(), UserDefinedCS)

ValueArray = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'ValueArray'), ValueArrayType)
Namespace.addCategoryObject('elementBinding', ValueArray.name().localName(), ValueArray)

VerticalCRS = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'VerticalCRS'), VerticalCRSType)
Namespace.addCategoryObject('elementBinding', VerticalCRS.name().localName(), VerticalCRS)

VerticalCS = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'VerticalCS'), VerticalCSType)
Namespace.addCategoryObject('elementBinding', VerticalCS.name().localName(), VerticalCS)

VerticalDatum = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'VerticalDatum'), VerticalDatumType)
Namespace.addCategoryObject('elementBinding', VerticalDatum.name().localName(), VerticalDatum)

abstractAssociationRole = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'abstractAssociationRole'), AssociationRoleType, abstract=pyxb.binding.datatypes.boolean(1))
Namespace.addCategoryObject('elementBinding', abstractAssociationRole.name().localName(), abstractAssociationRole)

abstractGeneralOperationParameterRef = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'abstractGeneralOperationParameterRef'), AbstractGeneralOperationParameterPropertyType)
Namespace.addCategoryObject('elementBinding', abstractGeneralOperationParameterRef.name().localName(), abstractGeneralOperationParameterRef)

abstractInlineProperty = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'abstractInlineProperty'), InlinePropertyType, abstract=pyxb.binding.datatypes.boolean(1))
Namespace.addCategoryObject('elementBinding', abstractInlineProperty.name().localName(), abstractInlineProperty)

abstractReference = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'abstractReference'), ReferenceType, abstract=pyxb.binding.datatypes.boolean(1))
Namespace.addCategoryObject('elementBinding', abstractReference.name().localName(), abstractReference)

abstractStrictAssociationRole = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'abstractStrictAssociationRole'), AssociationRoleType, abstract=pyxb.binding.datatypes.boolean(1))
Namespace.addCategoryObject('elementBinding', abstractStrictAssociationRole.name().localName(), abstractStrictAssociationRole)

affineCS = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'affineCS'), AffineCSPropertyType)
Namespace.addCategoryObject('elementBinding', affineCS.name().localName(), affineCS)

anchorDefinition = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'anchorDefinition'), CodeType)
Namespace.addCategoryObject('elementBinding', anchorDefinition.name().localName(), anchorDefinition)

anchorPoint = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'anchorPoint'), CodeType)
Namespace.addCategoryObject('elementBinding', anchorPoint.name().localName(), anchorPoint)

angle = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'angle'), AngleType)
Namespace.addCategoryObject('elementBinding', angle.name().localName(), angle)

associationName = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'associationName'), pyxb.binding.datatypes.string)
Namespace.addCategoryObject('elementBinding', associationName.name().localName(), associationName)

axis = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'axis'), CoordinateSystemAxisPropertyType)
Namespace.addCategoryObject('elementBinding', axis.name().localName(), axis)

axisAbbrev = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'axisAbbrev'), CodeType)
Namespace.addCategoryObject('elementBinding', axisAbbrev.name().localName(), axisAbbrev)

axisDirection = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'axisDirection'), CodeWithAuthorityType)
Namespace.addCategoryObject('elementBinding', axisDirection.name().localName(), axisDirection)

baseCRS = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'baseCRS'), SingleCRSPropertyType)
Namespace.addCategoryObject('elementBinding', baseCRS.name().localName(), baseCRS)

baseCurve = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'baseCurve'), CurvePropertyType)
Namespace.addCategoryObject('elementBinding', baseCurve.name().localName(), baseCurve)

baseGeodeticCRS = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'baseGeodeticCRS'), GeodeticCRSPropertyType)
Namespace.addCategoryObject('elementBinding', baseGeodeticCRS.name().localName(), baseGeodeticCRS)

baseGeographicCRS = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'baseGeographicCRS'), GeographicCRSPropertyType)
Namespace.addCategoryObject('elementBinding', baseGeographicCRS.name().localName(), baseGeographicCRS)

baseSurface = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'baseSurface'), SurfacePropertyType)
Namespace.addCategoryObject('elementBinding', baseSurface.name().localName(), baseSurface)

booleanValue = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'booleanValue'), pyxb.binding.datatypes.boolean)
Namespace.addCategoryObject('elementBinding', booleanValue.name().localName(), booleanValue)

boundedBy = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'boundedBy'), BoundingShapeType, nillable=pyxb.binding.datatypes.boolean(1))
Namespace.addCategoryObject('elementBinding', boundedBy.name().localName(), boundedBy)

cartesianCS = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'cartesianCS'), CartesianCSPropertyType)
Namespace.addCategoryObject('elementBinding', cartesianCS.name().localName(), cartesianCS)

cartesianCSRef = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'cartesianCSRef'), CartesianCSPropertyType)
Namespace.addCategoryObject('elementBinding', cartesianCSRef.name().localName(), cartesianCSRef)

catalogSymbol = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'catalogSymbol'), CodeType)
Namespace.addCategoryObject('elementBinding', catalogSymbol.name().localName(), catalogSymbol)

centerLineOf = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'centerLineOf'), CurvePropertyType)
Namespace.addCategoryObject('elementBinding', centerLineOf.name().localName(), centerLineOf)

centerOf = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'centerOf'), PointPropertyType)
Namespace.addCategoryObject('elementBinding', centerOf.name().localName(), centerOf)

componentReferenceSystem = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'componentReferenceSystem'), SingleCRSPropertyType)
Namespace.addCategoryObject('elementBinding', componentReferenceSystem.name().localName(), componentReferenceSystem)

compoundCRSRef = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'compoundCRSRef'), CompoundCRSPropertyType)
Namespace.addCategoryObject('elementBinding', compoundCRSRef.name().localName(), compoundCRSRef)

concatenatedOperationRef = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'concatenatedOperationRef'), ConcatenatedOperationPropertyType)
Namespace.addCategoryObject('elementBinding', concatenatedOperationRef.name().localName(), concatenatedOperationRef)

container = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'container'), ContainerPropertyType)
Namespace.addCategoryObject('elementBinding', container.name().localName(), container)

conversion = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'conversion'), GeneralConversionPropertyType)
Namespace.addCategoryObject('elementBinding', conversion.name().localName(), conversion)

conversionRef = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'conversionRef'), ConversionPropertyType)
Namespace.addCategoryObject('elementBinding', conversionRef.name().localName(), conversionRef)

conversionToPreferredUnit = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'conversionToPreferredUnit'), ConversionToPreferredUnitType)
Namespace.addCategoryObject('elementBinding', conversionToPreferredUnit.name().localName(), conversionToPreferredUnit)

coordOperation = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'coordOperation'), CoordinateOperationPropertyType)
Namespace.addCategoryObject('elementBinding', coordOperation.name().localName(), coordOperation)

coordinateOperationAccuracy = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'coordinateOperationAccuracy'), _CTD_ANON_25)
Namespace.addCategoryObject('elementBinding', coordinateOperationAccuracy.name().localName(), coordinateOperationAccuracy)

coordinateOperationRef = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'coordinateOperationRef'), CoordinateOperationPropertyType)
Namespace.addCategoryObject('elementBinding', coordinateOperationRef.name().localName(), coordinateOperationRef)

coordinateSystem = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'coordinateSystem'), CoordinateSystemPropertyType)
Namespace.addCategoryObject('elementBinding', coordinateSystem.name().localName(), coordinateSystem)

coordinateSystemAxisRef = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'coordinateSystemAxisRef'), CoordinateSystemAxisPropertyType)
Namespace.addCategoryObject('elementBinding', coordinateSystemAxisRef.name().localName(), coordinateSystemAxisRef)

coordinateSystemRef = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'coordinateSystemRef'), CoordinateSystemPropertyType)
Namespace.addCategoryObject('elementBinding', coordinateSystemRef.name().localName(), coordinateSystemRef)

coordinates = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'coordinates'), CoordinatesType)
Namespace.addCategoryObject('elementBinding', coordinates.name().localName(), coordinates)

coverageFunction = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'coverageFunction'), CoverageFunctionType)
Namespace.addCategoryObject('elementBinding', coverageFunction.name().localName(), coverageFunction)

crsRef = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'crsRef'), CRSPropertyType)
Namespace.addCategoryObject('elementBinding', crsRef.name().localName(), crsRef)

curveArrayProperty = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'curveArrayProperty'), CurveArrayPropertyType)
Namespace.addCategoryObject('elementBinding', curveArrayProperty.name().localName(), curveArrayProperty)

curveMember = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'curveMember'), CurvePropertyType)
Namespace.addCategoryObject('elementBinding', curveMember.name().localName(), curveMember)

curveMembers = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'curveMembers'), CurveArrayPropertyType)
Namespace.addCategoryObject('elementBinding', curveMembers.name().localName(), curveMembers)

curveProperty = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'curveProperty'), CurvePropertyType)
Namespace.addCategoryObject('elementBinding', curveProperty.name().localName(), curveProperty)

cylindricalCSRef = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'cylindricalCSRef'), CylindricalCSPropertyType)
Namespace.addCategoryObject('elementBinding', cylindricalCSRef.name().localName(), cylindricalCSRef)

dataSource = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'dataSource'), StringOrRefType)
Namespace.addCategoryObject('elementBinding', dataSource.name().localName(), dataSource)

dataSourceReference = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'dataSourceReference'), ReferenceType)
Namespace.addCategoryObject('elementBinding', dataSourceReference.name().localName(), dataSourceReference)

datumRef = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'datumRef'), DatumPropertyType)
Namespace.addCategoryObject('elementBinding', datumRef.name().localName(), datumRef)

decimalMinutes = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'decimalMinutes'), DecimalMinutesType)
Namespace.addCategoryObject('elementBinding', decimalMinutes.name().localName(), decimalMinutes)

defaultCodeSpace = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'defaultCodeSpace'), pyxb.binding.datatypes.anyURI)
Namespace.addCategoryObject('elementBinding', defaultCodeSpace.name().localName(), defaultCodeSpace)

definedByConversion = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'definedByConversion'), GeneralConversionPropertyType)
Namespace.addCategoryObject('elementBinding', definedByConversion.name().localName(), definedByConversion)

definitionMember = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'definitionMember'), DictionaryEntryType)
Namespace.addCategoryObject('elementBinding', definitionMember.name().localName(), definitionMember)

definitionRef = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'definitionRef'), ReferenceType)
Namespace.addCategoryObject('elementBinding', definitionRef.name().localName(), definitionRef)

degrees = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'degrees'), DegreesType)
Namespace.addCategoryObject('elementBinding', degrees.name().localName(), degrees)

derivationUnitTerm = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'derivationUnitTerm'), DerivationUnitTermType)
Namespace.addCategoryObject('elementBinding', derivationUnitTerm.name().localName(), derivationUnitTerm)

derivedCRSRef = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'derivedCRSRef'), DerivedCRSPropertyType)
Namespace.addCategoryObject('elementBinding', derivedCRSRef.name().localName(), derivedCRSRef)

derivedCRSType = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'derivedCRSType'), CodeWithAuthorityType)
Namespace.addCategoryObject('elementBinding', derivedCRSType.name().localName(), derivedCRSType)

description = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'description'), StringOrRefType)
Namespace.addCategoryObject('elementBinding', description.name().localName(), description)

descriptionReference = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'descriptionReference'), ReferenceType)
Namespace.addCategoryObject('elementBinding', descriptionReference.name().localName(), descriptionReference)

dictionaryEntry = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'dictionaryEntry'), DictionaryEntryType)
Namespace.addCategoryObject('elementBinding', dictionaryEntry.name().localName(), dictionaryEntry)

directedEdge = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'directedEdge'), DirectedEdgePropertyType)
Namespace.addCategoryObject('elementBinding', directedEdge.name().localName(), directedEdge)

directedFace = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'directedFace'), DirectedFacePropertyType)
Namespace.addCategoryObject('elementBinding', directedFace.name().localName(), directedFace)

directedNode = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'directedNode'), DirectedNodePropertyType)
Namespace.addCategoryObject('elementBinding', directedNode.name().localName(), directedNode)

directedTopoSolid = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'directedTopoSolid'), DirectedTopoSolidPropertyType)
Namespace.addCategoryObject('elementBinding', directedTopoSolid.name().localName(), directedTopoSolid)

direction = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'direction'), DirectionPropertyType)
Namespace.addCategoryObject('elementBinding', direction.name().localName(), direction)

dmsAngle = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'dmsAngle'), DMSAngleType)
Namespace.addCategoryObject('elementBinding', dmsAngle.name().localName(), dmsAngle)

dmsAngleValue = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'dmsAngleValue'), DMSAngleType)
Namespace.addCategoryObject('elementBinding', dmsAngleValue.name().localName(), dmsAngleValue)

domainOfValidity = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'domainOfValidity'), _CTD_ANON_22)
Namespace.addCategoryObject('elementBinding', domainOfValidity.name().localName(), domainOfValidity)

domainSet = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'domainSet'), DomainSetType)
Namespace.addCategoryObject('elementBinding', domainSet.name().localName(), domainSet)

doubleOrNilReasonTupleList = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'doubleOrNilReasonTupleList'), doubleOrNilReasonList)
Namespace.addCategoryObject('elementBinding', doubleOrNilReasonTupleList.name().localName(), doubleOrNilReasonTupleList)

duration = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'duration'), pyxb.binding.datatypes.duration)
Namespace.addCategoryObject('elementBinding', duration.name().localName(), duration)

dynamicMembers = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'dynamicMembers'), DynamicFeatureMemberType)
Namespace.addCategoryObject('elementBinding', dynamicMembers.name().localName(), dynamicMembers)

edgeOf = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'edgeOf'), CurvePropertyType)
Namespace.addCategoryObject('elementBinding', edgeOf.name().localName(), edgeOf)

ellipsoid = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'ellipsoid'), EllipsoidPropertyType)
Namespace.addCategoryObject('elementBinding', ellipsoid.name().localName(), ellipsoid)

ellipsoidRef = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'ellipsoidRef'), EllipsoidPropertyType)
Namespace.addCategoryObject('elementBinding', ellipsoidRef.name().localName(), ellipsoidRef)

ellipsoidalCS = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'ellipsoidalCS'), EllipsoidalCSPropertyType)
Namespace.addCategoryObject('elementBinding', ellipsoidalCS.name().localName(), ellipsoidalCS)

ellipsoidalCSRef = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'ellipsoidalCSRef'), EllipsoidalCSPropertyType)
Namespace.addCategoryObject('elementBinding', ellipsoidalCSRef.name().localName(), ellipsoidalCSRef)

engineeringCRSRef = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'engineeringCRSRef'), EngineeringCRSPropertyType)
Namespace.addCategoryObject('elementBinding', engineeringCRSRef.name().localName(), engineeringCRSRef)

engineeringDatum = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'engineeringDatum'), EngineeringDatumPropertyType)
Namespace.addCategoryObject('elementBinding', engineeringDatum.name().localName(), engineeringDatum)

engineeringDatumRef = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'engineeringDatumRef'), EngineeringDatumPropertyType)
Namespace.addCategoryObject('elementBinding', engineeringDatumRef.name().localName(), engineeringDatumRef)

extentOf = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'extentOf'), SurfacePropertyType)
Namespace.addCategoryObject('elementBinding', extentOf.name().localName(), extentOf)

exterior = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'exterior'), AbstractRingPropertyType)
Namespace.addCategoryObject('elementBinding', exterior.name().localName(), exterior)

featureMember = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'featureMember'), FeaturePropertyType)
Namespace.addCategoryObject('elementBinding', featureMember.name().localName(), featureMember)

featureMembers = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'featureMembers'), FeatureArrayPropertyType)
Namespace.addCategoryObject('elementBinding', featureMembers.name().localName(), featureMembers)

featureProperty = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'featureProperty'), FeaturePropertyType)
Namespace.addCategoryObject('elementBinding', featureProperty.name().localName(), featureProperty)

formula = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'formula'), CodeType)
Namespace.addCategoryObject('elementBinding', formula.name().localName(), formula)

generalConversionRef = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'generalConversionRef'), GeneralConversionPropertyType)
Namespace.addCategoryObject('elementBinding', generalConversionRef.name().localName(), generalConversionRef)

generalOperationParameter = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'generalOperationParameter'), AbstractGeneralOperationParameterPropertyType)
Namespace.addCategoryObject('elementBinding', generalOperationParameter.name().localName(), generalOperationParameter)

generalTransformationRef = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'generalTransformationRef'), GeneralTransformationPropertyType)
Namespace.addCategoryObject('elementBinding', generalTransformationRef.name().localName(), generalTransformationRef)

geocentricCRSRef = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'geocentricCRSRef'), GeocentricCRSPropertyType)
Namespace.addCategoryObject('elementBinding', geocentricCRSRef.name().localName(), geocentricCRSRef)

geodeticDatum = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'geodeticDatum'), GeodeticDatumPropertyType)
Namespace.addCategoryObject('elementBinding', geodeticDatum.name().localName(), geodeticDatum)

geodeticDatumRef = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'geodeticDatumRef'), GeodeticDatumPropertyType)
Namespace.addCategoryObject('elementBinding', geodeticDatumRef.name().localName(), geodeticDatumRef)

geographicCRSRef = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'geographicCRSRef'), GeographicCRSPropertyType)
Namespace.addCategoryObject('elementBinding', geographicCRSRef.name().localName(), geographicCRSRef)

geometryMember = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'geometryMember'), GeometryPropertyType)
Namespace.addCategoryObject('elementBinding', geometryMember.name().localName(), geometryMember)

geometryMembers = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'geometryMembers'), GeometryArrayPropertyType)
Namespace.addCategoryObject('elementBinding', geometryMembers.name().localName(), geometryMembers)

greenwichLongitude = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'greenwichLongitude'), AngleType)
Namespace.addCategoryObject('elementBinding', greenwichLongitude.name().localName(), greenwichLongitude)

gridDomain = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'gridDomain'), GridDomainType)
Namespace.addCategoryObject('elementBinding', gridDomain.name().localName(), gridDomain)

group = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'group'), OperationParameterGroupPropertyType)
Namespace.addCategoryObject('elementBinding', group.name().localName(), group)

history = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'history'), HistoryPropertyType)
Namespace.addCategoryObject('elementBinding', history.name().localName(), history)

identifier = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'identifier'), CodeWithAuthorityType)
Namespace.addCategoryObject('elementBinding', identifier.name().localName(), identifier)

imageCRSRef = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'imageCRSRef'), ImageCRSPropertyType)
Namespace.addCategoryObject('elementBinding', imageCRSRef.name().localName(), imageCRSRef)

imageDatum = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'imageDatum'), ImageDatumPropertyType)
Namespace.addCategoryObject('elementBinding', imageDatum.name().localName(), imageDatum)

imageDatumRef = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'imageDatumRef'), ImageDatumPropertyType)
Namespace.addCategoryObject('elementBinding', imageDatumRef.name().localName(), imageDatumRef)

includesParameter = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'includesParameter'), AbstractGeneralOperationParameterPropertyType)
Namespace.addCategoryObject('elementBinding', includesParameter.name().localName(), includesParameter)

includesSingleCRS = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'includesSingleCRS'), SingleCRSPropertyType)
Namespace.addCategoryObject('elementBinding', includesSingleCRS.name().localName(), includesSingleCRS)

includesValue = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'includesValue'), AbstractGeneralParameterValuePropertyType)
Namespace.addCategoryObject('elementBinding', includesValue.name().localName(), includesValue)

indirectEntry = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'indirectEntry'), IndirectEntryType)
Namespace.addCategoryObject('elementBinding', indirectEntry.name().localName(), indirectEntry)

integerValue = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'integerValue'), pyxb.binding.datatypes.positiveInteger)
Namespace.addCategoryObject('elementBinding', integerValue.name().localName(), integerValue)

integerValueList = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'integerValueList'), integerList)
Namespace.addCategoryObject('elementBinding', integerValueList.name().localName(), integerValueList)

interior = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'interior'), AbstractRingPropertyType)
Namespace.addCategoryObject('elementBinding', interior.name().localName(), interior)

isolated = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'isolated'), IsolatedPropertyType)
Namespace.addCategoryObject('elementBinding', isolated.name().localName(), isolated)

linearCSRef = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'linearCSRef'), LinearCSPropertyType)
Namespace.addCategoryObject('elementBinding', linearCSRef.name().localName(), linearCSRef)

location = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'location'), LocationPropertyType)
Namespace.addCategoryObject('elementBinding', location.name().localName(), location)

locationName = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'locationName'), CodeType)
Namespace.addCategoryObject('elementBinding', locationName.name().localName(), locationName)

locationReference = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'locationReference'), ReferenceType)
Namespace.addCategoryObject('elementBinding', locationReference.name().localName(), locationReference)

maximalComplex = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'maximalComplex'), TopoComplexMemberType)
Namespace.addCategoryObject('elementBinding', maximalComplex.name().localName(), maximalComplex)

maximumOccurs = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'maximumOccurs'), pyxb.binding.datatypes.positiveInteger)
Namespace.addCategoryObject('elementBinding', maximumOccurs.name().localName(), maximumOccurs)

maximumValue = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'maximumValue'), pyxb.binding.datatypes.double)
Namespace.addCategoryObject('elementBinding', maximumValue.name().localName(), maximumValue)

measure = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'measure'), MeasureType)
Namespace.addCategoryObject('elementBinding', measure.name().localName(), measure)

member = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'member'), AssociationRoleType)
Namespace.addCategoryObject('elementBinding', member.name().localName(), member)

members = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'members'), ArrayAssociationType)
Namespace.addCategoryObject('elementBinding', members.name().localName(), members)

metaDataProperty = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'metaDataProperty'), MetaDataPropertyType)
Namespace.addCategoryObject('elementBinding', metaDataProperty.name().localName(), metaDataProperty)

method = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'method'), OperationMethodPropertyType)
Namespace.addCategoryObject('elementBinding', method.name().localName(), method)

methodFormula = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'methodFormula'), CodeType)
Namespace.addCategoryObject('elementBinding', methodFormula.name().localName(), methodFormula)

minimumOccurs = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'minimumOccurs'), pyxb.binding.datatypes.nonNegativeInteger)
Namespace.addCategoryObject('elementBinding', minimumOccurs.name().localName(), minimumOccurs)

minimumValue = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'minimumValue'), pyxb.binding.datatypes.double)
Namespace.addCategoryObject('elementBinding', minimumValue.name().localName(), minimumValue)

minutes = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'minutes'), ArcMinutesType)
Namespace.addCategoryObject('elementBinding', minutes.name().localName(), minutes)

modifiedCoordinate = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'modifiedCoordinate'), pyxb.binding.datatypes.positiveInteger)
Namespace.addCategoryObject('elementBinding', modifiedCoordinate.name().localName(), modifiedCoordinate)

multiCenterLineOf = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'multiCenterLineOf'), MultiCurvePropertyType)
Namespace.addCategoryObject('elementBinding', multiCenterLineOf.name().localName(), multiCenterLineOf)

multiCenterOf = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'multiCenterOf'), MultiPointPropertyType)
Namespace.addCategoryObject('elementBinding', multiCenterOf.name().localName(), multiCenterOf)

multiCoverage = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'multiCoverage'), MultiSurfacePropertyType)
Namespace.addCategoryObject('elementBinding', multiCoverage.name().localName(), multiCoverage)

multiCurveDomain = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'multiCurveDomain'), MultiCurveDomainType)
Namespace.addCategoryObject('elementBinding', multiCurveDomain.name().localName(), multiCurveDomain)

multiCurveProperty = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'multiCurveProperty'), MultiCurvePropertyType)
Namespace.addCategoryObject('elementBinding', multiCurveProperty.name().localName(), multiCurveProperty)

multiEdgeOf = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'multiEdgeOf'), MultiCurvePropertyType)
Namespace.addCategoryObject('elementBinding', multiEdgeOf.name().localName(), multiEdgeOf)

multiExtentOf = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'multiExtentOf'), MultiSurfacePropertyType)
Namespace.addCategoryObject('elementBinding', multiExtentOf.name().localName(), multiExtentOf)

multiGeometryProperty = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'multiGeometryProperty'), MultiGeometryPropertyType)
Namespace.addCategoryObject('elementBinding', multiGeometryProperty.name().localName(), multiGeometryProperty)

multiLocation = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'multiLocation'), MultiPointPropertyType)
Namespace.addCategoryObject('elementBinding', multiLocation.name().localName(), multiLocation)

multiPointDomain = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'multiPointDomain'), MultiPointDomainType)
Namespace.addCategoryObject('elementBinding', multiPointDomain.name().localName(), multiPointDomain)

multiPointProperty = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'multiPointProperty'), MultiPointPropertyType)
Namespace.addCategoryObject('elementBinding', multiPointProperty.name().localName(), multiPointProperty)

multiPosition = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'multiPosition'), MultiPointPropertyType)
Namespace.addCategoryObject('elementBinding', multiPosition.name().localName(), multiPosition)

multiSolidDomain = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'multiSolidDomain'), MultiSolidDomainType)
Namespace.addCategoryObject('elementBinding', multiSolidDomain.name().localName(), multiSolidDomain)

multiSolidProperty = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'multiSolidProperty'), MultiSolidPropertyType)
Namespace.addCategoryObject('elementBinding', multiSolidProperty.name().localName(), multiSolidProperty)

multiSurfaceDomain = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'multiSurfaceDomain'), MultiSurfaceDomainType)
Namespace.addCategoryObject('elementBinding', multiSurfaceDomain.name().localName(), multiSurfaceDomain)

multiSurfaceProperty = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'multiSurfaceProperty'), MultiSurfacePropertyType)
Namespace.addCategoryObject('elementBinding', multiSurfaceProperty.name().localName(), multiSurfaceProperty)

name = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'name'), CodeType)
Namespace.addCategoryObject('elementBinding', name.name().localName(), name)

obliqueCartesianCSRef = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'obliqueCartesianCSRef'), ObliqueCartesianCSPropertyType)
Namespace.addCategoryObject('elementBinding', obliqueCartesianCSRef.name().localName(), obliqueCartesianCSRef)

operationMethodRef = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'operationMethodRef'), OperationMethodPropertyType)
Namespace.addCategoryObject('elementBinding', operationMethodRef.name().localName(), operationMethodRef)

operationParameter = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'operationParameter'), OperationParameterPropertyType)
Namespace.addCategoryObject('elementBinding', operationParameter.name().localName(), operationParameter)

operationParameterGroupRef = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'operationParameterGroupRef'), OperationParameterPropertyType)
Namespace.addCategoryObject('elementBinding', operationParameterGroupRef.name().localName(), operationParameterGroupRef)

operationParameterRef = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'operationParameterRef'), OperationParameterPropertyType)
Namespace.addCategoryObject('elementBinding', operationParameterRef.name().localName(), operationParameterRef)

operationRef = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'operationRef'), OperationPropertyType)
Namespace.addCategoryObject('elementBinding', operationRef.name().localName(), operationRef)

operationVersion = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'operationVersion'), pyxb.binding.datatypes.string)
Namespace.addCategoryObject('elementBinding', operationVersion.name().localName(), operationVersion)

origin = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'origin'), pyxb.binding.datatypes.dateTime)
Namespace.addCategoryObject('elementBinding', origin.name().localName(), origin)

parameterValue = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'parameterValue'), AbstractGeneralParameterValuePropertyType)
Namespace.addCategoryObject('elementBinding', parameterValue.name().localName(), parameterValue)

passThroughOperationRef = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'passThroughOperationRef'), PassThroughOperationPropertyType)
Namespace.addCategoryObject('elementBinding', passThroughOperationRef.name().localName(), passThroughOperationRef)

patches = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'patches'), SurfacePatchArrayPropertyType)
Namespace.addCategoryObject('elementBinding', patches.name().localName(), patches)

pixelInCell = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'pixelInCell'), CodeWithAuthorityType)
Namespace.addCategoryObject('elementBinding', pixelInCell.name().localName(), pixelInCell)

pointArrayProperty = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'pointArrayProperty'), PointArrayPropertyType)
Namespace.addCategoryObject('elementBinding', pointArrayProperty.name().localName(), pointArrayProperty)

pointMember = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'pointMember'), PointPropertyType)
Namespace.addCategoryObject('elementBinding', pointMember.name().localName(), pointMember)

pointMembers = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'pointMembers'), PointArrayPropertyType)
Namespace.addCategoryObject('elementBinding', pointMembers.name().localName(), pointMembers)

pointProperty = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'pointProperty'), PointPropertyType)
Namespace.addCategoryObject('elementBinding', pointProperty.name().localName(), pointProperty)

pointRep = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'pointRep'), PointPropertyType)
Namespace.addCategoryObject('elementBinding', pointRep.name().localName(), pointRep)

polarCSRef = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'polarCSRef'), PolarCSPropertyType)
Namespace.addCategoryObject('elementBinding', polarCSRef.name().localName(), polarCSRef)

polygonPatches = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'polygonPatches'), PolygonPatchArrayPropertyType)
Namespace.addCategoryObject('elementBinding', polygonPatches.name().localName(), polygonPatches)

pos = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'pos'), DirectPositionType)
Namespace.addCategoryObject('elementBinding', pos.name().localName(), pos)

posList = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'posList'), DirectPositionListType)
Namespace.addCategoryObject('elementBinding', posList.name().localName(), posList)

position = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'position'), PointPropertyType)
Namespace.addCategoryObject('elementBinding', position.name().localName(), position)

primeMeridian = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'primeMeridian'), PrimeMeridianPropertyType)
Namespace.addCategoryObject('elementBinding', primeMeridian.name().localName(), primeMeridian)

primeMeridianRef = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'primeMeridianRef'), PrimeMeridianPropertyType)
Namespace.addCategoryObject('elementBinding', primeMeridianRef.name().localName(), primeMeridianRef)

priorityLocation = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'priorityLocation'), PriorityLocationPropertyType)
Namespace.addCategoryObject('elementBinding', priorityLocation.name().localName(), priorityLocation)

projectedCRSRef = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'projectedCRSRef'), ProjectedCRSPropertyType)
Namespace.addCategoryObject('elementBinding', projectedCRSRef.name().localName(), projectedCRSRef)

quantityType = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'quantityType'), StringOrRefType)
Namespace.addCategoryObject('elementBinding', quantityType.name().localName(), quantityType)

quantityTypeReference = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'quantityTypeReference'), ReferenceType)
Namespace.addCategoryObject('elementBinding', quantityTypeReference.name().localName(), quantityTypeReference)

rangeMeaning = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'rangeMeaning'), CodeWithAuthorityType)
Namespace.addCategoryObject('elementBinding', rangeMeaning.name().localName(), rangeMeaning)

rangeParameters = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'rangeParameters'), RangeParametersType)
Namespace.addCategoryObject('elementBinding', rangeParameters.name().localName(), rangeParameters)

rangeSet = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'rangeSet'), RangeSetType)
Namespace.addCategoryObject('elementBinding', rangeSet.name().localName(), rangeSet)

realizationEpoch = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'realizationEpoch'), pyxb.binding.datatypes.date)
Namespace.addCategoryObject('elementBinding', realizationEpoch.name().localName(), realizationEpoch)

rectifiedGridDomain = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'rectifiedGridDomain'), RectifiedGridDomainType)
Namespace.addCategoryObject('elementBinding', rectifiedGridDomain.name().localName(), rectifiedGridDomain)

remarks = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'remarks'), pyxb.binding.datatypes.string)
Namespace.addCategoryObject('elementBinding', remarks.name().localName(), remarks)

resultOf = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'resultOf'), ResultType)
Namespace.addCategoryObject('elementBinding', resultOf.name().localName(), resultOf)

reversePropertyName = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'reversePropertyName'), pyxb.binding.datatypes.string)
Namespace.addCategoryObject('elementBinding', reversePropertyName.name().localName(), reversePropertyName)

roughConversionToPreferredUnit = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'roughConversionToPreferredUnit'), ConversionToPreferredUnitType)
Namespace.addCategoryObject('elementBinding', roughConversionToPreferredUnit.name().localName(), roughConversionToPreferredUnit)

scope = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'scope'), pyxb.binding.datatypes.string)
Namespace.addCategoryObject('elementBinding', scope.name().localName(), scope)

secondDefiningParameter = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'secondDefiningParameter'), _CTD_ANON_19)
Namespace.addCategoryObject('elementBinding', secondDefiningParameter.name().localName(), secondDefiningParameter)

seconds = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'seconds'), ArcSecondsType)
Namespace.addCategoryObject('elementBinding', seconds.name().localName(), seconds)

segments = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'segments'), CurveSegmentArrayPropertyType)
Namespace.addCategoryObject('elementBinding', segments.name().localName(), segments)

semiMajorAxis = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'semiMajorAxis'), MeasureType)
Namespace.addCategoryObject('elementBinding', semiMajorAxis.name().localName(), semiMajorAxis)

singleCRSRef = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'singleCRSRef'), SingleCRSPropertyType)
Namespace.addCategoryObject('elementBinding', singleCRSRef.name().localName(), singleCRSRef)

singleOperationRef = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'singleOperationRef'), SingleOperationPropertyType)
Namespace.addCategoryObject('elementBinding', singleOperationRef.name().localName(), singleOperationRef)

solidArrayProperty = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'solidArrayProperty'), SolidArrayPropertyType)
Namespace.addCategoryObject('elementBinding', solidArrayProperty.name().localName(), solidArrayProperty)

solidMember = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'solidMember'), SolidPropertyType)
Namespace.addCategoryObject('elementBinding', solidMember.name().localName(), solidMember)

solidMembers = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'solidMembers'), SolidArrayPropertyType)
Namespace.addCategoryObject('elementBinding', solidMembers.name().localName(), solidMembers)

solidProperty = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'solidProperty'), SolidPropertyType)
Namespace.addCategoryObject('elementBinding', solidProperty.name().localName(), solidProperty)

sourceCRS = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'sourceCRS'), CRSPropertyType)
Namespace.addCategoryObject('elementBinding', sourceCRS.name().localName(), sourceCRS)

sourceDimensions = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'sourceDimensions'), pyxb.binding.datatypes.positiveInteger)
Namespace.addCategoryObject('elementBinding', sourceDimensions.name().localName(), sourceDimensions)

sphericalCS = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'sphericalCS'), SphericalCSPropertyType)
Namespace.addCategoryObject('elementBinding', sphericalCS.name().localName(), sphericalCS)

sphericalCSRef = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'sphericalCSRef'), SphericalCSPropertyType)
Namespace.addCategoryObject('elementBinding', sphericalCSRef.name().localName(), sphericalCSRef)

status = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'status'), StringOrRefType)
Namespace.addCategoryObject('elementBinding', status.name().localName(), status)

statusReference = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'statusReference'), ReferenceType)
Namespace.addCategoryObject('elementBinding', statusReference.name().localName(), statusReference)

stringValue = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'stringValue'), pyxb.binding.datatypes.string)
Namespace.addCategoryObject('elementBinding', stringValue.name().localName(), stringValue)

subComplex = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'subComplex'), TopoComplexMemberType)
Namespace.addCategoryObject('elementBinding', subComplex.name().localName(), subComplex)

subject = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'subject'), TargetPropertyType)
Namespace.addCategoryObject('elementBinding', subject.name().localName(), subject)

superComplex = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'superComplex'), TopoComplexMemberType)
Namespace.addCategoryObject('elementBinding', superComplex.name().localName(), superComplex)

surfaceArrayProperty = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'surfaceArrayProperty'), SurfaceArrayPropertyType)
Namespace.addCategoryObject('elementBinding', surfaceArrayProperty.name().localName(), surfaceArrayProperty)

surfaceMember = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'surfaceMember'), SurfacePropertyType)
Namespace.addCategoryObject('elementBinding', surfaceMember.name().localName(), surfaceMember)

surfaceMembers = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'surfaceMembers'), SurfaceArrayPropertyType)
Namespace.addCategoryObject('elementBinding', surfaceMembers.name().localName(), surfaceMembers)

surfaceProperty = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'surfaceProperty'), SurfacePropertyType)
Namespace.addCategoryObject('elementBinding', surfaceProperty.name().localName(), surfaceProperty)

target = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'target'), TargetPropertyType)
Namespace.addCategoryObject('elementBinding', target.name().localName(), target)

targetCRS = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'targetCRS'), CRSPropertyType)
Namespace.addCategoryObject('elementBinding', targetCRS.name().localName(), targetCRS)

targetDimensions = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'targetDimensions'), pyxb.binding.datatypes.positiveInteger)
Namespace.addCategoryObject('elementBinding', targetDimensions.name().localName(), targetDimensions)

targetElement = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'targetElement'), pyxb.binding.datatypes.string)
Namespace.addCategoryObject('elementBinding', targetElement.name().localName(), targetElement)

temporalCRSRef = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'temporalCRSRef'), TemporalCRSPropertyType)
Namespace.addCategoryObject('elementBinding', temporalCRSRef.name().localName(), temporalCRSRef)

temporalCSRef = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'temporalCSRef'), TemporalCSPropertyType)
Namespace.addCategoryObject('elementBinding', temporalCSRef.name().localName(), temporalCSRef)

temporalDatum = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'temporalDatum'), TemporalDatumPropertyType)
Namespace.addCategoryObject('elementBinding', temporalDatum.name().localName(), temporalDatum)

temporalDatumRef = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'temporalDatumRef'), TemporalDatumPropertyType)
Namespace.addCategoryObject('elementBinding', temporalDatumRef.name().localName(), temporalDatumRef)

timeCS = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'timeCS'), TimeCSPropertyType)
Namespace.addCategoryObject('elementBinding', timeCS.name().localName(), timeCS)

timeInterval = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'timeInterval'), TimeIntervalLengthType)
Namespace.addCategoryObject('elementBinding', timeInterval.name().localName(), timeInterval)

timePosition = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'timePosition'), TimePositionType)
Namespace.addCategoryObject('elementBinding', timePosition.name().localName(), timePosition)

topoComplexProperty = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'topoComplexProperty'), TopoComplexMemberType)
Namespace.addCategoryObject('elementBinding', topoComplexProperty.name().localName(), topoComplexProperty)

topoCurveProperty = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'topoCurveProperty'), TopoCurvePropertyType)
Namespace.addCategoryObject('elementBinding', topoCurveProperty.name().localName(), topoCurveProperty)

topoPointProperty = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'topoPointProperty'), TopoPointPropertyType)
Namespace.addCategoryObject('elementBinding', topoPointProperty.name().localName(), topoPointProperty)

topoPrimitiveMember = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'topoPrimitiveMember'), TopoPrimitiveMemberType)
Namespace.addCategoryObject('elementBinding', topoPrimitiveMember.name().localName(), topoPrimitiveMember)

topoPrimitiveMembers = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'topoPrimitiveMembers'), TopoPrimitiveArrayAssociationType)
Namespace.addCategoryObject('elementBinding', topoPrimitiveMembers.name().localName(), topoPrimitiveMembers)

topoSurfaceProperty = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'topoSurfaceProperty'), TopoSurfacePropertyType)
Namespace.addCategoryObject('elementBinding', topoSurfaceProperty.name().localName(), topoSurfaceProperty)

topoVolumeProperty = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'topoVolumeProperty'), TopoVolumePropertyType)
Namespace.addCategoryObject('elementBinding', topoVolumeProperty.name().localName(), topoVolumeProperty)

track = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'track'), HistoryPropertyType)
Namespace.addCategoryObject('elementBinding', track.name().localName(), track)

transformationRef = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'transformationRef'), TransformationPropertyType)
Namespace.addCategoryObject('elementBinding', transformationRef.name().localName(), transformationRef)

trianglePatches = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'trianglePatches'), TrianglePatchArrayPropertyType)
Namespace.addCategoryObject('elementBinding', trianglePatches.name().localName(), trianglePatches)

tupleList = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'tupleList'), CoordinatesType)
Namespace.addCategoryObject('elementBinding', tupleList.name().localName(), tupleList)

unitOfMeasure = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'unitOfMeasure'), UnitOfMeasureType)
Namespace.addCategoryObject('elementBinding', unitOfMeasure.name().localName(), unitOfMeasure)

userDefinedCSRef = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'userDefinedCSRef'), UserDefinedCSPropertyType)
Namespace.addCategoryObject('elementBinding', userDefinedCSRef.name().localName(), userDefinedCSRef)

usesAffineCS = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'usesAffineCS'), AffineCSPropertyType)
Namespace.addCategoryObject('elementBinding', usesAffineCS.name().localName(), usesAffineCS)

usesAxis = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'usesAxis'), CoordinateSystemAxisPropertyType)
Namespace.addCategoryObject('elementBinding', usesAxis.name().localName(), usesAxis)

usesCS = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'usesCS'), CoordinateSystemPropertyType)
Namespace.addCategoryObject('elementBinding', usesCS.name().localName(), usesCS)

usesCartesianCS = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'usesCartesianCS'), CartesianCSPropertyType)
Namespace.addCategoryObject('elementBinding', usesCartesianCS.name().localName(), usesCartesianCS)

usesEllipsoid = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'usesEllipsoid'), EllipsoidPropertyType)
Namespace.addCategoryObject('elementBinding', usesEllipsoid.name().localName(), usesEllipsoid)

usesEllipsoidalCS = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'usesEllipsoidalCS'), EllipsoidalCSPropertyType)
Namespace.addCategoryObject('elementBinding', usesEllipsoidalCS.name().localName(), usesEllipsoidalCS)

usesEngineeringDatum = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'usesEngineeringDatum'), EngineeringDatumPropertyType)
Namespace.addCategoryObject('elementBinding', usesEngineeringDatum.name().localName(), usesEngineeringDatum)

usesGeodeticDatum = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'usesGeodeticDatum'), GeodeticDatumPropertyType)
Namespace.addCategoryObject('elementBinding', usesGeodeticDatum.name().localName(), usesGeodeticDatum)

usesImageDatum = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'usesImageDatum'), ImageDatumPropertyType)
Namespace.addCategoryObject('elementBinding', usesImageDatum.name().localName(), usesImageDatum)

usesMethod = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'usesMethod'), OperationMethodPropertyType)
Namespace.addCategoryObject('elementBinding', usesMethod.name().localName(), usesMethod)

usesObliqueCartesianCS = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'usesObliqueCartesianCS'), ObliqueCartesianCSPropertyType)
Namespace.addCategoryObject('elementBinding', usesObliqueCartesianCS.name().localName(), usesObliqueCartesianCS)

usesOperation = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'usesOperation'), CoordinateOperationPropertyType)
Namespace.addCategoryObject('elementBinding', usesOperation.name().localName(), usesOperation)

usesParameter = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'usesParameter'), AbstractGeneralOperationParameterPropertyType)
Namespace.addCategoryObject('elementBinding', usesParameter.name().localName(), usesParameter)

usesPrimeMeridian = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'usesPrimeMeridian'), PrimeMeridianPropertyType)
Namespace.addCategoryObject('elementBinding', usesPrimeMeridian.name().localName(), usesPrimeMeridian)

usesSingleOperation = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'usesSingleOperation'), CoordinateOperationPropertyType)
Namespace.addCategoryObject('elementBinding', usesSingleOperation.name().localName(), usesSingleOperation)

usesSphericalCS = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'usesSphericalCS'), SphericalCSPropertyType)
Namespace.addCategoryObject('elementBinding', usesSphericalCS.name().localName(), usesSphericalCS)

usesTemporalCS = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'usesTemporalCS'), TemporalCSPropertyType)
Namespace.addCategoryObject('elementBinding', usesTemporalCS.name().localName(), usesTemporalCS)

usesTemporalDatum = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'usesTemporalDatum'), TemporalDatumPropertyType)
Namespace.addCategoryObject('elementBinding', usesTemporalDatum.name().localName(), usesTemporalDatum)

usesTimeCS = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'usesTimeCS'), TimeCSPropertyType)
Namespace.addCategoryObject('elementBinding', usesTimeCS.name().localName(), usesTimeCS)

usesValue = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'usesValue'), AbstractGeneralParameterValuePropertyType)
Namespace.addCategoryObject('elementBinding', usesValue.name().localName(), usesValue)

usesVerticalCS = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'usesVerticalCS'), VerticalCSPropertyType)
Namespace.addCategoryObject('elementBinding', usesVerticalCS.name().localName(), usesVerticalCS)

usesVerticalDatum = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'usesVerticalDatum'), VerticalDatumPropertyType)
Namespace.addCategoryObject('elementBinding', usesVerticalDatum.name().localName(), usesVerticalDatum)

using = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'using'), ProcedurePropertyType)
Namespace.addCategoryObject('elementBinding', using.name().localName(), using)

validTime = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'validTime'), TimePrimitivePropertyType)
Namespace.addCategoryObject('elementBinding', validTime.name().localName(), validTime)

value = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'value'), MeasureType)
Namespace.addCategoryObject('elementBinding', value.name().localName(), value)

valueComponent = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'valueComponent'), ValuePropertyType)
Namespace.addCategoryObject('elementBinding', valueComponent.name().localName(), valueComponent)

valueComponents = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'valueComponents'), ValueArrayPropertyType)
Namespace.addCategoryObject('elementBinding', valueComponents.name().localName(), valueComponents)

valueFile = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'valueFile'), pyxb.binding.datatypes.anyURI)
Namespace.addCategoryObject('elementBinding', valueFile.name().localName(), valueFile)

valueList = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'valueList'), MeasureListType)
Namespace.addCategoryObject('elementBinding', valueList.name().localName(), valueList)

valueOfParameter = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'valueOfParameter'), OperationParameterPropertyType)
Namespace.addCategoryObject('elementBinding', valueOfParameter.name().localName(), valueOfParameter)

valueProperty = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'valueProperty'), ValuePropertyType)
Namespace.addCategoryObject('elementBinding', valueProperty.name().localName(), valueProperty)

valuesOfGroup = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'valuesOfGroup'), OperationParameterGroupPropertyType)
Namespace.addCategoryObject('elementBinding', valuesOfGroup.name().localName(), valuesOfGroup)

vector = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'vector'), VectorType)
Namespace.addCategoryObject('elementBinding', vector.name().localName(), vector)

verticalCRSRef = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'verticalCRSRef'), VerticalCRSPropertyType)
Namespace.addCategoryObject('elementBinding', verticalCRSRef.name().localName(), verticalCRSRef)

verticalCS = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'verticalCS'), VerticalCSPropertyType)
Namespace.addCategoryObject('elementBinding', verticalCS.name().localName(), verticalCS)

verticalCSRef = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'verticalCSRef'), VerticalCSPropertyType)
Namespace.addCategoryObject('elementBinding', verticalCSRef.name().localName(), verticalCSRef)

verticalDatum = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'verticalDatum'), VerticalDatumPropertyType)
Namespace.addCategoryObject('elementBinding', verticalDatum.name().localName(), verticalDatum)

verticalDatumRef = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'verticalDatumRef'), VerticalDatumPropertyType)
Namespace.addCategoryObject('elementBinding', verticalDatumRef.name().localName(), verticalDatumRef)



_CTD_ANON_16._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'inverseFlattening'), MeasureType, scope=_CTD_ANON_16))

_CTD_ANON_16._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'semiMinorAxis'), LengthType, scope=_CTD_ANON_16))

_CTD_ANON_16._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'isSphere'), _STD_ANON_2, scope=_CTD_ANON_16))
_CTD_ANON_16._ContentModel = pyxb.binding.content.ContentModel(state_map = {
      1 : pyxb.binding.content.ContentModelState(state=1, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=_CTD_ANON_16._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'inverseFlattening'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=_CTD_ANON_16._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'isSphere'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=_CTD_ANON_16._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'semiMinorAxis'))),
    ])
    , 2 : pyxb.binding.content.ContentModelState(state=2, is_final=True, transitions=[
    ])
})



_CTD_ANON_17._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'Row'), _CTD_ANON_18, scope=_CTD_ANON_17))
_CTD_ANON_17._ContentModel = pyxb.binding.content.ContentModel(state_map = {
      1 : pyxb.binding.content.ContentModelState(state=1, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=_CTD_ANON_17._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'Row'))),
    ])
    , 2 : pyxb.binding.content.ContentModelState(state=2, is_final=True, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=_CTD_ANON_17._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'Row'))),
    ])
})



_CTD_ANON_19._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'SecondDefiningParameter'), _CTD_ANON_16, scope=_CTD_ANON_19))
_CTD_ANON_19._ContentModel = pyxb.binding.content.ContentModel(state_map = {
      1 : pyxb.binding.content.ContentModelState(state=1, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=_CTD_ANON_19._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'SecondDefiningParameter'))),
    ])
    , 2 : pyxb.binding.content.ContentModelState(state=2, is_final=True, transitions=[
    ])
})



_CTD_ANON_21._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'posList'), DirectPositionListType, scope=_CTD_ANON_21))

_CTD_ANON_21._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'pos'), DirectPositionType, scope=_CTD_ANON_21))

_CTD_ANON_21._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'pointProperty'), PointPropertyType, scope=_CTD_ANON_21))
_CTD_ANON_21._ContentModel = pyxb.binding.content.ContentModel(state_map = {
      1 : pyxb.binding.content.ContentModelState(state=1, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=3, element_use=_CTD_ANON_21._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'posList'))),
        pyxb.binding.content.ContentModelTransition(next_state=5, element_use=_CTD_ANON_21._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'pointProperty'))),
        pyxb.binding.content.ContentModelTransition(next_state=5, element_use=_CTD_ANON_21._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'pos'))),
    ])
    , 2 : pyxb.binding.content.ContentModelState(state=2, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=4, element_use=_CTD_ANON_21._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'pointProperty'))),
        pyxb.binding.content.ContentModelTransition(next_state=4, element_use=_CTD_ANON_21._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'pos'))),
    ])
    , 3 : pyxb.binding.content.ContentModelState(state=3, is_final=True, transitions=[
    ])
    , 4 : pyxb.binding.content.ContentModelState(state=4, is_final=True, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=4, element_use=_CTD_ANON_21._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'pointProperty'))),
        pyxb.binding.content.ContentModelTransition(next_state=4, element_use=_CTD_ANON_21._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'pos'))),
    ])
    , 5 : pyxb.binding.content.ContentModelState(state=5, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=_CTD_ANON_21._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'pointProperty'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=_CTD_ANON_21._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'pos'))),
    ])
})



_CTD_ANON_22._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(MODULEhttpwww_isotc211_org2005gmd.Namespace, u'EX_Extent'), MODULEhttpwww_isotc211_org2005gmd.UNBOUNDhttpwww_isotc211_org2005gmdEX_Extent_Type, scope=_CTD_ANON_22))
_CTD_ANON_22._ContentModel = pyxb.binding.content.ContentModel(state_map = {
      1 : pyxb.binding.content.ContentModelState(state=1, is_final=True, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=_CTD_ANON_22._UseForTag(pyxb.namespace.ExpandedName(MODULEhttpwww_isotc211_org2005gmd.Namespace, u'EX_Extent'))),
    ])
    , 2 : pyxb.binding.content.ContentModelState(state=2, is_final=True, transitions=[
    ])
})



_CTD_ANON_18._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'posList'), DirectPositionListType, scope=_CTD_ANON_18))

_CTD_ANON_18._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'pos'), DirectPositionType, scope=_CTD_ANON_18))

_CTD_ANON_18._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'pointProperty'), PointPropertyType, scope=_CTD_ANON_18))
_CTD_ANON_18._ContentModel = pyxb.binding.content.ContentModel(state_map = {
      1 : pyxb.binding.content.ContentModelState(state=1, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=_CTD_ANON_18._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'posList'))),
        pyxb.binding.content.ContentModelTransition(next_state=3, element_use=_CTD_ANON_18._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'pointProperty'))),
        pyxb.binding.content.ContentModelTransition(next_state=3, element_use=_CTD_ANON_18._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'pos'))),
    ])
    , 2 : pyxb.binding.content.ContentModelState(state=2, is_final=True, transitions=[
    ])
    , 3 : pyxb.binding.content.ContentModelState(state=3, is_final=True, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=3, element_use=_CTD_ANON_18._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'pointProperty'))),
        pyxb.binding.content.ContentModelTransition(next_state=3, element_use=_CTD_ANON_18._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'pos'))),
    ])
})



_CTD_ANON_24._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'AffinePlacement'), AffinePlacementType, scope=_CTD_ANON_24))
_CTD_ANON_24._ContentModel = pyxb.binding.content.ContentModel(state_map = {
      1 : pyxb.binding.content.ContentModelState(state=1, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=_CTD_ANON_24._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'AffinePlacement'))),
    ])
    , 2 : pyxb.binding.content.ContentModelState(state=2, is_final=True, transitions=[
    ])
})



_CTD_ANON_25._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(MODULEhttpwww_isotc211_org2005gmd.Namespace, u'AbstractDQ_PositionalAccuracy'), MODULEhttpwww_isotc211_org2005gmd.UNBOUNDhttpwww_isotc211_org2005gmdAbstractDQ_PositionalAccuracy_Type, abstract=pyxb.binding.datatypes.boolean(1), scope=_CTD_ANON_25))
_CTD_ANON_25._ContentModel = pyxb.binding.content.ContentModel(state_map = {
      1 : pyxb.binding.content.ContentModelState(state=1, is_final=True, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=_CTD_ANON_25._UseForTag(pyxb.namespace.ExpandedName(MODULEhttpwww_isotc211_org2005gmd.Namespace, u'AbstractDQ_PositionalAccuracy'))),
    ])
    , 2 : pyxb.binding.content.ContentModelState(state=2, is_final=True, transitions=[
    ])
})



AbstractGMLType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'descriptionReference'), ReferenceType, scope=AbstractGMLType))

AbstractGMLType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'name'), CodeType, scope=AbstractGMLType))

AbstractGMLType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'identifier'), CodeWithAuthorityType, scope=AbstractGMLType))

AbstractGMLType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'metaDataProperty'), MetaDataPropertyType, scope=AbstractGMLType))

AbstractGMLType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'description'), StringOrRefType, scope=AbstractGMLType))
AbstractGMLType._ContentModel = pyxb.binding.content.ContentModel(state_map = {
      1 : pyxb.binding.content.ContentModelState(state=1, is_final=True, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=AbstractGMLType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'identifier'))),
        pyxb.binding.content.ContentModelTransition(next_state=3, element_use=AbstractGMLType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'descriptionReference'))),
        pyxb.binding.content.ContentModelTransition(next_state=1, element_use=AbstractGMLType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'metaDataProperty'))),
        pyxb.binding.content.ContentModelTransition(next_state=4, element_use=AbstractGMLType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'description'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=AbstractGMLType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name'))),
    ])
    , 2 : pyxb.binding.content.ContentModelState(state=2, is_final=True, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=AbstractGMLType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name'))),
    ])
    , 3 : pyxb.binding.content.ContentModelState(state=3, is_final=True, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=AbstractGMLType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'identifier'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=AbstractGMLType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name'))),
    ])
    , 4 : pyxb.binding.content.ContentModelState(state=4, is_final=True, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=AbstractGMLType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'identifier'))),
        pyxb.binding.content.ContentModelTransition(next_state=3, element_use=AbstractGMLType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'descriptionReference'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=AbstractGMLType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name'))),
    ])
})



AbstractGeneralOperationParameterPropertyType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'AbstractGeneralOperationParameter'), AbstractGeneralOperationParameterType, abstract=pyxb.binding.datatypes.boolean(1), scope=AbstractGeneralOperationParameterPropertyType))
AbstractGeneralOperationParameterPropertyType._ContentModel = pyxb.binding.content.ContentModel(state_map = {
      1 : pyxb.binding.content.ContentModelState(state=1, is_final=True, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=AbstractGeneralOperationParameterPropertyType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'AbstractGeneralOperationParameter'))),
    ])
    , 2 : pyxb.binding.content.ContentModelState(state=2, is_final=True, transitions=[
    ])
})



AbstractGeneralParameterValuePropertyType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'AbstractGeneralParameterValue'), AbstractGeneralParameterValueType, abstract=pyxb.binding.datatypes.boolean(1), scope=AbstractGeneralParameterValuePropertyType))
AbstractGeneralParameterValuePropertyType._ContentModel = pyxb.binding.content.ContentModel(state_map = {
      1 : pyxb.binding.content.ContentModelState(state=1, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=AbstractGeneralParameterValuePropertyType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'AbstractGeneralParameterValue'))),
    ])
    , 2 : pyxb.binding.content.ContentModelState(state=2, is_final=True, transitions=[
    ])
})


AbstractMetaDataType._ContentModel = pyxb.binding.content.ContentModel(state_map = {
      1 : pyxb.binding.content.ContentModelState(state=1, is_final=True, transitions=[
    ])
})



AbstractRingPropertyType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'AbstractRing'), AbstractRingType, abstract=pyxb.binding.datatypes.boolean(1), scope=AbstractRingPropertyType))
AbstractRingPropertyType._ContentModel = pyxb.binding.content.ContentModel(state_map = {
      1 : pyxb.binding.content.ContentModelState(state=1, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=AbstractRingPropertyType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'AbstractRing'))),
    ])
    , 2 : pyxb.binding.content.ContentModelState(state=2, is_final=True, transitions=[
    ])
})



AffineCSPropertyType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'AffineCS'), AffineCSType, scope=AffineCSPropertyType))
AffineCSPropertyType._ContentModel = pyxb.binding.content.ContentModel(state_map = {
      1 : pyxb.binding.content.ContentModelState(state=1, is_final=True, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=AffineCSPropertyType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'AffineCS'))),
    ])
    , 2 : pyxb.binding.content.ContentModelState(state=2, is_final=True, transitions=[
    ])
})



AffinePlacementType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'inDimension'), pyxb.binding.datatypes.positiveInteger, scope=AffinePlacementType))

AffinePlacementType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'location'), DirectPositionType, scope=AffinePlacementType))

AffinePlacementType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'refDirection'), VectorType, scope=AffinePlacementType))

AffinePlacementType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'outDimension'), pyxb.binding.datatypes.positiveInteger, scope=AffinePlacementType))
AffinePlacementType._ContentModel = pyxb.binding.content.ContentModel(state_map = {
      1 : pyxb.binding.content.ContentModelState(state=1, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=AffinePlacementType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'location'))),
    ])
    , 2 : pyxb.binding.content.ContentModelState(state=2, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=3, element_use=AffinePlacementType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'refDirection'))),
    ])
    , 3 : pyxb.binding.content.ContentModelState(state=3, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=3, element_use=AffinePlacementType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'refDirection'))),
        pyxb.binding.content.ContentModelTransition(next_state=4, element_use=AffinePlacementType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'inDimension'))),
    ])
    , 4 : pyxb.binding.content.ContentModelState(state=4, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=5, element_use=AffinePlacementType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'outDimension'))),
    ])
    , 5 : pyxb.binding.content.ContentModelState(state=5, is_final=True, transitions=[
    ])
})



AngleChoiceType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'dmsAngle'), DMSAngleType, scope=AngleChoiceType))

AngleChoiceType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'angle'), AngleType, scope=AngleChoiceType))
AngleChoiceType._ContentModel = pyxb.binding.content.ContentModel(state_map = {
      1 : pyxb.binding.content.ContentModelState(state=1, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=AngleChoiceType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'angle'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=AngleChoiceType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'dmsAngle'))),
    ])
    , 2 : pyxb.binding.content.ContentModelState(state=2, is_final=True, transitions=[
    ])
})



ArrayAssociationType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'AbstractObject'), pyxb.binding.datatypes.anyType, abstract=pyxb.binding.datatypes.boolean(1), scope=ArrayAssociationType))
ArrayAssociationType._ContentModel = pyxb.binding.content.ContentModel(state_map = {
      1 : pyxb.binding.content.ContentModelState(state=1, is_final=True, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=1, element_use=ArrayAssociationType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'AbstractObject'))),
    ])
})



AssociationRoleType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'AbstractObject'), pyxb.binding.datatypes.anyType, abstract=pyxb.binding.datatypes.boolean(1), scope=AssociationRoleType))
AssociationRoleType._ContentModel = pyxb.binding.content.ContentModel(state_map = {
      1 : pyxb.binding.content.ContentModelState(state=1, is_final=True, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=AssociationRoleType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'AbstractObject'))),
    ])
    , 2 : pyxb.binding.content.ContentModelState(state=2, is_final=True, transitions=[
    ])
})



BooleanPropertyType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'Boolean'), _CTD_ANON_20, nillable=pyxb.binding.datatypes.boolean(1), scope=BooleanPropertyType))
BooleanPropertyType._ContentModel = pyxb.binding.content.ContentModel(state_map = {
      1 : pyxb.binding.content.ContentModelState(state=1, is_final=True, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=BooleanPropertyType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'Boolean'))),
    ])
    , 2 : pyxb.binding.content.ContentModelState(state=2, is_final=True, transitions=[
    ])
})



BoundingShapeType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'Null'), NilReasonType, scope=BoundingShapeType))

BoundingShapeType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'Envelope'), EnvelopeType, scope=BoundingShapeType))
BoundingShapeType._ContentModel = pyxb.binding.content.ContentModel(state_map = {
      1 : pyxb.binding.content.ContentModelState(state=1, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=BoundingShapeType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'Envelope'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=BoundingShapeType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'Null'))),
    ])
    , 2 : pyxb.binding.content.ContentModelState(state=2, is_final=True, transitions=[
    ])
})



CRSPropertyType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'AbstractCRS'), AbstractCRSType, abstract=pyxb.binding.datatypes.boolean(1), scope=CRSPropertyType))
CRSPropertyType._ContentModel = pyxb.binding.content.ContentModel(state_map = {
      1 : pyxb.binding.content.ContentModelState(state=1, is_final=True, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=CRSPropertyType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'AbstractCRS'))),
    ])
    , 2 : pyxb.binding.content.ContentModelState(state=2, is_final=True, transitions=[
    ])
})



CartesianCSPropertyType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'CartesianCS'), CartesianCSType, scope=CartesianCSPropertyType))
CartesianCSPropertyType._ContentModel = pyxb.binding.content.ContentModel(state_map = {
      1 : pyxb.binding.content.ContentModelState(state=1, is_final=True, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=CartesianCSPropertyType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'CartesianCS'))),
    ])
    , 2 : pyxb.binding.content.ContentModelState(state=2, is_final=True, transitions=[
    ])
})



CategoryPropertyType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'Category'), _CTD_ANON_26, nillable=pyxb.binding.datatypes.boolean(1), scope=CategoryPropertyType))
CategoryPropertyType._ContentModel = pyxb.binding.content.ContentModel(state_map = {
      1 : pyxb.binding.content.ContentModelState(state=1, is_final=True, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=CategoryPropertyType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'Category'))),
    ])
    , 2 : pyxb.binding.content.ContentModelState(state=2, is_final=True, transitions=[
    ])
})



CompoundCRSPropertyType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'CompoundCRS'), CompoundCRSType, scope=CompoundCRSPropertyType))
CompoundCRSPropertyType._ContentModel = pyxb.binding.content.ContentModel(state_map = {
      1 : pyxb.binding.content.ContentModelState(state=1, is_final=True, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=CompoundCRSPropertyType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'CompoundCRS'))),
    ])
    , 2 : pyxb.binding.content.ContentModelState(state=2, is_final=True, transitions=[
    ])
})



ConcatenatedOperationPropertyType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'ConcatenatedOperation'), ConcatenatedOperationType, scope=ConcatenatedOperationPropertyType))
ConcatenatedOperationPropertyType._ContentModel = pyxb.binding.content.ContentModel(state_map = {
      1 : pyxb.binding.content.ContentModelState(state=1, is_final=True, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=ConcatenatedOperationPropertyType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'ConcatenatedOperation'))),
    ])
    , 2 : pyxb.binding.content.ContentModelState(state=2, is_final=True, transitions=[
    ])
})



ContainerPropertyType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'TopoSolid'), TopoSolidType, scope=ContainerPropertyType))

ContainerPropertyType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'Face'), FaceType, scope=ContainerPropertyType))
ContainerPropertyType._ContentModel = pyxb.binding.content.ContentModel(state_map = {
      1 : pyxb.binding.content.ContentModelState(state=1, is_final=True, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=ContainerPropertyType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'Face'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=ContainerPropertyType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'TopoSolid'))),
    ])
    , 2 : pyxb.binding.content.ContentModelState(state=2, is_final=True, transitions=[
    ])
})



ConversionPropertyType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'Conversion'), ConversionType, scope=ConversionPropertyType))
ConversionPropertyType._ContentModel = pyxb.binding.content.ContentModel(state_map = {
      1 : pyxb.binding.content.ContentModelState(state=1, is_final=True, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=ConversionPropertyType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'Conversion'))),
    ])
    , 2 : pyxb.binding.content.ContentModelState(state=2, is_final=True, transitions=[
    ])
})



CoordinateOperationPropertyType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'AbstractCoordinateOperation'), AbstractCoordinateOperationType, abstract=pyxb.binding.datatypes.boolean(1), scope=CoordinateOperationPropertyType))
CoordinateOperationPropertyType._ContentModel = pyxb.binding.content.ContentModel(state_map = {
      1 : pyxb.binding.content.ContentModelState(state=1, is_final=True, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=CoordinateOperationPropertyType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'AbstractCoordinateOperation'))),
    ])
    , 2 : pyxb.binding.content.ContentModelState(state=2, is_final=True, transitions=[
    ])
})



CoordinateSystemAxisPropertyType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'CoordinateSystemAxis'), CoordinateSystemAxisType, scope=CoordinateSystemAxisPropertyType))
CoordinateSystemAxisPropertyType._ContentModel = pyxb.binding.content.ContentModel(state_map = {
      1 : pyxb.binding.content.ContentModelState(state=1, is_final=True, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=CoordinateSystemAxisPropertyType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'CoordinateSystemAxis'))),
    ])
    , 2 : pyxb.binding.content.ContentModelState(state=2, is_final=True, transitions=[
    ])
})



CoordinateSystemPropertyType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'AbstractCoordinateSystem'), AbstractCoordinateSystemType, abstract=pyxb.binding.datatypes.boolean(1), scope=CoordinateSystemPropertyType))
CoordinateSystemPropertyType._ContentModel = pyxb.binding.content.ContentModel(state_map = {
      1 : pyxb.binding.content.ContentModelState(state=1, is_final=True, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=CoordinateSystemPropertyType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'AbstractCoordinateSystem'))),
    ])
    , 2 : pyxb.binding.content.ContentModelState(state=2, is_final=True, transitions=[
    ])
})



CountPropertyType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'Count'), _CTD_ANON_23, nillable=pyxb.binding.datatypes.boolean(1), scope=CountPropertyType))
CountPropertyType._ContentModel = pyxb.binding.content.ContentModel(state_map = {
      1 : pyxb.binding.content.ContentModelState(state=1, is_final=True, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=CountPropertyType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'Count'))),
    ])
    , 2 : pyxb.binding.content.ContentModelState(state=2, is_final=True, transitions=[
    ])
})



CoverageFunctionType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'MappingRule'), StringOrRefType, scope=CoverageFunctionType))

CoverageFunctionType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'CoverageMappingRule'), MappingRuleType, scope=CoverageFunctionType))

CoverageFunctionType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'GridFunction'), GridFunctionType, scope=CoverageFunctionType))
CoverageFunctionType._ContentModel = pyxb.binding.content.ContentModel(state_map = {
      1 : pyxb.binding.content.ContentModelState(state=1, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=CoverageFunctionType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'MappingRule'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=CoverageFunctionType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'CoverageMappingRule'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=CoverageFunctionType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'GridFunction'))),
    ])
    , 2 : pyxb.binding.content.ContentModelState(state=2, is_final=True, transitions=[
    ])
})



CurveArrayPropertyType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'AbstractCurve'), AbstractCurveType, abstract=pyxb.binding.datatypes.boolean(1), scope=CurveArrayPropertyType))
CurveArrayPropertyType._ContentModel = pyxb.binding.content.ContentModel(state_map = {
      1 : pyxb.binding.content.ContentModelState(state=1, is_final=True, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=1, element_use=CurveArrayPropertyType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'AbstractCurve'))),
    ])
})



CurvePropertyType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'AbstractCurve'), AbstractCurveType, abstract=pyxb.binding.datatypes.boolean(1), scope=CurvePropertyType))
CurvePropertyType._ContentModel = pyxb.binding.content.ContentModel(state_map = {
      1 : pyxb.binding.content.ContentModelState(state=1, is_final=True, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=CurvePropertyType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'AbstractCurve'))),
    ])
    , 2 : pyxb.binding.content.ContentModelState(state=2, is_final=True, transitions=[
    ])
})



CurveSegmentArrayPropertyType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'AbstractCurveSegment'), AbstractCurveSegmentType, abstract=pyxb.binding.datatypes.boolean(1), scope=CurveSegmentArrayPropertyType))
CurveSegmentArrayPropertyType._ContentModel = pyxb.binding.content.ContentModel(state_map = {
      1 : pyxb.binding.content.ContentModelState(state=1, is_final=True, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=1, element_use=CurveSegmentArrayPropertyType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'AbstractCurveSegment'))),
    ])
})



CylindricalCSPropertyType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'CylindricalCS'), CylindricalCSType, scope=CylindricalCSPropertyType))
CylindricalCSPropertyType._ContentModel = pyxb.binding.content.ContentModel(state_map = {
      1 : pyxb.binding.content.ContentModelState(state=1, is_final=True, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=CylindricalCSPropertyType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'CylindricalCS'))),
    ])
    , 2 : pyxb.binding.content.ContentModelState(state=2, is_final=True, transitions=[
    ])
})



DMSAngleType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'degrees'), DegreesType, scope=DMSAngleType))

DMSAngleType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'seconds'), ArcSecondsType, scope=DMSAngleType))

DMSAngleType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'decimalMinutes'), DecimalMinutesType, scope=DMSAngleType))

DMSAngleType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'minutes'), ArcMinutesType, scope=DMSAngleType))
DMSAngleType._ContentModel = pyxb.binding.content.ContentModel(state_map = {
      1 : pyxb.binding.content.ContentModelState(state=1, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=DMSAngleType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'degrees'))),
    ])
    , 2 : pyxb.binding.content.ContentModelState(state=2, is_final=True, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=4, element_use=DMSAngleType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'decimalMinutes'))),
        pyxb.binding.content.ContentModelTransition(next_state=3, element_use=DMSAngleType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'minutes'))),
    ])
    , 3 : pyxb.binding.content.ContentModelState(state=3, is_final=True, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=4, element_use=DMSAngleType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'seconds'))),
    ])
    , 4 : pyxb.binding.content.ContentModelState(state=4, is_final=True, transitions=[
    ])
})



DataBlockType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'tupleList'), CoordinatesType, scope=DataBlockType))

DataBlockType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'doubleOrNilReasonTupleList'), doubleOrNilReasonList, scope=DataBlockType))

DataBlockType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'rangeParameters'), RangeParametersType, scope=DataBlockType))
DataBlockType._ContentModel = pyxb.binding.content.ContentModel(state_map = {
      1 : pyxb.binding.content.ContentModelState(state=1, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=DataBlockType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'rangeParameters'))),
    ])
    , 2 : pyxb.binding.content.ContentModelState(state=2, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=3, element_use=DataBlockType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'doubleOrNilReasonTupleList'))),
        pyxb.binding.content.ContentModelTransition(next_state=3, element_use=DataBlockType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'tupleList'))),
    ])
    , 3 : pyxb.binding.content.ContentModelState(state=3, is_final=True, transitions=[
    ])
})



DatumPropertyType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'AbstractDatum'), AbstractDatumType, abstract=pyxb.binding.datatypes.boolean(1), scope=DatumPropertyType))
DatumPropertyType._ContentModel = pyxb.binding.content.ContentModel(state_map = {
      1 : pyxb.binding.content.ContentModelState(state=1, is_final=True, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=DatumPropertyType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'AbstractDatum'))),
    ])
    , 2 : pyxb.binding.content.ContentModelState(state=2, is_final=True, transitions=[
    ])
})



DerivedCRSPropertyType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'DerivedCRS'), DerivedCRSType, scope=DerivedCRSPropertyType))
DerivedCRSPropertyType._ContentModel = pyxb.binding.content.ContentModel(state_map = {
      1 : pyxb.binding.content.ContentModelState(state=1, is_final=True, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=DerivedCRSPropertyType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'DerivedCRS'))),
    ])
    , 2 : pyxb.binding.content.ContentModelState(state=2, is_final=True, transitions=[
    ])
})



DirectedEdgePropertyType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'Edge'), EdgeType, scope=DirectedEdgePropertyType))
DirectedEdgePropertyType._ContentModel = pyxb.binding.content.ContentModel(state_map = {
      1 : pyxb.binding.content.ContentModelState(state=1, is_final=True, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=DirectedEdgePropertyType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'Edge'))),
    ])
    , 2 : pyxb.binding.content.ContentModelState(state=2, is_final=True, transitions=[
    ])
})



DirectedFacePropertyType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'Face'), FaceType, scope=DirectedFacePropertyType))
DirectedFacePropertyType._ContentModel = pyxb.binding.content.ContentModel(state_map = {
      1 : pyxb.binding.content.ContentModelState(state=1, is_final=True, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=DirectedFacePropertyType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'Face'))),
    ])
    , 2 : pyxb.binding.content.ContentModelState(state=2, is_final=True, transitions=[
    ])
})



DirectedNodePropertyType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'Node'), NodeType, scope=DirectedNodePropertyType))
DirectedNodePropertyType._ContentModel = pyxb.binding.content.ContentModel(state_map = {
      1 : pyxb.binding.content.ContentModelState(state=1, is_final=True, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=DirectedNodePropertyType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'Node'))),
    ])
    , 2 : pyxb.binding.content.ContentModelState(state=2, is_final=True, transitions=[
    ])
})



DirectedTopoSolidPropertyType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'TopoSolid'), TopoSolidType, scope=DirectedTopoSolidPropertyType))
DirectedTopoSolidPropertyType._ContentModel = pyxb.binding.content.ContentModel(state_map = {
      1 : pyxb.binding.content.ContentModelState(state=1, is_final=True, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=DirectedTopoSolidPropertyType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'TopoSolid'))),
    ])
    , 2 : pyxb.binding.content.ContentModelState(state=2, is_final=True, transitions=[
    ])
})



DirectionDescriptionType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'compassPoint'), CompassPointEnumeration, scope=DirectionDescriptionType))

DirectionDescriptionType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'keyword'), CodeType, scope=DirectionDescriptionType))

DirectionDescriptionType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'description'), pyxb.binding.datatypes.string, scope=DirectionDescriptionType))

DirectionDescriptionType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'reference'), ReferenceType, scope=DirectionDescriptionType))
DirectionDescriptionType._ContentModel = pyxb.binding.content.ContentModel(state_map = {
      1 : pyxb.binding.content.ContentModelState(state=1, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=DirectionDescriptionType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'compassPoint'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=DirectionDescriptionType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'reference'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=DirectionDescriptionType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'keyword'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=DirectionDescriptionType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'description'))),
    ])
    , 2 : pyxb.binding.content.ContentModelState(state=2, is_final=True, transitions=[
    ])
})



DirectionPropertyType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'CompassPoint'), CompassPointEnumeration, scope=DirectionPropertyType))

DirectionPropertyType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'DirectionDescription'), DirectionDescriptionType, scope=DirectionPropertyType))

DirectionPropertyType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'DirectionKeyword'), CodeType, scope=DirectionPropertyType))

DirectionPropertyType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'DirectionVector'), DirectionVectorType, scope=DirectionPropertyType))

DirectionPropertyType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'DirectionString'), StringOrRefType, scope=DirectionPropertyType))
DirectionPropertyType._ContentModel = pyxb.binding.content.ContentModel(state_map = {
      1 : pyxb.binding.content.ContentModelState(state=1, is_final=True, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=DirectionPropertyType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'DirectionString'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=DirectionPropertyType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'DirectionKeyword'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=DirectionPropertyType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'DirectionVector'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=DirectionPropertyType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'DirectionDescription'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=DirectionPropertyType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'CompassPoint'))),
    ])
    , 2 : pyxb.binding.content.ContentModelState(state=2, is_final=True, transitions=[
    ])
})



DirectionVectorType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'verticalAngle'), AngleType, scope=DirectionVectorType))

DirectionVectorType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'vector'), VectorType, scope=DirectionVectorType))

DirectionVectorType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'horizontalAngle'), AngleType, scope=DirectionVectorType))
DirectionVectorType._ContentModel = pyxb.binding.content.ContentModel(state_map = {
      1 : pyxb.binding.content.ContentModelState(state=1, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=3, element_use=DirectionVectorType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'vector'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=DirectionVectorType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'horizontalAngle'))),
    ])
    , 2 : pyxb.binding.content.ContentModelState(state=2, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=3, element_use=DirectionVectorType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'verticalAngle'))),
    ])
    , 3 : pyxb.binding.content.ContentModelState(state=3, is_final=True, transitions=[
    ])
})



DomainSetType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'AbstractGeometry'), AbstractGeometryType, abstract=pyxb.binding.datatypes.boolean(1), scope=DomainSetType))

DomainSetType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'AbstractTimeObject'), AbstractTimeObjectType, abstract=pyxb.binding.datatypes.boolean(1), scope=DomainSetType))
DomainSetType._ContentModel = pyxb.binding.content.ContentModel(state_map = {
      1 : pyxb.binding.content.ContentModelState(state=1, is_final=True, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=DomainSetType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'AbstractGeometry'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=DomainSetType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'AbstractTimeObject'))),
    ])
    , 2 : pyxb.binding.content.ContentModelState(state=2, is_final=True, transitions=[
    ])
})



EllipsoidPropertyType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'Ellipsoid'), EllipsoidType, scope=EllipsoidPropertyType))
EllipsoidPropertyType._ContentModel = pyxb.binding.content.ContentModel(state_map = {
      1 : pyxb.binding.content.ContentModelState(state=1, is_final=True, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=EllipsoidPropertyType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'Ellipsoid'))),
    ])
    , 2 : pyxb.binding.content.ContentModelState(state=2, is_final=True, transitions=[
    ])
})



EllipsoidalCSPropertyType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'EllipsoidalCS'), EllipsoidalCSType, scope=EllipsoidalCSPropertyType))
EllipsoidalCSPropertyType._ContentModel = pyxb.binding.content.ContentModel(state_map = {
      1 : pyxb.binding.content.ContentModelState(state=1, is_final=True, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=EllipsoidalCSPropertyType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'EllipsoidalCS'))),
    ])
    , 2 : pyxb.binding.content.ContentModelState(state=2, is_final=True, transitions=[
    ])
})



EngineeringCRSPropertyType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'EngineeringCRS'), EngineeringCRSType, scope=EngineeringCRSPropertyType))
EngineeringCRSPropertyType._ContentModel = pyxb.binding.content.ContentModel(state_map = {
      1 : pyxb.binding.content.ContentModelState(state=1, is_final=True, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=EngineeringCRSPropertyType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'EngineeringCRS'))),
    ])
    , 2 : pyxb.binding.content.ContentModelState(state=2, is_final=True, transitions=[
    ])
})



EngineeringDatumPropertyType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'EngineeringDatum'), EngineeringDatumType, scope=EngineeringDatumPropertyType))
EngineeringDatumPropertyType._ContentModel = pyxb.binding.content.ContentModel(state_map = {
      1 : pyxb.binding.content.ContentModelState(state=1, is_final=True, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=EngineeringDatumPropertyType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'EngineeringDatum'))),
    ])
    , 2 : pyxb.binding.content.ContentModelState(state=2, is_final=True, transitions=[
    ])
})



EnvelopeType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'coordinates'), CoordinatesType, scope=EnvelopeType))

EnvelopeType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'lowerCorner'), DirectPositionType, scope=EnvelopeType))

EnvelopeType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'upperCorner'), DirectPositionType, scope=EnvelopeType))

EnvelopeType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'pos'), DirectPositionType, scope=EnvelopeType))
EnvelopeType._ContentModel = pyxb.binding.content.ContentModel(state_map = {
      1 : pyxb.binding.content.ContentModelState(state=1, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=EnvelopeType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'lowerCorner'))),
        pyxb.binding.content.ContentModelTransition(next_state=3, element_use=EnvelopeType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'coordinates'))),
        pyxb.binding.content.ContentModelTransition(next_state=4, element_use=EnvelopeType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'pos'))),
    ])
    , 2 : pyxb.binding.content.ContentModelState(state=2, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=3, element_use=EnvelopeType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'upperCorner'))),
    ])
    , 3 : pyxb.binding.content.ContentModelState(state=3, is_final=True, transitions=[
    ])
    , 4 : pyxb.binding.content.ContentModelState(state=4, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=3, element_use=EnvelopeType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'pos'))),
    ])
})



FeatureArrayPropertyType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'AbstractFeature'), AbstractFeatureType, abstract=pyxb.binding.datatypes.boolean(1), scope=FeatureArrayPropertyType))
FeatureArrayPropertyType._ContentModel = pyxb.binding.content.ContentModel(state_map = {
      1 : pyxb.binding.content.ContentModelState(state=1, is_final=True, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=1, element_use=FeatureArrayPropertyType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'AbstractFeature'))),
    ])
})



FeaturePropertyType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'AbstractFeature'), AbstractFeatureType, abstract=pyxb.binding.datatypes.boolean(1), scope=FeaturePropertyType))
FeaturePropertyType._ContentModel = pyxb.binding.content.ContentModel(state_map = {
      1 : pyxb.binding.content.ContentModelState(state=1, is_final=True, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=FeaturePropertyType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'AbstractFeature'))),
    ])
    , 2 : pyxb.binding.content.ContentModelState(state=2, is_final=True, transitions=[
    ])
})



FileType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'compression'), pyxb.binding.datatypes.anyURI, scope=FileType))

FileType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'fileStructure'), FileValueModelType, scope=FileType))

FileType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'fileReference'), pyxb.binding.datatypes.anyURI, scope=FileType))

FileType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'mimeType'), pyxb.binding.datatypes.anyURI, scope=FileType))

FileType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'fileName'), pyxb.binding.datatypes.anyURI, scope=FileType))

FileType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'rangeParameters'), RangeParametersType, scope=FileType))
FileType._ContentModel = pyxb.binding.content.ContentModel(state_map = {
      1 : pyxb.binding.content.ContentModelState(state=1, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=FileType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'rangeParameters'))),
    ])
    , 2 : pyxb.binding.content.ContentModelState(state=2, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=6, element_use=FileType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'fileName'))),
        pyxb.binding.content.ContentModelTransition(next_state=6, element_use=FileType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'fileReference'))),
    ])
    , 3 : pyxb.binding.content.ContentModelState(state=3, is_final=True, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=4, element_use=FileType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'mimeType'))),
        pyxb.binding.content.ContentModelTransition(next_state=5, element_use=FileType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'compression'))),
    ])
    , 4 : pyxb.binding.content.ContentModelState(state=4, is_final=True, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=5, element_use=FileType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'compression'))),
    ])
    , 5 : pyxb.binding.content.ContentModelState(state=5, is_final=True, transitions=[
    ])
    , 6 : pyxb.binding.content.ContentModelState(state=6, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=3, element_use=FileType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'fileStructure'))),
    ])
})



FormulaType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'b'), pyxb.binding.datatypes.double, scope=FormulaType))

FormulaType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'a'), pyxb.binding.datatypes.double, scope=FormulaType))

FormulaType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'd'), pyxb.binding.datatypes.double, scope=FormulaType))

FormulaType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'c'), pyxb.binding.datatypes.double, scope=FormulaType))
FormulaType._ContentModel = pyxb.binding.content.ContentModel(state_map = {
      1 : pyxb.binding.content.ContentModelState(state=1, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=FormulaType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'a'))),
        pyxb.binding.content.ContentModelTransition(next_state=3, element_use=FormulaType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'b'))),
    ])
    , 2 : pyxb.binding.content.ContentModelState(state=2, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=3, element_use=FormulaType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'b'))),
    ])
    , 3 : pyxb.binding.content.ContentModelState(state=3, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=4, element_use=FormulaType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'c'))),
    ])
    , 4 : pyxb.binding.content.ContentModelState(state=4, is_final=True, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=5, element_use=FormulaType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'd'))),
    ])
    , 5 : pyxb.binding.content.ContentModelState(state=5, is_final=True, transitions=[
    ])
})



GeneralConversionPropertyType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'AbstractGeneralConversion'), AbstractGeneralConversionType, abstract=pyxb.binding.datatypes.boolean(1), scope=GeneralConversionPropertyType))
GeneralConversionPropertyType._ContentModel = pyxb.binding.content.ContentModel(state_map = {
      1 : pyxb.binding.content.ContentModelState(state=1, is_final=True, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=GeneralConversionPropertyType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'AbstractGeneralConversion'))),
    ])
    , 2 : pyxb.binding.content.ContentModelState(state=2, is_final=True, transitions=[
    ])
})



GeneralTransformationPropertyType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'AbstractGeneralTransformation'), AbstractGeneralTransformationType, abstract=pyxb.binding.datatypes.boolean(1), scope=GeneralTransformationPropertyType))
GeneralTransformationPropertyType._ContentModel = pyxb.binding.content.ContentModel(state_map = {
      1 : pyxb.binding.content.ContentModelState(state=1, is_final=True, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=GeneralTransformationPropertyType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'AbstractGeneralTransformation'))),
    ])
    , 2 : pyxb.binding.content.ContentModelState(state=2, is_final=True, transitions=[
    ])
})



GeocentricCRSPropertyType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'GeocentricCRS'), GeocentricCRSType, scope=GeocentricCRSPropertyType))
GeocentricCRSPropertyType._ContentModel = pyxb.binding.content.ContentModel(state_map = {
      1 : pyxb.binding.content.ContentModelState(state=1, is_final=True, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=GeocentricCRSPropertyType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'GeocentricCRS'))),
    ])
    , 2 : pyxb.binding.content.ContentModelState(state=2, is_final=True, transitions=[
    ])
})



GeodeticCRSPropertyType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'GeodeticCRS'), GeodeticCRSType, scope=GeodeticCRSPropertyType))
GeodeticCRSPropertyType._ContentModel = pyxb.binding.content.ContentModel(state_map = {
      1 : pyxb.binding.content.ContentModelState(state=1, is_final=True, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=GeodeticCRSPropertyType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'GeodeticCRS'))),
    ])
    , 2 : pyxb.binding.content.ContentModelState(state=2, is_final=True, transitions=[
    ])
})



GeodeticDatumPropertyType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'GeodeticDatum'), GeodeticDatumType, scope=GeodeticDatumPropertyType))
GeodeticDatumPropertyType._ContentModel = pyxb.binding.content.ContentModel(state_map = {
      1 : pyxb.binding.content.ContentModelState(state=1, is_final=True, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=GeodeticDatumPropertyType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'GeodeticDatum'))),
    ])
    , 2 : pyxb.binding.content.ContentModelState(state=2, is_final=True, transitions=[
    ])
})



GeographicCRSPropertyType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'GeographicCRS'), GeographicCRSType, scope=GeographicCRSPropertyType))
GeographicCRSPropertyType._ContentModel = pyxb.binding.content.ContentModel(state_map = {
      1 : pyxb.binding.content.ContentModelState(state=1, is_final=True, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=GeographicCRSPropertyType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'GeographicCRS'))),
    ])
    , 2 : pyxb.binding.content.ContentModelState(state=2, is_final=True, transitions=[
    ])
})



GeometricComplexPropertyType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'GeometricComplex'), GeometricComplexType, scope=GeometricComplexPropertyType))

GeometricComplexPropertyType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'CompositeCurve'), CompositeCurveType, scope=GeometricComplexPropertyType))

GeometricComplexPropertyType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'CompositeSurface'), CompositeSurfaceType, scope=GeometricComplexPropertyType))

GeometricComplexPropertyType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'CompositeSolid'), CompositeSolidType, scope=GeometricComplexPropertyType))
GeometricComplexPropertyType._ContentModel = pyxb.binding.content.ContentModel(state_map = {
      1 : pyxb.binding.content.ContentModelState(state=1, is_final=True, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=GeometricComplexPropertyType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'GeometricComplex'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=GeometricComplexPropertyType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'CompositeSurface'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=GeometricComplexPropertyType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'CompositeSolid'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=GeometricComplexPropertyType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'CompositeCurve'))),
    ])
    , 2 : pyxb.binding.content.ContentModelState(state=2, is_final=True, transitions=[
    ])
})



GeometricPrimitivePropertyType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'AbstractGeometricPrimitive'), AbstractGeometricPrimitiveType, abstract=pyxb.binding.datatypes.boolean(1), scope=GeometricPrimitivePropertyType))
GeometricPrimitivePropertyType._ContentModel = pyxb.binding.content.ContentModel(state_map = {
      1 : pyxb.binding.content.ContentModelState(state=1, is_final=True, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=GeometricPrimitivePropertyType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'AbstractGeometricPrimitive'))),
    ])
    , 2 : pyxb.binding.content.ContentModelState(state=2, is_final=True, transitions=[
    ])
})



GeometryArrayPropertyType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'AbstractGeometry'), AbstractGeometryType, abstract=pyxb.binding.datatypes.boolean(1), scope=GeometryArrayPropertyType))
GeometryArrayPropertyType._ContentModel = pyxb.binding.content.ContentModel(state_map = {
      1 : pyxb.binding.content.ContentModelState(state=1, is_final=True, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=1, element_use=GeometryArrayPropertyType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'AbstractGeometry'))),
    ])
})



GeometryPropertyType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'AbstractGeometry'), AbstractGeometryType, abstract=pyxb.binding.datatypes.boolean(1), scope=GeometryPropertyType))
GeometryPropertyType._ContentModel = pyxb.binding.content.ContentModel(state_map = {
      1 : pyxb.binding.content.ContentModelState(state=1, is_final=True, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=GeometryPropertyType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'AbstractGeometry'))),
    ])
    , 2 : pyxb.binding.content.ContentModelState(state=2, is_final=True, transitions=[
    ])
})



GridEnvelopeType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'high'), integerList, scope=GridEnvelopeType))

GridEnvelopeType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'low'), integerList, scope=GridEnvelopeType))
GridEnvelopeType._ContentModel = pyxb.binding.content.ContentModel(state_map = {
      1 : pyxb.binding.content.ContentModelState(state=1, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=GridEnvelopeType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'low'))),
    ])
    , 2 : pyxb.binding.content.ContentModelState(state=2, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=3, element_use=GridEnvelopeType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'high'))),
    ])
    , 3 : pyxb.binding.content.ContentModelState(state=3, is_final=True, transitions=[
    ])
})



GridFunctionType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'sequenceRule'), SequenceRuleType, scope=GridFunctionType))

GridFunctionType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'startPoint'), integerList, scope=GridFunctionType))
GridFunctionType._ContentModel = pyxb.binding.content.ContentModel(state_map = {
      1 : pyxb.binding.content.ContentModelState(state=1, is_final=True, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=GridFunctionType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'sequenceRule'))),
        pyxb.binding.content.ContentModelTransition(next_state=3, element_use=GridFunctionType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'startPoint'))),
    ])
    , 2 : pyxb.binding.content.ContentModelState(state=2, is_final=True, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=3, element_use=GridFunctionType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'startPoint'))),
    ])
    , 3 : pyxb.binding.content.ContentModelState(state=3, is_final=True, transitions=[
    ])
})



GridLimitsType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'GridEnvelope'), GridEnvelopeType, scope=GridLimitsType))
GridLimitsType._ContentModel = pyxb.binding.content.ContentModel(state_map = {
      1 : pyxb.binding.content.ContentModelState(state=1, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=GridLimitsType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'GridEnvelope'))),
    ])
    , 2 : pyxb.binding.content.ContentModelState(state=2, is_final=True, transitions=[
    ])
})



HistoryPropertyType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'AbstractTimeSlice'), AbstractTimeSliceType, abstract=pyxb.binding.datatypes.boolean(1), scope=HistoryPropertyType))
HistoryPropertyType._ContentModel = pyxb.binding.content.ContentModel(state_map = {
      1 : pyxb.binding.content.ContentModelState(state=1, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=HistoryPropertyType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'AbstractTimeSlice'))),
    ])
    , 2 : pyxb.binding.content.ContentModelState(state=2, is_final=True, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=HistoryPropertyType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'AbstractTimeSlice'))),
    ])
})



ImageCRSPropertyType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'ImageCRS'), ImageCRSType, scope=ImageCRSPropertyType))
ImageCRSPropertyType._ContentModel = pyxb.binding.content.ContentModel(state_map = {
      1 : pyxb.binding.content.ContentModelState(state=1, is_final=True, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=ImageCRSPropertyType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'ImageCRS'))),
    ])
    , 2 : pyxb.binding.content.ContentModelState(state=2, is_final=True, transitions=[
    ])
})



ImageDatumPropertyType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'ImageDatum'), ImageDatumType, scope=ImageDatumPropertyType))
ImageDatumPropertyType._ContentModel = pyxb.binding.content.ContentModel(state_map = {
      1 : pyxb.binding.content.ContentModelState(state=1, is_final=True, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=ImageDatumPropertyType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'ImageDatum'))),
    ])
    , 2 : pyxb.binding.content.ContentModelState(state=2, is_final=True, transitions=[
    ])
})



IndirectEntryType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'DefinitionProxy'), DefinitionProxyType, scope=IndirectEntryType))
IndirectEntryType._ContentModel = pyxb.binding.content.ContentModel(state_map = {
      1 : pyxb.binding.content.ContentModelState(state=1, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=IndirectEntryType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'DefinitionProxy'))),
    ])
    , 2 : pyxb.binding.content.ContentModelState(state=2, is_final=True, transitions=[
    ])
})



InlinePropertyType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'AbstractObject'), pyxb.binding.datatypes.anyType, abstract=pyxb.binding.datatypes.boolean(1), scope=InlinePropertyType))
InlinePropertyType._ContentModel = pyxb.binding.content.ContentModel(state_map = {
      1 : pyxb.binding.content.ContentModelState(state=1, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=InlinePropertyType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'AbstractObject'))),
    ])
    , 2 : pyxb.binding.content.ContentModelState(state=2, is_final=True, transitions=[
    ])
})



IsolatedPropertyType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'Edge'), EdgeType, scope=IsolatedPropertyType))

IsolatedPropertyType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'Node'), NodeType, scope=IsolatedPropertyType))
IsolatedPropertyType._ContentModel = pyxb.binding.content.ContentModel(state_map = {
      1 : pyxb.binding.content.ContentModelState(state=1, is_final=True, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=IsolatedPropertyType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'Node'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=IsolatedPropertyType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'Edge'))),
    ])
    , 2 : pyxb.binding.content.ContentModelState(state=2, is_final=True, transitions=[
    ])
})



KnotPropertyType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'Knot'), KnotType, scope=KnotPropertyType))
KnotPropertyType._ContentModel = pyxb.binding.content.ContentModel(state_map = {
      1 : pyxb.binding.content.ContentModelState(state=1, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=KnotPropertyType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'Knot'))),
    ])
    , 2 : pyxb.binding.content.ContentModelState(state=2, is_final=True, transitions=[
    ])
})



KnotType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'multiplicity'), pyxb.binding.datatypes.nonNegativeInteger, scope=KnotType))

KnotType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'weight'), pyxb.binding.datatypes.double, scope=KnotType))

KnotType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'value'), pyxb.binding.datatypes.double, scope=KnotType))
KnotType._ContentModel = pyxb.binding.content.ContentModel(state_map = {
      1 : pyxb.binding.content.ContentModelState(state=1, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=KnotType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'value'))),
    ])
    , 2 : pyxb.binding.content.ContentModelState(state=2, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=3, element_use=KnotType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'multiplicity'))),
    ])
    , 3 : pyxb.binding.content.ContentModelState(state=3, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=4, element_use=KnotType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'weight'))),
    ])
    , 4 : pyxb.binding.content.ContentModelState(state=4, is_final=True, transitions=[
    ])
})



LineStringSegmentArrayPropertyType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'LineStringSegment'), LineStringSegmentType, scope=LineStringSegmentArrayPropertyType))
LineStringSegmentArrayPropertyType._ContentModel = pyxb.binding.content.ContentModel(state_map = {
      1 : pyxb.binding.content.ContentModelState(state=1, is_final=True, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=1, element_use=LineStringSegmentArrayPropertyType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'LineStringSegment'))),
    ])
})



LinearCSPropertyType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'LinearCS'), LinearCSType, scope=LinearCSPropertyType))
LinearCSPropertyType._ContentModel = pyxb.binding.content.ContentModel(state_map = {
      1 : pyxb.binding.content.ContentModelState(state=1, is_final=True, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=LinearCSPropertyType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'LinearCS'))),
    ])
    , 2 : pyxb.binding.content.ContentModelState(state=2, is_final=True, transitions=[
    ])
})



LinearRingPropertyType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'LinearRing'), LinearRingType, scope=LinearRingPropertyType))
LinearRingPropertyType._ContentModel = pyxb.binding.content.ContentModel(state_map = {
      1 : pyxb.binding.content.ContentModelState(state=1, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=LinearRingPropertyType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'LinearRing'))),
    ])
    , 2 : pyxb.binding.content.ContentModelState(state=2, is_final=True, transitions=[
    ])
})



LocationPropertyType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'LocationKeyWord'), CodeType, scope=LocationPropertyType))

LocationPropertyType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'AbstractGeometry'), AbstractGeometryType, abstract=pyxb.binding.datatypes.boolean(1), scope=LocationPropertyType))

LocationPropertyType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'Null'), NilReasonType, scope=LocationPropertyType))

LocationPropertyType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'LocationString'), StringOrRefType, scope=LocationPropertyType))
LocationPropertyType._ContentModel = pyxb.binding.content.ContentModel(state_map = {
      1 : pyxb.binding.content.ContentModelState(state=1, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=LocationPropertyType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'AbstractGeometry'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=LocationPropertyType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'LocationString'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=LocationPropertyType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'LocationKeyWord'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=LocationPropertyType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'Null'))),
    ])
    , 2 : pyxb.binding.content.ContentModelState(state=2, is_final=True, transitions=[
    ])
})



MappingRuleType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'ruleDefinition'), pyxb.binding.datatypes.string, scope=MappingRuleType))

MappingRuleType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'ruleReference'), ReferenceType, scope=MappingRuleType))
MappingRuleType._ContentModel = pyxb.binding.content.ContentModel(state_map = {
      1 : pyxb.binding.content.ContentModelState(state=1, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=MappingRuleType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'ruleDefinition'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=MappingRuleType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'ruleReference'))),
    ])
    , 2 : pyxb.binding.content.ContentModelState(state=2, is_final=True, transitions=[
    ])
})



MetaDataPropertyType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'AbstractMetaData'), AbstractMetaDataType, abstract=pyxb.binding.datatypes.boolean(1), scope=MetaDataPropertyType))
MetaDataPropertyType._ContentModel = pyxb.binding.content.ContentModel(state_map = {
      1 : pyxb.binding.content.ContentModelState(state=1, is_final=True, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=MetaDataPropertyType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'AbstractMetaData'))),
    ])
    , 2 : pyxb.binding.content.ContentModelState(state=2, is_final=True, transitions=[
    ])
})



MultiCurvePropertyType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'MultiCurve'), MultiCurveType, scope=MultiCurvePropertyType))
MultiCurvePropertyType._ContentModel = pyxb.binding.content.ContentModel(state_map = {
      1 : pyxb.binding.content.ContentModelState(state=1, is_final=True, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=MultiCurvePropertyType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'MultiCurve'))),
    ])
    , 2 : pyxb.binding.content.ContentModelState(state=2, is_final=True, transitions=[
    ])
})



MultiGeometryPropertyType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'AbstractGeometricAggregate'), AbstractGeometricAggregateType, abstract=pyxb.binding.datatypes.boolean(1), scope=MultiGeometryPropertyType))
MultiGeometryPropertyType._ContentModel = pyxb.binding.content.ContentModel(state_map = {
      1 : pyxb.binding.content.ContentModelState(state=1, is_final=True, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=MultiGeometryPropertyType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'AbstractGeometricAggregate'))),
    ])
    , 2 : pyxb.binding.content.ContentModelState(state=2, is_final=True, transitions=[
    ])
})



MultiPointPropertyType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'MultiPoint'), MultiPointType, scope=MultiPointPropertyType))
MultiPointPropertyType._ContentModel = pyxb.binding.content.ContentModel(state_map = {
      1 : pyxb.binding.content.ContentModelState(state=1, is_final=True, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=MultiPointPropertyType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'MultiPoint'))),
    ])
    , 2 : pyxb.binding.content.ContentModelState(state=2, is_final=True, transitions=[
    ])
})



MultiSolidPropertyType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'MultiSolid'), MultiSolidType, scope=MultiSolidPropertyType))
MultiSolidPropertyType._ContentModel = pyxb.binding.content.ContentModel(state_map = {
      1 : pyxb.binding.content.ContentModelState(state=1, is_final=True, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=MultiSolidPropertyType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'MultiSolid'))),
    ])
    , 2 : pyxb.binding.content.ContentModelState(state=2, is_final=True, transitions=[
    ])
})



MultiSurfacePropertyType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'MultiSurface'), MultiSurfaceType, scope=MultiSurfacePropertyType))
MultiSurfacePropertyType._ContentModel = pyxb.binding.content.ContentModel(state_map = {
      1 : pyxb.binding.content.ContentModelState(state=1, is_final=True, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=MultiSurfacePropertyType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'MultiSurface'))),
    ])
    , 2 : pyxb.binding.content.ContentModelState(state=2, is_final=True, transitions=[
    ])
})



ObliqueCartesianCSPropertyType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'ObliqueCartesianCS'), ObliqueCartesianCSType, scope=ObliqueCartesianCSPropertyType))
ObliqueCartesianCSPropertyType._ContentModel = pyxb.binding.content.ContentModel(state_map = {
      1 : pyxb.binding.content.ContentModelState(state=1, is_final=True, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=ObliqueCartesianCSPropertyType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'ObliqueCartesianCS'))),
    ])
    , 2 : pyxb.binding.content.ContentModelState(state=2, is_final=True, transitions=[
    ])
})



OperationMethodPropertyType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'OperationMethod'), OperationMethodType, scope=OperationMethodPropertyType))
OperationMethodPropertyType._ContentModel = pyxb.binding.content.ContentModel(state_map = {
      1 : pyxb.binding.content.ContentModelState(state=1, is_final=True, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=OperationMethodPropertyType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'OperationMethod'))),
    ])
    , 2 : pyxb.binding.content.ContentModelState(state=2, is_final=True, transitions=[
    ])
})



OperationParameterGroupPropertyType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'OperationParameterGroup'), OperationParameterGroupType, scope=OperationParameterGroupPropertyType))
OperationParameterGroupPropertyType._ContentModel = pyxb.binding.content.ContentModel(state_map = {
      1 : pyxb.binding.content.ContentModelState(state=1, is_final=True, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=OperationParameterGroupPropertyType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'OperationParameterGroup'))),
    ])
    , 2 : pyxb.binding.content.ContentModelState(state=2, is_final=True, transitions=[
    ])
})



OperationParameterPropertyType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'OperationParameter'), OperationParameterType, scope=OperationParameterPropertyType))
OperationParameterPropertyType._ContentModel = pyxb.binding.content.ContentModel(state_map = {
      1 : pyxb.binding.content.ContentModelState(state=1, is_final=True, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=OperationParameterPropertyType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'OperationParameter'))),
    ])
    , 2 : pyxb.binding.content.ContentModelState(state=2, is_final=True, transitions=[
    ])
})



OperationPropertyType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'AbstractOperation'), AbstractCoordinateOperationType, abstract=pyxb.binding.datatypes.boolean(1), scope=OperationPropertyType))
OperationPropertyType._ContentModel = pyxb.binding.content.ContentModel(state_map = {
      1 : pyxb.binding.content.ContentModelState(state=1, is_final=True, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=OperationPropertyType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'AbstractOperation'))),
    ])
    , 2 : pyxb.binding.content.ContentModelState(state=2, is_final=True, transitions=[
    ])
})



PassThroughOperationPropertyType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'PassThroughOperation'), PassThroughOperationType, scope=PassThroughOperationPropertyType))
PassThroughOperationPropertyType._ContentModel = pyxb.binding.content.ContentModel(state_map = {
      1 : pyxb.binding.content.ContentModelState(state=1, is_final=True, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=PassThroughOperationPropertyType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'PassThroughOperation'))),
    ])
    , 2 : pyxb.binding.content.ContentModelState(state=2, is_final=True, transitions=[
    ])
})



PointArrayPropertyType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'Point'), PointType, scope=PointArrayPropertyType))
PointArrayPropertyType._ContentModel = pyxb.binding.content.ContentModel(state_map = {
      1 : pyxb.binding.content.ContentModelState(state=1, is_final=True, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=1, element_use=PointArrayPropertyType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'Point'))),
    ])
})



PointPropertyType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'Point'), PointType, scope=PointPropertyType))
PointPropertyType._ContentModel = pyxb.binding.content.ContentModel(state_map = {
      1 : pyxb.binding.content.ContentModelState(state=1, is_final=True, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=PointPropertyType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'Point'))),
    ])
    , 2 : pyxb.binding.content.ContentModelState(state=2, is_final=True, transitions=[
    ])
})



PolarCSPropertyType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'PolarCS'), PolarCSType, scope=PolarCSPropertyType))
PolarCSPropertyType._ContentModel = pyxb.binding.content.ContentModel(state_map = {
      1 : pyxb.binding.content.ContentModelState(state=1, is_final=True, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=PolarCSPropertyType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'PolarCS'))),
    ])
    , 2 : pyxb.binding.content.ContentModelState(state=2, is_final=True, transitions=[
    ])
})



PrimeMeridianPropertyType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'PrimeMeridian'), PrimeMeridianType, scope=PrimeMeridianPropertyType))
PrimeMeridianPropertyType._ContentModel = pyxb.binding.content.ContentModel(state_map = {
      1 : pyxb.binding.content.ContentModelState(state=1, is_final=True, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=PrimeMeridianPropertyType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'PrimeMeridian'))),
    ])
    , 2 : pyxb.binding.content.ContentModelState(state=2, is_final=True, transitions=[
    ])
})



ProcedurePropertyType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'AbstractFeature'), AbstractFeatureType, abstract=pyxb.binding.datatypes.boolean(1), scope=ProcedurePropertyType))
ProcedurePropertyType._ContentModel = pyxb.binding.content.ContentModel(state_map = {
      1 : pyxb.binding.content.ContentModelState(state=1, is_final=True, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=ProcedurePropertyType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'AbstractFeature'))),
    ])
    , 2 : pyxb.binding.content.ContentModelState(state=2, is_final=True, transitions=[
    ])
})



ProjectedCRSPropertyType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'ProjectedCRS'), ProjectedCRSType, scope=ProjectedCRSPropertyType))
ProjectedCRSPropertyType._ContentModel = pyxb.binding.content.ContentModel(state_map = {
      1 : pyxb.binding.content.ContentModelState(state=1, is_final=True, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=ProjectedCRSPropertyType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'ProjectedCRS'))),
    ])
    , 2 : pyxb.binding.content.ContentModelState(state=2, is_final=True, transitions=[
    ])
})



QuantityPropertyType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'Quantity'), _CTD_ANON_27, nillable=pyxb.binding.datatypes.boolean(1), scope=QuantityPropertyType))
QuantityPropertyType._ContentModel = pyxb.binding.content.ContentModel(state_map = {
      1 : pyxb.binding.content.ContentModelState(state=1, is_final=True, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=QuantityPropertyType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'Quantity'))),
    ])
    , 2 : pyxb.binding.content.ContentModelState(state=2, is_final=True, transitions=[
    ])
})



RangeParametersType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'AbstractValue'), pyxb.binding.datatypes.anyType, abstract=pyxb.binding.datatypes.boolean(1), scope=RangeParametersType))
RangeParametersType._ContentModel = pyxb.binding.content.ContentModel(state_map = {
      1 : pyxb.binding.content.ContentModelState(state=1, is_final=True, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=RangeParametersType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'AbstractValue'))),
    ])
    , 2 : pyxb.binding.content.ContentModelState(state=2, is_final=True, transitions=[
    ])
})



RangeSetType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'File'), FileType, scope=RangeSetType))

RangeSetType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'ValueArray'), ValueArrayType, scope=RangeSetType))

RangeSetType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'DataBlock'), DataBlockType, scope=RangeSetType))

RangeSetType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'AbstractScalarValueList'), pyxb.binding.datatypes.anyType, abstract=pyxb.binding.datatypes.boolean(1), scope=RangeSetType))
RangeSetType._ContentModel = pyxb.binding.content.ContentModel(state_map = {
      1 : pyxb.binding.content.ContentModelState(state=1, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=3, element_use=RangeSetType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'ValueArray'))),
        pyxb.binding.content.ContentModelTransition(next_state=4, element_use=RangeSetType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'AbstractScalarValueList'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=RangeSetType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'File'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=RangeSetType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'DataBlock'))),
    ])
    , 2 : pyxb.binding.content.ContentModelState(state=2, is_final=True, transitions=[
    ])
    , 3 : pyxb.binding.content.ContentModelState(state=3, is_final=True, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=3, element_use=RangeSetType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'ValueArray'))),
    ])
    , 4 : pyxb.binding.content.ContentModelState(state=4, is_final=True, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=4, element_use=RangeSetType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'AbstractScalarValueList'))),
    ])
})



ResultType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'AbstractObject'), pyxb.binding.datatypes.anyType, abstract=pyxb.binding.datatypes.boolean(1), scope=ResultType))
ResultType._ContentModel = pyxb.binding.content.ContentModel(state_map = {
      1 : pyxb.binding.content.ContentModelState(state=1, is_final=True, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=ResultType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'AbstractObject'))),
    ])
    , 2 : pyxb.binding.content.ContentModelState(state=2, is_final=True, transitions=[
    ])
})



RingPropertyType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'Ring'), RingType, scope=RingPropertyType))
RingPropertyType._ContentModel = pyxb.binding.content.ContentModel(state_map = {
      1 : pyxb.binding.content.ContentModelState(state=1, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=RingPropertyType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'Ring'))),
    ])
    , 2 : pyxb.binding.content.ContentModelState(state=2, is_final=True, transitions=[
    ])
})



ShellPropertyType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'Shell'), ShellType, scope=ShellPropertyType))
ShellPropertyType._ContentModel = pyxb.binding.content.ContentModel(state_map = {
      1 : pyxb.binding.content.ContentModelState(state=1, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=ShellPropertyType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'Shell'))),
    ])
    , 2 : pyxb.binding.content.ContentModelState(state=2, is_final=True, transitions=[
    ])
})



ShellType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'surfaceMember'), SurfacePropertyType, scope=ShellType))
ShellType._ContentModel = pyxb.binding.content.ContentModel(state_map = {
      1 : pyxb.binding.content.ContentModelState(state=1, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=ShellType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'surfaceMember'))),
    ])
    , 2 : pyxb.binding.content.ContentModelState(state=2, is_final=True, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=ShellType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'surfaceMember'))),
    ])
})



SingleCRSPropertyType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'AbstractSingleCRS'), AbstractCRSType, abstract=pyxb.binding.datatypes.boolean(1), scope=SingleCRSPropertyType))
SingleCRSPropertyType._ContentModel = pyxb.binding.content.ContentModel(state_map = {
      1 : pyxb.binding.content.ContentModelState(state=1, is_final=True, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=SingleCRSPropertyType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'AbstractSingleCRS'))),
    ])
    , 2 : pyxb.binding.content.ContentModelState(state=2, is_final=True, transitions=[
    ])
})



SingleOperationPropertyType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'AbstractSingleOperation'), AbstractCoordinateOperationType, abstract=pyxb.binding.datatypes.boolean(1), scope=SingleOperationPropertyType))
SingleOperationPropertyType._ContentModel = pyxb.binding.content.ContentModel(state_map = {
      1 : pyxb.binding.content.ContentModelState(state=1, is_final=True, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=SingleOperationPropertyType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'AbstractSingleOperation'))),
    ])
    , 2 : pyxb.binding.content.ContentModelState(state=2, is_final=True, transitions=[
    ])
})



SolidArrayPropertyType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'AbstractSolid'), AbstractSolidType, abstract=pyxb.binding.datatypes.boolean(1), scope=SolidArrayPropertyType))
SolidArrayPropertyType._ContentModel = pyxb.binding.content.ContentModel(state_map = {
      1 : pyxb.binding.content.ContentModelState(state=1, is_final=True, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=1, element_use=SolidArrayPropertyType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'AbstractSolid'))),
    ])
})



SolidPropertyType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'AbstractSolid'), AbstractSolidType, abstract=pyxb.binding.datatypes.boolean(1), scope=SolidPropertyType))
SolidPropertyType._ContentModel = pyxb.binding.content.ContentModel(state_map = {
      1 : pyxb.binding.content.ContentModelState(state=1, is_final=True, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=SolidPropertyType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'AbstractSolid'))),
    ])
    , 2 : pyxb.binding.content.ContentModelState(state=2, is_final=True, transitions=[
    ])
})



SphericalCSPropertyType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'SphericalCS'), SphericalCSType, scope=SphericalCSPropertyType))
SphericalCSPropertyType._ContentModel = pyxb.binding.content.ContentModel(state_map = {
      1 : pyxb.binding.content.ContentModelState(state=1, is_final=True, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=SphericalCSPropertyType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'SphericalCS'))),
    ])
    , 2 : pyxb.binding.content.ContentModelState(state=2, is_final=True, transitions=[
    ])
})



SurfaceArrayPropertyType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'AbstractSurface'), AbstractSurfaceType, abstract=pyxb.binding.datatypes.boolean(1), scope=SurfaceArrayPropertyType))
SurfaceArrayPropertyType._ContentModel = pyxb.binding.content.ContentModel(state_map = {
      1 : pyxb.binding.content.ContentModelState(state=1, is_final=True, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=1, element_use=SurfaceArrayPropertyType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'AbstractSurface'))),
    ])
})



SurfacePatchArrayPropertyType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'AbstractSurfacePatch'), AbstractSurfacePatchType, abstract=pyxb.binding.datatypes.boolean(1), scope=SurfacePatchArrayPropertyType))
SurfacePatchArrayPropertyType._ContentModel = pyxb.binding.content.ContentModel(state_map = {
      1 : pyxb.binding.content.ContentModelState(state=1, is_final=True, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=1, element_use=SurfacePatchArrayPropertyType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'AbstractSurfacePatch'))),
    ])
})



SurfacePropertyType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'AbstractSurface'), AbstractSurfaceType, abstract=pyxb.binding.datatypes.boolean(1), scope=SurfacePropertyType))
SurfacePropertyType._ContentModel = pyxb.binding.content.ContentModel(state_map = {
      1 : pyxb.binding.content.ContentModelState(state=1, is_final=True, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=SurfacePropertyType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'AbstractSurface'))),
    ])
    , 2 : pyxb.binding.content.ContentModelState(state=2, is_final=True, transitions=[
    ])
})



TargetPropertyType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'AbstractGeometry'), AbstractGeometryType, abstract=pyxb.binding.datatypes.boolean(1), scope=TargetPropertyType))

TargetPropertyType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'AbstractFeature'), AbstractFeatureType, abstract=pyxb.binding.datatypes.boolean(1), scope=TargetPropertyType))
TargetPropertyType._ContentModel = pyxb.binding.content.ContentModel(state_map = {
      1 : pyxb.binding.content.ContentModelState(state=1, is_final=True, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=TargetPropertyType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'AbstractFeature'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=TargetPropertyType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'AbstractGeometry'))),
    ])
    , 2 : pyxb.binding.content.ContentModelState(state=2, is_final=True, transitions=[
    ])
})



TemporalCRSPropertyType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'TemporalCRS'), TemporalCRSType, scope=TemporalCRSPropertyType))
TemporalCRSPropertyType._ContentModel = pyxb.binding.content.ContentModel(state_map = {
      1 : pyxb.binding.content.ContentModelState(state=1, is_final=True, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=TemporalCRSPropertyType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'TemporalCRS'))),
    ])
    , 2 : pyxb.binding.content.ContentModelState(state=2, is_final=True, transitions=[
    ])
})



TemporalCSPropertyType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'TemporalCS'), TemporalCSType, scope=TemporalCSPropertyType))
TemporalCSPropertyType._ContentModel = pyxb.binding.content.ContentModel(state_map = {
      1 : pyxb.binding.content.ContentModelState(state=1, is_final=True, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=TemporalCSPropertyType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'TemporalCS'))),
    ])
    , 2 : pyxb.binding.content.ContentModelState(state=2, is_final=True, transitions=[
    ])
})



TemporalDatumPropertyType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'TemporalDatum'), TemporalDatumType, scope=TemporalDatumPropertyType))
TemporalDatumPropertyType._ContentModel = pyxb.binding.content.ContentModel(state_map = {
      1 : pyxb.binding.content.ContentModelState(state=1, is_final=True, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=TemporalDatumPropertyType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'TemporalDatum'))),
    ])
    , 2 : pyxb.binding.content.ContentModelState(state=2, is_final=True, transitions=[
    ])
})



TimeCSPropertyType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'TimeCS'), TimeCSType, scope=TimeCSPropertyType))
TimeCSPropertyType._ContentModel = pyxb.binding.content.ContentModel(state_map = {
      1 : pyxb.binding.content.ContentModelState(state=1, is_final=True, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=TimeCSPropertyType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'TimeCS'))),
    ])
    , 2 : pyxb.binding.content.ContentModelState(state=2, is_final=True, transitions=[
    ])
})



TimeCalendarEraPropertyType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'TimeCalendarEra'), TimeCalendarEraType, scope=TimeCalendarEraPropertyType))
TimeCalendarEraPropertyType._ContentModel = pyxb.binding.content.ContentModel(state_map = {
      1 : pyxb.binding.content.ContentModelState(state=1, is_final=True, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=TimeCalendarEraPropertyType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'TimeCalendarEra'))),
    ])
    , 2 : pyxb.binding.content.ContentModelState(state=2, is_final=True, transitions=[
    ])
})



TimeCalendarPropertyType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'TimeCalendar'), TimeCalendarType, scope=TimeCalendarPropertyType))
TimeCalendarPropertyType._ContentModel = pyxb.binding.content.ContentModel(state_map = {
      1 : pyxb.binding.content.ContentModelState(state=1, is_final=True, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=TimeCalendarPropertyType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'TimeCalendar'))),
    ])
    , 2 : pyxb.binding.content.ContentModelState(state=2, is_final=True, transitions=[
    ])
})



TimeClockPropertyType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'TimeClock'), TimeClockType, scope=TimeClockPropertyType))
TimeClockPropertyType._ContentModel = pyxb.binding.content.ContentModel(state_map = {
      1 : pyxb.binding.content.ContentModelState(state=1, is_final=True, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=TimeClockPropertyType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'TimeClock'))),
    ])
    , 2 : pyxb.binding.content.ContentModelState(state=2, is_final=True, transitions=[
    ])
})



TimeEdgePropertyType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'TimeEdge'), TimeEdgeType, scope=TimeEdgePropertyType))
TimeEdgePropertyType._ContentModel = pyxb.binding.content.ContentModel(state_map = {
      1 : pyxb.binding.content.ContentModelState(state=1, is_final=True, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=TimeEdgePropertyType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'TimeEdge'))),
    ])
    , 2 : pyxb.binding.content.ContentModelState(state=2, is_final=True, transitions=[
    ])
})



TimeInstantPropertyType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'TimeInstant'), TimeInstantType, scope=TimeInstantPropertyType))
TimeInstantPropertyType._ContentModel = pyxb.binding.content.ContentModel(state_map = {
      1 : pyxb.binding.content.ContentModelState(state=1, is_final=True, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=TimeInstantPropertyType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'TimeInstant'))),
    ])
    , 2 : pyxb.binding.content.ContentModelState(state=2, is_final=True, transitions=[
    ])
})



TimeNodePropertyType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'TimeNode'), TimeNodeType, scope=TimeNodePropertyType))
TimeNodePropertyType._ContentModel = pyxb.binding.content.ContentModel(state_map = {
      1 : pyxb.binding.content.ContentModelState(state=1, is_final=True, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=TimeNodePropertyType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'TimeNode'))),
    ])
    , 2 : pyxb.binding.content.ContentModelState(state=2, is_final=True, transitions=[
    ])
})



TimeOrdinalEraPropertyType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'TimeOrdinalEra'), TimeOrdinalEraType, scope=TimeOrdinalEraPropertyType))
TimeOrdinalEraPropertyType._ContentModel = pyxb.binding.content.ContentModel(state_map = {
      1 : pyxb.binding.content.ContentModelState(state=1, is_final=True, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=TimeOrdinalEraPropertyType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'TimeOrdinalEra'))),
    ])
    , 2 : pyxb.binding.content.ContentModelState(state=2, is_final=True, transitions=[
    ])
})



TimePeriodPropertyType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'TimePeriod'), TimePeriodType, scope=TimePeriodPropertyType))
TimePeriodPropertyType._ContentModel = pyxb.binding.content.ContentModel(state_map = {
      1 : pyxb.binding.content.ContentModelState(state=1, is_final=True, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=TimePeriodPropertyType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'TimePeriod'))),
    ])
    , 2 : pyxb.binding.content.ContentModelState(state=2, is_final=True, transitions=[
    ])
})



TimePrimitivePropertyType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'AbstractTimePrimitive'), AbstractTimePrimitiveType, abstract=pyxb.binding.datatypes.boolean(1), scope=TimePrimitivePropertyType))
TimePrimitivePropertyType._ContentModel = pyxb.binding.content.ContentModel(state_map = {
      1 : pyxb.binding.content.ContentModelState(state=1, is_final=True, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=TimePrimitivePropertyType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'AbstractTimePrimitive'))),
    ])
    , 2 : pyxb.binding.content.ContentModelState(state=2, is_final=True, transitions=[
    ])
})



TimeTopologyComplexPropertyType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'TimeTopologyComplex'), TimeTopologyComplexType, scope=TimeTopologyComplexPropertyType))
TimeTopologyComplexPropertyType._ContentModel = pyxb.binding.content.ContentModel(state_map = {
      1 : pyxb.binding.content.ContentModelState(state=1, is_final=True, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=TimeTopologyComplexPropertyType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'TimeTopologyComplex'))),
    ])
    , 2 : pyxb.binding.content.ContentModelState(state=2, is_final=True, transitions=[
    ])
})



TimeTopologyPrimitivePropertyType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'AbstractTimeTopologyPrimitive'), AbstractTimeTopologyPrimitiveType, abstract=pyxb.binding.datatypes.boolean(1), scope=TimeTopologyPrimitivePropertyType))
TimeTopologyPrimitivePropertyType._ContentModel = pyxb.binding.content.ContentModel(state_map = {
      1 : pyxb.binding.content.ContentModelState(state=1, is_final=True, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=TimeTopologyPrimitivePropertyType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'AbstractTimeTopologyPrimitive'))),
    ])
    , 2 : pyxb.binding.content.ContentModelState(state=2, is_final=True, transitions=[
    ])
})



TopoComplexMemberType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'TopoComplex'), TopoComplexType, scope=TopoComplexMemberType))
TopoComplexMemberType._ContentModel = pyxb.binding.content.ContentModel(state_map = {
      1 : pyxb.binding.content.ContentModelState(state=1, is_final=True, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=TopoComplexMemberType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'TopoComplex'))),
    ])
    , 2 : pyxb.binding.content.ContentModelState(state=2, is_final=True, transitions=[
    ])
})



TopoCurvePropertyType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'TopoCurve'), TopoCurveType, scope=TopoCurvePropertyType))
TopoCurvePropertyType._ContentModel = pyxb.binding.content.ContentModel(state_map = {
      1 : pyxb.binding.content.ContentModelState(state=1, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=TopoCurvePropertyType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'TopoCurve'))),
    ])
    , 2 : pyxb.binding.content.ContentModelState(state=2, is_final=True, transitions=[
    ])
})



TopoPointPropertyType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'TopoPoint'), TopoPointType, scope=TopoPointPropertyType))
TopoPointPropertyType._ContentModel = pyxb.binding.content.ContentModel(state_map = {
      1 : pyxb.binding.content.ContentModelState(state=1, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=TopoPointPropertyType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'TopoPoint'))),
    ])
    , 2 : pyxb.binding.content.ContentModelState(state=2, is_final=True, transitions=[
    ])
})



TopoPrimitiveArrayAssociationType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'AbstractTopoPrimitive'), AbstractTopoPrimitiveType, abstract=pyxb.binding.datatypes.boolean(1), scope=TopoPrimitiveArrayAssociationType))
TopoPrimitiveArrayAssociationType._ContentModel = pyxb.binding.content.ContentModel(state_map = {
      1 : pyxb.binding.content.ContentModelState(state=1, is_final=True, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=1, element_use=TopoPrimitiveArrayAssociationType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'AbstractTopoPrimitive'))),
    ])
})



TopoPrimitiveMemberType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'AbstractTopoPrimitive'), AbstractTopoPrimitiveType, abstract=pyxb.binding.datatypes.boolean(1), scope=TopoPrimitiveMemberType))
TopoPrimitiveMemberType._ContentModel = pyxb.binding.content.ContentModel(state_map = {
      1 : pyxb.binding.content.ContentModelState(state=1, is_final=True, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=TopoPrimitiveMemberType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'AbstractTopoPrimitive'))),
    ])
    , 2 : pyxb.binding.content.ContentModelState(state=2, is_final=True, transitions=[
    ])
})



TopoSurfacePropertyType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'TopoSurface'), TopoSurfaceType, scope=TopoSurfacePropertyType))
TopoSurfacePropertyType._ContentModel = pyxb.binding.content.ContentModel(state_map = {
      1 : pyxb.binding.content.ContentModelState(state=1, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=TopoSurfacePropertyType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'TopoSurface'))),
    ])
    , 2 : pyxb.binding.content.ContentModelState(state=2, is_final=True, transitions=[
    ])
})



TopoVolumePropertyType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'TopoVolume'), TopoVolumeType, scope=TopoVolumePropertyType))
TopoVolumePropertyType._ContentModel = pyxb.binding.content.ContentModel(state_map = {
      1 : pyxb.binding.content.ContentModelState(state=1, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=TopoVolumePropertyType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'TopoVolume'))),
    ])
    , 2 : pyxb.binding.content.ContentModelState(state=2, is_final=True, transitions=[
    ])
})



TransformationPropertyType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'Transformation'), TransformationType, scope=TransformationPropertyType))
TransformationPropertyType._ContentModel = pyxb.binding.content.ContentModel(state_map = {
      1 : pyxb.binding.content.ContentModelState(state=1, is_final=True, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=TransformationPropertyType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'Transformation'))),
    ])
    , 2 : pyxb.binding.content.ContentModelState(state=2, is_final=True, transitions=[
    ])
})



UserDefinedCSPropertyType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'UserDefinedCS'), UserDefinedCSType, scope=UserDefinedCSPropertyType))
UserDefinedCSPropertyType._ContentModel = pyxb.binding.content.ContentModel(state_map = {
      1 : pyxb.binding.content.ContentModelState(state=1, is_final=True, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=UserDefinedCSPropertyType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'UserDefinedCS'))),
    ])
    , 2 : pyxb.binding.content.ContentModelState(state=2, is_final=True, transitions=[
    ])
})



ValueArrayPropertyType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'AbstractTimeObject'), AbstractTimeObjectType, abstract=pyxb.binding.datatypes.boolean(1), scope=ValueArrayPropertyType))

ValueArrayPropertyType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'Null'), NilReasonType, scope=ValueArrayPropertyType))

ValueArrayPropertyType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'AbstractValue'), pyxb.binding.datatypes.anyType, abstract=pyxb.binding.datatypes.boolean(1), scope=ValueArrayPropertyType))

ValueArrayPropertyType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'AbstractGeometry'), AbstractGeometryType, abstract=pyxb.binding.datatypes.boolean(1), scope=ValueArrayPropertyType))
ValueArrayPropertyType._ContentModel = pyxb.binding.content.ContentModel(state_map = {
      1 : pyxb.binding.content.ContentModelState(state=1, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=ValueArrayPropertyType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'AbstractValue'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=ValueArrayPropertyType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'AbstractTimeObject'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=ValueArrayPropertyType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'Null'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=ValueArrayPropertyType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'AbstractGeometry'))),
    ])
    , 2 : pyxb.binding.content.ContentModelState(state=2, is_final=True, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=ValueArrayPropertyType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'AbstractValue'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=ValueArrayPropertyType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'AbstractTimeObject'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=ValueArrayPropertyType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'Null'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=ValueArrayPropertyType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'AbstractGeometry'))),
    ])
})



ValuePropertyType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'AbstractGeometry'), AbstractGeometryType, abstract=pyxb.binding.datatypes.boolean(1), scope=ValuePropertyType))

ValuePropertyType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'Null'), NilReasonType, scope=ValuePropertyType))

ValuePropertyType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'AbstractValue'), pyxb.binding.datatypes.anyType, abstract=pyxb.binding.datatypes.boolean(1), scope=ValuePropertyType))

ValuePropertyType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'AbstractTimeObject'), AbstractTimeObjectType, abstract=pyxb.binding.datatypes.boolean(1), scope=ValuePropertyType))
ValuePropertyType._ContentModel = pyxb.binding.content.ContentModel(state_map = {
      1 : pyxb.binding.content.ContentModelState(state=1, is_final=True, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=ValuePropertyType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'AbstractValue'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=ValuePropertyType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'AbstractGeometry'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=ValuePropertyType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'Null'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=ValuePropertyType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'AbstractTimeObject'))),
    ])
    , 2 : pyxb.binding.content.ContentModelState(state=2, is_final=True, transitions=[
    ])
})



VerticalCRSPropertyType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'VerticalCRS'), VerticalCRSType, scope=VerticalCRSPropertyType))
VerticalCRSPropertyType._ContentModel = pyxb.binding.content.ContentModel(state_map = {
      1 : pyxb.binding.content.ContentModelState(state=1, is_final=True, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=VerticalCRSPropertyType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'VerticalCRS'))),
    ])
    , 2 : pyxb.binding.content.ContentModelState(state=2, is_final=True, transitions=[
    ])
})



VerticalCSPropertyType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'VerticalCS'), VerticalCSType, scope=VerticalCSPropertyType))
VerticalCSPropertyType._ContentModel = pyxb.binding.content.ContentModel(state_map = {
      1 : pyxb.binding.content.ContentModelState(state=1, is_final=True, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=VerticalCSPropertyType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'VerticalCS'))),
    ])
    , 2 : pyxb.binding.content.ContentModelState(state=2, is_final=True, transitions=[
    ])
})



VerticalDatumPropertyType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'VerticalDatum'), VerticalDatumType, scope=VerticalDatumPropertyType))
VerticalDatumPropertyType._ContentModel = pyxb.binding.content.ContentModel(state_map = {
      1 : pyxb.binding.content.ContentModelState(state=1, is_final=True, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=VerticalDatumPropertyType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'VerticalDatum'))),
    ])
    , 2 : pyxb.binding.content.ContentModelState(state=2, is_final=True, transitions=[
    ])
})



AbstractFeatureType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'boundedBy'), BoundingShapeType, nillable=pyxb.binding.datatypes.boolean(1), scope=AbstractFeatureType))

AbstractFeatureType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'location'), LocationPropertyType, scope=AbstractFeatureType))
AbstractFeatureType._ContentModel = pyxb.binding.content.ContentModel(state_map = {
      1 : pyxb.binding.content.ContentModelState(state=1, is_final=True, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=6, element_use=AbstractFeatureType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'identifier'))),
        pyxb.binding.content.ContentModelTransition(next_state=4, element_use=AbstractFeatureType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'descriptionReference'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=AbstractFeatureType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'boundedBy'))),
        pyxb.binding.content.ContentModelTransition(next_state=3, element_use=AbstractFeatureType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'location'))),
        pyxb.binding.content.ContentModelTransition(next_state=1, element_use=AbstractFeatureType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'metaDataProperty'))),
        pyxb.binding.content.ContentModelTransition(next_state=6, element_use=AbstractFeatureType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name'))),
        pyxb.binding.content.ContentModelTransition(next_state=5, element_use=AbstractFeatureType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'description'))),
    ])
    , 2 : pyxb.binding.content.ContentModelState(state=2, is_final=True, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=3, element_use=AbstractFeatureType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'location'))),
    ])
    , 3 : pyxb.binding.content.ContentModelState(state=3, is_final=True, transitions=[
    ])
    , 4 : pyxb.binding.content.ContentModelState(state=4, is_final=True, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=6, element_use=AbstractFeatureType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'identifier'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=AbstractFeatureType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'boundedBy'))),
        pyxb.binding.content.ContentModelTransition(next_state=6, element_use=AbstractFeatureType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name'))),
        pyxb.binding.content.ContentModelTransition(next_state=3, element_use=AbstractFeatureType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'location'))),
    ])
    , 5 : pyxb.binding.content.ContentModelState(state=5, is_final=True, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=6, element_use=AbstractFeatureType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'identifier'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=AbstractFeatureType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'boundedBy'))),
        pyxb.binding.content.ContentModelTransition(next_state=6, element_use=AbstractFeatureType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name'))),
        pyxb.binding.content.ContentModelTransition(next_state=3, element_use=AbstractFeatureType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'location'))),
        pyxb.binding.content.ContentModelTransition(next_state=4, element_use=AbstractFeatureType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'descriptionReference'))),
    ])
    , 6 : pyxb.binding.content.ContentModelState(state=6, is_final=True, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=AbstractFeatureType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'boundedBy'))),
        pyxb.binding.content.ContentModelTransition(next_state=6, element_use=AbstractFeatureType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name'))),
        pyxb.binding.content.ContentModelTransition(next_state=3, element_use=AbstractFeatureType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'location'))),
    ])
})


AbstractGeometryType._ContentModel = pyxb.binding.content.ContentModel(state_map = {
      1 : pyxb.binding.content.ContentModelState(state=1, is_final=True, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=AbstractGeometryType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'identifier'))),
        pyxb.binding.content.ContentModelTransition(next_state=3, element_use=AbstractGeometryType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'descriptionReference'))),
        pyxb.binding.content.ContentModelTransition(next_state=1, element_use=AbstractGeometryType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'metaDataProperty'))),
        pyxb.binding.content.ContentModelTransition(next_state=4, element_use=AbstractGeometryType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'description'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=AbstractGeometryType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name'))),
    ])
    , 2 : pyxb.binding.content.ContentModelState(state=2, is_final=True, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=AbstractGeometryType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name'))),
    ])
    , 3 : pyxb.binding.content.ContentModelState(state=3, is_final=True, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=AbstractGeometryType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'identifier'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=AbstractGeometryType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name'))),
    ])
    , 4 : pyxb.binding.content.ContentModelState(state=4, is_final=True, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=AbstractGeometryType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'identifier'))),
        pyxb.binding.content.ContentModelTransition(next_state=3, element_use=AbstractGeometryType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'descriptionReference'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=AbstractGeometryType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name'))),
    ])
})


AbstractTimeObjectType._ContentModel = pyxb.binding.content.ContentModel(state_map = {
      1 : pyxb.binding.content.ContentModelState(state=1, is_final=True, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=AbstractTimeObjectType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'identifier'))),
        pyxb.binding.content.ContentModelTransition(next_state=3, element_use=AbstractTimeObjectType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'descriptionReference'))),
        pyxb.binding.content.ContentModelTransition(next_state=1, element_use=AbstractTimeObjectType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'metaDataProperty'))),
        pyxb.binding.content.ContentModelTransition(next_state=4, element_use=AbstractTimeObjectType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'description'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=AbstractTimeObjectType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name'))),
    ])
    , 2 : pyxb.binding.content.ContentModelState(state=2, is_final=True, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=AbstractTimeObjectType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name'))),
    ])
    , 3 : pyxb.binding.content.ContentModelState(state=3, is_final=True, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=AbstractTimeObjectType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'identifier'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=AbstractTimeObjectType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name'))),
    ])
    , 4 : pyxb.binding.content.ContentModelState(state=4, is_final=True, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=AbstractTimeObjectType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'identifier'))),
        pyxb.binding.content.ContentModelTransition(next_state=3, element_use=AbstractTimeObjectType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'descriptionReference'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=AbstractTimeObjectType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name'))),
    ])
})



AbstractTimeSliceType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'validTime'), TimePrimitivePropertyType, scope=AbstractTimeSliceType))

AbstractTimeSliceType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'dataSource'), StringOrRefType, scope=AbstractTimeSliceType))
AbstractTimeSliceType._ContentModel = pyxb.binding.content.ContentModel(state_map = {
      1 : pyxb.binding.content.ContentModelState(state=1, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=4, element_use=AbstractTimeSliceType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'descriptionReference'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=AbstractTimeSliceType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'validTime'))),
        pyxb.binding.content.ContentModelTransition(next_state=6, element_use=AbstractTimeSliceType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'identifier'))),
        pyxb.binding.content.ContentModelTransition(next_state=3, element_use=AbstractTimeSliceType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'description'))),
        pyxb.binding.content.ContentModelTransition(next_state=1, element_use=AbstractTimeSliceType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'metaDataProperty'))),
        pyxb.binding.content.ContentModelTransition(next_state=6, element_use=AbstractTimeSliceType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name'))),
    ])
    , 2 : pyxb.binding.content.ContentModelState(state=2, is_final=True, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=5, element_use=AbstractTimeSliceType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'dataSource'))),
    ])
    , 3 : pyxb.binding.content.ContentModelState(state=3, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=AbstractTimeSliceType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'validTime'))),
        pyxb.binding.content.ContentModelTransition(next_state=6, element_use=AbstractTimeSliceType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'identifier'))),
        pyxb.binding.content.ContentModelTransition(next_state=6, element_use=AbstractTimeSliceType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name'))),
        pyxb.binding.content.ContentModelTransition(next_state=4, element_use=AbstractTimeSliceType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'descriptionReference'))),
    ])
    , 4 : pyxb.binding.content.ContentModelState(state=4, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=AbstractTimeSliceType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'validTime'))),
        pyxb.binding.content.ContentModelTransition(next_state=6, element_use=AbstractTimeSliceType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'identifier'))),
        pyxb.binding.content.ContentModelTransition(next_state=6, element_use=AbstractTimeSliceType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name'))),
    ])
    , 5 : pyxb.binding.content.ContentModelState(state=5, is_final=True, transitions=[
    ])
    , 6 : pyxb.binding.content.ContentModelState(state=6, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=AbstractTimeSliceType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'validTime'))),
        pyxb.binding.content.ContentModelTransition(next_state=6, element_use=AbstractTimeSliceType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name'))),
    ])
})


AbstractTopologyType._ContentModel = pyxb.binding.content.ContentModel(state_map = {
      1 : pyxb.binding.content.ContentModelState(state=1, is_final=True, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=AbstractTopologyType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'identifier'))),
        pyxb.binding.content.ContentModelTransition(next_state=3, element_use=AbstractTopologyType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'descriptionReference'))),
        pyxb.binding.content.ContentModelTransition(next_state=1, element_use=AbstractTopologyType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'metaDataProperty'))),
        pyxb.binding.content.ContentModelTransition(next_state=4, element_use=AbstractTopologyType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'description'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=AbstractTopologyType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name'))),
    ])
    , 2 : pyxb.binding.content.ContentModelState(state=2, is_final=True, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=AbstractTopologyType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name'))),
    ])
    , 3 : pyxb.binding.content.ContentModelState(state=3, is_final=True, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=AbstractTopologyType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'identifier'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=AbstractTopologyType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name'))),
    ])
    , 4 : pyxb.binding.content.ContentModelState(state=4, is_final=True, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=AbstractTopologyType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'identifier'))),
        pyxb.binding.content.ContentModelTransition(next_state=3, element_use=AbstractTopologyType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'descriptionReference'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=AbstractTopologyType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name'))),
    ])
})



ArcByCenterPointType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'endAngle'), AngleType, scope=ArcByCenterPointType))

ArcByCenterPointType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'startAngle'), AngleType, scope=ArcByCenterPointType))

ArcByCenterPointType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'posList'), DirectPositionListType, scope=ArcByCenterPointType))

ArcByCenterPointType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'radius'), LengthType, scope=ArcByCenterPointType))

ArcByCenterPointType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'coordinates'), CoordinatesType, scope=ArcByCenterPointType))

ArcByCenterPointType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'pointRep'), PointPropertyType, scope=ArcByCenterPointType))

ArcByCenterPointType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'pos'), DirectPositionType, scope=ArcByCenterPointType))

ArcByCenterPointType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'pointProperty'), PointPropertyType, scope=ArcByCenterPointType))
ArcByCenterPointType._ContentModel = pyxb.binding.content.ContentModel(state_map = {
      1 : pyxb.binding.content.ContentModelState(state=1, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=4, element_use=ArcByCenterPointType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'pos'))),
        pyxb.binding.content.ContentModelTransition(next_state=4, element_use=ArcByCenterPointType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'posList'))),
        pyxb.binding.content.ContentModelTransition(next_state=4, element_use=ArcByCenterPointType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'coordinates'))),
        pyxb.binding.content.ContentModelTransition(next_state=4, element_use=ArcByCenterPointType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'pointProperty'))),
        pyxb.binding.content.ContentModelTransition(next_state=4, element_use=ArcByCenterPointType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'pointRep'))),
    ])
    , 2 : pyxb.binding.content.ContentModelState(state=2, is_final=True, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=3, element_use=ArcByCenterPointType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'endAngle'))),
    ])
    , 3 : pyxb.binding.content.ContentModelState(state=3, is_final=True, transitions=[
    ])
    , 4 : pyxb.binding.content.ContentModelState(state=4, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=5, element_use=ArcByCenterPointType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'radius'))),
    ])
    , 5 : pyxb.binding.content.ContentModelState(state=5, is_final=True, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=ArcByCenterPointType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'startAngle'))),
        pyxb.binding.content.ContentModelTransition(next_state=3, element_use=ArcByCenterPointType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'endAngle'))),
    ])
})



ArcStringByBulgeType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'bulge'), pyxb.binding.datatypes.double, scope=ArcStringByBulgeType))

ArcStringByBulgeType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'posList'), DirectPositionListType, scope=ArcStringByBulgeType))

ArcStringByBulgeType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'coordinates'), CoordinatesType, scope=ArcStringByBulgeType))

ArcStringByBulgeType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'pointRep'), PointPropertyType, scope=ArcStringByBulgeType))

ArcStringByBulgeType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'pos'), DirectPositionType, scope=ArcStringByBulgeType))

ArcStringByBulgeType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'normal'), VectorType, scope=ArcStringByBulgeType))

ArcStringByBulgeType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'pointProperty'), PointPropertyType, scope=ArcStringByBulgeType))
ArcStringByBulgeType._ContentModel = pyxb.binding.content.ContentModel(state_map = {
      1 : pyxb.binding.content.ContentModelState(state=1, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=ArcStringByBulgeType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'pointRep'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=ArcStringByBulgeType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'pointProperty'))),
        pyxb.binding.content.ContentModelTransition(next_state=3, element_use=ArcStringByBulgeType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'posList'))),
        pyxb.binding.content.ContentModelTransition(next_state=3, element_use=ArcStringByBulgeType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'coordinates'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=ArcStringByBulgeType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'pos'))),
    ])
    , 2 : pyxb.binding.content.ContentModelState(state=2, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=6, element_use=ArcStringByBulgeType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'pointRep'))),
        pyxb.binding.content.ContentModelTransition(next_state=6, element_use=ArcStringByBulgeType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'pointProperty'))),
        pyxb.binding.content.ContentModelTransition(next_state=6, element_use=ArcStringByBulgeType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'pos'))),
    ])
    , 3 : pyxb.binding.content.ContentModelState(state=3, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=4, element_use=ArcStringByBulgeType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'bulge'))),
    ])
    , 4 : pyxb.binding.content.ContentModelState(state=4, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=5, element_use=ArcStringByBulgeType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'normal'))),
        pyxb.binding.content.ContentModelTransition(next_state=4, element_use=ArcStringByBulgeType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'bulge'))),
    ])
    , 5 : pyxb.binding.content.ContentModelState(state=5, is_final=True, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=5, element_use=ArcStringByBulgeType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'normal'))),
    ])
    , 6 : pyxb.binding.content.ContentModelState(state=6, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=6, element_use=ArcStringByBulgeType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'pointRep'))),
        pyxb.binding.content.ContentModelTransition(next_state=6, element_use=ArcStringByBulgeType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'pointProperty'))),
        pyxb.binding.content.ContentModelTransition(next_state=4, element_use=ArcStringByBulgeType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'bulge'))),
        pyxb.binding.content.ContentModelTransition(next_state=6, element_use=ArcStringByBulgeType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'pos'))),
    ])
})



ArcStringType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'pos'), DirectPositionType, scope=ArcStringType))

ArcStringType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'pointRep'), PointPropertyType, scope=ArcStringType))

ArcStringType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'pointProperty'), PointPropertyType, scope=ArcStringType))

ArcStringType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'posList'), DirectPositionListType, scope=ArcStringType))

ArcStringType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'coordinates'), CoordinatesType, scope=ArcStringType))
ArcStringType._ContentModel = pyxb.binding.content.ContentModel(state_map = {
      1 : pyxb.binding.content.ContentModelState(state=1, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=ArcStringType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'pos'))),
        pyxb.binding.content.ContentModelTransition(next_state=4, element_use=ArcStringType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'coordinates'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=ArcStringType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'pointProperty'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=ArcStringType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'pointRep'))),
        pyxb.binding.content.ContentModelTransition(next_state=4, element_use=ArcStringType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'posList'))),
    ])
    , 2 : pyxb.binding.content.ContentModelState(state=2, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=5, element_use=ArcStringType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'pos'))),
        pyxb.binding.content.ContentModelTransition(next_state=5, element_use=ArcStringType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'pointProperty'))),
        pyxb.binding.content.ContentModelTransition(next_state=5, element_use=ArcStringType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'pointRep'))),
    ])
    , 3 : pyxb.binding.content.ContentModelState(state=3, is_final=True, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=3, element_use=ArcStringType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'pos'))),
        pyxb.binding.content.ContentModelTransition(next_state=3, element_use=ArcStringType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'pointProperty'))),
        pyxb.binding.content.ContentModelTransition(next_state=3, element_use=ArcStringType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'pointRep'))),
    ])
    , 4 : pyxb.binding.content.ContentModelState(state=4, is_final=True, transitions=[
    ])
    , 5 : pyxb.binding.content.ContentModelState(state=5, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=3, element_use=ArcStringType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'pos'))),
        pyxb.binding.content.ContentModelTransition(next_state=3, element_use=ArcStringType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'pointProperty'))),
        pyxb.binding.content.ContentModelTransition(next_state=3, element_use=ArcStringType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'pointRep'))),
    ])
})



ArrayType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'members'), ArrayAssociationType, scope=ArrayType))
ArrayType._ContentModel = pyxb.binding.content.ContentModel(state_map = {
      1 : pyxb.binding.content.ContentModelState(state=1, is_final=True, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=4, element_use=ArrayType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'identifier'))),
        pyxb.binding.content.ContentModelTransition(next_state=5, element_use=ArrayType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'descriptionReference'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=ArrayType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'members'))),
        pyxb.binding.content.ContentModelTransition(next_state=1, element_use=ArrayType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'metaDataProperty'))),
        pyxb.binding.content.ContentModelTransition(next_state=3, element_use=ArrayType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'description'))),
        pyxb.binding.content.ContentModelTransition(next_state=4, element_use=ArrayType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name'))),
    ])
    , 2 : pyxb.binding.content.ContentModelState(state=2, is_final=True, transitions=[
    ])
    , 3 : pyxb.binding.content.ContentModelState(state=3, is_final=True, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=4, element_use=ArrayType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'identifier'))),
        pyxb.binding.content.ContentModelTransition(next_state=4, element_use=ArrayType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=ArrayType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'members'))),
        pyxb.binding.content.ContentModelTransition(next_state=5, element_use=ArrayType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'descriptionReference'))),
    ])
    , 4 : pyxb.binding.content.ContentModelState(state=4, is_final=True, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=4, element_use=ArrayType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=ArrayType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'members'))),
    ])
    , 5 : pyxb.binding.content.ContentModelState(state=5, is_final=True, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=4, element_use=ArrayType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'identifier'))),
        pyxb.binding.content.ContentModelTransition(next_state=4, element_use=ArrayType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=ArrayType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'members'))),
    ])
})



BSplineType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'degree'), pyxb.binding.datatypes.nonNegativeInteger, scope=BSplineType))

BSplineType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'knot'), KnotPropertyType, scope=BSplineType))

BSplineType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'posList'), DirectPositionListType, scope=BSplineType))

BSplineType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'coordinates'), CoordinatesType, scope=BSplineType))

BSplineType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'pointRep'), PointPropertyType, scope=BSplineType))

BSplineType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'pos'), DirectPositionType, scope=BSplineType))

BSplineType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'pointProperty'), PointPropertyType, scope=BSplineType))
BSplineType._ContentModel = pyxb.binding.content.ContentModel(state_map = {
      1 : pyxb.binding.content.ContentModelState(state=1, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=6, element_use=BSplineType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'pointRep'))),
        pyxb.binding.content.ContentModelTransition(next_state=6, element_use=BSplineType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'pointProperty'))),
        pyxb.binding.content.ContentModelTransition(next_state=6, element_use=BSplineType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'pos'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=BSplineType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'posList'))),
        pyxb.binding.content.ContentModelTransition(next_state=4, element_use=BSplineType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'degree'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=BSplineType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'coordinates'))),
    ])
    , 2 : pyxb.binding.content.ContentModelState(state=2, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=4, element_use=BSplineType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'degree'))),
    ])
    , 3 : pyxb.binding.content.ContentModelState(state=3, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=5, element_use=BSplineType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'knot'))),
    ])
    , 4 : pyxb.binding.content.ContentModelState(state=4, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=3, element_use=BSplineType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'knot'))),
    ])
    , 5 : pyxb.binding.content.ContentModelState(state=5, is_final=True, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=5, element_use=BSplineType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'knot'))),
    ])
    , 6 : pyxb.binding.content.ContentModelState(state=6, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=6, element_use=BSplineType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'pointProperty'))),
        pyxb.binding.content.ContentModelTransition(next_state=4, element_use=BSplineType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'degree'))),
        pyxb.binding.content.ContentModelTransition(next_state=6, element_use=BSplineType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'pos'))),
        pyxb.binding.content.ContentModelTransition(next_state=6, element_use=BSplineType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'pointRep'))),
    ])
})



BagType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'member'), AssociationRoleType, scope=BagType))

BagType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'members'), ArrayAssociationType, scope=BagType))
BagType._ContentModel = pyxb.binding.content.ContentModel(state_map = {
      1 : pyxb.binding.content.ContentModelState(state=1, is_final=True, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=BagType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'identifier'))),
        pyxb.binding.content.ContentModelTransition(next_state=1, element_use=BagType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'metaDataProperty'))),
        pyxb.binding.content.ContentModelTransition(next_state=3, element_use=BagType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'descriptionReference'))),
        pyxb.binding.content.ContentModelTransition(next_state=4, element_use=BagType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'member'))),
        pyxb.binding.content.ContentModelTransition(next_state=5, element_use=BagType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'members'))),
        pyxb.binding.content.ContentModelTransition(next_state=6, element_use=BagType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'description'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=BagType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name'))),
    ])
    , 2 : pyxb.binding.content.ContentModelState(state=2, is_final=True, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=4, element_use=BagType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'member'))),
        pyxb.binding.content.ContentModelTransition(next_state=5, element_use=BagType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'members'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=BagType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name'))),
    ])
    , 3 : pyxb.binding.content.ContentModelState(state=3, is_final=True, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=BagType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'identifier'))),
        pyxb.binding.content.ContentModelTransition(next_state=4, element_use=BagType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'member'))),
        pyxb.binding.content.ContentModelTransition(next_state=5, element_use=BagType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'members'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=BagType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name'))),
    ])
    , 4 : pyxb.binding.content.ContentModelState(state=4, is_final=True, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=4, element_use=BagType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'member'))),
        pyxb.binding.content.ContentModelTransition(next_state=5, element_use=BagType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'members'))),
    ])
    , 5 : pyxb.binding.content.ContentModelState(state=5, is_final=True, transitions=[
    ])
    , 6 : pyxb.binding.content.ContentModelState(state=6, is_final=True, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=BagType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'identifier'))),
        pyxb.binding.content.ContentModelTransition(next_state=3, element_use=BagType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'descriptionReference'))),
        pyxb.binding.content.ContentModelTransition(next_state=4, element_use=BagType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'member'))),
        pyxb.binding.content.ContentModelTransition(next_state=5, element_use=BagType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'members'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=BagType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name'))),
    ])
})



ClothoidType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'refLocation'), _CTD_ANON_24, scope=ClothoidType))

ClothoidType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'endParameter'), pyxb.binding.datatypes.double, scope=ClothoidType))

ClothoidType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'startParameter'), pyxb.binding.datatypes.double, scope=ClothoidType))

ClothoidType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'scaleFactor'), pyxb.binding.datatypes.decimal, scope=ClothoidType))
ClothoidType._ContentModel = pyxb.binding.content.ContentModel(state_map = {
      1 : pyxb.binding.content.ContentModelState(state=1, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=ClothoidType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'refLocation'))),
    ])
    , 2 : pyxb.binding.content.ContentModelState(state=2, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=3, element_use=ClothoidType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'scaleFactor'))),
    ])
    , 3 : pyxb.binding.content.ContentModelState(state=3, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=4, element_use=ClothoidType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'startParameter'))),
    ])
    , 4 : pyxb.binding.content.ContentModelState(state=4, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=5, element_use=ClothoidType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'endParameter'))),
    ])
    , 5 : pyxb.binding.content.ContentModelState(state=5, is_final=True, transitions=[
    ])
})



CompositeValueType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'valueComponents'), ValueArrayPropertyType, scope=CompositeValueType))

CompositeValueType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'valueComponent'), ValuePropertyType, scope=CompositeValueType))
CompositeValueType._ContentModel = pyxb.binding.content.ContentModel(state_map = {
      1 : pyxb.binding.content.ContentModelState(state=1, is_final=True, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=6, element_use=CompositeValueType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'identifier'))),
        pyxb.binding.content.ContentModelTransition(next_state=3, element_use=CompositeValueType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'descriptionReference'))),
        pyxb.binding.content.ContentModelTransition(next_state=1, element_use=CompositeValueType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'metaDataProperty'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=CompositeValueType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'valueComponents'))),
        pyxb.binding.content.ContentModelTransition(next_state=6, element_use=CompositeValueType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name'))),
        pyxb.binding.content.ContentModelTransition(next_state=4, element_use=CompositeValueType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'description'))),
        pyxb.binding.content.ContentModelTransition(next_state=5, element_use=CompositeValueType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'valueComponent'))),
    ])
    , 2 : pyxb.binding.content.ContentModelState(state=2, is_final=True, transitions=[
    ])
    , 3 : pyxb.binding.content.ContentModelState(state=3, is_final=True, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=6, element_use=CompositeValueType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'identifier'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=CompositeValueType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'valueComponents'))),
        pyxb.binding.content.ContentModelTransition(next_state=6, element_use=CompositeValueType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name'))),
        pyxb.binding.content.ContentModelTransition(next_state=5, element_use=CompositeValueType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'valueComponent'))),
    ])
    , 4 : pyxb.binding.content.ContentModelState(state=4, is_final=True, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=6, element_use=CompositeValueType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'identifier'))),
        pyxb.binding.content.ContentModelTransition(next_state=3, element_use=CompositeValueType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'descriptionReference'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=CompositeValueType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'valueComponents'))),
        pyxb.binding.content.ContentModelTransition(next_state=6, element_use=CompositeValueType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name'))),
        pyxb.binding.content.ContentModelTransition(next_state=5, element_use=CompositeValueType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'valueComponent'))),
    ])
    , 5 : pyxb.binding.content.ContentModelState(state=5, is_final=True, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=CompositeValueType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'valueComponents'))),
        pyxb.binding.content.ContentModelTransition(next_state=5, element_use=CompositeValueType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'valueComponent'))),
    ])
    , 6 : pyxb.binding.content.ContentModelState(state=6, is_final=True, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=CompositeValueType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'valueComponents'))),
        pyxb.binding.content.ContentModelTransition(next_state=6, element_use=CompositeValueType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name'))),
        pyxb.binding.content.ContentModelTransition(next_state=5, element_use=CompositeValueType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'valueComponent'))),
    ])
})



ConversionToPreferredUnitType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'formula'), FormulaType, scope=ConversionToPreferredUnitType))

ConversionToPreferredUnitType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'factor'), pyxb.binding.datatypes.double, scope=ConversionToPreferredUnitType))
ConversionToPreferredUnitType._ContentModel = pyxb.binding.content.ContentModel(state_map = {
      1 : pyxb.binding.content.ContentModelState(state=1, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=ConversionToPreferredUnitType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'factor'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=ConversionToPreferredUnitType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'formula'))),
    ])
    , 2 : pyxb.binding.content.ContentModelState(state=2, is_final=True, transitions=[
    ])
})



CubicSplineType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'vectorAtEnd'), VectorType, scope=CubicSplineType))

CubicSplineType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'vectorAtStart'), VectorType, scope=CubicSplineType))

CubicSplineType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'posList'), DirectPositionListType, scope=CubicSplineType))

CubicSplineType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'coordinates'), CoordinatesType, scope=CubicSplineType))

CubicSplineType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'pointRep'), PointPropertyType, scope=CubicSplineType))

CubicSplineType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'pos'), DirectPositionType, scope=CubicSplineType))

CubicSplineType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'pointProperty'), PointPropertyType, scope=CubicSplineType))
CubicSplineType._ContentModel = pyxb.binding.content.ContentModel(state_map = {
      1 : pyxb.binding.content.ContentModelState(state=1, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=CubicSplineType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'pointRep'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=CubicSplineType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'pos'))),
        pyxb.binding.content.ContentModelTransition(next_state=5, element_use=CubicSplineType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'posList'))),
        pyxb.binding.content.ContentModelTransition(next_state=5, element_use=CubicSplineType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'coordinates'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=CubicSplineType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'pointProperty'))),
    ])
    , 2 : pyxb.binding.content.ContentModelState(state=2, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=6, element_use=CubicSplineType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'pointRep'))),
        pyxb.binding.content.ContentModelTransition(next_state=6, element_use=CubicSplineType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'pos'))),
        pyxb.binding.content.ContentModelTransition(next_state=6, element_use=CubicSplineType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'pointProperty'))),
    ])
    , 3 : pyxb.binding.content.ContentModelState(state=3, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=4, element_use=CubicSplineType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'vectorAtEnd'))),
    ])
    , 4 : pyxb.binding.content.ContentModelState(state=4, is_final=True, transitions=[
    ])
    , 5 : pyxb.binding.content.ContentModelState(state=5, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=3, element_use=CubicSplineType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'vectorAtStart'))),
    ])
    , 6 : pyxb.binding.content.ContentModelState(state=6, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=6, element_use=CubicSplineType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'pointRep'))),
        pyxb.binding.content.ContentModelTransition(next_state=6, element_use=CubicSplineType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'pos'))),
        pyxb.binding.content.ContentModelTransition(next_state=3, element_use=CubicSplineType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'vectorAtStart'))),
        pyxb.binding.content.ContentModelTransition(next_state=6, element_use=CubicSplineType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'pointProperty'))),
    ])
})


DefinitionBaseType._ContentModel = pyxb.binding.content.ContentModel(state_map = {
      1 : pyxb.binding.content.ContentModelState(state=1, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=1, element_use=DefinitionBaseType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'metaDataProperty'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=DefinitionBaseType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'descriptionReference'))),
        pyxb.binding.content.ContentModelTransition(next_state=3, element_use=DefinitionBaseType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'description'))),
        pyxb.binding.content.ContentModelTransition(next_state=4, element_use=DefinitionBaseType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'identifier'))),
    ])
    , 2 : pyxb.binding.content.ContentModelState(state=2, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=4, element_use=DefinitionBaseType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'identifier'))),
    ])
    , 3 : pyxb.binding.content.ContentModelState(state=3, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=DefinitionBaseType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'descriptionReference'))),
        pyxb.binding.content.ContentModelTransition(next_state=4, element_use=DefinitionBaseType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'identifier'))),
    ])
    , 4 : pyxb.binding.content.ContentModelState(state=4, is_final=True, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=4, element_use=DefinitionBaseType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name'))),
    ])
})



DictionaryEntryType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'Definition'), DefinitionType, scope=DictionaryEntryType))
DictionaryEntryType._ContentModel = pyxb.binding.content.ContentModel(state_map = {
      1 : pyxb.binding.content.ContentModelState(state=1, is_final=True, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=DictionaryEntryType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'Definition'))),
    ])
    , 2 : pyxb.binding.content.ContentModelState(state=2, is_final=True, transitions=[
    ])
})



DynamicFeatureMemberType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'DynamicFeature'), DynamicFeatureType, scope=DynamicFeatureMemberType))
DynamicFeatureMemberType._ContentModel = pyxb.binding.content.ContentModel(state_map = {
      1 : pyxb.binding.content.ContentModelState(state=1, is_final=True, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=1, element_use=DynamicFeatureMemberType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'DynamicFeature'))),
    ])
})



EnvelopeWithTimePeriodType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'endPosition'), TimePositionType, scope=EnvelopeWithTimePeriodType))

EnvelopeWithTimePeriodType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'beginPosition'), TimePositionType, scope=EnvelopeWithTimePeriodType))
EnvelopeWithTimePeriodType._ContentModel = pyxb.binding.content.ContentModel(state_map = {
      1 : pyxb.binding.content.ContentModelState(state=1, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=EnvelopeWithTimePeriodType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'pos'))),
        pyxb.binding.content.ContentModelTransition(next_state=4, element_use=EnvelopeWithTimePeriodType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'coordinates'))),
        pyxb.binding.content.ContentModelTransition(next_state=5, element_use=EnvelopeWithTimePeriodType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'lowerCorner'))),
    ])
    , 2 : pyxb.binding.content.ContentModelState(state=2, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=4, element_use=EnvelopeWithTimePeriodType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'pos'))),
    ])
    , 3 : pyxb.binding.content.ContentModelState(state=3, is_final=True, transitions=[
    ])
    , 4 : pyxb.binding.content.ContentModelState(state=4, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=6, element_use=EnvelopeWithTimePeriodType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'beginPosition'))),
    ])
    , 5 : pyxb.binding.content.ContentModelState(state=5, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=4, element_use=EnvelopeWithTimePeriodType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'upperCorner'))),
    ])
    , 6 : pyxb.binding.content.ContentModelState(state=6, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=3, element_use=EnvelopeWithTimePeriodType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'endPosition'))),
    ])
})


GenericMetaDataType._ContentModel = pyxb.binding.content.ContentModel(state_map = {
      1 : pyxb.binding.content.ContentModelState(state=1, is_final=True, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=1, term=pyxb.binding.content.Wildcard(process_contents=pyxb.binding.content.Wildcard.PC_lax, namespace_constraint=pyxb.binding.content.Wildcard.NC_any)),
    ])
})



GeodesicStringType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'posList'), DirectPositionListType, scope=GeodesicStringType))

GeodesicStringType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'pos'), DirectPositionType, scope=GeodesicStringType))

GeodesicStringType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'pointProperty'), PointPropertyType, scope=GeodesicStringType))
GeodesicStringType._ContentModel = pyxb.binding.content.ContentModel(state_map = {
      1 : pyxb.binding.content.ContentModelState(state=1, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=3, element_use=GeodesicStringType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'posList'))),
        pyxb.binding.content.ContentModelTransition(next_state=4, element_use=GeodesicStringType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'pointProperty'))),
        pyxb.binding.content.ContentModelTransition(next_state=4, element_use=GeodesicStringType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'pos'))),
    ])
    , 2 : pyxb.binding.content.ContentModelState(state=2, is_final=True, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=GeodesicStringType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'pointProperty'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=GeodesicStringType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'pos'))),
    ])
    , 3 : pyxb.binding.content.ContentModelState(state=3, is_final=True, transitions=[
    ])
    , 4 : pyxb.binding.content.ContentModelState(state=4, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=GeodesicStringType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'pointProperty'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=GeodesicStringType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'pos'))),
    ])
})



GridDomainType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'Grid'), GridType, scope=GridDomainType))
GridDomainType._ContentModel = pyxb.binding.content.ContentModel(state_map = {
      1 : pyxb.binding.content.ContentModelState(state=1, is_final=True, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=GridDomainType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'Grid'))),
    ])
    , 2 : pyxb.binding.content.ContentModelState(state=2, is_final=True, transitions=[
    ])
})



LineStringSegmentType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'pos'), DirectPositionType, scope=LineStringSegmentType))

LineStringSegmentType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'pointRep'), PointPropertyType, scope=LineStringSegmentType))

LineStringSegmentType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'pointProperty'), PointPropertyType, scope=LineStringSegmentType))

LineStringSegmentType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'posList'), DirectPositionListType, scope=LineStringSegmentType))

LineStringSegmentType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'coordinates'), CoordinatesType, scope=LineStringSegmentType))
LineStringSegmentType._ContentModel = pyxb.binding.content.ContentModel(state_map = {
      1 : pyxb.binding.content.ContentModelState(state=1, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=3, element_use=LineStringSegmentType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'pointProperty'))),
        pyxb.binding.content.ContentModelTransition(next_state=3, element_use=LineStringSegmentType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'pos'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=LineStringSegmentType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'coordinates'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=LineStringSegmentType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'posList'))),
        pyxb.binding.content.ContentModelTransition(next_state=3, element_use=LineStringSegmentType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'pointRep'))),
    ])
    , 2 : pyxb.binding.content.ContentModelState(state=2, is_final=True, transitions=[
    ])
    , 3 : pyxb.binding.content.ContentModelState(state=3, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=4, element_use=LineStringSegmentType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'pointProperty'))),
        pyxb.binding.content.ContentModelTransition(next_state=4, element_use=LineStringSegmentType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'pos'))),
        pyxb.binding.content.ContentModelTransition(next_state=4, element_use=LineStringSegmentType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'pointRep'))),
    ])
    , 4 : pyxb.binding.content.ContentModelState(state=4, is_final=True, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=4, element_use=LineStringSegmentType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'pointProperty'))),
        pyxb.binding.content.ContentModelTransition(next_state=4, element_use=LineStringSegmentType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'pos'))),
        pyxb.binding.content.ContentModelTransition(next_state=4, element_use=LineStringSegmentType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'pointRep'))),
    ])
})



LinearRingType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'pos'), DirectPositionType, scope=LinearRingType))

LinearRingType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'pointRep'), PointPropertyType, scope=LinearRingType))

LinearRingType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'pointProperty'), PointPropertyType, scope=LinearRingType))

LinearRingType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'posList'), DirectPositionListType, scope=LinearRingType))

LinearRingType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'coordinates'), CoordinatesType, scope=LinearRingType))
LinearRingType._ContentModel = pyxb.binding.content.ContentModel(state_map = {
      1 : pyxb.binding.content.ContentModelState(state=1, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=3, element_use=LinearRingType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'pos'))),
        pyxb.binding.content.ContentModelTransition(next_state=6, element_use=LinearRingType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'posList'))),
        pyxb.binding.content.ContentModelTransition(next_state=6, element_use=LinearRingType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'coordinates'))),
        pyxb.binding.content.ContentModelTransition(next_state=3, element_use=LinearRingType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'pointRep'))),
        pyxb.binding.content.ContentModelTransition(next_state=3, element_use=LinearRingType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'pointProperty'))),
    ])
    , 2 : pyxb.binding.content.ContentModelState(state=2, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=4, element_use=LinearRingType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'pos'))),
        pyxb.binding.content.ContentModelTransition(next_state=4, element_use=LinearRingType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'pointProperty'))),
        pyxb.binding.content.ContentModelTransition(next_state=4, element_use=LinearRingType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'pointRep'))),
    ])
    , 3 : pyxb.binding.content.ContentModelState(state=3, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=LinearRingType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'pos'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=LinearRingType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'pointProperty'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=LinearRingType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'pointRep'))),
    ])
    , 4 : pyxb.binding.content.ContentModelState(state=4, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=5, element_use=LinearRingType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'pos'))),
        pyxb.binding.content.ContentModelTransition(next_state=5, element_use=LinearRingType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'pointProperty'))),
        pyxb.binding.content.ContentModelTransition(next_state=5, element_use=LinearRingType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'pointRep'))),
    ])
    , 5 : pyxb.binding.content.ContentModelState(state=5, is_final=True, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=5, element_use=LinearRingType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'pos'))),
        pyxb.binding.content.ContentModelTransition(next_state=5, element_use=LinearRingType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'pointProperty'))),
        pyxb.binding.content.ContentModelTransition(next_state=5, element_use=LinearRingType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'pointRep'))),
    ])
    , 6 : pyxb.binding.content.ContentModelState(state=6, is_final=True, transitions=[
    ])
})



MultiCurveDomainType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'MultiCurve'), MultiCurveType, scope=MultiCurveDomainType))
MultiCurveDomainType._ContentModel = pyxb.binding.content.ContentModel(state_map = {
      1 : pyxb.binding.content.ContentModelState(state=1, is_final=True, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=MultiCurveDomainType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'MultiCurve'))),
    ])
    , 2 : pyxb.binding.content.ContentModelState(state=2, is_final=True, transitions=[
    ])
})



MultiPointDomainType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'MultiPoint'), MultiPointType, scope=MultiPointDomainType))
MultiPointDomainType._ContentModel = pyxb.binding.content.ContentModel(state_map = {
      1 : pyxb.binding.content.ContentModelState(state=1, is_final=True, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=MultiPointDomainType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'MultiPoint'))),
    ])
    , 2 : pyxb.binding.content.ContentModelState(state=2, is_final=True, transitions=[
    ])
})



MultiSolidDomainType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'MultiSolid'), MultiSolidType, scope=MultiSolidDomainType))
MultiSolidDomainType._ContentModel = pyxb.binding.content.ContentModel(state_map = {
      1 : pyxb.binding.content.ContentModelState(state=1, is_final=True, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=MultiSolidDomainType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'MultiSolid'))),
    ])
    , 2 : pyxb.binding.content.ContentModelState(state=2, is_final=True, transitions=[
    ])
})



MultiSurfaceDomainType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'MultiSurface'), MultiSurfaceType, scope=MultiSurfaceDomainType))
MultiSurfaceDomainType._ContentModel = pyxb.binding.content.ContentModel(state_map = {
      1 : pyxb.binding.content.ContentModelState(state=1, is_final=True, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=MultiSurfaceDomainType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'MultiSurface'))),
    ])
    , 2 : pyxb.binding.content.ContentModelState(state=2, is_final=True, transitions=[
    ])
})



OffsetCurveType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'distance'), LengthType, scope=OffsetCurveType))

OffsetCurveType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'offsetBase'), CurvePropertyType, scope=OffsetCurveType))

OffsetCurveType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'refDirection'), VectorType, scope=OffsetCurveType))
OffsetCurveType._ContentModel = pyxb.binding.content.ContentModel(state_map = {
      1 : pyxb.binding.content.ContentModelState(state=1, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=OffsetCurveType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'offsetBase'))),
    ])
    , 2 : pyxb.binding.content.ContentModelState(state=2, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=3, element_use=OffsetCurveType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'distance'))),
    ])
    , 3 : pyxb.binding.content.ContentModelState(state=3, is_final=True, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=4, element_use=OffsetCurveType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'refDirection'))),
    ])
    , 4 : pyxb.binding.content.ContentModelState(state=4, is_final=True, transitions=[
    ])
})



ParameterValueGroupType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'parameterValue'), AbstractGeneralParameterValuePropertyType, scope=ParameterValueGroupType))

ParameterValueGroupType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'group'), OperationParameterGroupPropertyType, scope=ParameterValueGroupType))
ParameterValueGroupType._ContentModel = pyxb.binding.content.ContentModel(state_map = {
      1 : pyxb.binding.content.ContentModelState(state=1, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=ParameterValueGroupType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'parameterValue'))),
    ])
    , 2 : pyxb.binding.content.ContentModelState(state=2, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=3, element_use=ParameterValueGroupType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'parameterValue'))),
    ])
    , 3 : pyxb.binding.content.ContentModelState(state=3, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=3, element_use=ParameterValueGroupType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'parameterValue'))),
        pyxb.binding.content.ContentModelTransition(next_state=4, element_use=ParameterValueGroupType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'group'))),
    ])
    , 4 : pyxb.binding.content.ContentModelState(state=4, is_final=True, transitions=[
    ])
})



ParameterValueType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'operationParameter'), OperationParameterPropertyType, scope=ParameterValueType))

ParameterValueType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'valueFile'), pyxb.binding.datatypes.anyURI, scope=ParameterValueType))

ParameterValueType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'integerValueList'), integerList, scope=ParameterValueType))

ParameterValueType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'dmsAngleValue'), DMSAngleType, scope=ParameterValueType))

ParameterValueType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'integerValue'), pyxb.binding.datatypes.positiveInteger, scope=ParameterValueType))

ParameterValueType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'valueList'), MeasureListType, scope=ParameterValueType))

ParameterValueType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'booleanValue'), pyxb.binding.datatypes.boolean, scope=ParameterValueType))

ParameterValueType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'stringValue'), pyxb.binding.datatypes.string, scope=ParameterValueType))

ParameterValueType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'value'), MeasureType, scope=ParameterValueType))
ParameterValueType._ContentModel = pyxb.binding.content.ContentModel(state_map = {
      1 : pyxb.binding.content.ContentModelState(state=1, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=3, element_use=ParameterValueType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'integerValue'))),
        pyxb.binding.content.ContentModelTransition(next_state=3, element_use=ParameterValueType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'booleanValue'))),
        pyxb.binding.content.ContentModelTransition(next_state=3, element_use=ParameterValueType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'value'))),
        pyxb.binding.content.ContentModelTransition(next_state=3, element_use=ParameterValueType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'valueList'))),
        pyxb.binding.content.ContentModelTransition(next_state=3, element_use=ParameterValueType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'integerValueList'))),
        pyxb.binding.content.ContentModelTransition(next_state=3, element_use=ParameterValueType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'dmsAngleValue'))),
        pyxb.binding.content.ContentModelTransition(next_state=3, element_use=ParameterValueType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'valueFile'))),
        pyxb.binding.content.ContentModelTransition(next_state=3, element_use=ParameterValueType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'stringValue'))),
    ])
    , 2 : pyxb.binding.content.ContentModelState(state=2, is_final=True, transitions=[
    ])
    , 3 : pyxb.binding.content.ContentModelState(state=3, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=ParameterValueType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'operationParameter'))),
    ])
})



PolygonPatchArrayPropertyType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'PolygonPatch'), PolygonPatchType, scope=PolygonPatchArrayPropertyType))
PolygonPatchArrayPropertyType._ContentModel = pyxb.binding.content.ContentModel(state_map = {
      1 : pyxb.binding.content.ContentModelState(state=1, is_final=True, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=1, element_use=PolygonPatchArrayPropertyType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'PolygonPatch'))),
    ])
})



PolygonPatchType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'exterior'), AbstractRingPropertyType, scope=PolygonPatchType))

PolygonPatchType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'interior'), AbstractRingPropertyType, scope=PolygonPatchType))
PolygonPatchType._ContentModel = pyxb.binding.content.ContentModel(state_map = {
      1 : pyxb.binding.content.ContentModelState(state=1, is_final=True, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=PolygonPatchType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'exterior'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=PolygonPatchType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'interior'))),
    ])
    , 2 : pyxb.binding.content.ContentModelState(state=2, is_final=True, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=PolygonPatchType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'interior'))),
    ])
})


PriorityLocationPropertyType._ContentModel = pyxb.binding.content.ContentModel(state_map = {
      1 : pyxb.binding.content.ContentModelState(state=1, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=PriorityLocationPropertyType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'AbstractGeometry'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=PriorityLocationPropertyType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'LocationString'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=PriorityLocationPropertyType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'LocationKeyWord'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=PriorityLocationPropertyType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'Null'))),
    ])
    , 2 : pyxb.binding.content.ContentModelState(state=2, is_final=True, transitions=[
    ])
})



RectangleType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'exterior'), AbstractRingPropertyType, scope=RectangleType))
RectangleType._ContentModel = pyxb.binding.content.ContentModel(state_map = {
      1 : pyxb.binding.content.ContentModelState(state=1, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=RectangleType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'exterior'))),
    ])
    , 2 : pyxb.binding.content.ContentModelState(state=2, is_final=True, transitions=[
    ])
})



RectifiedGridDomainType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'RectifiedGrid'), RectifiedGridType, scope=RectifiedGridDomainType))
RectifiedGridDomainType._ContentModel = pyxb.binding.content.ContentModel(state_map = {
      1 : pyxb.binding.content.ContentModelState(state=1, is_final=True, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=RectifiedGridDomainType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'RectifiedGrid'))),
    ])
    , 2 : pyxb.binding.content.ContentModelState(state=2, is_final=True, transitions=[
    ])
})


RelatedTimeType._ContentModel = pyxb.binding.content.ContentModel(state_map = {
      1 : pyxb.binding.content.ContentModelState(state=1, is_final=True, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=RelatedTimeType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'AbstractTimePrimitive'))),
    ])
    , 2 : pyxb.binding.content.ContentModelState(state=2, is_final=True, transitions=[
    ])
})



RingType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'curveMember'), CurvePropertyType, scope=RingType))
RingType._ContentModel = pyxb.binding.content.ContentModel(state_map = {
      1 : pyxb.binding.content.ContentModelState(state=1, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=RingType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'curveMember'))),
    ])
    , 2 : pyxb.binding.content.ContentModelState(state=2, is_final=True, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=RingType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'curveMember'))),
    ])
})



TrianglePatchArrayPropertyType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'Triangle'), TriangleType, scope=TrianglePatchArrayPropertyType))
TrianglePatchArrayPropertyType._ContentModel = pyxb.binding.content.ContentModel(state_map = {
      1 : pyxb.binding.content.ContentModelState(state=1, is_final=True, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=1, element_use=TrianglePatchArrayPropertyType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'Triangle'))),
    ])
})



TriangleType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'exterior'), AbstractRingPropertyType, scope=TriangleType))
TriangleType._ContentModel = pyxb.binding.content.ContentModel(state_map = {
      1 : pyxb.binding.content.ContentModelState(state=1, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=TriangleType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'exterior'))),
    ])
    , 2 : pyxb.binding.content.ContentModelState(state=2, is_final=True, transitions=[
    ])
})



AbstractCoverageType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'rangeSet'), RangeSetType, scope=AbstractCoverageType))

AbstractCoverageType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'domainSet'), DomainSetType, scope=AbstractCoverageType))
AbstractCoverageType._ContentModel = pyxb.binding.content.ContentModel(state_map = {
      1 : pyxb.binding.content.ContentModelState(state=1, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=8, element_use=AbstractCoverageType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'descriptionReference'))),
        pyxb.binding.content.ContentModelTransition(next_state=1, element_use=AbstractCoverageType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'metaDataProperty'))),
        pyxb.binding.content.ContentModelTransition(next_state=7, element_use=AbstractCoverageType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'identifier'))),
        pyxb.binding.content.ContentModelTransition(next_state=5, element_use=AbstractCoverageType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'boundedBy'))),
        pyxb.binding.content.ContentModelTransition(next_state=6, element_use=AbstractCoverageType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'domainSet'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=AbstractCoverageType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'location'))),
        pyxb.binding.content.ContentModelTransition(next_state=3, element_use=AbstractCoverageType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'description'))),
        pyxb.binding.content.ContentModelTransition(next_state=7, element_use=AbstractCoverageType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name'))),
    ])
    , 2 : pyxb.binding.content.ContentModelState(state=2, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=6, element_use=AbstractCoverageType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'domainSet'))),
    ])
    , 3 : pyxb.binding.content.ContentModelState(state=3, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=6, element_use=AbstractCoverageType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'domainSet'))),
        pyxb.binding.content.ContentModelTransition(next_state=8, element_use=AbstractCoverageType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'descriptionReference'))),
        pyxb.binding.content.ContentModelTransition(next_state=7, element_use=AbstractCoverageType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'identifier'))),
        pyxb.binding.content.ContentModelTransition(next_state=5, element_use=AbstractCoverageType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'boundedBy'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=AbstractCoverageType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'location'))),
        pyxb.binding.content.ContentModelTransition(next_state=7, element_use=AbstractCoverageType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name'))),
    ])
    , 4 : pyxb.binding.content.ContentModelState(state=4, is_final=True, transitions=[
    ])
    , 5 : pyxb.binding.content.ContentModelState(state=5, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=AbstractCoverageType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'location'))),
        pyxb.binding.content.ContentModelTransition(next_state=6, element_use=AbstractCoverageType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'domainSet'))),
    ])
    , 6 : pyxb.binding.content.ContentModelState(state=6, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=4, element_use=AbstractCoverageType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'rangeSet'))),
    ])
    , 7 : pyxb.binding.content.ContentModelState(state=7, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=AbstractCoverageType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'location'))),
        pyxb.binding.content.ContentModelTransition(next_state=5, element_use=AbstractCoverageType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'boundedBy'))),
        pyxb.binding.content.ContentModelTransition(next_state=6, element_use=AbstractCoverageType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'domainSet'))),
        pyxb.binding.content.ContentModelTransition(next_state=7, element_use=AbstractCoverageType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name'))),
    ])
    , 8 : pyxb.binding.content.ContentModelState(state=8, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=AbstractCoverageType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'location'))),
        pyxb.binding.content.ContentModelTransition(next_state=7, element_use=AbstractCoverageType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'identifier'))),
        pyxb.binding.content.ContentModelTransition(next_state=5, element_use=AbstractCoverageType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'boundedBy'))),
        pyxb.binding.content.ContentModelTransition(next_state=6, element_use=AbstractCoverageType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'domainSet'))),
        pyxb.binding.content.ContentModelTransition(next_state=7, element_use=AbstractCoverageType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name'))),
    ])
})



AbstractFeatureCollectionType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'featureMembers'), FeatureArrayPropertyType, scope=AbstractFeatureCollectionType))

AbstractFeatureCollectionType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'featureMember'), FeaturePropertyType, scope=AbstractFeatureCollectionType))
AbstractFeatureCollectionType._ContentModel = pyxb.binding.content.ContentModel(state_map = {
      1 : pyxb.binding.content.ContentModelState(state=1, is_final=True, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=AbstractFeatureCollectionType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'identifier'))),
        pyxb.binding.content.ContentModelTransition(next_state=5, element_use=AbstractFeatureCollectionType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'featureMembers'))),
        pyxb.binding.content.ContentModelTransition(next_state=4, element_use=AbstractFeatureCollectionType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'descriptionReference'))),
        pyxb.binding.content.ContentModelTransition(next_state=7, element_use=AbstractFeatureCollectionType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'featureMember'))),
        pyxb.binding.content.ContentModelTransition(next_state=6, element_use=AbstractFeatureCollectionType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'boundedBy'))),
        pyxb.binding.content.ContentModelTransition(next_state=7, element_use=AbstractFeatureCollectionType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'location'))),
        pyxb.binding.content.ContentModelTransition(next_state=1, element_use=AbstractFeatureCollectionType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'metaDataProperty'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=AbstractFeatureCollectionType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name'))),
        pyxb.binding.content.ContentModelTransition(next_state=3, element_use=AbstractFeatureCollectionType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'description'))),
    ])
    , 2 : pyxb.binding.content.ContentModelState(state=2, is_final=True, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=7, element_use=AbstractFeatureCollectionType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'featureMember'))),
        pyxb.binding.content.ContentModelTransition(next_state=5, element_use=AbstractFeatureCollectionType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'featureMembers'))),
        pyxb.binding.content.ContentModelTransition(next_state=6, element_use=AbstractFeatureCollectionType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'boundedBy'))),
        pyxb.binding.content.ContentModelTransition(next_state=7, element_use=AbstractFeatureCollectionType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'location'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=AbstractFeatureCollectionType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name'))),
    ])
    , 3 : pyxb.binding.content.ContentModelState(state=3, is_final=True, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=AbstractFeatureCollectionType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'identifier'))),
        pyxb.binding.content.ContentModelTransition(next_state=5, element_use=AbstractFeatureCollectionType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'featureMembers'))),
        pyxb.binding.content.ContentModelTransition(next_state=4, element_use=AbstractFeatureCollectionType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'descriptionReference'))),
        pyxb.binding.content.ContentModelTransition(next_state=7, element_use=AbstractFeatureCollectionType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'featureMember'))),
        pyxb.binding.content.ContentModelTransition(next_state=6, element_use=AbstractFeatureCollectionType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'boundedBy'))),
        pyxb.binding.content.ContentModelTransition(next_state=7, element_use=AbstractFeatureCollectionType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'location'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=AbstractFeatureCollectionType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name'))),
    ])
    , 4 : pyxb.binding.content.ContentModelState(state=4, is_final=True, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=AbstractFeatureCollectionType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'identifier'))),
        pyxb.binding.content.ContentModelTransition(next_state=5, element_use=AbstractFeatureCollectionType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'featureMembers'))),
        pyxb.binding.content.ContentModelTransition(next_state=7, element_use=AbstractFeatureCollectionType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'featureMember'))),
        pyxb.binding.content.ContentModelTransition(next_state=6, element_use=AbstractFeatureCollectionType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'boundedBy'))),
        pyxb.binding.content.ContentModelTransition(next_state=7, element_use=AbstractFeatureCollectionType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'location'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=AbstractFeatureCollectionType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name'))),
    ])
    , 5 : pyxb.binding.content.ContentModelState(state=5, is_final=True, transitions=[
    ])
    , 6 : pyxb.binding.content.ContentModelState(state=6, is_final=True, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=7, element_use=AbstractFeatureCollectionType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'featureMember'))),
        pyxb.binding.content.ContentModelTransition(next_state=5, element_use=AbstractFeatureCollectionType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'featureMembers'))),
        pyxb.binding.content.ContentModelTransition(next_state=7, element_use=AbstractFeatureCollectionType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'location'))),
    ])
    , 7 : pyxb.binding.content.ContentModelState(state=7, is_final=True, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=7, element_use=AbstractFeatureCollectionType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'featureMember'))),
        pyxb.binding.content.ContentModelTransition(next_state=5, element_use=AbstractFeatureCollectionType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'featureMembers'))),
    ])
})


AbstractGeometricAggregateType._ContentModel = pyxb.binding.content.ContentModel(state_map = {
      1 : pyxb.binding.content.ContentModelState(state=1, is_final=True, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=AbstractGeometricAggregateType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'identifier'))),
        pyxb.binding.content.ContentModelTransition(next_state=3, element_use=AbstractGeometricAggregateType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'descriptionReference'))),
        pyxb.binding.content.ContentModelTransition(next_state=1, element_use=AbstractGeometricAggregateType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'metaDataProperty'))),
        pyxb.binding.content.ContentModelTransition(next_state=4, element_use=AbstractGeometricAggregateType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'description'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=AbstractGeometricAggregateType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name'))),
    ])
    , 2 : pyxb.binding.content.ContentModelState(state=2, is_final=True, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=AbstractGeometricAggregateType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name'))),
    ])
    , 3 : pyxb.binding.content.ContentModelState(state=3, is_final=True, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=AbstractGeometricAggregateType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'identifier'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=AbstractGeometricAggregateType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name'))),
    ])
    , 4 : pyxb.binding.content.ContentModelState(state=4, is_final=True, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=AbstractGeometricAggregateType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'identifier'))),
        pyxb.binding.content.ContentModelTransition(next_state=3, element_use=AbstractGeometricAggregateType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'descriptionReference'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=AbstractGeometricAggregateType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name'))),
    ])
})


AbstractGeometricPrimitiveType._ContentModel = pyxb.binding.content.ContentModel(state_map = {
      1 : pyxb.binding.content.ContentModelState(state=1, is_final=True, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=AbstractGeometricPrimitiveType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'identifier'))),
        pyxb.binding.content.ContentModelTransition(next_state=3, element_use=AbstractGeometricPrimitiveType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'descriptionReference'))),
        pyxb.binding.content.ContentModelTransition(next_state=1, element_use=AbstractGeometricPrimitiveType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'metaDataProperty'))),
        pyxb.binding.content.ContentModelTransition(next_state=4, element_use=AbstractGeometricPrimitiveType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'description'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=AbstractGeometricPrimitiveType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name'))),
    ])
    , 2 : pyxb.binding.content.ContentModelState(state=2, is_final=True, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=AbstractGeometricPrimitiveType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name'))),
    ])
    , 3 : pyxb.binding.content.ContentModelState(state=3, is_final=True, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=AbstractGeometricPrimitiveType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'identifier'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=AbstractGeometricPrimitiveType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name'))),
    ])
    , 4 : pyxb.binding.content.ContentModelState(state=4, is_final=True, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=AbstractGeometricPrimitiveType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'identifier'))),
        pyxb.binding.content.ContentModelTransition(next_state=3, element_use=AbstractGeometricPrimitiveType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'descriptionReference'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=AbstractGeometricPrimitiveType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name'))),
    ])
})



AbstractGriddedSurfaceType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'rows'), _CTD_ANON_17, scope=AbstractGriddedSurfaceType))
AbstractGriddedSurfaceType._ContentModel = pyxb.binding.content.ContentModel(state_map = {
      1 : pyxb.binding.content.ContentModelState(state=1, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=AbstractGriddedSurfaceType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'rows'))),
    ])
    , 2 : pyxb.binding.content.ContentModelState(state=2, is_final=True, transitions=[
    ])
})


AbstractTimeComplexType._ContentModel = pyxb.binding.content.ContentModel(state_map = {
      1 : pyxb.binding.content.ContentModelState(state=1, is_final=True, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=AbstractTimeComplexType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'identifier'))),
        pyxb.binding.content.ContentModelTransition(next_state=3, element_use=AbstractTimeComplexType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'descriptionReference'))),
        pyxb.binding.content.ContentModelTransition(next_state=1, element_use=AbstractTimeComplexType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'metaDataProperty'))),
        pyxb.binding.content.ContentModelTransition(next_state=4, element_use=AbstractTimeComplexType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'description'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=AbstractTimeComplexType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name'))),
    ])
    , 2 : pyxb.binding.content.ContentModelState(state=2, is_final=True, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=AbstractTimeComplexType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name'))),
    ])
    , 3 : pyxb.binding.content.ContentModelState(state=3, is_final=True, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=AbstractTimeComplexType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'identifier'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=AbstractTimeComplexType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name'))),
    ])
    , 4 : pyxb.binding.content.ContentModelState(state=4, is_final=True, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=AbstractTimeComplexType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'identifier'))),
        pyxb.binding.content.ContentModelTransition(next_state=3, element_use=AbstractTimeComplexType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'descriptionReference'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=AbstractTimeComplexType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name'))),
    ])
})



AbstractTimePrimitiveType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'relatedTime'), RelatedTimeType, scope=AbstractTimePrimitiveType))
AbstractTimePrimitiveType._ContentModel = pyxb.binding.content.ContentModel(state_map = {
      1 : pyxb.binding.content.ContentModelState(state=1, is_final=True, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=4, element_use=AbstractTimePrimitiveType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'identifier'))),
        pyxb.binding.content.ContentModelTransition(next_state=5, element_use=AbstractTimePrimitiveType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'descriptionReference'))),
        pyxb.binding.content.ContentModelTransition(next_state=3, element_use=AbstractTimePrimitiveType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'relatedTime'))),
        pyxb.binding.content.ContentModelTransition(next_state=1, element_use=AbstractTimePrimitiveType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'metaDataProperty'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=AbstractTimePrimitiveType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'description'))),
        pyxb.binding.content.ContentModelTransition(next_state=4, element_use=AbstractTimePrimitiveType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name'))),
    ])
    , 2 : pyxb.binding.content.ContentModelState(state=2, is_final=True, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=4, element_use=AbstractTimePrimitiveType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'identifier'))),
        pyxb.binding.content.ContentModelTransition(next_state=4, element_use=AbstractTimePrimitiveType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name'))),
        pyxb.binding.content.ContentModelTransition(next_state=5, element_use=AbstractTimePrimitiveType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'descriptionReference'))),
        pyxb.binding.content.ContentModelTransition(next_state=3, element_use=AbstractTimePrimitiveType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'relatedTime'))),
    ])
    , 3 : pyxb.binding.content.ContentModelState(state=3, is_final=True, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=3, element_use=AbstractTimePrimitiveType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'relatedTime'))),
    ])
    , 4 : pyxb.binding.content.ContentModelState(state=4, is_final=True, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=4, element_use=AbstractTimePrimitiveType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name'))),
        pyxb.binding.content.ContentModelTransition(next_state=3, element_use=AbstractTimePrimitiveType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'relatedTime'))),
    ])
    , 5 : pyxb.binding.content.ContentModelState(state=5, is_final=True, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=4, element_use=AbstractTimePrimitiveType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'identifier'))),
        pyxb.binding.content.ContentModelTransition(next_state=4, element_use=AbstractTimePrimitiveType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name'))),
        pyxb.binding.content.ContentModelTransition(next_state=3, element_use=AbstractTimePrimitiveType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'relatedTime'))),
    ])
})



AbstractTopoPrimitiveType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'container'), ContainerPropertyType, scope=AbstractTopoPrimitiveType))

AbstractTopoPrimitiveType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'isolated'), IsolatedPropertyType, scope=AbstractTopoPrimitiveType))
AbstractTopoPrimitiveType._ContentModel = pyxb.binding.content.ContentModel(state_map = {
      1 : pyxb.binding.content.ContentModelState(state=1, is_final=True, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=AbstractTopoPrimitiveType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'identifier'))),
        pyxb.binding.content.ContentModelTransition(next_state=4, element_use=AbstractTopoPrimitiveType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'descriptionReference'))),
        pyxb.binding.content.ContentModelTransition(next_state=3, element_use=AbstractTopoPrimitiveType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'container'))),
        pyxb.binding.content.ContentModelTransition(next_state=5, element_use=AbstractTopoPrimitiveType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'description'))),
        pyxb.binding.content.ContentModelTransition(next_state=1, element_use=AbstractTopoPrimitiveType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'metaDataProperty'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=AbstractTopoPrimitiveType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name'))),
        pyxb.binding.content.ContentModelTransition(next_state=6, element_use=AbstractTopoPrimitiveType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'isolated'))),
    ])
    , 2 : pyxb.binding.content.ContentModelState(state=2, is_final=True, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=3, element_use=AbstractTopoPrimitiveType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'container'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=AbstractTopoPrimitiveType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name'))),
        pyxb.binding.content.ContentModelTransition(next_state=6, element_use=AbstractTopoPrimitiveType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'isolated'))),
    ])
    , 3 : pyxb.binding.content.ContentModelState(state=3, is_final=True, transitions=[
    ])
    , 4 : pyxb.binding.content.ContentModelState(state=4, is_final=True, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=AbstractTopoPrimitiveType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'identifier'))),
        pyxb.binding.content.ContentModelTransition(next_state=3, element_use=AbstractTopoPrimitiveType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'container'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=AbstractTopoPrimitiveType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name'))),
        pyxb.binding.content.ContentModelTransition(next_state=6, element_use=AbstractTopoPrimitiveType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'isolated'))),
    ])
    , 5 : pyxb.binding.content.ContentModelState(state=5, is_final=True, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=AbstractTopoPrimitiveType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'identifier'))),
        pyxb.binding.content.ContentModelTransition(next_state=4, element_use=AbstractTopoPrimitiveType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'descriptionReference'))),
        pyxb.binding.content.ContentModelTransition(next_state=3, element_use=AbstractTopoPrimitiveType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'container'))),
        pyxb.binding.content.ContentModelTransition(next_state=6, element_use=AbstractTopoPrimitiveType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'isolated'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=AbstractTopoPrimitiveType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name'))),
    ])
    , 6 : pyxb.binding.content.ContentModelState(state=6, is_final=True, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=3, element_use=AbstractTopoPrimitiveType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'container'))),
        pyxb.binding.content.ContentModelTransition(next_state=6, element_use=AbstractTopoPrimitiveType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'isolated'))),
    ])
})


ArcByBulgeType._ContentModel = pyxb.binding.content.ContentModel(state_map = {
      1 : pyxb.binding.content.ContentModelState(state=1, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=ArcByBulgeType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'coordinates'))),
        pyxb.binding.content.ContentModelTransition(next_state=5, element_use=ArcByBulgeType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'pointProperty'))),
        pyxb.binding.content.ContentModelTransition(next_state=5, element_use=ArcByBulgeType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'pos'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=ArcByBulgeType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'posList'))),
        pyxb.binding.content.ContentModelTransition(next_state=5, element_use=ArcByBulgeType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'pointRep'))),
    ])
    , 2 : pyxb.binding.content.ContentModelState(state=2, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=3, element_use=ArcByBulgeType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'bulge'))),
    ])
    , 3 : pyxb.binding.content.ContentModelState(state=3, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=4, element_use=ArcByBulgeType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'normal'))),
    ])
    , 4 : pyxb.binding.content.ContentModelState(state=4, is_final=True, transitions=[
    ])
    , 5 : pyxb.binding.content.ContentModelState(state=5, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=ArcByBulgeType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'pointProperty'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=ArcByBulgeType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'pointRep'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=ArcByBulgeType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'pos'))),
    ])
})


ArcType._ContentModel = pyxb.binding.content.ContentModel(state_map = {
      1 : pyxb.binding.content.ContentModelState(state=1, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=ArcType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'pointRep'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=ArcType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'pos'))),
        pyxb.binding.content.ContentModelTransition(next_state=4, element_use=ArcType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'coordinates'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=ArcType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'pointProperty'))),
        pyxb.binding.content.ContentModelTransition(next_state=4, element_use=ArcType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'posList'))),
    ])
    , 2 : pyxb.binding.content.ContentModelState(state=2, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=3, element_use=ArcType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'pointRep'))),
        pyxb.binding.content.ContentModelTransition(next_state=3, element_use=ArcType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'pos'))),
        pyxb.binding.content.ContentModelTransition(next_state=3, element_use=ArcType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'pointProperty'))),
    ])
    , 3 : pyxb.binding.content.ContentModelState(state=3, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=4, element_use=ArcType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'pointRep'))),
        pyxb.binding.content.ContentModelTransition(next_state=4, element_use=ArcType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'pos'))),
        pyxb.binding.content.ContentModelTransition(next_state=4, element_use=ArcType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'pointProperty'))),
    ])
    , 4 : pyxb.binding.content.ContentModelState(state=4, is_final=True, transitions=[
    ])
})


BezierType._ContentModel = pyxb.binding.content.ContentModel(state_map = {
      1 : pyxb.binding.content.ContentModelState(state=1, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=BezierType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'pointProperty'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=BezierType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'pos'))),
        pyxb.binding.content.ContentModelTransition(next_state=3, element_use=BezierType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'posList'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=BezierType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'pointRep'))),
        pyxb.binding.content.ContentModelTransition(next_state=3, element_use=BezierType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'coordinates'))),
        pyxb.binding.content.ContentModelTransition(next_state=6, element_use=BezierType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'degree'))),
    ])
    , 2 : pyxb.binding.content.ContentModelState(state=2, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=BezierType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'pos'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=BezierType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'pointRep'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=BezierType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'pointProperty'))),
        pyxb.binding.content.ContentModelTransition(next_state=6, element_use=BezierType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'degree'))),
    ])
    , 3 : pyxb.binding.content.ContentModelState(state=3, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=6, element_use=BezierType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'degree'))),
    ])
    , 4 : pyxb.binding.content.ContentModelState(state=4, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=5, element_use=BezierType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'knot'))),
    ])
    , 5 : pyxb.binding.content.ContentModelState(state=5, is_final=True, transitions=[
    ])
    , 6 : pyxb.binding.content.ContentModelState(state=6, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=4, element_use=BezierType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'knot'))),
    ])
})


BoundedFeatureType._ContentModel = pyxb.binding.content.ContentModel(state_map = {
      1 : pyxb.binding.content.ContentModelState(state=1, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=4, element_use=BoundedFeatureType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'identifier'))),
        pyxb.binding.content.ContentModelTransition(next_state=1, element_use=BoundedFeatureType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'metaDataProperty'))),
        pyxb.binding.content.ContentModelTransition(next_state=3, element_use=BoundedFeatureType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'description'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=BoundedFeatureType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'boundedBy'))),
        pyxb.binding.content.ContentModelTransition(next_state=4, element_use=BoundedFeatureType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name'))),
        pyxb.binding.content.ContentModelTransition(next_state=5, element_use=BoundedFeatureType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'descriptionReference'))),
    ])
    , 2 : pyxb.binding.content.ContentModelState(state=2, is_final=True, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=6, element_use=BoundedFeatureType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'location'))),
    ])
    , 3 : pyxb.binding.content.ContentModelState(state=3, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=4, element_use=BoundedFeatureType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name'))),
        pyxb.binding.content.ContentModelTransition(next_state=4, element_use=BoundedFeatureType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'identifier'))),
        pyxb.binding.content.ContentModelTransition(next_state=5, element_use=BoundedFeatureType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'descriptionReference'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=BoundedFeatureType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'boundedBy'))),
    ])
    , 4 : pyxb.binding.content.ContentModelState(state=4, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=4, element_use=BoundedFeatureType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=BoundedFeatureType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'boundedBy'))),
    ])
    , 5 : pyxb.binding.content.ContentModelState(state=5, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=4, element_use=BoundedFeatureType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name'))),
        pyxb.binding.content.ContentModelTransition(next_state=4, element_use=BoundedFeatureType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'identifier'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=BoundedFeatureType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'boundedBy'))),
    ])
    , 6 : pyxb.binding.content.ContentModelState(state=6, is_final=True, transitions=[
    ])
})


CircleByCenterPointType._ContentModel = pyxb.binding.content.ContentModel(state_map = {
      1 : pyxb.binding.content.ContentModelState(state=1, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=3, element_use=CircleByCenterPointType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'posList'))),
        pyxb.binding.content.ContentModelTransition(next_state=3, element_use=CircleByCenterPointType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'pointProperty'))),
        pyxb.binding.content.ContentModelTransition(next_state=3, element_use=CircleByCenterPointType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'pointRep'))),
        pyxb.binding.content.ContentModelTransition(next_state=3, element_use=CircleByCenterPointType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'pos'))),
        pyxb.binding.content.ContentModelTransition(next_state=3, element_use=CircleByCenterPointType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'coordinates'))),
    ])
    , 2 : pyxb.binding.content.ContentModelState(state=2, is_final=True, transitions=[
    ])
    , 3 : pyxb.binding.content.ContentModelState(state=3, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=CircleByCenterPointType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'radius'))),
    ])
})



DefinitionType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'remarks'), pyxb.binding.datatypes.string, scope=DefinitionType))
DefinitionType._ContentModel = pyxb.binding.content.ContentModel(state_map = {
      1 : pyxb.binding.content.ContentModelState(state=1, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=1, element_use=DefinitionType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'metaDataProperty'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=DefinitionType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'descriptionReference'))),
        pyxb.binding.content.ContentModelTransition(next_state=3, element_use=DefinitionType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'description'))),
        pyxb.binding.content.ContentModelTransition(next_state=5, element_use=DefinitionType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'identifier'))),
    ])
    , 2 : pyxb.binding.content.ContentModelState(state=2, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=5, element_use=DefinitionType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'identifier'))),
    ])
    , 3 : pyxb.binding.content.ContentModelState(state=3, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=DefinitionType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'descriptionReference'))),
        pyxb.binding.content.ContentModelTransition(next_state=5, element_use=DefinitionType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'identifier'))),
    ])
    , 4 : pyxb.binding.content.ContentModelState(state=4, is_final=True, transitions=[
    ])
    , 5 : pyxb.binding.content.ContentModelState(state=5, is_final=True, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=4, element_use=DefinitionType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'remarks'))),
        pyxb.binding.content.ContentModelTransition(next_state=5, element_use=DefinitionType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name'))),
    ])
})



DynamicFeatureType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'history'), HistoryPropertyType, scope=DynamicFeatureType))

DynamicFeatureType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'validTime'), TimePrimitivePropertyType, scope=DynamicFeatureType))

DynamicFeatureType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'dataSourceReference'), ReferenceType, scope=DynamicFeatureType))

DynamicFeatureType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'dataSource'), StringOrRefType, scope=DynamicFeatureType))
DynamicFeatureType._ContentModel = pyxb.binding.content.ContentModel(state_map = {
      1 : pyxb.binding.content.ContentModelState(state=1, is_final=True, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=3, element_use=DynamicFeatureType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'validTime'))),
        pyxb.binding.content.ContentModelTransition(next_state=6, element_use=DynamicFeatureType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'dataSourceReference'))),
        pyxb.binding.content.ContentModelTransition(next_state=5, element_use=DynamicFeatureType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'history'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=DynamicFeatureType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'identifier'))),
        pyxb.binding.content.ContentModelTransition(next_state=8, element_use=DynamicFeatureType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'boundedBy'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=DynamicFeatureType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name'))),
        pyxb.binding.content.ContentModelTransition(next_state=10, element_use=DynamicFeatureType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'dataSource'))),
        pyxb.binding.content.ContentModelTransition(next_state=4, element_use=DynamicFeatureType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'location'))),
        pyxb.binding.content.ContentModelTransition(next_state=1, element_use=DynamicFeatureType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'metaDataProperty'))),
        pyxb.binding.content.ContentModelTransition(next_state=7, element_use=DynamicFeatureType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'descriptionReference'))),
        pyxb.binding.content.ContentModelTransition(next_state=9, element_use=DynamicFeatureType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'description'))),
    ])
    , 2 : pyxb.binding.content.ContentModelState(state=2, is_final=True, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=3, element_use=DynamicFeatureType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'validTime'))),
        pyxb.binding.content.ContentModelTransition(next_state=5, element_use=DynamicFeatureType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'history'))),
        pyxb.binding.content.ContentModelTransition(next_state=8, element_use=DynamicFeatureType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'boundedBy'))),
        pyxb.binding.content.ContentModelTransition(next_state=10, element_use=DynamicFeatureType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'dataSource'))),
        pyxb.binding.content.ContentModelTransition(next_state=4, element_use=DynamicFeatureType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'location'))),
        pyxb.binding.content.ContentModelTransition(next_state=6, element_use=DynamicFeatureType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'dataSourceReference'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=DynamicFeatureType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name'))),
    ])
    , 3 : pyxb.binding.content.ContentModelState(state=3, is_final=True, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=5, element_use=DynamicFeatureType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'history'))),
        pyxb.binding.content.ContentModelTransition(next_state=10, element_use=DynamicFeatureType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'dataSource'))),
        pyxb.binding.content.ContentModelTransition(next_state=6, element_use=DynamicFeatureType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'dataSourceReference'))),
    ])
    , 4 : pyxb.binding.content.ContentModelState(state=4, is_final=True, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=3, element_use=DynamicFeatureType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'validTime'))),
        pyxb.binding.content.ContentModelTransition(next_state=5, element_use=DynamicFeatureType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'history'))),
        pyxb.binding.content.ContentModelTransition(next_state=6, element_use=DynamicFeatureType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'dataSourceReference'))),
        pyxb.binding.content.ContentModelTransition(next_state=10, element_use=DynamicFeatureType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'dataSource'))),
    ])
    , 5 : pyxb.binding.content.ContentModelState(state=5, is_final=True, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=10, element_use=DynamicFeatureType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'dataSource'))),
        pyxb.binding.content.ContentModelTransition(next_state=6, element_use=DynamicFeatureType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'dataSourceReference'))),
    ])
    , 6 : pyxb.binding.content.ContentModelState(state=6, is_final=True, transitions=[
    ])
    , 7 : pyxb.binding.content.ContentModelState(state=7, is_final=True, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=5, element_use=DynamicFeatureType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'history'))),
        pyxb.binding.content.ContentModelTransition(next_state=3, element_use=DynamicFeatureType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'validTime'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=DynamicFeatureType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'identifier'))),
        pyxb.binding.content.ContentModelTransition(next_state=8, element_use=DynamicFeatureType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'boundedBy'))),
        pyxb.binding.content.ContentModelTransition(next_state=10, element_use=DynamicFeatureType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'dataSource'))),
        pyxb.binding.content.ContentModelTransition(next_state=4, element_use=DynamicFeatureType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'location'))),
        pyxb.binding.content.ContentModelTransition(next_state=6, element_use=DynamicFeatureType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'dataSourceReference'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=DynamicFeatureType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name'))),
    ])
    , 8 : pyxb.binding.content.ContentModelState(state=8, is_final=True, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=3, element_use=DynamicFeatureType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'validTime'))),
        pyxb.binding.content.ContentModelTransition(next_state=5, element_use=DynamicFeatureType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'history'))),
        pyxb.binding.content.ContentModelTransition(next_state=10, element_use=DynamicFeatureType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'dataSource'))),
        pyxb.binding.content.ContentModelTransition(next_state=4, element_use=DynamicFeatureType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'location'))),
        pyxb.binding.content.ContentModelTransition(next_state=6, element_use=DynamicFeatureType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'dataSourceReference'))),
    ])
    , 9 : pyxb.binding.content.ContentModelState(state=9, is_final=True, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=5, element_use=DynamicFeatureType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'history'))),
        pyxb.binding.content.ContentModelTransition(next_state=3, element_use=DynamicFeatureType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'validTime'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=DynamicFeatureType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'identifier'))),
        pyxb.binding.content.ContentModelTransition(next_state=8, element_use=DynamicFeatureType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'boundedBy'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=DynamicFeatureType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name'))),
        pyxb.binding.content.ContentModelTransition(next_state=10, element_use=DynamicFeatureType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'dataSource'))),
        pyxb.binding.content.ContentModelTransition(next_state=4, element_use=DynamicFeatureType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'location'))),
        pyxb.binding.content.ContentModelTransition(next_state=6, element_use=DynamicFeatureType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'dataSourceReference'))),
        pyxb.binding.content.ContentModelTransition(next_state=7, element_use=DynamicFeatureType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'descriptionReference'))),
    ])
    , 10 : pyxb.binding.content.ContentModelState(state=10, is_final=True, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=6, element_use=DynamicFeatureType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'dataSourceReference'))),
    ])
})


GeodesicType._ContentModel = pyxb.binding.content.ContentModel(state_map = {
      1 : pyxb.binding.content.ContentModelState(state=1, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=3, element_use=GeodesicType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'posList'))),
        pyxb.binding.content.ContentModelTransition(next_state=4, element_use=GeodesicType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'pointProperty'))),
        pyxb.binding.content.ContentModelTransition(next_state=4, element_use=GeodesicType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'pos'))),
    ])
    , 2 : pyxb.binding.content.ContentModelState(state=2, is_final=True, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=GeodesicType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'pointProperty'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=GeodesicType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'pos'))),
    ])
    , 3 : pyxb.binding.content.ContentModelState(state=3, is_final=True, transitions=[
    ])
    , 4 : pyxb.binding.content.ContentModelState(state=4, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=GeodesicType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'pointProperty'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=GeodesicType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'pos'))),
    ])
})



GeometricComplexType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'element'), GeometricPrimitivePropertyType, scope=GeometricComplexType))
GeometricComplexType._ContentModel = pyxb.binding.content.ContentModel(state_map = {
      1 : pyxb.binding.content.ContentModelState(state=1, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=4, element_use=GeometricComplexType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'identifier'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=GeometricComplexType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'element'))),
        pyxb.binding.content.ContentModelTransition(next_state=1, element_use=GeometricComplexType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'metaDataProperty'))),
        pyxb.binding.content.ContentModelTransition(next_state=4, element_use=GeometricComplexType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name'))),
        pyxb.binding.content.ContentModelTransition(next_state=3, element_use=GeometricComplexType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'description'))),
        pyxb.binding.content.ContentModelTransition(next_state=5, element_use=GeometricComplexType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'descriptionReference'))),
    ])
    , 2 : pyxb.binding.content.ContentModelState(state=2, is_final=True, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=GeometricComplexType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'element'))),
    ])
    , 3 : pyxb.binding.content.ContentModelState(state=3, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=4, element_use=GeometricComplexType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'identifier'))),
        pyxb.binding.content.ContentModelTransition(next_state=4, element_use=GeometricComplexType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=GeometricComplexType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'element'))),
        pyxb.binding.content.ContentModelTransition(next_state=5, element_use=GeometricComplexType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'descriptionReference'))),
    ])
    , 4 : pyxb.binding.content.ContentModelState(state=4, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=4, element_use=GeometricComplexType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=GeometricComplexType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'element'))),
    ])
    , 5 : pyxb.binding.content.ContentModelState(state=5, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=4, element_use=GeometricComplexType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'identifier'))),
        pyxb.binding.content.ContentModelTransition(next_state=4, element_use=GeometricComplexType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=GeometricComplexType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'element'))),
    ])
})



GridType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'limits'), GridLimitsType, scope=GridType))

GridType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'axisLabels'), NCNameList, scope=GridType))

GridType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'axisName'), pyxb.binding.datatypes.string, scope=GridType))
GridType._ContentModel = pyxb.binding.content.ContentModel(state_map = {
      1 : pyxb.binding.content.ContentModelState(state=1, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=5, element_use=GridType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'identifier'))),
        pyxb.binding.content.ContentModelTransition(next_state=5, element_use=GridType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name'))),
        pyxb.binding.content.ContentModelTransition(next_state=3, element_use=GridType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'description'))),
        pyxb.binding.content.ContentModelTransition(next_state=4, element_use=GridType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'limits'))),
        pyxb.binding.content.ContentModelTransition(next_state=1, element_use=GridType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'metaDataProperty'))),
        pyxb.binding.content.ContentModelTransition(next_state=6, element_use=GridType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'descriptionReference'))),
    ])
    , 2 : pyxb.binding.content.ContentModelState(state=2, is_final=True, transitions=[
    ])
    , 3 : pyxb.binding.content.ContentModelState(state=3, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=5, element_use=GridType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'identifier'))),
        pyxb.binding.content.ContentModelTransition(next_state=5, element_use=GridType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name'))),
        pyxb.binding.content.ContentModelTransition(next_state=4, element_use=GridType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'limits'))),
        pyxb.binding.content.ContentModelTransition(next_state=6, element_use=GridType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'descriptionReference'))),
    ])
    , 4 : pyxb.binding.content.ContentModelState(state=4, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=7, element_use=GridType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'axisName'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=GridType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'axisLabels'))),
    ])
    , 5 : pyxb.binding.content.ContentModelState(state=5, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=5, element_use=GridType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name'))),
        pyxb.binding.content.ContentModelTransition(next_state=4, element_use=GridType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'limits'))),
    ])
    , 6 : pyxb.binding.content.ContentModelState(state=6, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=5, element_use=GridType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'identifier'))),
        pyxb.binding.content.ContentModelTransition(next_state=5, element_use=GridType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name'))),
        pyxb.binding.content.ContentModelTransition(next_state=4, element_use=GridType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'limits'))),
    ])
    , 7 : pyxb.binding.content.ContentModelState(state=7, is_final=True, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=7, element_use=GridType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'axisName'))),
    ])
})



MovingObjectStatusType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'locationName'), CodeType, scope=MovingObjectStatusType))

MovingObjectStatusType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'elevation'), MeasureType, scope=MovingObjectStatusType))

MovingObjectStatusType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'locationReference'), ReferenceType, scope=MovingObjectStatusType))

MovingObjectStatusType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'speed'), MeasureType, scope=MovingObjectStatusType))

MovingObjectStatusType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'bearing'), DirectionPropertyType, scope=MovingObjectStatusType))

MovingObjectStatusType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'status'), StringOrRefType, scope=MovingObjectStatusType))

MovingObjectStatusType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'location'), LocationPropertyType, scope=MovingObjectStatusType))

MovingObjectStatusType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'acceleration'), MeasureType, scope=MovingObjectStatusType))

MovingObjectStatusType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'position'), GeometryPropertyType, scope=MovingObjectStatusType))

MovingObjectStatusType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'pos'), DirectPositionType, scope=MovingObjectStatusType))

MovingObjectStatusType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'statusReference'), ReferenceType, scope=MovingObjectStatusType))
MovingObjectStatusType._ContentModel = pyxb.binding.content.ContentModel(state_map = {
      1 : pyxb.binding.content.ContentModelState(state=1, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=3, element_use=MovingObjectStatusType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'description'))),
        pyxb.binding.content.ContentModelTransition(next_state=7, element_use=MovingObjectStatusType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'validTime'))),
        pyxb.binding.content.ContentModelTransition(next_state=12, element_use=MovingObjectStatusType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'identifier'))),
        pyxb.binding.content.ContentModelTransition(next_state=12, element_use=MovingObjectStatusType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name'))),
        pyxb.binding.content.ContentModelTransition(next_state=1, element_use=MovingObjectStatusType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'metaDataProperty'))),
        pyxb.binding.content.ContentModelTransition(next_state=5, element_use=MovingObjectStatusType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'descriptionReference'))),
    ])
    , 2 : pyxb.binding.content.ContentModelState(state=2, is_final=True, transitions=[
    ])
    , 3 : pyxb.binding.content.ContentModelState(state=3, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=12, element_use=MovingObjectStatusType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name'))),
        pyxb.binding.content.ContentModelTransition(next_state=12, element_use=MovingObjectStatusType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'identifier'))),
        pyxb.binding.content.ContentModelTransition(next_state=5, element_use=MovingObjectStatusType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'descriptionReference'))),
        pyxb.binding.content.ContentModelTransition(next_state=7, element_use=MovingObjectStatusType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'validTime'))),
    ])
    , 4 : pyxb.binding.content.ContentModelState(state=4, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=9, element_use=MovingObjectStatusType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'location'))),
        pyxb.binding.content.ContentModelTransition(next_state=9, element_use=MovingObjectStatusType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'locationReference'))),
        pyxb.binding.content.ContentModelTransition(next_state=9, element_use=MovingObjectStatusType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'locationName'))),
        pyxb.binding.content.ContentModelTransition(next_state=9, element_use=MovingObjectStatusType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'pos'))),
        pyxb.binding.content.ContentModelTransition(next_state=9, element_use=MovingObjectStatusType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'position'))),
    ])
    , 5 : pyxb.binding.content.ContentModelState(state=5, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=12, element_use=MovingObjectStatusType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name'))),
        pyxb.binding.content.ContentModelTransition(next_state=12, element_use=MovingObjectStatusType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'identifier'))),
        pyxb.binding.content.ContentModelTransition(next_state=7, element_use=MovingObjectStatusType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'validTime'))),
    ])
    , 6 : pyxb.binding.content.ContentModelState(state=6, is_final=True, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=13, element_use=MovingObjectStatusType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'status'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=MovingObjectStatusType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'statusReference'))),
    ])
    , 7 : pyxb.binding.content.ContentModelState(state=7, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=4, element_use=MovingObjectStatusType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'dataSource'))),
        pyxb.binding.content.ContentModelTransition(next_state=9, element_use=MovingObjectStatusType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'location'))),
        pyxb.binding.content.ContentModelTransition(next_state=9, element_use=MovingObjectStatusType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'position'))),
        pyxb.binding.content.ContentModelTransition(next_state=9, element_use=MovingObjectStatusType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'locationReference'))),
        pyxb.binding.content.ContentModelTransition(next_state=9, element_use=MovingObjectStatusType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'pos'))),
        pyxb.binding.content.ContentModelTransition(next_state=9, element_use=MovingObjectStatusType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'locationName'))),
    ])
    , 8 : pyxb.binding.content.ContentModelState(state=8, is_final=True, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=6, element_use=MovingObjectStatusType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'elevation'))),
        pyxb.binding.content.ContentModelTransition(next_state=11, element_use=MovingObjectStatusType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'acceleration'))),
        pyxb.binding.content.ContentModelTransition(next_state=13, element_use=MovingObjectStatusType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'status'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=MovingObjectStatusType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'statusReference'))),
        pyxb.binding.content.ContentModelTransition(next_state=10, element_use=MovingObjectStatusType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'bearing'))),
    ])
    , 9 : pyxb.binding.content.ContentModelState(state=9, is_final=True, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=6, element_use=MovingObjectStatusType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'elevation'))),
        pyxb.binding.content.ContentModelTransition(next_state=11, element_use=MovingObjectStatusType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'acceleration'))),
        pyxb.binding.content.ContentModelTransition(next_state=13, element_use=MovingObjectStatusType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'status'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=MovingObjectStatusType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'statusReference'))),
        pyxb.binding.content.ContentModelTransition(next_state=8, element_use=MovingObjectStatusType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'speed'))),
        pyxb.binding.content.ContentModelTransition(next_state=10, element_use=MovingObjectStatusType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'bearing'))),
    ])
    , 10 : pyxb.binding.content.ContentModelState(state=10, is_final=True, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=11, element_use=MovingObjectStatusType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'acceleration'))),
        pyxb.binding.content.ContentModelTransition(next_state=13, element_use=MovingObjectStatusType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'status'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=MovingObjectStatusType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'statusReference'))),
        pyxb.binding.content.ContentModelTransition(next_state=6, element_use=MovingObjectStatusType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'elevation'))),
    ])
    , 11 : pyxb.binding.content.ContentModelState(state=11, is_final=True, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=13, element_use=MovingObjectStatusType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'status'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=MovingObjectStatusType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'statusReference'))),
        pyxb.binding.content.ContentModelTransition(next_state=6, element_use=MovingObjectStatusType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'elevation'))),
    ])
    , 12 : pyxb.binding.content.ContentModelState(state=12, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=12, element_use=MovingObjectStatusType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name'))),
        pyxb.binding.content.ContentModelTransition(next_state=7, element_use=MovingObjectStatusType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'validTime'))),
    ])
    , 13 : pyxb.binding.content.ContentModelState(state=13, is_final=True, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=MovingObjectStatusType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'statusReference'))),
    ])
})



ObservationType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'target'), TargetPropertyType, scope=ObservationType))

ObservationType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'resultOf'), ResultType, scope=ObservationType))

ObservationType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'validTime'), TimePrimitivePropertyType, scope=ObservationType))

ObservationType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'using'), ProcedurePropertyType, scope=ObservationType))
ObservationType._ContentModel = pyxb.binding.content.ContentModel(state_map = {
      1 : pyxb.binding.content.ContentModelState(state=1, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=10, element_use=ObservationType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'identifier'))),
        pyxb.binding.content.ContentModelTransition(next_state=9, element_use=ObservationType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'descriptionReference'))),
        pyxb.binding.content.ContentModelTransition(next_state=3, element_use=ObservationType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'boundedBy'))),
        pyxb.binding.content.ContentModelTransition(next_state=8, element_use=ObservationType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'validTime'))),
        pyxb.binding.content.ContentModelTransition(next_state=6, element_use=ObservationType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'location'))),
        pyxb.binding.content.ContentModelTransition(next_state=1, element_use=ObservationType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'metaDataProperty'))),
        pyxb.binding.content.ContentModelTransition(next_state=10, element_use=ObservationType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=ObservationType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'description'))),
    ])
    , 2 : pyxb.binding.content.ContentModelState(state=2, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=10, element_use=ObservationType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'identifier'))),
        pyxb.binding.content.ContentModelTransition(next_state=3, element_use=ObservationType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'boundedBy'))),
        pyxb.binding.content.ContentModelTransition(next_state=8, element_use=ObservationType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'validTime'))),
        pyxb.binding.content.ContentModelTransition(next_state=10, element_use=ObservationType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name'))),
        pyxb.binding.content.ContentModelTransition(next_state=6, element_use=ObservationType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'location'))),
        pyxb.binding.content.ContentModelTransition(next_state=9, element_use=ObservationType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'descriptionReference'))),
    ])
    , 3 : pyxb.binding.content.ContentModelState(state=3, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=6, element_use=ObservationType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'location'))),
        pyxb.binding.content.ContentModelTransition(next_state=8, element_use=ObservationType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'validTime'))),
    ])
    , 4 : pyxb.binding.content.ContentModelState(state=4, is_final=True, transitions=[
    ])
    , 5 : pyxb.binding.content.ContentModelState(state=5, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=4, element_use=ObservationType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'resultOf'))),
    ])
    , 6 : pyxb.binding.content.ContentModelState(state=6, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=8, element_use=ObservationType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'validTime'))),
    ])
    , 7 : pyxb.binding.content.ContentModelState(state=7, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=4, element_use=ObservationType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'resultOf'))),
        pyxb.binding.content.ContentModelTransition(next_state=5, element_use=ObservationType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'target'))),
    ])
    , 8 : pyxb.binding.content.ContentModelState(state=8, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=4, element_use=ObservationType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'resultOf'))),
        pyxb.binding.content.ContentModelTransition(next_state=5, element_use=ObservationType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'target'))),
        pyxb.binding.content.ContentModelTransition(next_state=7, element_use=ObservationType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'using'))),
    ])
    , 9 : pyxb.binding.content.ContentModelState(state=9, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=10, element_use=ObservationType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'identifier'))),
        pyxb.binding.content.ContentModelTransition(next_state=3, element_use=ObservationType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'boundedBy'))),
        pyxb.binding.content.ContentModelTransition(next_state=8, element_use=ObservationType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'validTime'))),
        pyxb.binding.content.ContentModelTransition(next_state=10, element_use=ObservationType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name'))),
        pyxb.binding.content.ContentModelTransition(next_state=6, element_use=ObservationType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'location'))),
    ])
    , 10 : pyxb.binding.content.ContentModelState(state=10, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=3, element_use=ObservationType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'boundedBy'))),
        pyxb.binding.content.ContentModelTransition(next_state=10, element_use=ObservationType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name'))),
        pyxb.binding.content.ContentModelTransition(next_state=8, element_use=ObservationType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'validTime'))),
        pyxb.binding.content.ContentModelTransition(next_state=6, element_use=ObservationType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'location'))),
    ])
})



TopoComplexType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'superComplex'), TopoComplexMemberType, scope=TopoComplexType))

TopoComplexType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'subComplex'), TopoComplexMemberType, scope=TopoComplexType))

TopoComplexType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'topoPrimitiveMember'), TopoPrimitiveMemberType, scope=TopoComplexType))

TopoComplexType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'topoPrimitiveMembers'), TopoPrimitiveArrayAssociationType, scope=TopoComplexType))

TopoComplexType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'maximalComplex'), TopoComplexMemberType, scope=TopoComplexType))
TopoComplexType._ContentModel = pyxb.binding.content.ContentModel(state_map = {
      1 : pyxb.binding.content.ContentModelState(state=1, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=6, element_use=TopoComplexType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'identifier'))),
        pyxb.binding.content.ContentModelTransition(next_state=3, element_use=TopoComplexType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'descriptionReference'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=TopoComplexType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'maximalComplex'))),
        pyxb.binding.content.ContentModelTransition(next_state=4, element_use=TopoComplexType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'description'))),
        pyxb.binding.content.ContentModelTransition(next_state=1, element_use=TopoComplexType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'metaDataProperty'))),
        pyxb.binding.content.ContentModelTransition(next_state=6, element_use=TopoComplexType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name'))),
    ])
    , 2 : pyxb.binding.content.ContentModelState(state=2, is_final=True, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=5, element_use=TopoComplexType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'topoPrimitiveMembers'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=TopoComplexType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'topoPrimitiveMember'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=TopoComplexType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'superComplex'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=TopoComplexType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'subComplex'))),
    ])
    , 3 : pyxb.binding.content.ContentModelState(state=3, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=6, element_use=TopoComplexType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'identifier'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=TopoComplexType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'maximalComplex'))),
        pyxb.binding.content.ContentModelTransition(next_state=6, element_use=TopoComplexType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name'))),
    ])
    , 4 : pyxb.binding.content.ContentModelState(state=4, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=6, element_use=TopoComplexType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'identifier'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=TopoComplexType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'maximalComplex'))),
        pyxb.binding.content.ContentModelTransition(next_state=3, element_use=TopoComplexType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'descriptionReference'))),
        pyxb.binding.content.ContentModelTransition(next_state=6, element_use=TopoComplexType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name'))),
    ])
    , 5 : pyxb.binding.content.ContentModelState(state=5, is_final=True, transitions=[
    ])
    , 6 : pyxb.binding.content.ContentModelState(state=6, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=TopoComplexType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'maximalComplex'))),
        pyxb.binding.content.ContentModelTransition(next_state=6, element_use=TopoComplexType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name'))),
    ])
})



TopoCurveType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'directedEdge'), DirectedEdgePropertyType, scope=TopoCurveType))
TopoCurveType._ContentModel = pyxb.binding.content.ContentModel(state_map = {
      1 : pyxb.binding.content.ContentModelState(state=1, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=4, element_use=TopoCurveType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'identifier'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=TopoCurveType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'directedEdge'))),
        pyxb.binding.content.ContentModelTransition(next_state=1, element_use=TopoCurveType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'metaDataProperty'))),
        pyxb.binding.content.ContentModelTransition(next_state=4, element_use=TopoCurveType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name'))),
        pyxb.binding.content.ContentModelTransition(next_state=5, element_use=TopoCurveType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'description'))),
        pyxb.binding.content.ContentModelTransition(next_state=3, element_use=TopoCurveType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'descriptionReference'))),
    ])
    , 2 : pyxb.binding.content.ContentModelState(state=2, is_final=True, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=TopoCurveType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'directedEdge'))),
    ])
    , 3 : pyxb.binding.content.ContentModelState(state=3, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=4, element_use=TopoCurveType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'identifier'))),
        pyxb.binding.content.ContentModelTransition(next_state=4, element_use=TopoCurveType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=TopoCurveType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'directedEdge'))),
    ])
    , 4 : pyxb.binding.content.ContentModelState(state=4, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=4, element_use=TopoCurveType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=TopoCurveType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'directedEdge'))),
    ])
    , 5 : pyxb.binding.content.ContentModelState(state=5, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=4, element_use=TopoCurveType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'identifier'))),
        pyxb.binding.content.ContentModelTransition(next_state=4, element_use=TopoCurveType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=TopoCurveType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'directedEdge'))),
        pyxb.binding.content.ContentModelTransition(next_state=3, element_use=TopoCurveType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'descriptionReference'))),
    ])
})



TopoPointType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'directedNode'), DirectedNodePropertyType, scope=TopoPointType))
TopoPointType._ContentModel = pyxb.binding.content.ContentModel(state_map = {
      1 : pyxb.binding.content.ContentModelState(state=1, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=4, element_use=TopoPointType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'identifier'))),
        pyxb.binding.content.ContentModelTransition(next_state=1, element_use=TopoPointType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'metaDataProperty'))),
        pyxb.binding.content.ContentModelTransition(next_state=4, element_use=TopoPointType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=TopoPointType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'directedNode'))),
        pyxb.binding.content.ContentModelTransition(next_state=3, element_use=TopoPointType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'description'))),
        pyxb.binding.content.ContentModelTransition(next_state=5, element_use=TopoPointType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'descriptionReference'))),
    ])
    , 2 : pyxb.binding.content.ContentModelState(state=2, is_final=True, transitions=[
    ])
    , 3 : pyxb.binding.content.ContentModelState(state=3, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=4, element_use=TopoPointType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'identifier'))),
        pyxb.binding.content.ContentModelTransition(next_state=4, element_use=TopoPointType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name'))),
        pyxb.binding.content.ContentModelTransition(next_state=5, element_use=TopoPointType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'descriptionReference'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=TopoPointType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'directedNode'))),
    ])
    , 4 : pyxb.binding.content.ContentModelState(state=4, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=4, element_use=TopoPointType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=TopoPointType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'directedNode'))),
    ])
    , 5 : pyxb.binding.content.ContentModelState(state=5, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=4, element_use=TopoPointType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'identifier'))),
        pyxb.binding.content.ContentModelTransition(next_state=4, element_use=TopoPointType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=TopoPointType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'directedNode'))),
    ])
})



TopoSurfaceType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'directedFace'), DirectedFacePropertyType, scope=TopoSurfaceType))
TopoSurfaceType._ContentModel = pyxb.binding.content.ContentModel(state_map = {
      1 : pyxb.binding.content.ContentModelState(state=1, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=4, element_use=TopoSurfaceType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'identifier'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=TopoSurfaceType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'directedFace'))),
        pyxb.binding.content.ContentModelTransition(next_state=1, element_use=TopoSurfaceType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'metaDataProperty'))),
        pyxb.binding.content.ContentModelTransition(next_state=4, element_use=TopoSurfaceType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name'))),
        pyxb.binding.content.ContentModelTransition(next_state=3, element_use=TopoSurfaceType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'description'))),
        pyxb.binding.content.ContentModelTransition(next_state=5, element_use=TopoSurfaceType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'descriptionReference'))),
    ])
    , 2 : pyxb.binding.content.ContentModelState(state=2, is_final=True, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=TopoSurfaceType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'directedFace'))),
    ])
    , 3 : pyxb.binding.content.ContentModelState(state=3, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=4, element_use=TopoSurfaceType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'identifier'))),
        pyxb.binding.content.ContentModelTransition(next_state=4, element_use=TopoSurfaceType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name'))),
        pyxb.binding.content.ContentModelTransition(next_state=5, element_use=TopoSurfaceType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'descriptionReference'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=TopoSurfaceType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'directedFace'))),
    ])
    , 4 : pyxb.binding.content.ContentModelState(state=4, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=4, element_use=TopoSurfaceType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=TopoSurfaceType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'directedFace'))),
    ])
    , 5 : pyxb.binding.content.ContentModelState(state=5, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=4, element_use=TopoSurfaceType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'identifier'))),
        pyxb.binding.content.ContentModelTransition(next_state=4, element_use=TopoSurfaceType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=TopoSurfaceType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'directedFace'))),
    ])
})



TopoVolumeType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'directedTopoSolid'), DirectedTopoSolidPropertyType, scope=TopoVolumeType))
TopoVolumeType._ContentModel = pyxb.binding.content.ContentModel(state_map = {
      1 : pyxb.binding.content.ContentModelState(state=1, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=4, element_use=TopoVolumeType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'identifier'))),
        pyxb.binding.content.ContentModelTransition(next_state=1, element_use=TopoVolumeType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'metaDataProperty'))),
        pyxb.binding.content.ContentModelTransition(next_state=4, element_use=TopoVolumeType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=TopoVolumeType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'directedTopoSolid'))),
        pyxb.binding.content.ContentModelTransition(next_state=3, element_use=TopoVolumeType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'description'))),
        pyxb.binding.content.ContentModelTransition(next_state=5, element_use=TopoVolumeType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'descriptionReference'))),
    ])
    , 2 : pyxb.binding.content.ContentModelState(state=2, is_final=True, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=TopoVolumeType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'directedTopoSolid'))),
    ])
    , 3 : pyxb.binding.content.ContentModelState(state=3, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=4, element_use=TopoVolumeType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'identifier'))),
        pyxb.binding.content.ContentModelTransition(next_state=4, element_use=TopoVolumeType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name'))),
        pyxb.binding.content.ContentModelTransition(next_state=5, element_use=TopoVolumeType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'descriptionReference'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=TopoVolumeType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'directedTopoSolid'))),
    ])
    , 4 : pyxb.binding.content.ContentModelState(state=4, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=4, element_use=TopoVolumeType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=TopoVolumeType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'directedTopoSolid'))),
    ])
    , 5 : pyxb.binding.content.ContentModelState(state=5, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=4, element_use=TopoVolumeType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'identifier'))),
        pyxb.binding.content.ContentModelTransition(next_state=4, element_use=TopoVolumeType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=TopoVolumeType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'directedTopoSolid'))),
    ])
})


ValueArrayType._ContentModel = pyxb.binding.content.ContentModel(state_map = {
      1 : pyxb.binding.content.ContentModelState(state=1, is_final=True, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=6, element_use=ValueArrayType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'identifier'))),
        pyxb.binding.content.ContentModelTransition(next_state=3, element_use=ValueArrayType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'descriptionReference'))),
        pyxb.binding.content.ContentModelTransition(next_state=1, element_use=ValueArrayType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'metaDataProperty'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=ValueArrayType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'valueComponents'))),
        pyxb.binding.content.ContentModelTransition(next_state=6, element_use=ValueArrayType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name'))),
        pyxb.binding.content.ContentModelTransition(next_state=4, element_use=ValueArrayType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'description'))),
        pyxb.binding.content.ContentModelTransition(next_state=5, element_use=ValueArrayType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'valueComponent'))),
    ])
    , 2 : pyxb.binding.content.ContentModelState(state=2, is_final=True, transitions=[
    ])
    , 3 : pyxb.binding.content.ContentModelState(state=3, is_final=True, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=6, element_use=ValueArrayType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'identifier'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=ValueArrayType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'valueComponents'))),
        pyxb.binding.content.ContentModelTransition(next_state=6, element_use=ValueArrayType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name'))),
        pyxb.binding.content.ContentModelTransition(next_state=5, element_use=ValueArrayType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'valueComponent'))),
    ])
    , 4 : pyxb.binding.content.ContentModelState(state=4, is_final=True, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=6, element_use=ValueArrayType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'identifier'))),
        pyxb.binding.content.ContentModelTransition(next_state=3, element_use=ValueArrayType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'descriptionReference'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=ValueArrayType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'valueComponents'))),
        pyxb.binding.content.ContentModelTransition(next_state=6, element_use=ValueArrayType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name'))),
        pyxb.binding.content.ContentModelTransition(next_state=5, element_use=ValueArrayType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'valueComponent'))),
    ])
    , 5 : pyxb.binding.content.ContentModelState(state=5, is_final=True, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=ValueArrayType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'valueComponents'))),
        pyxb.binding.content.ContentModelTransition(next_state=5, element_use=ValueArrayType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'valueComponent'))),
    ])
    , 6 : pyxb.binding.content.ContentModelState(state=6, is_final=True, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=ValueArrayType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'valueComponents'))),
        pyxb.binding.content.ContentModelTransition(next_state=6, element_use=ValueArrayType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name'))),
        pyxb.binding.content.ContentModelTransition(next_state=5, element_use=ValueArrayType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'valueComponent'))),
    ])
})



AbstractContinuousCoverageType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'coverageFunction'), CoverageFunctionType, scope=AbstractContinuousCoverageType))
AbstractContinuousCoverageType._ContentModel = pyxb.binding.content.ContentModel(state_map = {
      1 : pyxb.binding.content.ContentModelState(state=1, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=9, element_use=AbstractContinuousCoverageType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'identifier'))),
        pyxb.binding.content.ContentModelTransition(next_state=8, element_use=AbstractContinuousCoverageType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'descriptionReference'))),
        pyxb.binding.content.ContentModelTransition(next_state=3, element_use=AbstractContinuousCoverageType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'boundedBy'))),
        pyxb.binding.content.ContentModelTransition(next_state=5, element_use=AbstractContinuousCoverageType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'domainSet'))),
        pyxb.binding.content.ContentModelTransition(next_state=7, element_use=AbstractContinuousCoverageType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'location'))),
        pyxb.binding.content.ContentModelTransition(next_state=1, element_use=AbstractContinuousCoverageType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'metaDataProperty'))),
        pyxb.binding.content.ContentModelTransition(next_state=9, element_use=AbstractContinuousCoverageType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=AbstractContinuousCoverageType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'description'))),
    ])
    , 2 : pyxb.binding.content.ContentModelState(state=2, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=9, element_use=AbstractContinuousCoverageType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'identifier'))),
        pyxb.binding.content.ContentModelTransition(next_state=3, element_use=AbstractContinuousCoverageType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'boundedBy'))),
        pyxb.binding.content.ContentModelTransition(next_state=5, element_use=AbstractContinuousCoverageType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'domainSet'))),
        pyxb.binding.content.ContentModelTransition(next_state=9, element_use=AbstractContinuousCoverageType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name'))),
        pyxb.binding.content.ContentModelTransition(next_state=7, element_use=AbstractContinuousCoverageType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'location'))),
        pyxb.binding.content.ContentModelTransition(next_state=8, element_use=AbstractContinuousCoverageType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'descriptionReference'))),
    ])
    , 3 : pyxb.binding.content.ContentModelState(state=3, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=5, element_use=AbstractContinuousCoverageType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'domainSet'))),
        pyxb.binding.content.ContentModelTransition(next_state=7, element_use=AbstractContinuousCoverageType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'location'))),
    ])
    , 4 : pyxb.binding.content.ContentModelState(state=4, is_final=True, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=6, element_use=AbstractContinuousCoverageType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'coverageFunction'))),
    ])
    , 5 : pyxb.binding.content.ContentModelState(state=5, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=4, element_use=AbstractContinuousCoverageType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'rangeSet'))),
    ])
    , 6 : pyxb.binding.content.ContentModelState(state=6, is_final=True, transitions=[
    ])
    , 7 : pyxb.binding.content.ContentModelState(state=7, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=5, element_use=AbstractContinuousCoverageType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'domainSet'))),
    ])
    , 8 : pyxb.binding.content.ContentModelState(state=8, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=9, element_use=AbstractContinuousCoverageType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'identifier'))),
        pyxb.binding.content.ContentModelTransition(next_state=3, element_use=AbstractContinuousCoverageType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'boundedBy'))),
        pyxb.binding.content.ContentModelTransition(next_state=5, element_use=AbstractContinuousCoverageType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'domainSet'))),
        pyxb.binding.content.ContentModelTransition(next_state=9, element_use=AbstractContinuousCoverageType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name'))),
        pyxb.binding.content.ContentModelTransition(next_state=7, element_use=AbstractContinuousCoverageType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'location'))),
    ])
    , 9 : pyxb.binding.content.ContentModelState(state=9, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=3, element_use=AbstractContinuousCoverageType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'boundedBy'))),
        pyxb.binding.content.ContentModelTransition(next_state=5, element_use=AbstractContinuousCoverageType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'domainSet'))),
        pyxb.binding.content.ContentModelTransition(next_state=9, element_use=AbstractContinuousCoverageType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name'))),
        pyxb.binding.content.ContentModelTransition(next_state=7, element_use=AbstractContinuousCoverageType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'location'))),
    ])
})


AbstractCurveType._ContentModel = pyxb.binding.content.ContentModel(state_map = {
      1 : pyxb.binding.content.ContentModelState(state=1, is_final=True, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=AbstractCurveType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'identifier'))),
        pyxb.binding.content.ContentModelTransition(next_state=3, element_use=AbstractCurveType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'descriptionReference'))),
        pyxb.binding.content.ContentModelTransition(next_state=1, element_use=AbstractCurveType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'metaDataProperty'))),
        pyxb.binding.content.ContentModelTransition(next_state=4, element_use=AbstractCurveType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'description'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=AbstractCurveType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name'))),
    ])
    , 2 : pyxb.binding.content.ContentModelState(state=2, is_final=True, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=AbstractCurveType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name'))),
    ])
    , 3 : pyxb.binding.content.ContentModelState(state=3, is_final=True, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=AbstractCurveType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'identifier'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=AbstractCurveType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name'))),
    ])
    , 4 : pyxb.binding.content.ContentModelState(state=4, is_final=True, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=AbstractCurveType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'identifier'))),
        pyxb.binding.content.ContentModelTransition(next_state=3, element_use=AbstractCurveType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'descriptionReference'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=AbstractCurveType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name'))),
    ])
})



AbstractDiscreteCoverageType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'coverageFunction'), CoverageFunctionType, scope=AbstractDiscreteCoverageType))
AbstractDiscreteCoverageType._ContentModel = pyxb.binding.content.ContentModel(state_map = {
      1 : pyxb.binding.content.ContentModelState(state=1, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=9, element_use=AbstractDiscreteCoverageType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'descriptionReference'))),
        pyxb.binding.content.ContentModelTransition(next_state=1, element_use=AbstractDiscreteCoverageType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'metaDataProperty'))),
        pyxb.binding.content.ContentModelTransition(next_state=8, element_use=AbstractDiscreteCoverageType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'identifier'))),
        pyxb.binding.content.ContentModelTransition(next_state=5, element_use=AbstractDiscreteCoverageType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'boundedBy'))),
        pyxb.binding.content.ContentModelTransition(next_state=7, element_use=AbstractDiscreteCoverageType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'domainSet'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=AbstractDiscreteCoverageType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'location'))),
        pyxb.binding.content.ContentModelTransition(next_state=3, element_use=AbstractDiscreteCoverageType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'description'))),
        pyxb.binding.content.ContentModelTransition(next_state=8, element_use=AbstractDiscreteCoverageType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name'))),
    ])
    , 2 : pyxb.binding.content.ContentModelState(state=2, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=7, element_use=AbstractDiscreteCoverageType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'domainSet'))),
    ])
    , 3 : pyxb.binding.content.ContentModelState(state=3, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=7, element_use=AbstractDiscreteCoverageType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'domainSet'))),
        pyxb.binding.content.ContentModelTransition(next_state=9, element_use=AbstractDiscreteCoverageType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'descriptionReference'))),
        pyxb.binding.content.ContentModelTransition(next_state=8, element_use=AbstractDiscreteCoverageType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'identifier'))),
        pyxb.binding.content.ContentModelTransition(next_state=5, element_use=AbstractDiscreteCoverageType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'boundedBy'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=AbstractDiscreteCoverageType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'location'))),
        pyxb.binding.content.ContentModelTransition(next_state=8, element_use=AbstractDiscreteCoverageType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name'))),
    ])
    , 4 : pyxb.binding.content.ContentModelState(state=4, is_final=True, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=6, element_use=AbstractDiscreteCoverageType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'coverageFunction'))),
    ])
    , 5 : pyxb.binding.content.ContentModelState(state=5, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=AbstractDiscreteCoverageType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'location'))),
        pyxb.binding.content.ContentModelTransition(next_state=7, element_use=AbstractDiscreteCoverageType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'domainSet'))),
    ])
    , 6 : pyxb.binding.content.ContentModelState(state=6, is_final=True, transitions=[
    ])
    , 7 : pyxb.binding.content.ContentModelState(state=7, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=4, element_use=AbstractDiscreteCoverageType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'rangeSet'))),
    ])
    , 8 : pyxb.binding.content.ContentModelState(state=8, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=AbstractDiscreteCoverageType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'location'))),
        pyxb.binding.content.ContentModelTransition(next_state=5, element_use=AbstractDiscreteCoverageType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'boundedBy'))),
        pyxb.binding.content.ContentModelTransition(next_state=7, element_use=AbstractDiscreteCoverageType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'domainSet'))),
        pyxb.binding.content.ContentModelTransition(next_state=8, element_use=AbstractDiscreteCoverageType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name'))),
    ])
    , 9 : pyxb.binding.content.ContentModelState(state=9, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=AbstractDiscreteCoverageType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'location'))),
        pyxb.binding.content.ContentModelTransition(next_state=8, element_use=AbstractDiscreteCoverageType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'identifier'))),
        pyxb.binding.content.ContentModelTransition(next_state=5, element_use=AbstractDiscreteCoverageType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'boundedBy'))),
        pyxb.binding.content.ContentModelTransition(next_state=7, element_use=AbstractDiscreteCoverageType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'domainSet'))),
        pyxb.binding.content.ContentModelTransition(next_state=8, element_use=AbstractDiscreteCoverageType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name'))),
    ])
})


AbstractSolidType._ContentModel = pyxb.binding.content.ContentModel(state_map = {
      1 : pyxb.binding.content.ContentModelState(state=1, is_final=True, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=AbstractSolidType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'identifier'))),
        pyxb.binding.content.ContentModelTransition(next_state=3, element_use=AbstractSolidType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'descriptionReference'))),
        pyxb.binding.content.ContentModelTransition(next_state=1, element_use=AbstractSolidType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'metaDataProperty'))),
        pyxb.binding.content.ContentModelTransition(next_state=4, element_use=AbstractSolidType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'description'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=AbstractSolidType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name'))),
    ])
    , 2 : pyxb.binding.content.ContentModelState(state=2, is_final=True, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=AbstractSolidType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name'))),
    ])
    , 3 : pyxb.binding.content.ContentModelState(state=3, is_final=True, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=AbstractSolidType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'identifier'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=AbstractSolidType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name'))),
    ])
    , 4 : pyxb.binding.content.ContentModelState(state=4, is_final=True, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=AbstractSolidType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'identifier'))),
        pyxb.binding.content.ContentModelTransition(next_state=3, element_use=AbstractSolidType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'descriptionReference'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=AbstractSolidType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name'))),
    ])
})


AbstractSurfaceType._ContentModel = pyxb.binding.content.ContentModel(state_map = {
      1 : pyxb.binding.content.ContentModelState(state=1, is_final=True, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=AbstractSurfaceType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'identifier'))),
        pyxb.binding.content.ContentModelTransition(next_state=3, element_use=AbstractSurfaceType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'descriptionReference'))),
        pyxb.binding.content.ContentModelTransition(next_state=1, element_use=AbstractSurfaceType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'metaDataProperty'))),
        pyxb.binding.content.ContentModelTransition(next_state=4, element_use=AbstractSurfaceType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'description'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=AbstractSurfaceType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name'))),
    ])
    , 2 : pyxb.binding.content.ContentModelState(state=2, is_final=True, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=AbstractSurfaceType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name'))),
    ])
    , 3 : pyxb.binding.content.ContentModelState(state=3, is_final=True, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=AbstractSurfaceType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'identifier'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=AbstractSurfaceType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name'))),
    ])
    , 4 : pyxb.binding.content.ContentModelState(state=4, is_final=True, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=AbstractSurfaceType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'identifier'))),
        pyxb.binding.content.ContentModelTransition(next_state=3, element_use=AbstractSurfaceType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'descriptionReference'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=AbstractSurfaceType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name'))),
    ])
})


AbstractTimeGeometricPrimitiveType._ContentModel = pyxb.binding.content.ContentModel(state_map = {
      1 : pyxb.binding.content.ContentModelState(state=1, is_final=True, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=4, element_use=AbstractTimeGeometricPrimitiveType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'identifier'))),
        pyxb.binding.content.ContentModelTransition(next_state=5, element_use=AbstractTimeGeometricPrimitiveType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'descriptionReference'))),
        pyxb.binding.content.ContentModelTransition(next_state=3, element_use=AbstractTimeGeometricPrimitiveType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'relatedTime'))),
        pyxb.binding.content.ContentModelTransition(next_state=1, element_use=AbstractTimeGeometricPrimitiveType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'metaDataProperty'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=AbstractTimeGeometricPrimitiveType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'description'))),
        pyxb.binding.content.ContentModelTransition(next_state=4, element_use=AbstractTimeGeometricPrimitiveType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name'))),
    ])
    , 2 : pyxb.binding.content.ContentModelState(state=2, is_final=True, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=4, element_use=AbstractTimeGeometricPrimitiveType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'identifier'))),
        pyxb.binding.content.ContentModelTransition(next_state=4, element_use=AbstractTimeGeometricPrimitiveType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name'))),
        pyxb.binding.content.ContentModelTransition(next_state=5, element_use=AbstractTimeGeometricPrimitiveType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'descriptionReference'))),
        pyxb.binding.content.ContentModelTransition(next_state=3, element_use=AbstractTimeGeometricPrimitiveType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'relatedTime'))),
    ])
    , 3 : pyxb.binding.content.ContentModelState(state=3, is_final=True, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=3, element_use=AbstractTimeGeometricPrimitiveType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'relatedTime'))),
    ])
    , 4 : pyxb.binding.content.ContentModelState(state=4, is_final=True, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=4, element_use=AbstractTimeGeometricPrimitiveType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name'))),
        pyxb.binding.content.ContentModelTransition(next_state=3, element_use=AbstractTimeGeometricPrimitiveType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'relatedTime'))),
    ])
    , 5 : pyxb.binding.content.ContentModelState(state=5, is_final=True, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=4, element_use=AbstractTimeGeometricPrimitiveType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'identifier'))),
        pyxb.binding.content.ContentModelTransition(next_state=4, element_use=AbstractTimeGeometricPrimitiveType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name'))),
        pyxb.binding.content.ContentModelTransition(next_state=3, element_use=AbstractTimeGeometricPrimitiveType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'relatedTime'))),
    ])
})



AbstractTimeTopologyPrimitiveType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'complex'), ReferenceType, scope=AbstractTimeTopologyPrimitiveType))
AbstractTimeTopologyPrimitiveType._ContentModel = pyxb.binding.content.ContentModel(state_map = {
      1 : pyxb.binding.content.ContentModelState(state=1, is_final=True, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=AbstractTimeTopologyPrimitiveType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'identifier'))),
        pyxb.binding.content.ContentModelTransition(next_state=5, element_use=AbstractTimeTopologyPrimitiveType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'descriptionReference'))),
        pyxb.binding.content.ContentModelTransition(next_state=3, element_use=AbstractTimeTopologyPrimitiveType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'complex'))),
        pyxb.binding.content.ContentModelTransition(next_state=4, element_use=AbstractTimeTopologyPrimitiveType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'relatedTime'))),
        pyxb.binding.content.ContentModelTransition(next_state=1, element_use=AbstractTimeTopologyPrimitiveType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'metaDataProperty'))),
        pyxb.binding.content.ContentModelTransition(next_state=6, element_use=AbstractTimeTopologyPrimitiveType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'description'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=AbstractTimeTopologyPrimitiveType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name'))),
    ])
    , 2 : pyxb.binding.content.ContentModelState(state=2, is_final=True, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=3, element_use=AbstractTimeTopologyPrimitiveType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'complex'))),
        pyxb.binding.content.ContentModelTransition(next_state=4, element_use=AbstractTimeTopologyPrimitiveType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'relatedTime'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=AbstractTimeTopologyPrimitiveType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name'))),
    ])
    , 3 : pyxb.binding.content.ContentModelState(state=3, is_final=True, transitions=[
    ])
    , 4 : pyxb.binding.content.ContentModelState(state=4, is_final=True, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=3, element_use=AbstractTimeTopologyPrimitiveType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'complex'))),
        pyxb.binding.content.ContentModelTransition(next_state=4, element_use=AbstractTimeTopologyPrimitiveType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'relatedTime'))),
    ])
    , 5 : pyxb.binding.content.ContentModelState(state=5, is_final=True, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=AbstractTimeTopologyPrimitiveType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'identifier'))),
        pyxb.binding.content.ContentModelTransition(next_state=3, element_use=AbstractTimeTopologyPrimitiveType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'complex'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=AbstractTimeTopologyPrimitiveType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name'))),
        pyxb.binding.content.ContentModelTransition(next_state=4, element_use=AbstractTimeTopologyPrimitiveType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'relatedTime'))),
    ])
    , 6 : pyxb.binding.content.ContentModelState(state=6, is_final=True, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=AbstractTimeTopologyPrimitiveType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'identifier'))),
        pyxb.binding.content.ContentModelTransition(next_state=5, element_use=AbstractTimeTopologyPrimitiveType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'descriptionReference'))),
        pyxb.binding.content.ContentModelTransition(next_state=4, element_use=AbstractTimeTopologyPrimitiveType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'relatedTime'))),
        pyxb.binding.content.ContentModelTransition(next_state=3, element_use=AbstractTimeTopologyPrimitiveType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'complex'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=AbstractTimeTopologyPrimitiveType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name'))),
    ])
})


CircleType._ContentModel = pyxb.binding.content.ContentModel(state_map = {
      1 : pyxb.binding.content.ContentModelState(state=1, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=CircleType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'pointRep'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=CircleType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'pos'))),
        pyxb.binding.content.ContentModelTransition(next_state=4, element_use=CircleType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'coordinates'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=CircleType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'pointProperty'))),
        pyxb.binding.content.ContentModelTransition(next_state=4, element_use=CircleType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'posList'))),
    ])
    , 2 : pyxb.binding.content.ContentModelState(state=2, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=3, element_use=CircleType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'pointRep'))),
        pyxb.binding.content.ContentModelTransition(next_state=3, element_use=CircleType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'pos'))),
        pyxb.binding.content.ContentModelTransition(next_state=3, element_use=CircleType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'pointProperty'))),
    ])
    , 3 : pyxb.binding.content.ContentModelState(state=3, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=4, element_use=CircleType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'pointRep'))),
        pyxb.binding.content.ContentModelTransition(next_state=4, element_use=CircleType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'pos'))),
        pyxb.binding.content.ContentModelTransition(next_state=4, element_use=CircleType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'pointProperty'))),
    ])
    , 4 : pyxb.binding.content.ContentModelState(state=4, is_final=True, transitions=[
    ])
})


ConeType._ContentModel = pyxb.binding.content.ContentModel(state_map = {
      1 : pyxb.binding.content.ContentModelState(state=1, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=ConeType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'rows'))),
    ])
    , 2 : pyxb.binding.content.ContentModelState(state=2, is_final=True, transitions=[
    ])
})


CylinderType._ContentModel = pyxb.binding.content.ContentModel(state_map = {
      1 : pyxb.binding.content.ContentModelState(state=1, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=CylinderType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'rows'))),
    ])
    , 2 : pyxb.binding.content.ContentModelState(state=2, is_final=True, transitions=[
    ])
})



DefinitionProxyType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'definitionRef'), ReferenceType, scope=DefinitionProxyType))
DefinitionProxyType._ContentModel = pyxb.binding.content.ContentModel(state_map = {
      1 : pyxb.binding.content.ContentModelState(state=1, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=DefinitionProxyType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'descriptionReference'))),
        pyxb.binding.content.ContentModelTransition(next_state=1, element_use=DefinitionProxyType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'metaDataProperty'))),
        pyxb.binding.content.ContentModelTransition(next_state=3, element_use=DefinitionProxyType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'description'))),
        pyxb.binding.content.ContentModelTransition(next_state=6, element_use=DefinitionProxyType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'identifier'))),
    ])
    , 2 : pyxb.binding.content.ContentModelState(state=2, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=6, element_use=DefinitionProxyType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'identifier'))),
    ])
    , 3 : pyxb.binding.content.ContentModelState(state=3, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=DefinitionProxyType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'descriptionReference'))),
        pyxb.binding.content.ContentModelTransition(next_state=6, element_use=DefinitionProxyType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'identifier'))),
    ])
    , 4 : pyxb.binding.content.ContentModelState(state=4, is_final=True, transitions=[
    ])
    , 5 : pyxb.binding.content.ContentModelState(state=5, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=4, element_use=DefinitionProxyType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'definitionRef'))),
    ])
    , 6 : pyxb.binding.content.ContentModelState(state=6, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=4, element_use=DefinitionProxyType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'definitionRef'))),
        pyxb.binding.content.ContentModelTransition(next_state=5, element_use=DefinitionProxyType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'remarks'))),
        pyxb.binding.content.ContentModelTransition(next_state=6, element_use=DefinitionProxyType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name'))),
    ])
})



DictionaryType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'indirectEntry'), IndirectEntryType, scope=DictionaryType))

DictionaryType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'dictionaryEntry'), DictionaryEntryType, scope=DictionaryType))
DictionaryType._ContentModel = pyxb.binding.content.ContentModel(state_map = {
      1 : pyxb.binding.content.ContentModelState(state=1, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=3, element_use=DictionaryType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'descriptionReference'))),
        pyxb.binding.content.ContentModelTransition(next_state=1, element_use=DictionaryType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'metaDataProperty'))),
        pyxb.binding.content.ContentModelTransition(next_state=4, element_use=DictionaryType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'description'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=DictionaryType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'identifier'))),
    ])
    , 2 : pyxb.binding.content.ContentModelState(state=2, is_final=True, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=5, element_use=DictionaryType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'remarks'))),
        pyxb.binding.content.ContentModelTransition(next_state=5, element_use=DictionaryType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'dictionaryEntry'))),
        pyxb.binding.content.ContentModelTransition(next_state=5, element_use=DictionaryType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'indirectEntry'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=DictionaryType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name'))),
    ])
    , 3 : pyxb.binding.content.ContentModelState(state=3, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=DictionaryType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'identifier'))),
    ])
    , 4 : pyxb.binding.content.ContentModelState(state=4, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=3, element_use=DictionaryType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'descriptionReference'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=DictionaryType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'identifier'))),
    ])
    , 5 : pyxb.binding.content.ContentModelState(state=5, is_final=True, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=5, element_use=DictionaryType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'dictionaryEntry'))),
        pyxb.binding.content.ContentModelTransition(next_state=5, element_use=DictionaryType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'indirectEntry'))),
    ])
})



DirectedObservationType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'direction'), DirectionPropertyType, scope=DirectedObservationType))
DirectedObservationType._ContentModel = pyxb.binding.content.ContentModel(state_map = {
      1 : pyxb.binding.content.ContentModelState(state=1, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=11, element_use=DirectedObservationType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'identifier'))),
        pyxb.binding.content.ContentModelTransition(next_state=10, element_use=DirectedObservationType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'descriptionReference'))),
        pyxb.binding.content.ContentModelTransition(next_state=3, element_use=DirectedObservationType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'boundedBy'))),
        pyxb.binding.content.ContentModelTransition(next_state=8, element_use=DirectedObservationType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'validTime'))),
        pyxb.binding.content.ContentModelTransition(next_state=6, element_use=DirectedObservationType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'location'))),
        pyxb.binding.content.ContentModelTransition(next_state=1, element_use=DirectedObservationType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'metaDataProperty'))),
        pyxb.binding.content.ContentModelTransition(next_state=11, element_use=DirectedObservationType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=DirectedObservationType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'description'))),
    ])
    , 2 : pyxb.binding.content.ContentModelState(state=2, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=11, element_use=DirectedObservationType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'identifier'))),
        pyxb.binding.content.ContentModelTransition(next_state=3, element_use=DirectedObservationType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'boundedBy'))),
        pyxb.binding.content.ContentModelTransition(next_state=8, element_use=DirectedObservationType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'validTime'))),
        pyxb.binding.content.ContentModelTransition(next_state=11, element_use=DirectedObservationType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name'))),
        pyxb.binding.content.ContentModelTransition(next_state=6, element_use=DirectedObservationType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'location'))),
        pyxb.binding.content.ContentModelTransition(next_state=10, element_use=DirectedObservationType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'descriptionReference'))),
    ])
    , 3 : pyxb.binding.content.ContentModelState(state=3, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=6, element_use=DirectedObservationType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'location'))),
        pyxb.binding.content.ContentModelTransition(next_state=8, element_use=DirectedObservationType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'validTime'))),
    ])
    , 4 : pyxb.binding.content.ContentModelState(state=4, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=9, element_use=DirectedObservationType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'direction'))),
    ])
    , 5 : pyxb.binding.content.ContentModelState(state=5, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=4, element_use=DirectedObservationType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'resultOf'))),
    ])
    , 6 : pyxb.binding.content.ContentModelState(state=6, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=8, element_use=DirectedObservationType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'validTime'))),
    ])
    , 7 : pyxb.binding.content.ContentModelState(state=7, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=4, element_use=DirectedObservationType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'resultOf'))),
        pyxb.binding.content.ContentModelTransition(next_state=5, element_use=DirectedObservationType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'target'))),
    ])
    , 8 : pyxb.binding.content.ContentModelState(state=8, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=4, element_use=DirectedObservationType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'resultOf'))),
        pyxb.binding.content.ContentModelTransition(next_state=5, element_use=DirectedObservationType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'target'))),
        pyxb.binding.content.ContentModelTransition(next_state=7, element_use=DirectedObservationType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'using'))),
    ])
    , 9 : pyxb.binding.content.ContentModelState(state=9, is_final=True, transitions=[
    ])
    , 10 : pyxb.binding.content.ContentModelState(state=10, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=11, element_use=DirectedObservationType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'identifier'))),
        pyxb.binding.content.ContentModelTransition(next_state=3, element_use=DirectedObservationType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'boundedBy'))),
        pyxb.binding.content.ContentModelTransition(next_state=8, element_use=DirectedObservationType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'validTime'))),
        pyxb.binding.content.ContentModelTransition(next_state=11, element_use=DirectedObservationType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name'))),
        pyxb.binding.content.ContentModelTransition(next_state=6, element_use=DirectedObservationType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'location'))),
    ])
    , 11 : pyxb.binding.content.ContentModelState(state=11, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=3, element_use=DirectedObservationType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'boundedBy'))),
        pyxb.binding.content.ContentModelTransition(next_state=11, element_use=DirectedObservationType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name'))),
        pyxb.binding.content.ContentModelTransition(next_state=8, element_use=DirectedObservationType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'validTime'))),
        pyxb.binding.content.ContentModelTransition(next_state=6, element_use=DirectedObservationType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'location'))),
    ])
})



DynamicFeatureCollectionType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'dynamicMembers'), DynamicFeatureMemberType, scope=DynamicFeatureCollectionType))
DynamicFeatureCollectionType._ContentModel = pyxb.binding.content.ContentModel(state_map = {
      1 : pyxb.binding.content.ContentModelState(state=1, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=3, element_use=DynamicFeatureCollectionType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'validTime'))),
        pyxb.binding.content.ContentModelTransition(next_state=4, element_use=DynamicFeatureCollectionType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'dynamicMembers'))),
        pyxb.binding.content.ContentModelTransition(next_state=11, element_use=DynamicFeatureCollectionType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'dataSourceReference'))),
        pyxb.binding.content.ContentModelTransition(next_state=5, element_use=DynamicFeatureCollectionType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'history'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=DynamicFeatureCollectionType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'identifier'))),
        pyxb.binding.content.ContentModelTransition(next_state=8, element_use=DynamicFeatureCollectionType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'boundedBy'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=DynamicFeatureCollectionType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name'))),
        pyxb.binding.content.ContentModelTransition(next_state=10, element_use=DynamicFeatureCollectionType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'dataSource'))),
        pyxb.binding.content.ContentModelTransition(next_state=6, element_use=DynamicFeatureCollectionType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'location'))),
        pyxb.binding.content.ContentModelTransition(next_state=1, element_use=DynamicFeatureCollectionType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'metaDataProperty'))),
        pyxb.binding.content.ContentModelTransition(next_state=9, element_use=DynamicFeatureCollectionType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'descriptionReference'))),
        pyxb.binding.content.ContentModelTransition(next_state=7, element_use=DynamicFeatureCollectionType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'description'))),
    ])
    , 2 : pyxb.binding.content.ContentModelState(state=2, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=10, element_use=DynamicFeatureCollectionType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'dataSource'))),
        pyxb.binding.content.ContentModelTransition(next_state=3, element_use=DynamicFeatureCollectionType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'validTime'))),
        pyxb.binding.content.ContentModelTransition(next_state=5, element_use=DynamicFeatureCollectionType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'history'))),
        pyxb.binding.content.ContentModelTransition(next_state=8, element_use=DynamicFeatureCollectionType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'boundedBy'))),
        pyxb.binding.content.ContentModelTransition(next_state=4, element_use=DynamicFeatureCollectionType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'dynamicMembers'))),
        pyxb.binding.content.ContentModelTransition(next_state=6, element_use=DynamicFeatureCollectionType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'location'))),
        pyxb.binding.content.ContentModelTransition(next_state=11, element_use=DynamicFeatureCollectionType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'dataSourceReference'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=DynamicFeatureCollectionType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name'))),
    ])
    , 3 : pyxb.binding.content.ContentModelState(state=3, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=5, element_use=DynamicFeatureCollectionType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'history'))),
        pyxb.binding.content.ContentModelTransition(next_state=11, element_use=DynamicFeatureCollectionType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'dataSourceReference'))),
        pyxb.binding.content.ContentModelTransition(next_state=4, element_use=DynamicFeatureCollectionType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'dynamicMembers'))),
        pyxb.binding.content.ContentModelTransition(next_state=10, element_use=DynamicFeatureCollectionType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'dataSource'))),
    ])
    , 4 : pyxb.binding.content.ContentModelState(state=4, is_final=True, transitions=[
    ])
    , 5 : pyxb.binding.content.ContentModelState(state=5, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=11, element_use=DynamicFeatureCollectionType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'dataSourceReference'))),
        pyxb.binding.content.ContentModelTransition(next_state=4, element_use=DynamicFeatureCollectionType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'dynamicMembers'))),
        pyxb.binding.content.ContentModelTransition(next_state=10, element_use=DynamicFeatureCollectionType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'dataSource'))),
    ])
    , 6 : pyxb.binding.content.ContentModelState(state=6, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=3, element_use=DynamicFeatureCollectionType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'validTime'))),
        pyxb.binding.content.ContentModelTransition(next_state=5, element_use=DynamicFeatureCollectionType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'history'))),
        pyxb.binding.content.ContentModelTransition(next_state=11, element_use=DynamicFeatureCollectionType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'dataSourceReference'))),
        pyxb.binding.content.ContentModelTransition(next_state=4, element_use=DynamicFeatureCollectionType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'dynamicMembers'))),
        pyxb.binding.content.ContentModelTransition(next_state=10, element_use=DynamicFeatureCollectionType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'dataSource'))),
    ])
    , 7 : pyxb.binding.content.ContentModelState(state=7, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=5, element_use=DynamicFeatureCollectionType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'history'))),
        pyxb.binding.content.ContentModelTransition(next_state=4, element_use=DynamicFeatureCollectionType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'dynamicMembers'))),
        pyxb.binding.content.ContentModelTransition(next_state=3, element_use=DynamicFeatureCollectionType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'validTime'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=DynamicFeatureCollectionType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'identifier'))),
        pyxb.binding.content.ContentModelTransition(next_state=8, element_use=DynamicFeatureCollectionType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'boundedBy'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=DynamicFeatureCollectionType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name'))),
        pyxb.binding.content.ContentModelTransition(next_state=10, element_use=DynamicFeatureCollectionType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'dataSource'))),
        pyxb.binding.content.ContentModelTransition(next_state=6, element_use=DynamicFeatureCollectionType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'location'))),
        pyxb.binding.content.ContentModelTransition(next_state=11, element_use=DynamicFeatureCollectionType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'dataSourceReference'))),
        pyxb.binding.content.ContentModelTransition(next_state=9, element_use=DynamicFeatureCollectionType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'descriptionReference'))),
    ])
    , 8 : pyxb.binding.content.ContentModelState(state=8, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=4, element_use=DynamicFeatureCollectionType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'dynamicMembers'))),
        pyxb.binding.content.ContentModelTransition(next_state=3, element_use=DynamicFeatureCollectionType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'validTime'))),
        pyxb.binding.content.ContentModelTransition(next_state=5, element_use=DynamicFeatureCollectionType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'history'))),
        pyxb.binding.content.ContentModelTransition(next_state=10, element_use=DynamicFeatureCollectionType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'dataSource'))),
        pyxb.binding.content.ContentModelTransition(next_state=6, element_use=DynamicFeatureCollectionType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'location'))),
        pyxb.binding.content.ContentModelTransition(next_state=11, element_use=DynamicFeatureCollectionType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'dataSourceReference'))),
    ])
    , 9 : pyxb.binding.content.ContentModelState(state=9, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=5, element_use=DynamicFeatureCollectionType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'history'))),
        pyxb.binding.content.ContentModelTransition(next_state=3, element_use=DynamicFeatureCollectionType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'validTime'))),
        pyxb.binding.content.ContentModelTransition(next_state=10, element_use=DynamicFeatureCollectionType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'dataSource'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=DynamicFeatureCollectionType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'identifier'))),
        pyxb.binding.content.ContentModelTransition(next_state=8, element_use=DynamicFeatureCollectionType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'boundedBy'))),
        pyxb.binding.content.ContentModelTransition(next_state=4, element_use=DynamicFeatureCollectionType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'dynamicMembers'))),
        pyxb.binding.content.ContentModelTransition(next_state=6, element_use=DynamicFeatureCollectionType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'location'))),
        pyxb.binding.content.ContentModelTransition(next_state=11, element_use=DynamicFeatureCollectionType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'dataSourceReference'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=DynamicFeatureCollectionType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name'))),
    ])
    , 10 : pyxb.binding.content.ContentModelState(state=10, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=11, element_use=DynamicFeatureCollectionType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'dataSourceReference'))),
        pyxb.binding.content.ContentModelTransition(next_state=4, element_use=DynamicFeatureCollectionType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'dynamicMembers'))),
    ])
    , 11 : pyxb.binding.content.ContentModelState(state=11, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=4, element_use=DynamicFeatureCollectionType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'dynamicMembers'))),
    ])
})



EdgeType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'curveProperty'), CurvePropertyType, scope=EdgeType))

EdgeType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'directedFace'), DirectedFacePropertyType, scope=EdgeType))

EdgeType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'directedNode'), DirectedNodePropertyType, scope=EdgeType))
EdgeType._ContentModel = pyxb.binding.content.ContentModel(state_map = {
      1 : pyxb.binding.content.ContentModelState(state=1, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=7, element_use=EdgeType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'identifier'))),
        pyxb.binding.content.ContentModelTransition(next_state=3, element_use=EdgeType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'container'))),
        pyxb.binding.content.ContentModelTransition(next_state=7, element_use=EdgeType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name'))),
        pyxb.binding.content.ContentModelTransition(next_state=5, element_use=EdgeType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'directedNode'))),
        pyxb.binding.content.ContentModelTransition(next_state=8, element_use=EdgeType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'description'))),
        pyxb.binding.content.ContentModelTransition(next_state=1, element_use=EdgeType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'metaDataProperty'))),
        pyxb.binding.content.ContentModelTransition(next_state=9, element_use=EdgeType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'descriptionReference'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=EdgeType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'isolated'))),
    ])
    , 2 : pyxb.binding.content.ContentModelState(state=2, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=3, element_use=EdgeType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'container'))),
        pyxb.binding.content.ContentModelTransition(next_state=5, element_use=EdgeType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'directedNode'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=EdgeType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'isolated'))),
    ])
    , 3 : pyxb.binding.content.ContentModelState(state=3, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=5, element_use=EdgeType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'directedNode'))),
    ])
    , 4 : pyxb.binding.content.ContentModelState(state=4, is_final=True, transitions=[
    ])
    , 5 : pyxb.binding.content.ContentModelState(state=5, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=6, element_use=EdgeType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'directedNode'))),
    ])
    , 6 : pyxb.binding.content.ContentModelState(state=6, is_final=True, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=4, element_use=EdgeType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'curveProperty'))),
        pyxb.binding.content.ContentModelTransition(next_state=6, element_use=EdgeType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'directedFace'))),
    ])
    , 7 : pyxb.binding.content.ContentModelState(state=7, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=7, element_use=EdgeType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name'))),
        pyxb.binding.content.ContentModelTransition(next_state=3, element_use=EdgeType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'container'))),
        pyxb.binding.content.ContentModelTransition(next_state=5, element_use=EdgeType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'directedNode'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=EdgeType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'isolated'))),
    ])
    , 8 : pyxb.binding.content.ContentModelState(state=8, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=7, element_use=EdgeType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'identifier'))),
        pyxb.binding.content.ContentModelTransition(next_state=3, element_use=EdgeType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'container'))),
        pyxb.binding.content.ContentModelTransition(next_state=7, element_use=EdgeType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name'))),
        pyxb.binding.content.ContentModelTransition(next_state=5, element_use=EdgeType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'directedNode'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=EdgeType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'isolated'))),
        pyxb.binding.content.ContentModelTransition(next_state=9, element_use=EdgeType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'descriptionReference'))),
    ])
    , 9 : pyxb.binding.content.ContentModelState(state=9, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=7, element_use=EdgeType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'identifier'))),
        pyxb.binding.content.ContentModelTransition(next_state=7, element_use=EdgeType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name'))),
        pyxb.binding.content.ContentModelTransition(next_state=3, element_use=EdgeType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'container'))),
        pyxb.binding.content.ContentModelTransition(next_state=5, element_use=EdgeType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'directedNode'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=EdgeType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'isolated'))),
    ])
})



FaceType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'directedTopoSolid'), DirectedTopoSolidPropertyType, scope=FaceType))

FaceType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'surfaceProperty'), SurfacePropertyType, scope=FaceType))

FaceType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'directedEdge'), DirectedEdgePropertyType, scope=FaceType))
FaceType._ContentModel = pyxb.binding.content.ContentModel(state_map = {
      1 : pyxb.binding.content.ContentModelState(state=1, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=5, element_use=FaceType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'directedEdge'))),
        pyxb.binding.content.ContentModelTransition(next_state=3, element_use=FaceType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'container'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=FaceType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'identifier'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=FaceType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name'))),
        pyxb.binding.content.ContentModelTransition(next_state=9, element_use=FaceType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'description'))),
        pyxb.binding.content.ContentModelTransition(next_state=1, element_use=FaceType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'metaDataProperty'))),
        pyxb.binding.content.ContentModelTransition(next_state=10, element_use=FaceType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'descriptionReference'))),
        pyxb.binding.content.ContentModelTransition(next_state=4, element_use=FaceType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'isolated'))),
    ])
    , 2 : pyxb.binding.content.ContentModelState(state=2, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=3, element_use=FaceType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'container'))),
        pyxb.binding.content.ContentModelTransition(next_state=5, element_use=FaceType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'directedEdge'))),
        pyxb.binding.content.ContentModelTransition(next_state=4, element_use=FaceType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'isolated'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=FaceType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name'))),
    ])
    , 3 : pyxb.binding.content.ContentModelState(state=3, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=5, element_use=FaceType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'directedEdge'))),
    ])
    , 4 : pyxb.binding.content.ContentModelState(state=4, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=3, element_use=FaceType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'container'))),
        pyxb.binding.content.ContentModelTransition(next_state=5, element_use=FaceType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'directedEdge'))),
        pyxb.binding.content.ContentModelTransition(next_state=4, element_use=FaceType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'isolated'))),
    ])
    , 5 : pyxb.binding.content.ContentModelState(state=5, is_final=True, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=6, element_use=FaceType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'directedTopoSolid'))),
        pyxb.binding.content.ContentModelTransition(next_state=5, element_use=FaceType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'directedEdge'))),
        pyxb.binding.content.ContentModelTransition(next_state=7, element_use=FaceType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'surfaceProperty'))),
    ])
    , 6 : pyxb.binding.content.ContentModelState(state=6, is_final=True, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=8, element_use=FaceType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'directedTopoSolid'))),
        pyxb.binding.content.ContentModelTransition(next_state=7, element_use=FaceType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'surfaceProperty'))),
    ])
    , 7 : pyxb.binding.content.ContentModelState(state=7, is_final=True, transitions=[
    ])
    , 8 : pyxb.binding.content.ContentModelState(state=8, is_final=True, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=7, element_use=FaceType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'surfaceProperty'))),
    ])
    , 9 : pyxb.binding.content.ContentModelState(state=9, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=5, element_use=FaceType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'directedEdge'))),
        pyxb.binding.content.ContentModelTransition(next_state=3, element_use=FaceType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'container'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=FaceType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'identifier'))),
        pyxb.binding.content.ContentModelTransition(next_state=10, element_use=FaceType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'descriptionReference'))),
        pyxb.binding.content.ContentModelTransition(next_state=4, element_use=FaceType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'isolated'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=FaceType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name'))),
    ])
    , 10 : pyxb.binding.content.ContentModelState(state=10, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=3, element_use=FaceType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'container'))),
        pyxb.binding.content.ContentModelTransition(next_state=5, element_use=FaceType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'directedEdge'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=FaceType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'identifier'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=FaceType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name'))),
        pyxb.binding.content.ContentModelTransition(next_state=4, element_use=FaceType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'isolated'))),
    ])
})


FeatureCollectionType._ContentModel = pyxb.binding.content.ContentModel(state_map = {
      1 : pyxb.binding.content.ContentModelState(state=1, is_final=True, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=FeatureCollectionType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'identifier'))),
        pyxb.binding.content.ContentModelTransition(next_state=5, element_use=FeatureCollectionType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'featureMembers'))),
        pyxb.binding.content.ContentModelTransition(next_state=4, element_use=FeatureCollectionType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'descriptionReference'))),
        pyxb.binding.content.ContentModelTransition(next_state=7, element_use=FeatureCollectionType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'featureMember'))),
        pyxb.binding.content.ContentModelTransition(next_state=6, element_use=FeatureCollectionType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'boundedBy'))),
        pyxb.binding.content.ContentModelTransition(next_state=7, element_use=FeatureCollectionType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'location'))),
        pyxb.binding.content.ContentModelTransition(next_state=1, element_use=FeatureCollectionType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'metaDataProperty'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=FeatureCollectionType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name'))),
        pyxb.binding.content.ContentModelTransition(next_state=3, element_use=FeatureCollectionType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'description'))),
    ])
    , 2 : pyxb.binding.content.ContentModelState(state=2, is_final=True, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=7, element_use=FeatureCollectionType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'featureMember'))),
        pyxb.binding.content.ContentModelTransition(next_state=5, element_use=FeatureCollectionType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'featureMembers'))),
        pyxb.binding.content.ContentModelTransition(next_state=6, element_use=FeatureCollectionType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'boundedBy'))),
        pyxb.binding.content.ContentModelTransition(next_state=7, element_use=FeatureCollectionType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'location'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=FeatureCollectionType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name'))),
    ])
    , 3 : pyxb.binding.content.ContentModelState(state=3, is_final=True, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=FeatureCollectionType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'identifier'))),
        pyxb.binding.content.ContentModelTransition(next_state=5, element_use=FeatureCollectionType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'featureMembers'))),
        pyxb.binding.content.ContentModelTransition(next_state=4, element_use=FeatureCollectionType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'descriptionReference'))),
        pyxb.binding.content.ContentModelTransition(next_state=7, element_use=FeatureCollectionType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'featureMember'))),
        pyxb.binding.content.ContentModelTransition(next_state=6, element_use=FeatureCollectionType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'boundedBy'))),
        pyxb.binding.content.ContentModelTransition(next_state=7, element_use=FeatureCollectionType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'location'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=FeatureCollectionType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name'))),
    ])
    , 4 : pyxb.binding.content.ContentModelState(state=4, is_final=True, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=FeatureCollectionType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'identifier'))),
        pyxb.binding.content.ContentModelTransition(next_state=5, element_use=FeatureCollectionType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'featureMembers'))),
        pyxb.binding.content.ContentModelTransition(next_state=7, element_use=FeatureCollectionType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'featureMember'))),
        pyxb.binding.content.ContentModelTransition(next_state=6, element_use=FeatureCollectionType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'boundedBy'))),
        pyxb.binding.content.ContentModelTransition(next_state=7, element_use=FeatureCollectionType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'location'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=FeatureCollectionType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name'))),
    ])
    , 5 : pyxb.binding.content.ContentModelState(state=5, is_final=True, transitions=[
    ])
    , 6 : pyxb.binding.content.ContentModelState(state=6, is_final=True, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=7, element_use=FeatureCollectionType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'featureMember'))),
        pyxb.binding.content.ContentModelTransition(next_state=5, element_use=FeatureCollectionType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'featureMembers'))),
        pyxb.binding.content.ContentModelTransition(next_state=7, element_use=FeatureCollectionType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'location'))),
    ])
    , 7 : pyxb.binding.content.ContentModelState(state=7, is_final=True, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=7, element_use=FeatureCollectionType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'featureMember'))),
        pyxb.binding.content.ContentModelTransition(next_state=5, element_use=FeatureCollectionType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'featureMembers'))),
    ])
})


IdentifiedObjectType._ContentModel = pyxb.binding.content.ContentModel(state_map = {
      1 : pyxb.binding.content.ContentModelState(state=1, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=1, element_use=IdentifiedObjectType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'metaDataProperty'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=IdentifiedObjectType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'descriptionReference'))),
        pyxb.binding.content.ContentModelTransition(next_state=3, element_use=IdentifiedObjectType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'description'))),
        pyxb.binding.content.ContentModelTransition(next_state=5, element_use=IdentifiedObjectType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'identifier'))),
    ])
    , 2 : pyxb.binding.content.ContentModelState(state=2, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=5, element_use=IdentifiedObjectType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'identifier'))),
    ])
    , 3 : pyxb.binding.content.ContentModelState(state=3, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=IdentifiedObjectType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'descriptionReference'))),
        pyxb.binding.content.ContentModelTransition(next_state=5, element_use=IdentifiedObjectType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'identifier'))),
    ])
    , 4 : pyxb.binding.content.ContentModelState(state=4, is_final=True, transitions=[
    ])
    , 5 : pyxb.binding.content.ContentModelState(state=5, is_final=True, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=4, element_use=IdentifiedObjectType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'remarks'))),
        pyxb.binding.content.ContentModelTransition(next_state=5, element_use=IdentifiedObjectType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name'))),
    ])
})



MultiCurveType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'curveMember'), CurvePropertyType, scope=MultiCurveType))

MultiCurveType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'curveMembers'), CurveArrayPropertyType, scope=MultiCurveType))
MultiCurveType._ContentModel = pyxb.binding.content.ContentModel(state_map = {
      1 : pyxb.binding.content.ContentModelState(state=1, is_final=True, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=MultiCurveType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'identifier'))),
        pyxb.binding.content.ContentModelTransition(next_state=1, element_use=MultiCurveType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'metaDataProperty'))),
        pyxb.binding.content.ContentModelTransition(next_state=4, element_use=MultiCurveType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'descriptionReference'))),
        pyxb.binding.content.ContentModelTransition(next_state=3, element_use=MultiCurveType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'curveMembers'))),
        pyxb.binding.content.ContentModelTransition(next_state=5, element_use=MultiCurveType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'curveMember'))),
        pyxb.binding.content.ContentModelTransition(next_state=6, element_use=MultiCurveType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'description'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=MultiCurveType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name'))),
    ])
    , 2 : pyxb.binding.content.ContentModelState(state=2, is_final=True, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=3, element_use=MultiCurveType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'curveMembers'))),
        pyxb.binding.content.ContentModelTransition(next_state=5, element_use=MultiCurveType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'curveMember'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=MultiCurveType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name'))),
    ])
    , 3 : pyxb.binding.content.ContentModelState(state=3, is_final=True, transitions=[
    ])
    , 4 : pyxb.binding.content.ContentModelState(state=4, is_final=True, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=MultiCurveType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'identifier'))),
        pyxb.binding.content.ContentModelTransition(next_state=3, element_use=MultiCurveType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'curveMembers'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=MultiCurveType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name'))),
        pyxb.binding.content.ContentModelTransition(next_state=5, element_use=MultiCurveType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'curveMember'))),
    ])
    , 5 : pyxb.binding.content.ContentModelState(state=5, is_final=True, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=3, element_use=MultiCurveType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'curveMembers'))),
        pyxb.binding.content.ContentModelTransition(next_state=5, element_use=MultiCurveType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'curveMember'))),
    ])
    , 6 : pyxb.binding.content.ContentModelState(state=6, is_final=True, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=MultiCurveType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'identifier'))),
        pyxb.binding.content.ContentModelTransition(next_state=4, element_use=MultiCurveType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'descriptionReference'))),
        pyxb.binding.content.ContentModelTransition(next_state=3, element_use=MultiCurveType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'curveMembers'))),
        pyxb.binding.content.ContentModelTransition(next_state=5, element_use=MultiCurveType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'curveMember'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=MultiCurveType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name'))),
    ])
})



MultiGeometryType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'geometryMember'), GeometryPropertyType, scope=MultiGeometryType))

MultiGeometryType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'geometryMembers'), GeometryArrayPropertyType, scope=MultiGeometryType))
MultiGeometryType._ContentModel = pyxb.binding.content.ContentModel(state_map = {
      1 : pyxb.binding.content.ContentModelState(state=1, is_final=True, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=MultiGeometryType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'identifier'))),
        pyxb.binding.content.ContentModelTransition(next_state=1, element_use=MultiGeometryType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'metaDataProperty'))),
        pyxb.binding.content.ContentModelTransition(next_state=4, element_use=MultiGeometryType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'descriptionReference'))),
        pyxb.binding.content.ContentModelTransition(next_state=3, element_use=MultiGeometryType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'geometryMembers'))),
        pyxb.binding.content.ContentModelTransition(next_state=6, element_use=MultiGeometryType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'geometryMember'))),
        pyxb.binding.content.ContentModelTransition(next_state=5, element_use=MultiGeometryType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'description'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=MultiGeometryType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name'))),
    ])
    , 2 : pyxb.binding.content.ContentModelState(state=2, is_final=True, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=3, element_use=MultiGeometryType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'geometryMembers'))),
        pyxb.binding.content.ContentModelTransition(next_state=6, element_use=MultiGeometryType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'geometryMember'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=MultiGeometryType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name'))),
    ])
    , 3 : pyxb.binding.content.ContentModelState(state=3, is_final=True, transitions=[
    ])
    , 4 : pyxb.binding.content.ContentModelState(state=4, is_final=True, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=MultiGeometryType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'identifier'))),
        pyxb.binding.content.ContentModelTransition(next_state=3, element_use=MultiGeometryType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'geometryMembers'))),
        pyxb.binding.content.ContentModelTransition(next_state=6, element_use=MultiGeometryType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'geometryMember'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=MultiGeometryType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name'))),
    ])
    , 5 : pyxb.binding.content.ContentModelState(state=5, is_final=True, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=MultiGeometryType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'identifier'))),
        pyxb.binding.content.ContentModelTransition(next_state=4, element_use=MultiGeometryType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'descriptionReference'))),
        pyxb.binding.content.ContentModelTransition(next_state=3, element_use=MultiGeometryType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'geometryMembers'))),
        pyxb.binding.content.ContentModelTransition(next_state=6, element_use=MultiGeometryType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'geometryMember'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=MultiGeometryType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name'))),
    ])
    , 6 : pyxb.binding.content.ContentModelState(state=6, is_final=True, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=3, element_use=MultiGeometryType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'geometryMembers'))),
        pyxb.binding.content.ContentModelTransition(next_state=6, element_use=MultiGeometryType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'geometryMember'))),
    ])
})



MultiPointType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'pointMember'), PointPropertyType, scope=MultiPointType))

MultiPointType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'pointMembers'), PointArrayPropertyType, scope=MultiPointType))
MultiPointType._ContentModel = pyxb.binding.content.ContentModel(state_map = {
      1 : pyxb.binding.content.ContentModelState(state=1, is_final=True, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=MultiPointType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'identifier'))),
        pyxb.binding.content.ContentModelTransition(next_state=1, element_use=MultiPointType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'metaDataProperty'))),
        pyxb.binding.content.ContentModelTransition(next_state=4, element_use=MultiPointType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'descriptionReference'))),
        pyxb.binding.content.ContentModelTransition(next_state=3, element_use=MultiPointType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'pointMembers'))),
        pyxb.binding.content.ContentModelTransition(next_state=5, element_use=MultiPointType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'pointMember'))),
        pyxb.binding.content.ContentModelTransition(next_state=6, element_use=MultiPointType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'description'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=MultiPointType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name'))),
    ])
    , 2 : pyxb.binding.content.ContentModelState(state=2, is_final=True, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=3, element_use=MultiPointType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'pointMembers'))),
        pyxb.binding.content.ContentModelTransition(next_state=5, element_use=MultiPointType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'pointMember'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=MultiPointType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name'))),
    ])
    , 3 : pyxb.binding.content.ContentModelState(state=3, is_final=True, transitions=[
    ])
    , 4 : pyxb.binding.content.ContentModelState(state=4, is_final=True, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=MultiPointType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'identifier'))),
        pyxb.binding.content.ContentModelTransition(next_state=3, element_use=MultiPointType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'pointMembers'))),
        pyxb.binding.content.ContentModelTransition(next_state=5, element_use=MultiPointType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'pointMember'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=MultiPointType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name'))),
    ])
    , 5 : pyxb.binding.content.ContentModelState(state=5, is_final=True, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=3, element_use=MultiPointType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'pointMembers'))),
        pyxb.binding.content.ContentModelTransition(next_state=5, element_use=MultiPointType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'pointMember'))),
    ])
    , 6 : pyxb.binding.content.ContentModelState(state=6, is_final=True, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=MultiPointType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'identifier'))),
        pyxb.binding.content.ContentModelTransition(next_state=4, element_use=MultiPointType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'descriptionReference'))),
        pyxb.binding.content.ContentModelTransition(next_state=3, element_use=MultiPointType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'pointMembers'))),
        pyxb.binding.content.ContentModelTransition(next_state=5, element_use=MultiPointType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'pointMember'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=MultiPointType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name'))),
    ])
})



MultiSolidType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'solidMembers'), SolidArrayPropertyType, scope=MultiSolidType))

MultiSolidType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'solidMember'), SolidPropertyType, scope=MultiSolidType))
MultiSolidType._ContentModel = pyxb.binding.content.ContentModel(state_map = {
      1 : pyxb.binding.content.ContentModelState(state=1, is_final=True, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=MultiSolidType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'identifier'))),
        pyxb.binding.content.ContentModelTransition(next_state=1, element_use=MultiSolidType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'metaDataProperty'))),
        pyxb.binding.content.ContentModelTransition(next_state=3, element_use=MultiSolidType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'descriptionReference'))),
        pyxb.binding.content.ContentModelTransition(next_state=4, element_use=MultiSolidType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'solidMembers'))),
        pyxb.binding.content.ContentModelTransition(next_state=5, element_use=MultiSolidType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'solidMember'))),
        pyxb.binding.content.ContentModelTransition(next_state=6, element_use=MultiSolidType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'description'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=MultiSolidType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name'))),
    ])
    , 2 : pyxb.binding.content.ContentModelState(state=2, is_final=True, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=4, element_use=MultiSolidType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'solidMembers'))),
        pyxb.binding.content.ContentModelTransition(next_state=5, element_use=MultiSolidType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'solidMember'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=MultiSolidType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name'))),
    ])
    , 3 : pyxb.binding.content.ContentModelState(state=3, is_final=True, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=MultiSolidType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'identifier'))),
        pyxb.binding.content.ContentModelTransition(next_state=4, element_use=MultiSolidType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'solidMembers'))),
        pyxb.binding.content.ContentModelTransition(next_state=5, element_use=MultiSolidType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'solidMember'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=MultiSolidType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name'))),
    ])
    , 4 : pyxb.binding.content.ContentModelState(state=4, is_final=True, transitions=[
    ])
    , 5 : pyxb.binding.content.ContentModelState(state=5, is_final=True, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=4, element_use=MultiSolidType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'solidMembers'))),
        pyxb.binding.content.ContentModelTransition(next_state=5, element_use=MultiSolidType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'solidMember'))),
    ])
    , 6 : pyxb.binding.content.ContentModelState(state=6, is_final=True, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=MultiSolidType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'identifier'))),
        pyxb.binding.content.ContentModelTransition(next_state=3, element_use=MultiSolidType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'descriptionReference'))),
        pyxb.binding.content.ContentModelTransition(next_state=4, element_use=MultiSolidType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'solidMembers'))),
        pyxb.binding.content.ContentModelTransition(next_state=5, element_use=MultiSolidType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'solidMember'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=MultiSolidType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name'))),
    ])
})



MultiSurfaceType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'surfaceMembers'), SurfaceArrayPropertyType, scope=MultiSurfaceType))

MultiSurfaceType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'surfaceMember'), SurfacePropertyType, scope=MultiSurfaceType))
MultiSurfaceType._ContentModel = pyxb.binding.content.ContentModel(state_map = {
      1 : pyxb.binding.content.ContentModelState(state=1, is_final=True, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=MultiSurfaceType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'identifier'))),
        pyxb.binding.content.ContentModelTransition(next_state=4, element_use=MultiSurfaceType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'descriptionReference'))),
        pyxb.binding.content.ContentModelTransition(next_state=1, element_use=MultiSurfaceType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'metaDataProperty'))),
        pyxb.binding.content.ContentModelTransition(next_state=3, element_use=MultiSurfaceType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'surfaceMembers'))),
        pyxb.binding.content.ContentModelTransition(next_state=5, element_use=MultiSurfaceType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'surfaceMember'))),
        pyxb.binding.content.ContentModelTransition(next_state=6, element_use=MultiSurfaceType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'description'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=MultiSurfaceType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name'))),
    ])
    , 2 : pyxb.binding.content.ContentModelState(state=2, is_final=True, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=3, element_use=MultiSurfaceType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'surfaceMembers'))),
        pyxb.binding.content.ContentModelTransition(next_state=5, element_use=MultiSurfaceType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'surfaceMember'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=MultiSurfaceType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name'))),
    ])
    , 3 : pyxb.binding.content.ContentModelState(state=3, is_final=True, transitions=[
    ])
    , 4 : pyxb.binding.content.ContentModelState(state=4, is_final=True, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=MultiSurfaceType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'identifier'))),
        pyxb.binding.content.ContentModelTransition(next_state=3, element_use=MultiSurfaceType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'surfaceMembers'))),
        pyxb.binding.content.ContentModelTransition(next_state=5, element_use=MultiSurfaceType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'surfaceMember'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=MultiSurfaceType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name'))),
    ])
    , 5 : pyxb.binding.content.ContentModelState(state=5, is_final=True, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=3, element_use=MultiSurfaceType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'surfaceMembers'))),
        pyxb.binding.content.ContentModelTransition(next_state=5, element_use=MultiSurfaceType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'surfaceMember'))),
    ])
    , 6 : pyxb.binding.content.ContentModelState(state=6, is_final=True, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=MultiSurfaceType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'identifier'))),
        pyxb.binding.content.ContentModelTransition(next_state=4, element_use=MultiSurfaceType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'descriptionReference'))),
        pyxb.binding.content.ContentModelTransition(next_state=3, element_use=MultiSurfaceType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'surfaceMembers'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=MultiSurfaceType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name'))),
        pyxb.binding.content.ContentModelTransition(next_state=5, element_use=MultiSurfaceType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'surfaceMember'))),
    ])
})



NodeType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'directedEdge'), DirectedEdgePropertyType, scope=NodeType))

NodeType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'pointProperty'), PointPropertyType, scope=NodeType))
NodeType._ContentModel = pyxb.binding.content.ContentModel(state_map = {
      1 : pyxb.binding.content.ContentModelState(state=1, is_final=True, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=5, element_use=NodeType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'directedEdge'))),
        pyxb.binding.content.ContentModelTransition(next_state=5, element_use=NodeType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'container'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=NodeType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'identifier'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=NodeType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name'))),
        pyxb.binding.content.ContentModelTransition(next_state=6, element_use=NodeType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'pointProperty'))),
        pyxb.binding.content.ContentModelTransition(next_state=7, element_use=NodeType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'description'))),
        pyxb.binding.content.ContentModelTransition(next_state=1, element_use=NodeType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'metaDataProperty'))),
        pyxb.binding.content.ContentModelTransition(next_state=3, element_use=NodeType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'descriptionReference'))),
        pyxb.binding.content.ContentModelTransition(next_state=4, element_use=NodeType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'isolated'))),
    ])
    , 2 : pyxb.binding.content.ContentModelState(state=2, is_final=True, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=5, element_use=NodeType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'container'))),
        pyxb.binding.content.ContentModelTransition(next_state=6, element_use=NodeType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'pointProperty'))),
        pyxb.binding.content.ContentModelTransition(next_state=5, element_use=NodeType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'directedEdge'))),
        pyxb.binding.content.ContentModelTransition(next_state=4, element_use=NodeType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'isolated'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=NodeType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name'))),
    ])
    , 3 : pyxb.binding.content.ContentModelState(state=3, is_final=True, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=5, element_use=NodeType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'directedEdge'))),
        pyxb.binding.content.ContentModelTransition(next_state=5, element_use=NodeType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'container'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=NodeType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'identifier'))),
        pyxb.binding.content.ContentModelTransition(next_state=6, element_use=NodeType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'pointProperty'))),
        pyxb.binding.content.ContentModelTransition(next_state=4, element_use=NodeType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'isolated'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=NodeType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name'))),
    ])
    , 4 : pyxb.binding.content.ContentModelState(state=4, is_final=True, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=5, element_use=NodeType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'container'))),
        pyxb.binding.content.ContentModelTransition(next_state=5, element_use=NodeType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'directedEdge'))),
        pyxb.binding.content.ContentModelTransition(next_state=4, element_use=NodeType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'isolated'))),
        pyxb.binding.content.ContentModelTransition(next_state=6, element_use=NodeType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'pointProperty'))),
    ])
    , 5 : pyxb.binding.content.ContentModelState(state=5, is_final=True, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=5, element_use=NodeType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'directedEdge'))),
        pyxb.binding.content.ContentModelTransition(next_state=6, element_use=NodeType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'pointProperty'))),
    ])
    , 6 : pyxb.binding.content.ContentModelState(state=6, is_final=True, transitions=[
    ])
    , 7 : pyxb.binding.content.ContentModelState(state=7, is_final=True, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=5, element_use=NodeType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'directedEdge'))),
        pyxb.binding.content.ContentModelTransition(next_state=5, element_use=NodeType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'container'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=NodeType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'identifier'))),
        pyxb.binding.content.ContentModelTransition(next_state=3, element_use=NodeType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'descriptionReference'))),
        pyxb.binding.content.ContentModelTransition(next_state=6, element_use=NodeType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'pointProperty'))),
        pyxb.binding.content.ContentModelTransition(next_state=4, element_use=NodeType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'isolated'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=NodeType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name'))),
    ])
})



PointType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'coordinates'), CoordinatesType, scope=PointType))

PointType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'pos'), DirectPositionType, scope=PointType))
PointType._ContentModel = pyxb.binding.content.ContentModel(state_map = {
      1 : pyxb.binding.content.ContentModelState(state=1, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=3, element_use=PointType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'identifier'))),
        pyxb.binding.content.ContentModelTransition(next_state=3, element_use=PointType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=PointType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'pos'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=PointType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'coordinates'))),
        pyxb.binding.content.ContentModelTransition(next_state=4, element_use=PointType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'description'))),
        pyxb.binding.content.ContentModelTransition(next_state=1, element_use=PointType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'metaDataProperty'))),
        pyxb.binding.content.ContentModelTransition(next_state=5, element_use=PointType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'descriptionReference'))),
    ])
    , 2 : pyxb.binding.content.ContentModelState(state=2, is_final=True, transitions=[
    ])
    , 3 : pyxb.binding.content.ContentModelState(state=3, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=3, element_use=PointType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=PointType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'pos'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=PointType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'coordinates'))),
    ])
    , 4 : pyxb.binding.content.ContentModelState(state=4, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=3, element_use=PointType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'identifier'))),
        pyxb.binding.content.ContentModelTransition(next_state=3, element_use=PointType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=PointType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'coordinates'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=PointType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'pos'))),
        pyxb.binding.content.ContentModelTransition(next_state=5, element_use=PointType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'descriptionReference'))),
    ])
    , 5 : pyxb.binding.content.ContentModelState(state=5, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=3, element_use=PointType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'identifier'))),
        pyxb.binding.content.ContentModelTransition(next_state=3, element_use=PointType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=PointType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'pos'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=PointType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'coordinates'))),
    ])
})



RectifiedGridType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'origin'), PointPropertyType, scope=RectifiedGridType))

RectifiedGridType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'offsetVector'), VectorType, scope=RectifiedGridType))
RectifiedGridType._ContentModel = pyxb.binding.content.ContentModel(state_map = {
      1 : pyxb.binding.content.ContentModelState(state=1, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=7, element_use=RectifiedGridType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'identifier'))),
        pyxb.binding.content.ContentModelTransition(next_state=7, element_use=RectifiedGridType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name'))),
        pyxb.binding.content.ContentModelTransition(next_state=4, element_use=RectifiedGridType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'description'))),
        pyxb.binding.content.ContentModelTransition(next_state=6, element_use=RectifiedGridType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'limits'))),
        pyxb.binding.content.ContentModelTransition(next_state=1, element_use=RectifiedGridType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'metaDataProperty'))),
        pyxb.binding.content.ContentModelTransition(next_state=8, element_use=RectifiedGridType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'descriptionReference'))),
    ])
    , 2 : pyxb.binding.content.ContentModelState(state=2, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=RectifiedGridType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'axisName'))),
        pyxb.binding.content.ContentModelTransition(next_state=3, element_use=RectifiedGridType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'origin'))),
    ])
    , 3 : pyxb.binding.content.ContentModelState(state=3, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=5, element_use=RectifiedGridType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'offsetVector'))),
    ])
    , 4 : pyxb.binding.content.ContentModelState(state=4, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=7, element_use=RectifiedGridType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'identifier'))),
        pyxb.binding.content.ContentModelTransition(next_state=7, element_use=RectifiedGridType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name'))),
        pyxb.binding.content.ContentModelTransition(next_state=6, element_use=RectifiedGridType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'limits'))),
        pyxb.binding.content.ContentModelTransition(next_state=8, element_use=RectifiedGridType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'descriptionReference'))),
    ])
    , 5 : pyxb.binding.content.ContentModelState(state=5, is_final=True, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=5, element_use=RectifiedGridType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'offsetVector'))),
    ])
    , 6 : pyxb.binding.content.ContentModelState(state=6, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=9, element_use=RectifiedGridType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'axisLabels'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=RectifiedGridType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'axisName'))),
    ])
    , 7 : pyxb.binding.content.ContentModelState(state=7, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=7, element_use=RectifiedGridType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name'))),
        pyxb.binding.content.ContentModelTransition(next_state=6, element_use=RectifiedGridType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'limits'))),
    ])
    , 8 : pyxb.binding.content.ContentModelState(state=8, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=7, element_use=RectifiedGridType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'identifier'))),
        pyxb.binding.content.ContentModelTransition(next_state=7, element_use=RectifiedGridType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name'))),
        pyxb.binding.content.ContentModelTransition(next_state=6, element_use=RectifiedGridType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'limits'))),
    ])
    , 9 : pyxb.binding.content.ContentModelState(state=9, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=3, element_use=RectifiedGridType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'origin'))),
    ])
})


SphereType._ContentModel = pyxb.binding.content.ContentModel(state_map = {
      1 : pyxb.binding.content.ContentModelState(state=1, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=SphereType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'rows'))),
    ])
    , 2 : pyxb.binding.content.ContentModelState(state=2, is_final=True, transitions=[
    ])
})



TimeCalendarEraType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'referenceDate'), CalDate, scope=TimeCalendarEraType))

TimeCalendarEraType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'epochOfUse'), TimePeriodPropertyType, scope=TimeCalendarEraType))

TimeCalendarEraType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'julianReference'), pyxb.binding.datatypes.decimal, scope=TimeCalendarEraType))

TimeCalendarEraType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'referenceEvent'), StringOrRefType, scope=TimeCalendarEraType))
TimeCalendarEraType._ContentModel = pyxb.binding.content.ContentModel(state_map = {
      1 : pyxb.binding.content.ContentModelState(state=1, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=TimeCalendarEraType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'descriptionReference'))),
        pyxb.binding.content.ContentModelTransition(next_state=1, element_use=TimeCalendarEraType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'metaDataProperty'))),
        pyxb.binding.content.ContentModelTransition(next_state=5, element_use=TimeCalendarEraType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'description'))),
        pyxb.binding.content.ContentModelTransition(next_state=9, element_use=TimeCalendarEraType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'identifier'))),
    ])
    , 2 : pyxb.binding.content.ContentModelState(state=2, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=9, element_use=TimeCalendarEraType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'identifier'))),
    ])
    , 3 : pyxb.binding.content.ContentModelState(state=3, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=4, element_use=TimeCalendarEraType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'julianReference'))),
    ])
    , 4 : pyxb.binding.content.ContentModelState(state=4, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=6, element_use=TimeCalendarEraType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'epochOfUse'))),
    ])
    , 5 : pyxb.binding.content.ContentModelState(state=5, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=TimeCalendarEraType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'descriptionReference'))),
        pyxb.binding.content.ContentModelTransition(next_state=9, element_use=TimeCalendarEraType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'identifier'))),
    ])
    , 6 : pyxb.binding.content.ContentModelState(state=6, is_final=True, transitions=[
    ])
    , 7 : pyxb.binding.content.ContentModelState(state=7, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=3, element_use=TimeCalendarEraType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'referenceDate'))),
    ])
    , 8 : pyxb.binding.content.ContentModelState(state=8, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=7, element_use=TimeCalendarEraType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'referenceEvent'))),
    ])
    , 9 : pyxb.binding.content.ContentModelState(state=9, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=7, element_use=TimeCalendarEraType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'referenceEvent'))),
        pyxb.binding.content.ContentModelTransition(next_state=8, element_use=TimeCalendarEraType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'remarks'))),
        pyxb.binding.content.ContentModelTransition(next_state=9, element_use=TimeCalendarEraType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name'))),
    ])
})



TimeOrdinalEraType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'start'), TimeNodePropertyType, scope=TimeOrdinalEraType))

TimeOrdinalEraType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'member'), TimeOrdinalEraPropertyType, scope=TimeOrdinalEraType))

TimeOrdinalEraType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'end'), TimeNodePropertyType, scope=TimeOrdinalEraType))

TimeOrdinalEraType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'group'), ReferenceType, scope=TimeOrdinalEraType))

TimeOrdinalEraType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'extent'), TimePeriodPropertyType, scope=TimeOrdinalEraType))

TimeOrdinalEraType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'relatedTime'), RelatedTimeType, scope=TimeOrdinalEraType))
TimeOrdinalEraType._ContentModel = pyxb.binding.content.ContentModel(state_map = {
      1 : pyxb.binding.content.ContentModelState(state=1, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=3, element_use=TimeOrdinalEraType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'descriptionReference'))),
        pyxb.binding.content.ContentModelTransition(next_state=4, element_use=TimeOrdinalEraType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'description'))),
        pyxb.binding.content.ContentModelTransition(next_state=1, element_use=TimeOrdinalEraType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'metaDataProperty'))),
        pyxb.binding.content.ContentModelTransition(next_state=9, element_use=TimeOrdinalEraType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'identifier'))),
    ])
    , 2 : pyxb.binding.content.ContentModelState(state=2, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=7, element_use=TimeOrdinalEraType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'start'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=TimeOrdinalEraType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'relatedTime'))),
    ])
    , 3 : pyxb.binding.content.ContentModelState(state=3, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=9, element_use=TimeOrdinalEraType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'identifier'))),
    ])
    , 4 : pyxb.binding.content.ContentModelState(state=4, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=3, element_use=TimeOrdinalEraType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'descriptionReference'))),
        pyxb.binding.content.ContentModelTransition(next_state=9, element_use=TimeOrdinalEraType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'identifier'))),
    ])
    , 5 : pyxb.binding.content.ContentModelState(state=5, is_final=True, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=6, element_use=TimeOrdinalEraType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'group'))),
        pyxb.binding.content.ContentModelTransition(next_state=8, element_use=TimeOrdinalEraType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'extent'))),
        pyxb.binding.content.ContentModelTransition(next_state=8, element_use=TimeOrdinalEraType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'member'))),
    ])
    , 6 : pyxb.binding.content.ContentModelState(state=6, is_final=True, transitions=[
    ])
    , 7 : pyxb.binding.content.ContentModelState(state=7, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=5, element_use=TimeOrdinalEraType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'end'))),
    ])
    , 8 : pyxb.binding.content.ContentModelState(state=8, is_final=True, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=6, element_use=TimeOrdinalEraType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'group'))),
        pyxb.binding.content.ContentModelTransition(next_state=8, element_use=TimeOrdinalEraType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'member'))),
    ])
    , 9 : pyxb.binding.content.ContentModelState(state=9, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=7, element_use=TimeOrdinalEraType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'start'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=TimeOrdinalEraType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'relatedTime'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=TimeOrdinalEraType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'remarks'))),
        pyxb.binding.content.ContentModelTransition(next_state=9, element_use=TimeOrdinalEraType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name'))),
    ])
})



TimeReferenceSystemType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'domainOfValidity'), pyxb.binding.datatypes.string, scope=TimeReferenceSystemType))
TimeReferenceSystemType._ContentModel = pyxb.binding.content.ContentModel(state_map = {
      1 : pyxb.binding.content.ContentModelState(state=1, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=TimeReferenceSystemType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'descriptionReference'))),
        pyxb.binding.content.ContentModelTransition(next_state=1, element_use=TimeReferenceSystemType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'metaDataProperty'))),
        pyxb.binding.content.ContentModelTransition(next_state=3, element_use=TimeReferenceSystemType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'description'))),
        pyxb.binding.content.ContentModelTransition(next_state=6, element_use=TimeReferenceSystemType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'identifier'))),
    ])
    , 2 : pyxb.binding.content.ContentModelState(state=2, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=6, element_use=TimeReferenceSystemType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'identifier'))),
    ])
    , 3 : pyxb.binding.content.ContentModelState(state=3, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=TimeReferenceSystemType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'descriptionReference'))),
        pyxb.binding.content.ContentModelTransition(next_state=6, element_use=TimeReferenceSystemType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'identifier'))),
    ])
    , 4 : pyxb.binding.content.ContentModelState(state=4, is_final=True, transitions=[
    ])
    , 5 : pyxb.binding.content.ContentModelState(state=5, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=4, element_use=TimeReferenceSystemType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'domainOfValidity'))),
    ])
    , 6 : pyxb.binding.content.ContentModelState(state=6, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=4, element_use=TimeReferenceSystemType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'domainOfValidity'))),
        pyxb.binding.content.ContentModelTransition(next_state=5, element_use=TimeReferenceSystemType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'remarks'))),
        pyxb.binding.content.ContentModelTransition(next_state=6, element_use=TimeReferenceSystemType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name'))),
    ])
})



TimeTopologyComplexType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'primitive'), TimeTopologyPrimitivePropertyType, scope=TimeTopologyComplexType))
TimeTopologyComplexType._ContentModel = pyxb.binding.content.ContentModel(state_map = {
      1 : pyxb.binding.content.ContentModelState(state=1, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=4, element_use=TimeTopologyComplexType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'identifier'))),
        pyxb.binding.content.ContentModelTransition(next_state=1, element_use=TimeTopologyComplexType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'metaDataProperty'))),
        pyxb.binding.content.ContentModelTransition(next_state=4, element_use=TimeTopologyComplexType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=TimeTopologyComplexType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'primitive'))),
        pyxb.binding.content.ContentModelTransition(next_state=3, element_use=TimeTopologyComplexType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'description'))),
        pyxb.binding.content.ContentModelTransition(next_state=5, element_use=TimeTopologyComplexType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'descriptionReference'))),
    ])
    , 2 : pyxb.binding.content.ContentModelState(state=2, is_final=True, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=TimeTopologyComplexType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'primitive'))),
    ])
    , 3 : pyxb.binding.content.ContentModelState(state=3, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=4, element_use=TimeTopologyComplexType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'identifier'))),
        pyxb.binding.content.ContentModelTransition(next_state=4, element_use=TimeTopologyComplexType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=TimeTopologyComplexType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'primitive'))),
        pyxb.binding.content.ContentModelTransition(next_state=5, element_use=TimeTopologyComplexType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'descriptionReference'))),
    ])
    , 4 : pyxb.binding.content.ContentModelState(state=4, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=4, element_use=TimeTopologyComplexType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=TimeTopologyComplexType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'primitive'))),
    ])
    , 5 : pyxb.binding.content.ContentModelState(state=5, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=4, element_use=TimeTopologyComplexType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'identifier'))),
        pyxb.binding.content.ContentModelTransition(next_state=4, element_use=TimeTopologyComplexType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=TimeTopologyComplexType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'primitive'))),
    ])
})



TopoSolidType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'directedFace'), DirectedFacePropertyType, scope=TopoSolidType))

TopoSolidType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'solidProperty'), SolidPropertyType, scope=TopoSolidType))
TopoSolidType._ContentModel = pyxb.binding.content.ContentModel(state_map = {
      1 : pyxb.binding.content.ContentModelState(state=1, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=TopoSolidType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'identifier'))),
        pyxb.binding.content.ContentModelTransition(next_state=6, element_use=TopoSolidType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'descriptionReference'))),
        pyxb.binding.content.ContentModelTransition(next_state=4, element_use=TopoSolidType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'container'))),
        pyxb.binding.content.ContentModelTransition(next_state=8, element_use=TopoSolidType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'description'))),
        pyxb.binding.content.ContentModelTransition(next_state=7, element_use=TopoSolidType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'directedFace'))),
        pyxb.binding.content.ContentModelTransition(next_state=1, element_use=TopoSolidType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'metaDataProperty'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=TopoSolidType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name'))),
        pyxb.binding.content.ContentModelTransition(next_state=3, element_use=TopoSolidType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'isolated'))),
    ])
    , 2 : pyxb.binding.content.ContentModelState(state=2, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=4, element_use=TopoSolidType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'container'))),
        pyxb.binding.content.ContentModelTransition(next_state=7, element_use=TopoSolidType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'directedFace'))),
        pyxb.binding.content.ContentModelTransition(next_state=3, element_use=TopoSolidType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'isolated'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=TopoSolidType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name'))),
    ])
    , 3 : pyxb.binding.content.ContentModelState(state=3, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=4, element_use=TopoSolidType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'container'))),
        pyxb.binding.content.ContentModelTransition(next_state=7, element_use=TopoSolidType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'directedFace'))),
        pyxb.binding.content.ContentModelTransition(next_state=3, element_use=TopoSolidType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'isolated'))),
    ])
    , 4 : pyxb.binding.content.ContentModelState(state=4, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=7, element_use=TopoSolidType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'directedFace'))),
    ])
    , 5 : pyxb.binding.content.ContentModelState(state=5, is_final=True, transitions=[
    ])
    , 6 : pyxb.binding.content.ContentModelState(state=6, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=TopoSolidType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'identifier'))),
        pyxb.binding.content.ContentModelTransition(next_state=4, element_use=TopoSolidType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'container'))),
        pyxb.binding.content.ContentModelTransition(next_state=7, element_use=TopoSolidType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'directedFace'))),
        pyxb.binding.content.ContentModelTransition(next_state=3, element_use=TopoSolidType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'isolated'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=TopoSolidType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name'))),
    ])
    , 7 : pyxb.binding.content.ContentModelState(state=7, is_final=True, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=5, element_use=TopoSolidType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'solidProperty'))),
        pyxb.binding.content.ContentModelTransition(next_state=7, element_use=TopoSolidType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'directedFace'))),
    ])
    , 8 : pyxb.binding.content.ContentModelState(state=8, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=TopoSolidType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'identifier'))),
        pyxb.binding.content.ContentModelTransition(next_state=6, element_use=TopoSolidType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'descriptionReference'))),
        pyxb.binding.content.ContentModelTransition(next_state=4, element_use=TopoSolidType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'container'))),
        pyxb.binding.content.ContentModelTransition(next_state=7, element_use=TopoSolidType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'directedFace'))),
        pyxb.binding.content.ContentModelTransition(next_state=3, element_use=TopoSolidType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'isolated'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=TopoSolidType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name'))),
    ])
})



UnitDefinitionType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'quantityType'), StringOrRefType, scope=UnitDefinitionType))

UnitDefinitionType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'catalogSymbol'), CodeType, scope=UnitDefinitionType))

UnitDefinitionType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'quantityTypeReference'), ReferenceType, scope=UnitDefinitionType))
UnitDefinitionType._ContentModel = pyxb.binding.content.ContentModel(state_map = {
      1 : pyxb.binding.content.ContentModelState(state=1, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=1, element_use=UnitDefinitionType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'metaDataProperty'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=UnitDefinitionType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'descriptionReference'))),
        pyxb.binding.content.ContentModelTransition(next_state=4, element_use=UnitDefinitionType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'description'))),
        pyxb.binding.content.ContentModelTransition(next_state=3, element_use=UnitDefinitionType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'identifier'))),
    ])
    , 2 : pyxb.binding.content.ContentModelState(state=2, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=3, element_use=UnitDefinitionType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'identifier'))),
    ])
    , 3 : pyxb.binding.content.ContentModelState(state=3, is_final=True, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=5, element_use=UnitDefinitionType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'catalogSymbol'))),
        pyxb.binding.content.ContentModelTransition(next_state=6, element_use=UnitDefinitionType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'quantityTypeReference'))),
        pyxb.binding.content.ContentModelTransition(next_state=7, element_use=UnitDefinitionType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'remarks'))),
        pyxb.binding.content.ContentModelTransition(next_state=8, element_use=UnitDefinitionType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'quantityType'))),
        pyxb.binding.content.ContentModelTransition(next_state=3, element_use=UnitDefinitionType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name'))),
    ])
    , 4 : pyxb.binding.content.ContentModelState(state=4, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=UnitDefinitionType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'descriptionReference'))),
        pyxb.binding.content.ContentModelTransition(next_state=3, element_use=UnitDefinitionType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'identifier'))),
    ])
    , 5 : pyxb.binding.content.ContentModelState(state=5, is_final=True, transitions=[
    ])
    , 6 : pyxb.binding.content.ContentModelState(state=6, is_final=True, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=5, element_use=UnitDefinitionType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'catalogSymbol'))),
    ])
    , 7 : pyxb.binding.content.ContentModelState(state=7, is_final=True, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=5, element_use=UnitDefinitionType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'catalogSymbol'))),
        pyxb.binding.content.ContentModelTransition(next_state=6, element_use=UnitDefinitionType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'quantityTypeReference'))),
        pyxb.binding.content.ContentModelTransition(next_state=8, element_use=UnitDefinitionType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'quantityType'))),
    ])
    , 8 : pyxb.binding.content.ContentModelState(state=8, is_final=True, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=5, element_use=UnitDefinitionType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'catalogSymbol'))),
        pyxb.binding.content.ContentModelTransition(next_state=6, element_use=UnitDefinitionType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'quantityTypeReference'))),
    ])
})



AbstractCRSType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'scope'), pyxb.binding.datatypes.string, scope=AbstractCRSType))

AbstractCRSType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'domainOfValidity'), _CTD_ANON_22, scope=AbstractCRSType))
AbstractCRSType._ContentModel = pyxb.binding.content.ContentModel(state_map = {
      1 : pyxb.binding.content.ContentModelState(state=1, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=4, element_use=AbstractCRSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'descriptionReference'))),
        pyxb.binding.content.ContentModelTransition(next_state=1, element_use=AbstractCRSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'metaDataProperty'))),
        pyxb.binding.content.ContentModelTransition(next_state=5, element_use=AbstractCRSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'description'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=AbstractCRSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'identifier'))),
    ])
    , 2 : pyxb.binding.content.ContentModelState(state=2, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=6, element_use=AbstractCRSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'scope'))),
        pyxb.binding.content.ContentModelTransition(next_state=3, element_use=AbstractCRSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'remarks'))),
        pyxb.binding.content.ContentModelTransition(next_state=3, element_use=AbstractCRSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'domainOfValidity'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=AbstractCRSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name'))),
    ])
    , 3 : pyxb.binding.content.ContentModelState(state=3, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=6, element_use=AbstractCRSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'scope'))),
        pyxb.binding.content.ContentModelTransition(next_state=3, element_use=AbstractCRSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'domainOfValidity'))),
    ])
    , 4 : pyxb.binding.content.ContentModelState(state=4, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=AbstractCRSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'identifier'))),
    ])
    , 5 : pyxb.binding.content.ContentModelState(state=5, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=4, element_use=AbstractCRSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'descriptionReference'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=AbstractCRSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'identifier'))),
    ])
    , 6 : pyxb.binding.content.ContentModelState(state=6, is_final=True, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=6, element_use=AbstractCRSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'scope'))),
        pyxb.binding.content.ContentModelTransition(next_state=3, element_use=AbstractCRSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'domainOfValidity'))),
    ])
})



AbstractCoordinateOperationType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'operationVersion'), pyxb.binding.datatypes.string, scope=AbstractCoordinateOperationType))

AbstractCoordinateOperationType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'domainOfValidity'), _CTD_ANON_22, scope=AbstractCoordinateOperationType))

AbstractCoordinateOperationType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'targetCRS'), CRSPropertyType, scope=AbstractCoordinateOperationType))

AbstractCoordinateOperationType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'coordinateOperationAccuracy'), _CTD_ANON_25, scope=AbstractCoordinateOperationType))

AbstractCoordinateOperationType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'sourceCRS'), CRSPropertyType, scope=AbstractCoordinateOperationType))

AbstractCoordinateOperationType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'scope'), pyxb.binding.datatypes.string, scope=AbstractCoordinateOperationType))
AbstractCoordinateOperationType._ContentModel = pyxb.binding.content.ContentModel(state_map = {
      1 : pyxb.binding.content.ContentModelState(state=1, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=3, element_use=AbstractCoordinateOperationType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'descriptionReference'))),
        pyxb.binding.content.ContentModelTransition(next_state=1, element_use=AbstractCoordinateOperationType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'metaDataProperty'))),
        pyxb.binding.content.ContentModelTransition(next_state=4, element_use=AbstractCoordinateOperationType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'description'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=AbstractCoordinateOperationType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'identifier'))),
    ])
    , 2 : pyxb.binding.content.ContentModelState(state=2, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=6, element_use=AbstractCoordinateOperationType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'scope'))),
        pyxb.binding.content.ContentModelTransition(next_state=8, element_use=AbstractCoordinateOperationType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'domainOfValidity'))),
        pyxb.binding.content.ContentModelTransition(next_state=10, element_use=AbstractCoordinateOperationType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'remarks'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=AbstractCoordinateOperationType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name'))),
    ])
    , 3 : pyxb.binding.content.ContentModelState(state=3, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=AbstractCoordinateOperationType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'identifier'))),
    ])
    , 4 : pyxb.binding.content.ContentModelState(state=4, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=3, element_use=AbstractCoordinateOperationType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'descriptionReference'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=AbstractCoordinateOperationType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'identifier'))),
    ])
    , 5 : pyxb.binding.content.ContentModelState(state=5, is_final=True, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=5, element_use=AbstractCoordinateOperationType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'coordinateOperationAccuracy'))),
        pyxb.binding.content.ContentModelTransition(next_state=7, element_use=AbstractCoordinateOperationType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'sourceCRS'))),
        pyxb.binding.content.ContentModelTransition(next_state=9, element_use=AbstractCoordinateOperationType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'targetCRS'))),
    ])
    , 6 : pyxb.binding.content.ContentModelState(state=6, is_final=True, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=6, element_use=AbstractCoordinateOperationType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'scope'))),
        pyxb.binding.content.ContentModelTransition(next_state=5, element_use=AbstractCoordinateOperationType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'operationVersion'))),
        pyxb.binding.content.ContentModelTransition(next_state=5, element_use=AbstractCoordinateOperationType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'coordinateOperationAccuracy'))),
        pyxb.binding.content.ContentModelTransition(next_state=7, element_use=AbstractCoordinateOperationType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'sourceCRS'))),
        pyxb.binding.content.ContentModelTransition(next_state=9, element_use=AbstractCoordinateOperationType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'targetCRS'))),
    ])
    , 7 : pyxb.binding.content.ContentModelState(state=7, is_final=True, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=9, element_use=AbstractCoordinateOperationType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'targetCRS'))),
    ])
    , 8 : pyxb.binding.content.ContentModelState(state=8, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=6, element_use=AbstractCoordinateOperationType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'scope'))),
    ])
    , 9 : pyxb.binding.content.ContentModelState(state=9, is_final=True, transitions=[
    ])
    , 10 : pyxb.binding.content.ContentModelState(state=10, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=6, element_use=AbstractCoordinateOperationType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'scope'))),
        pyxb.binding.content.ContentModelTransition(next_state=8, element_use=AbstractCoordinateOperationType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'domainOfValidity'))),
    ])
})



AbstractCoordinateSystemType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'axis'), CoordinateSystemAxisPropertyType, scope=AbstractCoordinateSystemType))
AbstractCoordinateSystemType._ContentModel = pyxb.binding.content.ContentModel(state_map = {
      1 : pyxb.binding.content.ContentModelState(state=1, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=AbstractCoordinateSystemType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'descriptionReference'))),
        pyxb.binding.content.ContentModelTransition(next_state=1, element_use=AbstractCoordinateSystemType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'metaDataProperty'))),
        pyxb.binding.content.ContentModelTransition(next_state=3, element_use=AbstractCoordinateSystemType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'description'))),
        pyxb.binding.content.ContentModelTransition(next_state=6, element_use=AbstractCoordinateSystemType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'identifier'))),
    ])
    , 2 : pyxb.binding.content.ContentModelState(state=2, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=6, element_use=AbstractCoordinateSystemType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'identifier'))),
    ])
    , 3 : pyxb.binding.content.ContentModelState(state=3, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=AbstractCoordinateSystemType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'descriptionReference'))),
        pyxb.binding.content.ContentModelTransition(next_state=6, element_use=AbstractCoordinateSystemType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'identifier'))),
    ])
    , 4 : pyxb.binding.content.ContentModelState(state=4, is_final=True, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=4, element_use=AbstractCoordinateSystemType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'axis'))),
    ])
    , 5 : pyxb.binding.content.ContentModelState(state=5, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=4, element_use=AbstractCoordinateSystemType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'axis'))),
    ])
    , 6 : pyxb.binding.content.ContentModelState(state=6, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=4, element_use=AbstractCoordinateSystemType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'axis'))),
        pyxb.binding.content.ContentModelTransition(next_state=5, element_use=AbstractCoordinateSystemType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'remarks'))),
        pyxb.binding.content.ContentModelTransition(next_state=6, element_use=AbstractCoordinateSystemType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name'))),
    ])
})



AbstractDatumType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'realizationEpoch'), pyxb.binding.datatypes.date, scope=AbstractDatumType))

AbstractDatumType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'scope'), pyxb.binding.datatypes.string, scope=AbstractDatumType))

AbstractDatumType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'domainOfValidity'), _CTD_ANON_22, scope=AbstractDatumType))

AbstractDatumType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'anchorDefinition'), CodeType, scope=AbstractDatumType))
AbstractDatumType._ContentModel = pyxb.binding.content.ContentModel(state_map = {
      1 : pyxb.binding.content.ContentModelState(state=1, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=3, element_use=AbstractDatumType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'descriptionReference'))),
        pyxb.binding.content.ContentModelTransition(next_state=1, element_use=AbstractDatumType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'metaDataProperty'))),
        pyxb.binding.content.ContentModelTransition(next_state=5, element_use=AbstractDatumType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'description'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=AbstractDatumType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'identifier'))),
    ])
    , 2 : pyxb.binding.content.ContentModelState(state=2, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=7, element_use=AbstractDatumType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'domainOfValidity'))),
        pyxb.binding.content.ContentModelTransition(next_state=8, element_use=AbstractDatumType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'scope'))),
        pyxb.binding.content.ContentModelTransition(next_state=9, element_use=AbstractDatumType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'remarks'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=AbstractDatumType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name'))),
    ])
    , 3 : pyxb.binding.content.ContentModelState(state=3, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=AbstractDatumType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'identifier'))),
    ])
    , 4 : pyxb.binding.content.ContentModelState(state=4, is_final=True, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=6, element_use=AbstractDatumType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'realizationEpoch'))),
    ])
    , 5 : pyxb.binding.content.ContentModelState(state=5, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=3, element_use=AbstractDatumType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'descriptionReference'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=AbstractDatumType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'identifier'))),
    ])
    , 6 : pyxb.binding.content.ContentModelState(state=6, is_final=True, transitions=[
    ])
    , 7 : pyxb.binding.content.ContentModelState(state=7, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=8, element_use=AbstractDatumType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'scope'))),
    ])
    , 8 : pyxb.binding.content.ContentModelState(state=8, is_final=True, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=4, element_use=AbstractDatumType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'anchorDefinition'))),
        pyxb.binding.content.ContentModelTransition(next_state=8, element_use=AbstractDatumType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'scope'))),
        pyxb.binding.content.ContentModelTransition(next_state=6, element_use=AbstractDatumType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'realizationEpoch'))),
    ])
    , 9 : pyxb.binding.content.ContentModelState(state=9, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=7, element_use=AbstractDatumType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'domainOfValidity'))),
        pyxb.binding.content.ContentModelTransition(next_state=8, element_use=AbstractDatumType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'scope'))),
    ])
})



AbstractGeneralOperationParameterType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'minimumOccurs'), pyxb.binding.datatypes.nonNegativeInteger, scope=AbstractGeneralOperationParameterType))
AbstractGeneralOperationParameterType._ContentModel = pyxb.binding.content.ContentModel(state_map = {
      1 : pyxb.binding.content.ContentModelState(state=1, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=AbstractGeneralOperationParameterType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'descriptionReference'))),
        pyxb.binding.content.ContentModelTransition(next_state=1, element_use=AbstractGeneralOperationParameterType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'metaDataProperty'))),
        pyxb.binding.content.ContentModelTransition(next_state=3, element_use=AbstractGeneralOperationParameterType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'description'))),
        pyxb.binding.content.ContentModelTransition(next_state=6, element_use=AbstractGeneralOperationParameterType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'identifier'))),
    ])
    , 2 : pyxb.binding.content.ContentModelState(state=2, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=6, element_use=AbstractGeneralOperationParameterType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'identifier'))),
    ])
    , 3 : pyxb.binding.content.ContentModelState(state=3, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=AbstractGeneralOperationParameterType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'descriptionReference'))),
        pyxb.binding.content.ContentModelTransition(next_state=6, element_use=AbstractGeneralOperationParameterType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'identifier'))),
    ])
    , 4 : pyxb.binding.content.ContentModelState(state=4, is_final=True, transitions=[
    ])
    , 5 : pyxb.binding.content.ContentModelState(state=5, is_final=True, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=4, element_use=AbstractGeneralOperationParameterType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'minimumOccurs'))),
    ])
    , 6 : pyxb.binding.content.ContentModelState(state=6, is_final=True, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=4, element_use=AbstractGeneralOperationParameterType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'minimumOccurs'))),
        pyxb.binding.content.ContentModelTransition(next_state=5, element_use=AbstractGeneralOperationParameterType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'remarks'))),
        pyxb.binding.content.ContentModelTransition(next_state=6, element_use=AbstractGeneralOperationParameterType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name'))),
    ])
})



BaseUnitType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'unitsSystem'), ReferenceType, scope=BaseUnitType))
BaseUnitType._ContentModel = pyxb.binding.content.ContentModel(state_map = {
      1 : pyxb.binding.content.ContentModelState(state=1, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=BaseUnitType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'descriptionReference'))),
        pyxb.binding.content.ContentModelTransition(next_state=1, element_use=BaseUnitType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'metaDataProperty'))),
        pyxb.binding.content.ContentModelTransition(next_state=5, element_use=BaseUnitType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'description'))),
        pyxb.binding.content.ContentModelTransition(next_state=9, element_use=BaseUnitType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'identifier'))),
    ])
    , 2 : pyxb.binding.content.ContentModelState(state=2, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=9, element_use=BaseUnitType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'identifier'))),
    ])
    , 3 : pyxb.binding.content.ContentModelState(state=3, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=6, element_use=BaseUnitType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'catalogSymbol'))),
        pyxb.binding.content.ContentModelTransition(next_state=7, element_use=BaseUnitType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'quantityTypeReference'))),
        pyxb.binding.content.ContentModelTransition(next_state=4, element_use=BaseUnitType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'unitsSystem'))),
    ])
    , 4 : pyxb.binding.content.ContentModelState(state=4, is_final=True, transitions=[
    ])
    , 5 : pyxb.binding.content.ContentModelState(state=5, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=BaseUnitType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'descriptionReference'))),
        pyxb.binding.content.ContentModelTransition(next_state=9, element_use=BaseUnitType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'identifier'))),
    ])
    , 6 : pyxb.binding.content.ContentModelState(state=6, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=4, element_use=BaseUnitType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'unitsSystem'))),
    ])
    , 7 : pyxb.binding.content.ContentModelState(state=7, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=6, element_use=BaseUnitType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'catalogSymbol'))),
        pyxb.binding.content.ContentModelTransition(next_state=4, element_use=BaseUnitType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'unitsSystem'))),
    ])
    , 8 : pyxb.binding.content.ContentModelState(state=8, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=6, element_use=BaseUnitType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'catalogSymbol'))),
        pyxb.binding.content.ContentModelTransition(next_state=7, element_use=BaseUnitType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'quantityTypeReference'))),
        pyxb.binding.content.ContentModelTransition(next_state=3, element_use=BaseUnitType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'quantityType'))),
        pyxb.binding.content.ContentModelTransition(next_state=4, element_use=BaseUnitType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'unitsSystem'))),
    ])
    , 9 : pyxb.binding.content.ContentModelState(state=9, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=6, element_use=BaseUnitType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'catalogSymbol'))),
        pyxb.binding.content.ContentModelTransition(next_state=7, element_use=BaseUnitType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'quantityTypeReference'))),
        pyxb.binding.content.ContentModelTransition(next_state=8, element_use=BaseUnitType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'remarks'))),
        pyxb.binding.content.ContentModelTransition(next_state=3, element_use=BaseUnitType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'quantityType'))),
        pyxb.binding.content.ContentModelTransition(next_state=4, element_use=BaseUnitType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'unitsSystem'))),
        pyxb.binding.content.ContentModelTransition(next_state=9, element_use=BaseUnitType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name'))),
    ])
})



CompositeCurveType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'curveMember'), CurvePropertyType, scope=CompositeCurveType))
CompositeCurveType._ContentModel = pyxb.binding.content.ContentModel(state_map = {
      1 : pyxb.binding.content.ContentModelState(state=1, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=5, element_use=CompositeCurveType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'identifier'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=CompositeCurveType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'curveMember'))),
        pyxb.binding.content.ContentModelTransition(next_state=1, element_use=CompositeCurveType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'metaDataProperty'))),
        pyxb.binding.content.ContentModelTransition(next_state=5, element_use=CompositeCurveType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name'))),
        pyxb.binding.content.ContentModelTransition(next_state=3, element_use=CompositeCurveType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'description'))),
        pyxb.binding.content.ContentModelTransition(next_state=4, element_use=CompositeCurveType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'descriptionReference'))),
    ])
    , 2 : pyxb.binding.content.ContentModelState(state=2, is_final=True, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=CompositeCurveType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'curveMember'))),
    ])
    , 3 : pyxb.binding.content.ContentModelState(state=3, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=5, element_use=CompositeCurveType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'identifier'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=CompositeCurveType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'curveMember'))),
        pyxb.binding.content.ContentModelTransition(next_state=5, element_use=CompositeCurveType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name'))),
        pyxb.binding.content.ContentModelTransition(next_state=4, element_use=CompositeCurveType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'descriptionReference'))),
    ])
    , 4 : pyxb.binding.content.ContentModelState(state=4, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=5, element_use=CompositeCurveType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'identifier'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=CompositeCurveType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'curveMember'))),
        pyxb.binding.content.ContentModelTransition(next_state=5, element_use=CompositeCurveType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name'))),
    ])
    , 5 : pyxb.binding.content.ContentModelState(state=5, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=CompositeCurveType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'curveMember'))),
        pyxb.binding.content.ContentModelTransition(next_state=5, element_use=CompositeCurveType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name'))),
    ])
})



CompositeSolidType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'solidMember'), SolidPropertyType, scope=CompositeSolidType))
CompositeSolidType._ContentModel = pyxb.binding.content.ContentModel(state_map = {
      1 : pyxb.binding.content.ContentModelState(state=1, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=4, element_use=CompositeSolidType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'identifier'))),
        pyxb.binding.content.ContentModelTransition(next_state=1, element_use=CompositeSolidType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'metaDataProperty'))),
        pyxb.binding.content.ContentModelTransition(next_state=4, element_use=CompositeSolidType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=CompositeSolidType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'solidMember'))),
        pyxb.binding.content.ContentModelTransition(next_state=3, element_use=CompositeSolidType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'description'))),
        pyxb.binding.content.ContentModelTransition(next_state=5, element_use=CompositeSolidType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'descriptionReference'))),
    ])
    , 2 : pyxb.binding.content.ContentModelState(state=2, is_final=True, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=CompositeSolidType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'solidMember'))),
    ])
    , 3 : pyxb.binding.content.ContentModelState(state=3, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=4, element_use=CompositeSolidType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'identifier'))),
        pyxb.binding.content.ContentModelTransition(next_state=4, element_use=CompositeSolidType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=CompositeSolidType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'solidMember'))),
        pyxb.binding.content.ContentModelTransition(next_state=5, element_use=CompositeSolidType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'descriptionReference'))),
    ])
    , 4 : pyxb.binding.content.ContentModelState(state=4, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=4, element_use=CompositeSolidType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=CompositeSolidType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'solidMember'))),
    ])
    , 5 : pyxb.binding.content.ContentModelState(state=5, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=4, element_use=CompositeSolidType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'identifier'))),
        pyxb.binding.content.ContentModelTransition(next_state=4, element_use=CompositeSolidType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=CompositeSolidType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'solidMember'))),
    ])
})



CompositeSurfaceType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'surfaceMember'), SurfacePropertyType, scope=CompositeSurfaceType))
CompositeSurfaceType._ContentModel = pyxb.binding.content.ContentModel(state_map = {
      1 : pyxb.binding.content.ContentModelState(state=1, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=4, element_use=CompositeSurfaceType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'identifier'))),
        pyxb.binding.content.ContentModelTransition(next_state=1, element_use=CompositeSurfaceType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'metaDataProperty'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=CompositeSurfaceType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'surfaceMember'))),
        pyxb.binding.content.ContentModelTransition(next_state=4, element_use=CompositeSurfaceType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name'))),
        pyxb.binding.content.ContentModelTransition(next_state=3, element_use=CompositeSurfaceType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'description'))),
        pyxb.binding.content.ContentModelTransition(next_state=5, element_use=CompositeSurfaceType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'descriptionReference'))),
    ])
    , 2 : pyxb.binding.content.ContentModelState(state=2, is_final=True, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=CompositeSurfaceType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'surfaceMember'))),
    ])
    , 3 : pyxb.binding.content.ContentModelState(state=3, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=4, element_use=CompositeSurfaceType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'identifier'))),
        pyxb.binding.content.ContentModelTransition(next_state=4, element_use=CompositeSurfaceType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=CompositeSurfaceType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'surfaceMember'))),
        pyxb.binding.content.ContentModelTransition(next_state=5, element_use=CompositeSurfaceType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'descriptionReference'))),
    ])
    , 4 : pyxb.binding.content.ContentModelState(state=4, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=4, element_use=CompositeSurfaceType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=CompositeSurfaceType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'surfaceMember'))),
    ])
    , 5 : pyxb.binding.content.ContentModelState(state=5, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=4, element_use=CompositeSurfaceType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'identifier'))),
        pyxb.binding.content.ContentModelTransition(next_state=4, element_use=CompositeSurfaceType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=CompositeSurfaceType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'surfaceMember'))),
    ])
})



ConventionalUnitType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'conversionToPreferredUnit'), ConversionToPreferredUnitType, scope=ConventionalUnitType))

ConventionalUnitType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'derivationUnitTerm'), DerivationUnitTermType, scope=ConventionalUnitType))

ConventionalUnitType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'roughConversionToPreferredUnit'), ConversionToPreferredUnitType, scope=ConventionalUnitType))
ConventionalUnitType._ContentModel = pyxb.binding.content.ContentModel(state_map = {
      1 : pyxb.binding.content.ContentModelState(state=1, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=1, element_use=ConventionalUnitType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'metaDataProperty'))),
        pyxb.binding.content.ContentModelTransition(next_state=3, element_use=ConventionalUnitType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'descriptionReference'))),
        pyxb.binding.content.ContentModelTransition(next_state=6, element_use=ConventionalUnitType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'description'))),
        pyxb.binding.content.ContentModelTransition(next_state=4, element_use=ConventionalUnitType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'identifier'))),
    ])
    , 2 : pyxb.binding.content.ContentModelState(state=2, is_final=True, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=ConventionalUnitType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'derivationUnitTerm'))),
    ])
    , 3 : pyxb.binding.content.ContentModelState(state=3, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=4, element_use=ConventionalUnitType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'identifier'))),
    ])
    , 4 : pyxb.binding.content.ContentModelState(state=4, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=8, element_use=ConventionalUnitType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'quantityTypeReference'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=ConventionalUnitType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'conversionToPreferredUnit'))),
        pyxb.binding.content.ContentModelTransition(next_state=9, element_use=ConventionalUnitType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'catalogSymbol'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=ConventionalUnitType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'roughConversionToPreferredUnit'))),
        pyxb.binding.content.ContentModelTransition(next_state=5, element_use=ConventionalUnitType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'remarks'))),
        pyxb.binding.content.ContentModelTransition(next_state=7, element_use=ConventionalUnitType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'quantityType'))),
        pyxb.binding.content.ContentModelTransition(next_state=4, element_use=ConventionalUnitType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name'))),
    ])
    , 5 : pyxb.binding.content.ContentModelState(state=5, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=8, element_use=ConventionalUnitType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'quantityTypeReference'))),
        pyxb.binding.content.ContentModelTransition(next_state=9, element_use=ConventionalUnitType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'catalogSymbol'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=ConventionalUnitType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'roughConversionToPreferredUnit'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=ConventionalUnitType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'conversionToPreferredUnit'))),
        pyxb.binding.content.ContentModelTransition(next_state=7, element_use=ConventionalUnitType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'quantityType'))),
    ])
    , 6 : pyxb.binding.content.ContentModelState(state=6, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=3, element_use=ConventionalUnitType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'descriptionReference'))),
        pyxb.binding.content.ContentModelTransition(next_state=4, element_use=ConventionalUnitType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'identifier'))),
    ])
    , 7 : pyxb.binding.content.ContentModelState(state=7, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=8, element_use=ConventionalUnitType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'quantityTypeReference'))),
        pyxb.binding.content.ContentModelTransition(next_state=9, element_use=ConventionalUnitType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'catalogSymbol'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=ConventionalUnitType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'roughConversionToPreferredUnit'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=ConventionalUnitType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'conversionToPreferredUnit'))),
    ])
    , 8 : pyxb.binding.content.ContentModelState(state=8, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=9, element_use=ConventionalUnitType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'catalogSymbol'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=ConventionalUnitType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'conversionToPreferredUnit'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=ConventionalUnitType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'roughConversionToPreferredUnit'))),
    ])
    , 9 : pyxb.binding.content.ContentModelState(state=9, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=ConventionalUnitType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'conversionToPreferredUnit'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=ConventionalUnitType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'roughConversionToPreferredUnit'))),
    ])
})



CoordinateSystemAxisType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'axisAbbrev'), CodeType, scope=CoordinateSystemAxisType))

CoordinateSystemAxisType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'rangeMeaning'), CodeWithAuthorityType, scope=CoordinateSystemAxisType))

CoordinateSystemAxisType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'axisDirection'), CodeWithAuthorityType, scope=CoordinateSystemAxisType))

CoordinateSystemAxisType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'maximumValue'), pyxb.binding.datatypes.double, scope=CoordinateSystemAxisType))

CoordinateSystemAxisType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'minimumValue'), pyxb.binding.datatypes.double, scope=CoordinateSystemAxisType))
CoordinateSystemAxisType._ContentModel = pyxb.binding.content.ContentModel(state_map = {
      1 : pyxb.binding.content.ContentModelState(state=1, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=3, element_use=CoordinateSystemAxisType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'description'))),
        pyxb.binding.content.ContentModelTransition(next_state=1, element_use=CoordinateSystemAxisType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'metaDataProperty'))),
        pyxb.binding.content.ContentModelTransition(next_state=5, element_use=CoordinateSystemAxisType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'descriptionReference'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=CoordinateSystemAxisType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'identifier'))),
    ])
    , 2 : pyxb.binding.content.ContentModelState(state=2, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=8, element_use=CoordinateSystemAxisType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'remarks'))),
        pyxb.binding.content.ContentModelTransition(next_state=10, element_use=CoordinateSystemAxisType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'axisAbbrev'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=CoordinateSystemAxisType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name'))),
    ])
    , 3 : pyxb.binding.content.ContentModelState(state=3, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=5, element_use=CoordinateSystemAxisType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'descriptionReference'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=CoordinateSystemAxisType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'identifier'))),
    ])
    , 4 : pyxb.binding.content.ContentModelState(state=4, is_final=True, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=6, element_use=CoordinateSystemAxisType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'minimumValue'))),
        pyxb.binding.content.ContentModelTransition(next_state=7, element_use=CoordinateSystemAxisType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'maximumValue'))),
        pyxb.binding.content.ContentModelTransition(next_state=9, element_use=CoordinateSystemAxisType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'rangeMeaning'))),
    ])
    , 5 : pyxb.binding.content.ContentModelState(state=5, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=CoordinateSystemAxisType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'identifier'))),
    ])
    , 6 : pyxb.binding.content.ContentModelState(state=6, is_final=True, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=7, element_use=CoordinateSystemAxisType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'maximumValue'))),
        pyxb.binding.content.ContentModelTransition(next_state=9, element_use=CoordinateSystemAxisType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'rangeMeaning'))),
    ])
    , 7 : pyxb.binding.content.ContentModelState(state=7, is_final=True, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=9, element_use=CoordinateSystemAxisType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'rangeMeaning'))),
    ])
    , 8 : pyxb.binding.content.ContentModelState(state=8, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=10, element_use=CoordinateSystemAxisType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'axisAbbrev'))),
    ])
    , 9 : pyxb.binding.content.ContentModelState(state=9, is_final=True, transitions=[
    ])
    , 10 : pyxb.binding.content.ContentModelState(state=10, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=4, element_use=CoordinateSystemAxisType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'axisDirection'))),
    ])
})



CurveType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'segments'), CurveSegmentArrayPropertyType, scope=CurveType))
CurveType._ContentModel = pyxb.binding.content.ContentModel(state_map = {
      1 : pyxb.binding.content.ContentModelState(state=1, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=4, element_use=CurveType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'identifier'))),
        pyxb.binding.content.ContentModelTransition(next_state=1, element_use=CurveType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'metaDataProperty'))),
        pyxb.binding.content.ContentModelTransition(next_state=4, element_use=CurveType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=CurveType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'segments'))),
        pyxb.binding.content.ContentModelTransition(next_state=3, element_use=CurveType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'description'))),
        pyxb.binding.content.ContentModelTransition(next_state=5, element_use=CurveType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'descriptionReference'))),
    ])
    , 2 : pyxb.binding.content.ContentModelState(state=2, is_final=True, transitions=[
    ])
    , 3 : pyxb.binding.content.ContentModelState(state=3, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=4, element_use=CurveType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'identifier'))),
        pyxb.binding.content.ContentModelTransition(next_state=4, element_use=CurveType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=CurveType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'segments'))),
        pyxb.binding.content.ContentModelTransition(next_state=5, element_use=CurveType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'descriptionReference'))),
    ])
    , 4 : pyxb.binding.content.ContentModelState(state=4, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=4, element_use=CurveType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=CurveType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'segments'))),
    ])
    , 5 : pyxb.binding.content.ContentModelState(state=5, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=4, element_use=CurveType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'identifier'))),
        pyxb.binding.content.ContentModelTransition(next_state=4, element_use=CurveType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=CurveType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'segments'))),
    ])
})



DerivedUnitType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'derivationUnitTerm'), DerivationUnitTermType, scope=DerivedUnitType))
DerivedUnitType._ContentModel = pyxb.binding.content.ContentModel(state_map = {
      1 : pyxb.binding.content.ContentModelState(state=1, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=3, element_use=DerivedUnitType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'description'))),
        pyxb.binding.content.ContentModelTransition(next_state=1, element_use=DerivedUnitType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'metaDataProperty'))),
        pyxb.binding.content.ContentModelTransition(next_state=5, element_use=DerivedUnitType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'descriptionReference'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=DerivedUnitType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'identifier'))),
    ])
    , 2 : pyxb.binding.content.ContentModelState(state=2, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=7, element_use=DerivedUnitType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'catalogSymbol'))),
        pyxb.binding.content.ContentModelTransition(next_state=8, element_use=DerivedUnitType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'quantityTypeReference'))),
        pyxb.binding.content.ContentModelTransition(next_state=9, element_use=DerivedUnitType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'remarks'))),
        pyxb.binding.content.ContentModelTransition(next_state=4, element_use=DerivedUnitType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'derivationUnitTerm'))),
        pyxb.binding.content.ContentModelTransition(next_state=6, element_use=DerivedUnitType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'quantityType'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=DerivedUnitType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name'))),
    ])
    , 3 : pyxb.binding.content.ContentModelState(state=3, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=5, element_use=DerivedUnitType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'descriptionReference'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=DerivedUnitType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'identifier'))),
    ])
    , 4 : pyxb.binding.content.ContentModelState(state=4, is_final=True, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=4, element_use=DerivedUnitType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'derivationUnitTerm'))),
    ])
    , 5 : pyxb.binding.content.ContentModelState(state=5, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=DerivedUnitType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'identifier'))),
    ])
    , 6 : pyxb.binding.content.ContentModelState(state=6, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=7, element_use=DerivedUnitType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'catalogSymbol'))),
        pyxb.binding.content.ContentModelTransition(next_state=8, element_use=DerivedUnitType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'quantityTypeReference'))),
        pyxb.binding.content.ContentModelTransition(next_state=4, element_use=DerivedUnitType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'derivationUnitTerm'))),
    ])
    , 7 : pyxb.binding.content.ContentModelState(state=7, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=4, element_use=DerivedUnitType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'derivationUnitTerm'))),
    ])
    , 8 : pyxb.binding.content.ContentModelState(state=8, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=7, element_use=DerivedUnitType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'catalogSymbol'))),
        pyxb.binding.content.ContentModelTransition(next_state=4, element_use=DerivedUnitType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'derivationUnitTerm'))),
    ])
    , 9 : pyxb.binding.content.ContentModelState(state=9, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=7, element_use=DerivedUnitType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'catalogSymbol'))),
        pyxb.binding.content.ContentModelTransition(next_state=8, element_use=DerivedUnitType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'quantityTypeReference'))),
        pyxb.binding.content.ContentModelTransition(next_state=4, element_use=DerivedUnitType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'derivationUnitTerm'))),
        pyxb.binding.content.ContentModelTransition(next_state=6, element_use=DerivedUnitType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'quantityType'))),
    ])
})



DirectedObservationAtDistanceType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'distance'), MeasureType, scope=DirectedObservationAtDistanceType))
DirectedObservationAtDistanceType._ContentModel = pyxb.binding.content.ContentModel(state_map = {
      1 : pyxb.binding.content.ContentModelState(state=1, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=DirectedObservationAtDistanceType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'identifier'))),
        pyxb.binding.content.ContentModelTransition(next_state=4, element_use=DirectedObservationAtDistanceType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'descriptionReference'))),
        pyxb.binding.content.ContentModelTransition(next_state=6, element_use=DirectedObservationAtDistanceType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'boundedBy'))),
        pyxb.binding.content.ContentModelTransition(next_state=8, element_use=DirectedObservationAtDistanceType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'location'))),
        pyxb.binding.content.ContentModelTransition(next_state=10, element_use=DirectedObservationAtDistanceType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'validTime'))),
        pyxb.binding.content.ContentModelTransition(next_state=1, element_use=DirectedObservationAtDistanceType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'metaDataProperty'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=DirectedObservationAtDistanceType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name'))),
        pyxb.binding.content.ContentModelTransition(next_state=3, element_use=DirectedObservationAtDistanceType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'description'))),
    ])
    , 2 : pyxb.binding.content.ContentModelState(state=2, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=6, element_use=DirectedObservationAtDistanceType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'boundedBy'))),
        pyxb.binding.content.ContentModelTransition(next_state=8, element_use=DirectedObservationAtDistanceType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'location'))),
        pyxb.binding.content.ContentModelTransition(next_state=10, element_use=DirectedObservationAtDistanceType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'validTime'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=DirectedObservationAtDistanceType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name'))),
    ])
    , 3 : pyxb.binding.content.ContentModelState(state=3, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=DirectedObservationAtDistanceType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'identifier'))),
        pyxb.binding.content.ContentModelTransition(next_state=4, element_use=DirectedObservationAtDistanceType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'descriptionReference'))),
        pyxb.binding.content.ContentModelTransition(next_state=6, element_use=DirectedObservationAtDistanceType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'boundedBy'))),
        pyxb.binding.content.ContentModelTransition(next_state=8, element_use=DirectedObservationAtDistanceType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'location'))),
        pyxb.binding.content.ContentModelTransition(next_state=10, element_use=DirectedObservationAtDistanceType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'validTime'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=DirectedObservationAtDistanceType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name'))),
    ])
    , 4 : pyxb.binding.content.ContentModelState(state=4, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=DirectedObservationAtDistanceType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'identifier'))),
        pyxb.binding.content.ContentModelTransition(next_state=6, element_use=DirectedObservationAtDistanceType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'boundedBy'))),
        pyxb.binding.content.ContentModelTransition(next_state=10, element_use=DirectedObservationAtDistanceType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'validTime'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=DirectedObservationAtDistanceType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name'))),
        pyxb.binding.content.ContentModelTransition(next_state=8, element_use=DirectedObservationAtDistanceType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'location'))),
    ])
    , 5 : pyxb.binding.content.ContentModelState(state=5, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=11, element_use=DirectedObservationAtDistanceType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'direction'))),
    ])
    , 6 : pyxb.binding.content.ContentModelState(state=6, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=8, element_use=DirectedObservationAtDistanceType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'location'))),
        pyxb.binding.content.ContentModelTransition(next_state=10, element_use=DirectedObservationAtDistanceType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'validTime'))),
    ])
    , 7 : pyxb.binding.content.ContentModelState(state=7, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=5, element_use=DirectedObservationAtDistanceType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'resultOf'))),
    ])
    , 8 : pyxb.binding.content.ContentModelState(state=8, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=10, element_use=DirectedObservationAtDistanceType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'validTime'))),
    ])
    , 9 : pyxb.binding.content.ContentModelState(state=9, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=5, element_use=DirectedObservationAtDistanceType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'resultOf'))),
        pyxb.binding.content.ContentModelTransition(next_state=7, element_use=DirectedObservationAtDistanceType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'target'))),
    ])
    , 10 : pyxb.binding.content.ContentModelState(state=10, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=5, element_use=DirectedObservationAtDistanceType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'resultOf'))),
        pyxb.binding.content.ContentModelTransition(next_state=7, element_use=DirectedObservationAtDistanceType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'target'))),
        pyxb.binding.content.ContentModelTransition(next_state=9, element_use=DirectedObservationAtDistanceType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'using'))),
    ])
    , 11 : pyxb.binding.content.ContentModelState(state=11, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=12, element_use=DirectedObservationAtDistanceType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'distance'))),
    ])
    , 12 : pyxb.binding.content.ContentModelState(state=12, is_final=True, transitions=[
    ])
})



EllipsoidType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'secondDefiningParameter'), _CTD_ANON_19, scope=EllipsoidType))

EllipsoidType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'semiMajorAxis'), MeasureType, scope=EllipsoidType))
EllipsoidType._ContentModel = pyxb.binding.content.ContentModel(state_map = {
      1 : pyxb.binding.content.ContentModelState(state=1, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=1, element_use=EllipsoidType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'metaDataProperty'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=EllipsoidType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'descriptionReference'))),
        pyxb.binding.content.ContentModelTransition(next_state=4, element_use=EllipsoidType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'description'))),
        pyxb.binding.content.ContentModelTransition(next_state=7, element_use=EllipsoidType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'identifier'))),
    ])
    , 2 : pyxb.binding.content.ContentModelState(state=2, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=7, element_use=EllipsoidType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'identifier'))),
    ])
    , 3 : pyxb.binding.content.ContentModelState(state=3, is_final=True, transitions=[
    ])
    , 4 : pyxb.binding.content.ContentModelState(state=4, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=EllipsoidType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'descriptionReference'))),
        pyxb.binding.content.ContentModelTransition(next_state=7, element_use=EllipsoidType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'identifier'))),
    ])
    , 5 : pyxb.binding.content.ContentModelState(state=5, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=3, element_use=EllipsoidType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'secondDefiningParameter'))),
    ])
    , 6 : pyxb.binding.content.ContentModelState(state=6, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=5, element_use=EllipsoidType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'semiMajorAxis'))),
    ])
    , 7 : pyxb.binding.content.ContentModelState(state=7, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=5, element_use=EllipsoidType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'semiMajorAxis'))),
        pyxb.binding.content.ContentModelTransition(next_state=6, element_use=EllipsoidType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'remarks'))),
        pyxb.binding.content.ContentModelTransition(next_state=7, element_use=EllipsoidType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name'))),
    ])
})



GridCoverageType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'gridDomain'), GridDomainType, scope=GridCoverageType))
GridCoverageType._ContentModel = pyxb.binding.content.ContentModel(state_map = {
      1 : pyxb.binding.content.ContentModelState(state=1, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=GridCoverageType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'identifier'))),
        pyxb.binding.content.ContentModelTransition(next_state=3, element_use=GridCoverageType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'description'))),
        pyxb.binding.content.ContentModelTransition(next_state=5, element_use=GridCoverageType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'descriptionReference'))),
        pyxb.binding.content.ContentModelTransition(next_state=7, element_use=GridCoverageType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'boundedBy'))),
        pyxb.binding.content.ContentModelTransition(next_state=8, element_use=GridCoverageType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'gridDomain'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=GridCoverageType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name'))),
        pyxb.binding.content.ContentModelTransition(next_state=1, element_use=GridCoverageType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'metaDataProperty'))),
    ])
    , 2 : pyxb.binding.content.ContentModelState(state=2, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=7, element_use=GridCoverageType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'boundedBy'))),
        pyxb.binding.content.ContentModelTransition(next_state=8, element_use=GridCoverageType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'gridDomain'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=GridCoverageType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name'))),
    ])
    , 3 : pyxb.binding.content.ContentModelState(state=3, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=5, element_use=GridCoverageType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'descriptionReference'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=GridCoverageType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'identifier'))),
        pyxb.binding.content.ContentModelTransition(next_state=7, element_use=GridCoverageType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'boundedBy'))),
        pyxb.binding.content.ContentModelTransition(next_state=8, element_use=GridCoverageType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'gridDomain'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=GridCoverageType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name'))),
    ])
    , 4 : pyxb.binding.content.ContentModelState(state=4, is_final=True, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=6, element_use=GridCoverageType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'coverageFunction'))),
    ])
    , 5 : pyxb.binding.content.ContentModelState(state=5, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=GridCoverageType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'identifier'))),
        pyxb.binding.content.ContentModelTransition(next_state=7, element_use=GridCoverageType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'boundedBy'))),
        pyxb.binding.content.ContentModelTransition(next_state=8, element_use=GridCoverageType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'gridDomain'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=GridCoverageType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name'))),
    ])
    , 6 : pyxb.binding.content.ContentModelState(state=6, is_final=True, transitions=[
    ])
    , 7 : pyxb.binding.content.ContentModelState(state=7, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=8, element_use=GridCoverageType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'gridDomain'))),
    ])
    , 8 : pyxb.binding.content.ContentModelState(state=8, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=4, element_use=GridCoverageType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'rangeSet'))),
    ])
})



LineStringType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'posList'), DirectPositionListType, scope=LineStringType))

LineStringType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'coordinates'), CoordinatesType, scope=LineStringType))

LineStringType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'pointRep'), PointPropertyType, scope=LineStringType))

LineStringType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'pos'), DirectPositionType, scope=LineStringType))

LineStringType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'pointProperty'), PointPropertyType, scope=LineStringType))
LineStringType._ContentModel = pyxb.binding.content.ContentModel(state_map = {
      1 : pyxb.binding.content.ContentModelState(state=1, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=6, element_use=LineStringType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'pos'))),
        pyxb.binding.content.ContentModelTransition(next_state=6, element_use=LineStringType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'pointProperty'))),
        pyxb.binding.content.ContentModelTransition(next_state=6, element_use=LineStringType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'pointRep'))),
        pyxb.binding.content.ContentModelTransition(next_state=7, element_use=LineStringType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'posList'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=LineStringType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'identifier'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=LineStringType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name'))),
        pyxb.binding.content.ContentModelTransition(next_state=7, element_use=LineStringType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'coordinates'))),
        pyxb.binding.content.ContentModelTransition(next_state=4, element_use=LineStringType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'description'))),
        pyxb.binding.content.ContentModelTransition(next_state=1, element_use=LineStringType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'metaDataProperty'))),
        pyxb.binding.content.ContentModelTransition(next_state=3, element_use=LineStringType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'descriptionReference'))),
    ])
    , 2 : pyxb.binding.content.ContentModelState(state=2, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=6, element_use=LineStringType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'pointRep'))),
        pyxb.binding.content.ContentModelTransition(next_state=6, element_use=LineStringType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'pointProperty'))),
        pyxb.binding.content.ContentModelTransition(next_state=6, element_use=LineStringType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'pos'))),
        pyxb.binding.content.ContentModelTransition(next_state=7, element_use=LineStringType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'coordinates'))),
        pyxb.binding.content.ContentModelTransition(next_state=7, element_use=LineStringType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'posList'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=LineStringType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name'))),
    ])
    , 3 : pyxb.binding.content.ContentModelState(state=3, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=6, element_use=LineStringType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'pos'))),
        pyxb.binding.content.ContentModelTransition(next_state=6, element_use=LineStringType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'pointProperty'))),
        pyxb.binding.content.ContentModelTransition(next_state=6, element_use=LineStringType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'pointRep'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=LineStringType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'identifier'))),
        pyxb.binding.content.ContentModelTransition(next_state=7, element_use=LineStringType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'coordinates'))),
        pyxb.binding.content.ContentModelTransition(next_state=7, element_use=LineStringType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'posList'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=LineStringType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name'))),
    ])
    , 4 : pyxb.binding.content.ContentModelState(state=4, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=6, element_use=LineStringType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'pos'))),
        pyxb.binding.content.ContentModelTransition(next_state=6, element_use=LineStringType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'pointProperty'))),
        pyxb.binding.content.ContentModelTransition(next_state=6, element_use=LineStringType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'pointRep'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=LineStringType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'identifier'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=LineStringType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name'))),
        pyxb.binding.content.ContentModelTransition(next_state=7, element_use=LineStringType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'coordinates'))),
        pyxb.binding.content.ContentModelTransition(next_state=7, element_use=LineStringType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'posList'))),
        pyxb.binding.content.ContentModelTransition(next_state=3, element_use=LineStringType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'descriptionReference'))),
    ])
    , 5 : pyxb.binding.content.ContentModelState(state=5, is_final=True, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=5, element_use=LineStringType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'pointProperty'))),
        pyxb.binding.content.ContentModelTransition(next_state=5, element_use=LineStringType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'pos'))),
        pyxb.binding.content.ContentModelTransition(next_state=5, element_use=LineStringType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'pointRep'))),
    ])
    , 6 : pyxb.binding.content.ContentModelState(state=6, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=5, element_use=LineStringType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'pointProperty'))),
        pyxb.binding.content.ContentModelTransition(next_state=5, element_use=LineStringType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'pos'))),
        pyxb.binding.content.ContentModelTransition(next_state=5, element_use=LineStringType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'pointRep'))),
    ])
    , 7 : pyxb.binding.content.ContentModelState(state=7, is_final=True, transitions=[
    ])
})



MultiCurveCoverageType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'multiCurveDomain'), MultiCurveDomainType, scope=MultiCurveCoverageType))
MultiCurveCoverageType._ContentModel = pyxb.binding.content.ContentModel(state_map = {
      1 : pyxb.binding.content.ContentModelState(state=1, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=1, element_use=MultiCurveCoverageType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'metaDataProperty'))),
        pyxb.binding.content.ContentModelTransition(next_state=3, element_use=MultiCurveCoverageType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'multiCurveDomain'))),
        pyxb.binding.content.ContentModelTransition(next_state=5, element_use=MultiCurveCoverageType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'description'))),
        pyxb.binding.content.ContentModelTransition(next_state=7, element_use=MultiCurveCoverageType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'boundedBy'))),
        pyxb.binding.content.ContentModelTransition(next_state=8, element_use=MultiCurveCoverageType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'descriptionReference'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=MultiCurveCoverageType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'identifier'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=MultiCurveCoverageType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name'))),
    ])
    , 2 : pyxb.binding.content.ContentModelState(state=2, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=3, element_use=MultiCurveCoverageType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'multiCurveDomain'))),
        pyxb.binding.content.ContentModelTransition(next_state=7, element_use=MultiCurveCoverageType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'boundedBy'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=MultiCurveCoverageType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name'))),
    ])
    , 3 : pyxb.binding.content.ContentModelState(state=3, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=4, element_use=MultiCurveCoverageType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'rangeSet'))),
    ])
    , 4 : pyxb.binding.content.ContentModelState(state=4, is_final=True, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=6, element_use=MultiCurveCoverageType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'coverageFunction'))),
    ])
    , 5 : pyxb.binding.content.ContentModelState(state=5, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=3, element_use=MultiCurveCoverageType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'multiCurveDomain'))),
        pyxb.binding.content.ContentModelTransition(next_state=7, element_use=MultiCurveCoverageType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'boundedBy'))),
        pyxb.binding.content.ContentModelTransition(next_state=8, element_use=MultiCurveCoverageType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'descriptionReference'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=MultiCurveCoverageType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=MultiCurveCoverageType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'identifier'))),
    ])
    , 6 : pyxb.binding.content.ContentModelState(state=6, is_final=True, transitions=[
    ])
    , 7 : pyxb.binding.content.ContentModelState(state=7, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=3, element_use=MultiCurveCoverageType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'multiCurveDomain'))),
    ])
    , 8 : pyxb.binding.content.ContentModelState(state=8, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=3, element_use=MultiCurveCoverageType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'multiCurveDomain'))),
        pyxb.binding.content.ContentModelTransition(next_state=7, element_use=MultiCurveCoverageType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'boundedBy'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=MultiCurveCoverageType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=MultiCurveCoverageType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'identifier'))),
    ])
})



MultiPointCoverageType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'multiPointDomain'), MultiPointDomainType, scope=MultiPointCoverageType))
MultiPointCoverageType._ContentModel = pyxb.binding.content.ContentModel(state_map = {
      1 : pyxb.binding.content.ContentModelState(state=1, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=8, element_use=MultiPointCoverageType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'identifier'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=MultiPointCoverageType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'descriptionReference'))),
        pyxb.binding.content.ContentModelTransition(next_state=8, element_use=MultiPointCoverageType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name'))),
        pyxb.binding.content.ContentModelTransition(next_state=5, element_use=MultiPointCoverageType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'boundedBy'))),
        pyxb.binding.content.ContentModelTransition(next_state=6, element_use=MultiPointCoverageType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'description'))),
        pyxb.binding.content.ContentModelTransition(next_state=7, element_use=MultiPointCoverageType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'multiPointDomain'))),
        pyxb.binding.content.ContentModelTransition(next_state=1, element_use=MultiPointCoverageType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'metaDataProperty'))),
    ])
    , 2 : pyxb.binding.content.ContentModelState(state=2, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=8, element_use=MultiPointCoverageType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'identifier'))),
        pyxb.binding.content.ContentModelTransition(next_state=5, element_use=MultiPointCoverageType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'boundedBy'))),
        pyxb.binding.content.ContentModelTransition(next_state=7, element_use=MultiPointCoverageType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'multiPointDomain'))),
        pyxb.binding.content.ContentModelTransition(next_state=8, element_use=MultiPointCoverageType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name'))),
    ])
    , 3 : pyxb.binding.content.ContentModelState(state=3, is_final=True, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=4, element_use=MultiPointCoverageType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'coverageFunction'))),
    ])
    , 4 : pyxb.binding.content.ContentModelState(state=4, is_final=True, transitions=[
    ])
    , 5 : pyxb.binding.content.ContentModelState(state=5, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=7, element_use=MultiPointCoverageType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'multiPointDomain'))),
    ])
    , 6 : pyxb.binding.content.ContentModelState(state=6, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=MultiPointCoverageType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'descriptionReference'))),
        pyxb.binding.content.ContentModelTransition(next_state=8, element_use=MultiPointCoverageType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'identifier'))),
        pyxb.binding.content.ContentModelTransition(next_state=7, element_use=MultiPointCoverageType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'multiPointDomain'))),
        pyxb.binding.content.ContentModelTransition(next_state=8, element_use=MultiPointCoverageType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name'))),
        pyxb.binding.content.ContentModelTransition(next_state=5, element_use=MultiPointCoverageType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'boundedBy'))),
    ])
    , 7 : pyxb.binding.content.ContentModelState(state=7, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=3, element_use=MultiPointCoverageType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'rangeSet'))),
    ])
    , 8 : pyxb.binding.content.ContentModelState(state=8, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=5, element_use=MultiPointCoverageType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'boundedBy'))),
        pyxb.binding.content.ContentModelTransition(next_state=7, element_use=MultiPointCoverageType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'multiPointDomain'))),
        pyxb.binding.content.ContentModelTransition(next_state=8, element_use=MultiPointCoverageType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name'))),
    ])
})



MultiSolidCoverageType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'multiSolidDomain'), MultiSolidDomainType, scope=MultiSolidCoverageType))
MultiSolidCoverageType._ContentModel = pyxb.binding.content.ContentModel(state_map = {
      1 : pyxb.binding.content.ContentModelState(state=1, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=1, element_use=MultiSolidCoverageType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'metaDataProperty'))),
        pyxb.binding.content.ContentModelTransition(next_state=3, element_use=MultiSolidCoverageType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'boundedBy'))),
        pyxb.binding.content.ContentModelTransition(next_state=5, element_use=MultiSolidCoverageType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'multiSolidDomain'))),
        pyxb.binding.content.ContentModelTransition(next_state=7, element_use=MultiSolidCoverageType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'description'))),
        pyxb.binding.content.ContentModelTransition(next_state=8, element_use=MultiSolidCoverageType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'descriptionReference'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=MultiSolidCoverageType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'identifier'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=MultiSolidCoverageType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name'))),
    ])
    , 2 : pyxb.binding.content.ContentModelState(state=2, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=3, element_use=MultiSolidCoverageType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'boundedBy'))),
        pyxb.binding.content.ContentModelTransition(next_state=5, element_use=MultiSolidCoverageType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'multiSolidDomain'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=MultiSolidCoverageType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name'))),
    ])
    , 3 : pyxb.binding.content.ContentModelState(state=3, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=5, element_use=MultiSolidCoverageType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'multiSolidDomain'))),
    ])
    , 4 : pyxb.binding.content.ContentModelState(state=4, is_final=True, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=6, element_use=MultiSolidCoverageType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'coverageFunction'))),
    ])
    , 5 : pyxb.binding.content.ContentModelState(state=5, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=4, element_use=MultiSolidCoverageType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'rangeSet'))),
    ])
    , 6 : pyxb.binding.content.ContentModelState(state=6, is_final=True, transitions=[
    ])
    , 7 : pyxb.binding.content.ContentModelState(state=7, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=3, element_use=MultiSolidCoverageType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'boundedBy'))),
        pyxb.binding.content.ContentModelTransition(next_state=5, element_use=MultiSolidCoverageType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'multiSolidDomain'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=MultiSolidCoverageType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'identifier'))),
        pyxb.binding.content.ContentModelTransition(next_state=8, element_use=MultiSolidCoverageType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'descriptionReference'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=MultiSolidCoverageType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name'))),
    ])
    , 8 : pyxb.binding.content.ContentModelState(state=8, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=3, element_use=MultiSolidCoverageType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'boundedBy'))),
        pyxb.binding.content.ContentModelTransition(next_state=5, element_use=MultiSolidCoverageType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'multiSolidDomain'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=MultiSolidCoverageType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'identifier'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=MultiSolidCoverageType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name'))),
    ])
})



MultiSurfaceCoverageType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'multiSurfaceDomain'), MultiSurfaceDomainType, scope=MultiSurfaceCoverageType))
MultiSurfaceCoverageType._ContentModel = pyxb.binding.content.ContentModel(state_map = {
      1 : pyxb.binding.content.ContentModelState(state=1, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=MultiSurfaceCoverageType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'identifier'))),
        pyxb.binding.content.ContentModelTransition(next_state=3, element_use=MultiSurfaceCoverageType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'descriptionReference'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=MultiSurfaceCoverageType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name'))),
        pyxb.binding.content.ContentModelTransition(next_state=5, element_use=MultiSurfaceCoverageType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'description'))),
        pyxb.binding.content.ContentModelTransition(next_state=7, element_use=MultiSurfaceCoverageType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'boundedBy'))),
        pyxb.binding.content.ContentModelTransition(next_state=8, element_use=MultiSurfaceCoverageType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'multiSurfaceDomain'))),
        pyxb.binding.content.ContentModelTransition(next_state=1, element_use=MultiSurfaceCoverageType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'metaDataProperty'))),
    ])
    , 2 : pyxb.binding.content.ContentModelState(state=2, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=MultiSurfaceCoverageType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name'))),
        pyxb.binding.content.ContentModelTransition(next_state=7, element_use=MultiSurfaceCoverageType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'boundedBy'))),
        pyxb.binding.content.ContentModelTransition(next_state=8, element_use=MultiSurfaceCoverageType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'multiSurfaceDomain'))),
    ])
    , 3 : pyxb.binding.content.ContentModelState(state=3, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=MultiSurfaceCoverageType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'identifier'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=MultiSurfaceCoverageType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name'))),
        pyxb.binding.content.ContentModelTransition(next_state=7, element_use=MultiSurfaceCoverageType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'boundedBy'))),
        pyxb.binding.content.ContentModelTransition(next_state=8, element_use=MultiSurfaceCoverageType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'multiSurfaceDomain'))),
    ])
    , 4 : pyxb.binding.content.ContentModelState(state=4, is_final=True, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=6, element_use=MultiSurfaceCoverageType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'coverageFunction'))),
    ])
    , 5 : pyxb.binding.content.ContentModelState(state=5, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=3, element_use=MultiSurfaceCoverageType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'descriptionReference'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=MultiSurfaceCoverageType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'identifier'))),
        pyxb.binding.content.ContentModelTransition(next_state=7, element_use=MultiSurfaceCoverageType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'boundedBy'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=MultiSurfaceCoverageType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name'))),
        pyxb.binding.content.ContentModelTransition(next_state=8, element_use=MultiSurfaceCoverageType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'multiSurfaceDomain'))),
    ])
    , 6 : pyxb.binding.content.ContentModelState(state=6, is_final=True, transitions=[
    ])
    , 7 : pyxb.binding.content.ContentModelState(state=7, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=8, element_use=MultiSurfaceCoverageType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'multiSurfaceDomain'))),
    ])
    , 8 : pyxb.binding.content.ContentModelState(state=8, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=4, element_use=MultiSurfaceCoverageType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'rangeSet'))),
    ])
})



OperationMethodType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'sourceDimensions'), pyxb.binding.datatypes.positiveInteger, scope=OperationMethodType))

OperationMethodType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'generalOperationParameter'), AbstractGeneralOperationParameterPropertyType, scope=OperationMethodType))

OperationMethodType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'formula'), CodeType, scope=OperationMethodType))

OperationMethodType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'targetDimensions'), pyxb.binding.datatypes.positiveInteger, scope=OperationMethodType))
OperationMethodType._ContentModel = pyxb.binding.content.ContentModel(state_map = {
      1 : pyxb.binding.content.ContentModelState(state=1, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=1, element_use=OperationMethodType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'metaDataProperty'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=OperationMethodType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'descriptionReference'))),
        pyxb.binding.content.ContentModelTransition(next_state=4, element_use=OperationMethodType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'description'))),
        pyxb.binding.content.ContentModelTransition(next_state=8, element_use=OperationMethodType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'identifier'))),
    ])
    , 2 : pyxb.binding.content.ContentModelState(state=2, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=8, element_use=OperationMethodType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'identifier'))),
    ])
    , 3 : pyxb.binding.content.ContentModelState(state=3, is_final=True, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=5, element_use=OperationMethodType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'targetDimensions'))),
        pyxb.binding.content.ContentModelTransition(next_state=5, element_use=OperationMethodType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'generalOperationParameter'))),
    ])
    , 4 : pyxb.binding.content.ContentModelState(state=4, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=OperationMethodType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'descriptionReference'))),
        pyxb.binding.content.ContentModelTransition(next_state=8, element_use=OperationMethodType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'identifier'))),
    ])
    , 5 : pyxb.binding.content.ContentModelState(state=5, is_final=True, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=5, element_use=OperationMethodType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'generalOperationParameter'))),
    ])
    , 6 : pyxb.binding.content.ContentModelState(state=6, is_final=True, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=3, element_use=OperationMethodType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'sourceDimensions'))),
        pyxb.binding.content.ContentModelTransition(next_state=5, element_use=OperationMethodType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'targetDimensions'))),
        pyxb.binding.content.ContentModelTransition(next_state=5, element_use=OperationMethodType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'generalOperationParameter'))),
    ])
    , 7 : pyxb.binding.content.ContentModelState(state=7, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=6, element_use=OperationMethodType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'formula'))),
    ])
    , 8 : pyxb.binding.content.ContentModelState(state=8, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=6, element_use=OperationMethodType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'formula'))),
        pyxb.binding.content.ContentModelTransition(next_state=7, element_use=OperationMethodType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'remarks'))),
        pyxb.binding.content.ContentModelTransition(next_state=8, element_use=OperationMethodType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name'))),
    ])
})



OrientableCurveType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'baseCurve'), CurvePropertyType, scope=OrientableCurveType))
OrientableCurveType._ContentModel = pyxb.binding.content.ContentModel(state_map = {
      1 : pyxb.binding.content.ContentModelState(state=1, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=4, element_use=OrientableCurveType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'identifier'))),
        pyxb.binding.content.ContentModelTransition(next_state=3, element_use=OrientableCurveType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'baseCurve'))),
        pyxb.binding.content.ContentModelTransition(next_state=1, element_use=OrientableCurveType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'metaDataProperty'))),
        pyxb.binding.content.ContentModelTransition(next_state=4, element_use=OrientableCurveType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=OrientableCurveType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'description'))),
        pyxb.binding.content.ContentModelTransition(next_state=5, element_use=OrientableCurveType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'descriptionReference'))),
    ])
    , 2 : pyxb.binding.content.ContentModelState(state=2, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=4, element_use=OrientableCurveType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'identifier'))),
        pyxb.binding.content.ContentModelTransition(next_state=4, element_use=OrientableCurveType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name'))),
        pyxb.binding.content.ContentModelTransition(next_state=3, element_use=OrientableCurveType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'baseCurve'))),
        pyxb.binding.content.ContentModelTransition(next_state=5, element_use=OrientableCurveType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'descriptionReference'))),
    ])
    , 3 : pyxb.binding.content.ContentModelState(state=3, is_final=True, transitions=[
    ])
    , 4 : pyxb.binding.content.ContentModelState(state=4, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=4, element_use=OrientableCurveType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name'))),
        pyxb.binding.content.ContentModelTransition(next_state=3, element_use=OrientableCurveType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'baseCurve'))),
    ])
    , 5 : pyxb.binding.content.ContentModelState(state=5, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=4, element_use=OrientableCurveType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'identifier'))),
        pyxb.binding.content.ContentModelTransition(next_state=4, element_use=OrientableCurveType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name'))),
        pyxb.binding.content.ContentModelTransition(next_state=3, element_use=OrientableCurveType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'baseCurve'))),
    ])
})



OrientableSurfaceType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'baseSurface'), SurfacePropertyType, scope=OrientableSurfaceType))
OrientableSurfaceType._ContentModel = pyxb.binding.content.ContentModel(state_map = {
      1 : pyxb.binding.content.ContentModelState(state=1, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=5, element_use=OrientableSurfaceType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'identifier'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=OrientableSurfaceType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'baseSurface'))),
        pyxb.binding.content.ContentModelTransition(next_state=4, element_use=OrientableSurfaceType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'descriptionReference'))),
        pyxb.binding.content.ContentModelTransition(next_state=1, element_use=OrientableSurfaceType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'metaDataProperty'))),
        pyxb.binding.content.ContentModelTransition(next_state=3, element_use=OrientableSurfaceType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'description'))),
        pyxb.binding.content.ContentModelTransition(next_state=5, element_use=OrientableSurfaceType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name'))),
    ])
    , 2 : pyxb.binding.content.ContentModelState(state=2, is_final=True, transitions=[
    ])
    , 3 : pyxb.binding.content.ContentModelState(state=3, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=5, element_use=OrientableSurfaceType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'identifier'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=OrientableSurfaceType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'baseSurface'))),
        pyxb.binding.content.ContentModelTransition(next_state=5, element_use=OrientableSurfaceType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name'))),
        pyxb.binding.content.ContentModelTransition(next_state=4, element_use=OrientableSurfaceType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'descriptionReference'))),
    ])
    , 4 : pyxb.binding.content.ContentModelState(state=4, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=5, element_use=OrientableSurfaceType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'identifier'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=OrientableSurfaceType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'baseSurface'))),
        pyxb.binding.content.ContentModelTransition(next_state=5, element_use=OrientableSurfaceType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name'))),
    ])
    , 5 : pyxb.binding.content.ContentModelState(state=5, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=OrientableSurfaceType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'baseSurface'))),
        pyxb.binding.content.ContentModelTransition(next_state=5, element_use=OrientableSurfaceType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name'))),
    ])
})



PolygonType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'interior'), AbstractRingPropertyType, scope=PolygonType))

PolygonType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'exterior'), AbstractRingPropertyType, scope=PolygonType))
PolygonType._ContentModel = pyxb.binding.content.ContentModel(state_map = {
      1 : pyxb.binding.content.ContentModelState(state=1, is_final=True, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=PolygonType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'identifier'))),
        pyxb.binding.content.ContentModelTransition(next_state=1, element_use=PolygonType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'metaDataProperty'))),
        pyxb.binding.content.ContentModelTransition(next_state=3, element_use=PolygonType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'interior'))),
        pyxb.binding.content.ContentModelTransition(next_state=4, element_use=PolygonType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'descriptionReference'))),
        pyxb.binding.content.ContentModelTransition(next_state=3, element_use=PolygonType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'exterior'))),
        pyxb.binding.content.ContentModelTransition(next_state=5, element_use=PolygonType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'description'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=PolygonType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name'))),
    ])
    , 2 : pyxb.binding.content.ContentModelState(state=2, is_final=True, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=3, element_use=PolygonType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'exterior'))),
        pyxb.binding.content.ContentModelTransition(next_state=3, element_use=PolygonType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'interior'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=PolygonType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name'))),
    ])
    , 3 : pyxb.binding.content.ContentModelState(state=3, is_final=True, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=3, element_use=PolygonType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'interior'))),
    ])
    , 4 : pyxb.binding.content.ContentModelState(state=4, is_final=True, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=PolygonType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'identifier'))),
        pyxb.binding.content.ContentModelTransition(next_state=3, element_use=PolygonType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'exterior'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=PolygonType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name'))),
        pyxb.binding.content.ContentModelTransition(next_state=3, element_use=PolygonType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'interior'))),
    ])
    , 5 : pyxb.binding.content.ContentModelState(state=5, is_final=True, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=PolygonType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'identifier'))),
        pyxb.binding.content.ContentModelTransition(next_state=4, element_use=PolygonType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'descriptionReference'))),
        pyxb.binding.content.ContentModelTransition(next_state=3, element_use=PolygonType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'exterior'))),
        pyxb.binding.content.ContentModelTransition(next_state=3, element_use=PolygonType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'interior'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=PolygonType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name'))),
    ])
})



PrimeMeridianType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'greenwichLongitude'), AngleType, scope=PrimeMeridianType))
PrimeMeridianType._ContentModel = pyxb.binding.content.ContentModel(state_map = {
      1 : pyxb.binding.content.ContentModelState(state=1, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=PrimeMeridianType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'descriptionReference'))),
        pyxb.binding.content.ContentModelTransition(next_state=1, element_use=PrimeMeridianType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'metaDataProperty'))),
        pyxb.binding.content.ContentModelTransition(next_state=3, element_use=PrimeMeridianType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'description'))),
        pyxb.binding.content.ContentModelTransition(next_state=6, element_use=PrimeMeridianType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'identifier'))),
    ])
    , 2 : pyxb.binding.content.ContentModelState(state=2, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=6, element_use=PrimeMeridianType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'identifier'))),
    ])
    , 3 : pyxb.binding.content.ContentModelState(state=3, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=PrimeMeridianType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'descriptionReference'))),
        pyxb.binding.content.ContentModelTransition(next_state=6, element_use=PrimeMeridianType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'identifier'))),
    ])
    , 4 : pyxb.binding.content.ContentModelState(state=4, is_final=True, transitions=[
    ])
    , 5 : pyxb.binding.content.ContentModelState(state=5, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=4, element_use=PrimeMeridianType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'greenwichLongitude'))),
    ])
    , 6 : pyxb.binding.content.ContentModelState(state=6, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=4, element_use=PrimeMeridianType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'greenwichLongitude'))),
        pyxb.binding.content.ContentModelTransition(next_state=5, element_use=PrimeMeridianType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'remarks'))),
        pyxb.binding.content.ContentModelTransition(next_state=6, element_use=PrimeMeridianType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name'))),
    ])
})



RectifiedGridCoverageType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'rectifiedGridDomain'), RectifiedGridDomainType, scope=RectifiedGridCoverageType))
RectifiedGridCoverageType._ContentModel = pyxb.binding.content.ContentModel(state_map = {
      1 : pyxb.binding.content.ContentModelState(state=1, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=RectifiedGridCoverageType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name'))),
        pyxb.binding.content.ContentModelTransition(next_state=6, element_use=RectifiedGridCoverageType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'boundedBy'))),
        pyxb.binding.content.ContentModelTransition(next_state=4, element_use=RectifiedGridCoverageType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'rectifiedGridDomain'))),
        pyxb.binding.content.ContentModelTransition(next_state=7, element_use=RectifiedGridCoverageType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'description'))),
        pyxb.binding.content.ContentModelTransition(next_state=8, element_use=RectifiedGridCoverageType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'descriptionReference'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=RectifiedGridCoverageType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'identifier'))),
        pyxb.binding.content.ContentModelTransition(next_state=1, element_use=RectifiedGridCoverageType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'metaDataProperty'))),
    ])
    , 2 : pyxb.binding.content.ContentModelState(state=2, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=RectifiedGridCoverageType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name'))),
        pyxb.binding.content.ContentModelTransition(next_state=4, element_use=RectifiedGridCoverageType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'rectifiedGridDomain'))),
        pyxb.binding.content.ContentModelTransition(next_state=6, element_use=RectifiedGridCoverageType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'boundedBy'))),
    ])
    , 3 : pyxb.binding.content.ContentModelState(state=3, is_final=True, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=5, element_use=RectifiedGridCoverageType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'coverageFunction'))),
    ])
    , 4 : pyxb.binding.content.ContentModelState(state=4, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=3, element_use=RectifiedGridCoverageType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'rangeSet'))),
    ])
    , 5 : pyxb.binding.content.ContentModelState(state=5, is_final=True, transitions=[
    ])
    , 6 : pyxb.binding.content.ContentModelState(state=6, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=4, element_use=RectifiedGridCoverageType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'rectifiedGridDomain'))),
    ])
    , 7 : pyxb.binding.content.ContentModelState(state=7, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=RectifiedGridCoverageType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name'))),
        pyxb.binding.content.ContentModelTransition(next_state=4, element_use=RectifiedGridCoverageType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'rectifiedGridDomain'))),
        pyxb.binding.content.ContentModelTransition(next_state=6, element_use=RectifiedGridCoverageType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'boundedBy'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=RectifiedGridCoverageType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'identifier'))),
        pyxb.binding.content.ContentModelTransition(next_state=8, element_use=RectifiedGridCoverageType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'descriptionReference'))),
    ])
    , 8 : pyxb.binding.content.ContentModelState(state=8, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=RectifiedGridCoverageType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name'))),
        pyxb.binding.content.ContentModelTransition(next_state=4, element_use=RectifiedGridCoverageType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'rectifiedGridDomain'))),
        pyxb.binding.content.ContentModelTransition(next_state=6, element_use=RectifiedGridCoverageType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'boundedBy'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=RectifiedGridCoverageType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'identifier'))),
    ])
})



SolidType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'interior'), ShellPropertyType, scope=SolidType))

SolidType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'exterior'), ShellPropertyType, scope=SolidType))
SolidType._ContentModel = pyxb.binding.content.ContentModel(state_map = {
      1 : pyxb.binding.content.ContentModelState(state=1, is_final=True, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=SolidType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'identifier'))),
        pyxb.binding.content.ContentModelTransition(next_state=5, element_use=SolidType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'interior'))),
        pyxb.binding.content.ContentModelTransition(next_state=3, element_use=SolidType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'descriptionReference'))),
        pyxb.binding.content.ContentModelTransition(next_state=1, element_use=SolidType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'metaDataProperty'))),
        pyxb.binding.content.ContentModelTransition(next_state=5, element_use=SolidType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'exterior'))),
        pyxb.binding.content.ContentModelTransition(next_state=4, element_use=SolidType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'description'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=SolidType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name'))),
    ])
    , 2 : pyxb.binding.content.ContentModelState(state=2, is_final=True, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=5, element_use=SolidType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'exterior'))),
        pyxb.binding.content.ContentModelTransition(next_state=5, element_use=SolidType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'interior'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=SolidType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name'))),
    ])
    , 3 : pyxb.binding.content.ContentModelState(state=3, is_final=True, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=SolidType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'identifier'))),
        pyxb.binding.content.ContentModelTransition(next_state=5, element_use=SolidType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'exterior'))),
        pyxb.binding.content.ContentModelTransition(next_state=5, element_use=SolidType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'interior'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=SolidType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name'))),
    ])
    , 4 : pyxb.binding.content.ContentModelState(state=4, is_final=True, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=SolidType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'identifier'))),
        pyxb.binding.content.ContentModelTransition(next_state=3, element_use=SolidType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'descriptionReference'))),
        pyxb.binding.content.ContentModelTransition(next_state=5, element_use=SolidType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'interior'))),
        pyxb.binding.content.ContentModelTransition(next_state=5, element_use=SolidType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'exterior'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=SolidType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name'))),
    ])
    , 5 : pyxb.binding.content.ContentModelState(state=5, is_final=True, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=5, element_use=SolidType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'interior'))),
    ])
})



SurfaceType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'patches'), SurfacePatchArrayPropertyType, scope=SurfaceType))
SurfaceType._ContentModel = pyxb.binding.content.ContentModel(state_map = {
      1 : pyxb.binding.content.ContentModelState(state=1, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=4, element_use=SurfaceType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'identifier'))),
        pyxb.binding.content.ContentModelTransition(next_state=5, element_use=SurfaceType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'descriptionReference'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=SurfaceType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'patches'))),
        pyxb.binding.content.ContentModelTransition(next_state=1, element_use=SurfaceType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'metaDataProperty'))),
        pyxb.binding.content.ContentModelTransition(next_state=3, element_use=SurfaceType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'description'))),
        pyxb.binding.content.ContentModelTransition(next_state=4, element_use=SurfaceType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name'))),
    ])
    , 2 : pyxb.binding.content.ContentModelState(state=2, is_final=True, transitions=[
    ])
    , 3 : pyxb.binding.content.ContentModelState(state=3, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=4, element_use=SurfaceType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'identifier'))),
        pyxb.binding.content.ContentModelTransition(next_state=4, element_use=SurfaceType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=SurfaceType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'patches'))),
        pyxb.binding.content.ContentModelTransition(next_state=5, element_use=SurfaceType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'descriptionReference'))),
    ])
    , 4 : pyxb.binding.content.ContentModelState(state=4, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=4, element_use=SurfaceType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=SurfaceType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'patches'))),
    ])
    , 5 : pyxb.binding.content.ContentModelState(state=5, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=4, element_use=SurfaceType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'identifier'))),
        pyxb.binding.content.ContentModelTransition(next_state=4, element_use=SurfaceType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=SurfaceType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'patches'))),
    ])
})



TimeCalendarType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'referenceFrame'), TimeCalendarEraPropertyType, scope=TimeCalendarType))
TimeCalendarType._ContentModel = pyxb.binding.content.ContentModel(state_map = {
      1 : pyxb.binding.content.ContentModelState(state=1, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=3, element_use=TimeCalendarType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'descriptionReference'))),
        pyxb.binding.content.ContentModelTransition(next_state=1, element_use=TimeCalendarType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'metaDataProperty'))),
        pyxb.binding.content.ContentModelTransition(next_state=5, element_use=TimeCalendarType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'description'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=TimeCalendarType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'identifier'))),
    ])
    , 2 : pyxb.binding.content.ContentModelState(state=2, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=6, element_use=TimeCalendarType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'domainOfValidity'))),
        pyxb.binding.content.ContentModelTransition(next_state=7, element_use=TimeCalendarType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'remarks'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=TimeCalendarType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name'))),
    ])
    , 3 : pyxb.binding.content.ContentModelState(state=3, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=TimeCalendarType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'identifier'))),
    ])
    , 4 : pyxb.binding.content.ContentModelState(state=4, is_final=True, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=4, element_use=TimeCalendarType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'referenceFrame'))),
    ])
    , 5 : pyxb.binding.content.ContentModelState(state=5, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=3, element_use=TimeCalendarType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'descriptionReference'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=TimeCalendarType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'identifier'))),
    ])
    , 6 : pyxb.binding.content.ContentModelState(state=6, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=4, element_use=TimeCalendarType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'referenceFrame'))),
    ])
    , 7 : pyxb.binding.content.ContentModelState(state=7, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=6, element_use=TimeCalendarType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'domainOfValidity'))),
    ])
})



TimeClockType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'referenceTime'), pyxb.binding.datatypes.time, scope=TimeClockType))

TimeClockType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'dateBasis'), TimeCalendarPropertyType, scope=TimeClockType))

TimeClockType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'referenceEvent'), StringOrRefType, scope=TimeClockType))

TimeClockType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'utcReference'), pyxb.binding.datatypes.time, scope=TimeClockType))
TimeClockType._ContentModel = pyxb.binding.content.ContentModel(state_map = {
      1 : pyxb.binding.content.ContentModelState(state=1, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=4, element_use=TimeClockType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'descriptionReference'))),
        pyxb.binding.content.ContentModelTransition(next_state=6, element_use=TimeClockType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'description'))),
        pyxb.binding.content.ContentModelTransition(next_state=1, element_use=TimeClockType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'metaDataProperty'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=TimeClockType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'identifier'))),
    ])
    , 2 : pyxb.binding.content.ContentModelState(state=2, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=8, element_use=TimeClockType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'domainOfValidity'))),
        pyxb.binding.content.ContentModelTransition(next_state=9, element_use=TimeClockType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'remarks'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=TimeClockType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name'))),
    ])
    , 3 : pyxb.binding.content.ContentModelState(state=3, is_final=True, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=3, element_use=TimeClockType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'dateBasis'))),
    ])
    , 4 : pyxb.binding.content.ContentModelState(state=4, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=TimeClockType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'identifier'))),
    ])
    , 5 : pyxb.binding.content.ContentModelState(state=5, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=7, element_use=TimeClockType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'referenceTime'))),
    ])
    , 6 : pyxb.binding.content.ContentModelState(state=6, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=4, element_use=TimeClockType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'descriptionReference'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=TimeClockType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'identifier'))),
    ])
    , 7 : pyxb.binding.content.ContentModelState(state=7, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=3, element_use=TimeClockType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'utcReference'))),
    ])
    , 8 : pyxb.binding.content.ContentModelState(state=8, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=5, element_use=TimeClockType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'referenceEvent'))),
    ])
    , 9 : pyxb.binding.content.ContentModelState(state=9, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=8, element_use=TimeClockType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'domainOfValidity'))),
    ])
})



TimeCoordinateSystemType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'originPosition'), TimePositionType, scope=TimeCoordinateSystemType))

TimeCoordinateSystemType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'interval'), TimeIntervalLengthType, scope=TimeCoordinateSystemType))

TimeCoordinateSystemType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'origin'), TimeInstantPropertyType, scope=TimeCoordinateSystemType))
TimeCoordinateSystemType._ContentModel = pyxb.binding.content.ContentModel(state_map = {
      1 : pyxb.binding.content.ContentModelState(state=1, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=TimeCoordinateSystemType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'descriptionReference'))),
        pyxb.binding.content.ContentModelTransition(next_state=1, element_use=TimeCoordinateSystemType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'metaDataProperty'))),
        pyxb.binding.content.ContentModelTransition(next_state=3, element_use=TimeCoordinateSystemType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'description'))),
        pyxb.binding.content.ContentModelTransition(next_state=8, element_use=TimeCoordinateSystemType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'identifier'))),
    ])
    , 2 : pyxb.binding.content.ContentModelState(state=2, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=8, element_use=TimeCoordinateSystemType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'identifier'))),
    ])
    , 3 : pyxb.binding.content.ContentModelState(state=3, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=TimeCoordinateSystemType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'descriptionReference'))),
        pyxb.binding.content.ContentModelTransition(next_state=8, element_use=TimeCoordinateSystemType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'identifier'))),
    ])
    , 4 : pyxb.binding.content.ContentModelState(state=4, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=5, element_use=TimeCoordinateSystemType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'interval'))),
    ])
    , 5 : pyxb.binding.content.ContentModelState(state=5, is_final=True, transitions=[
    ])
    , 6 : pyxb.binding.content.ContentModelState(state=6, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=4, element_use=TimeCoordinateSystemType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'originPosition'))),
        pyxb.binding.content.ContentModelTransition(next_state=4, element_use=TimeCoordinateSystemType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'origin'))),
    ])
    , 7 : pyxb.binding.content.ContentModelState(state=7, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=6, element_use=TimeCoordinateSystemType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'domainOfValidity'))),
    ])
    , 8 : pyxb.binding.content.ContentModelState(state=8, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=6, element_use=TimeCoordinateSystemType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'domainOfValidity'))),
        pyxb.binding.content.ContentModelTransition(next_state=7, element_use=TimeCoordinateSystemType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'remarks'))),
        pyxb.binding.content.ContentModelTransition(next_state=8, element_use=TimeCoordinateSystemType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name'))),
    ])
})



TimeEdgeType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'start'), TimeNodePropertyType, scope=TimeEdgeType))

TimeEdgeType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'end'), TimeNodePropertyType, scope=TimeEdgeType))

TimeEdgeType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'extent'), TimePeriodPropertyType, scope=TimeEdgeType))
TimeEdgeType._ContentModel = pyxb.binding.content.ContentModel(state_map = {
      1 : pyxb.binding.content.ContentModelState(state=1, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=TimeEdgeType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'identifier'))),
        pyxb.binding.content.ContentModelTransition(next_state=8, element_use=TimeEdgeType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'relatedTime'))),
        pyxb.binding.content.ContentModelTransition(next_state=1, element_use=TimeEdgeType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'metaDataProperty'))),
        pyxb.binding.content.ContentModelTransition(next_state=5, element_use=TimeEdgeType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'complex'))),
        pyxb.binding.content.ContentModelTransition(next_state=7, element_use=TimeEdgeType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'start'))),
        pyxb.binding.content.ContentModelTransition(next_state=3, element_use=TimeEdgeType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'descriptionReference'))),
        pyxb.binding.content.ContentModelTransition(next_state=9, element_use=TimeEdgeType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'description'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=TimeEdgeType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name'))),
    ])
    , 2 : pyxb.binding.content.ContentModelState(state=2, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=5, element_use=TimeEdgeType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'complex'))),
        pyxb.binding.content.ContentModelTransition(next_state=7, element_use=TimeEdgeType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'start'))),
        pyxb.binding.content.ContentModelTransition(next_state=8, element_use=TimeEdgeType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'relatedTime'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=TimeEdgeType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name'))),
    ])
    , 3 : pyxb.binding.content.ContentModelState(state=3, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=TimeEdgeType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'identifier'))),
        pyxb.binding.content.ContentModelTransition(next_state=5, element_use=TimeEdgeType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'complex'))),
        pyxb.binding.content.ContentModelTransition(next_state=8, element_use=TimeEdgeType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'relatedTime'))),
        pyxb.binding.content.ContentModelTransition(next_state=7, element_use=TimeEdgeType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'start'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=TimeEdgeType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name'))),
    ])
    , 4 : pyxb.binding.content.ContentModelState(state=4, is_final=True, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=6, element_use=TimeEdgeType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'extent'))),
    ])
    , 5 : pyxb.binding.content.ContentModelState(state=5, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=7, element_use=TimeEdgeType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'start'))),
    ])
    , 6 : pyxb.binding.content.ContentModelState(state=6, is_final=True, transitions=[
    ])
    , 7 : pyxb.binding.content.ContentModelState(state=7, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=4, element_use=TimeEdgeType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'end'))),
    ])
    , 8 : pyxb.binding.content.ContentModelState(state=8, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=5, element_use=TimeEdgeType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'complex'))),
        pyxb.binding.content.ContentModelTransition(next_state=7, element_use=TimeEdgeType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'start'))),
        pyxb.binding.content.ContentModelTransition(next_state=8, element_use=TimeEdgeType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'relatedTime'))),
    ])
    , 9 : pyxb.binding.content.ContentModelState(state=9, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=TimeEdgeType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'identifier'))),
        pyxb.binding.content.ContentModelTransition(next_state=5, element_use=TimeEdgeType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'complex'))),
        pyxb.binding.content.ContentModelTransition(next_state=8, element_use=TimeEdgeType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'relatedTime'))),
        pyxb.binding.content.ContentModelTransition(next_state=7, element_use=TimeEdgeType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'start'))),
        pyxb.binding.content.ContentModelTransition(next_state=3, element_use=TimeEdgeType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'descriptionReference'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=TimeEdgeType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name'))),
    ])
})



TimeInstantType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'timePosition'), TimePositionType, scope=TimeInstantType))
TimeInstantType._ContentModel = pyxb.binding.content.ContentModel(state_map = {
      1 : pyxb.binding.content.ContentModelState(state=1, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=TimeInstantType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'identifier'))),
        pyxb.binding.content.ContentModelTransition(next_state=5, element_use=TimeInstantType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'relatedTime'))),
        pyxb.binding.content.ContentModelTransition(next_state=4, element_use=TimeInstantType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'descriptionReference'))),
        pyxb.binding.content.ContentModelTransition(next_state=3, element_use=TimeInstantType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'timePosition'))),
        pyxb.binding.content.ContentModelTransition(next_state=6, element_use=TimeInstantType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'description'))),
        pyxb.binding.content.ContentModelTransition(next_state=1, element_use=TimeInstantType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'metaDataProperty'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=TimeInstantType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name'))),
    ])
    , 2 : pyxb.binding.content.ContentModelState(state=2, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=3, element_use=TimeInstantType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'timePosition'))),
        pyxb.binding.content.ContentModelTransition(next_state=5, element_use=TimeInstantType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'relatedTime'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=TimeInstantType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name'))),
    ])
    , 3 : pyxb.binding.content.ContentModelState(state=3, is_final=True, transitions=[
    ])
    , 4 : pyxb.binding.content.ContentModelState(state=4, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=TimeInstantType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'identifier'))),
        pyxb.binding.content.ContentModelTransition(next_state=3, element_use=TimeInstantType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'timePosition'))),
        pyxb.binding.content.ContentModelTransition(next_state=5, element_use=TimeInstantType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'relatedTime'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=TimeInstantType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name'))),
    ])
    , 5 : pyxb.binding.content.ContentModelState(state=5, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=3, element_use=TimeInstantType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'timePosition'))),
        pyxb.binding.content.ContentModelTransition(next_state=5, element_use=TimeInstantType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'relatedTime'))),
    ])
    , 6 : pyxb.binding.content.ContentModelState(state=6, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=TimeInstantType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'identifier'))),
        pyxb.binding.content.ContentModelTransition(next_state=3, element_use=TimeInstantType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'timePosition'))),
        pyxb.binding.content.ContentModelTransition(next_state=4, element_use=TimeInstantType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'descriptionReference'))),
        pyxb.binding.content.ContentModelTransition(next_state=5, element_use=TimeInstantType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'relatedTime'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=TimeInstantType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name'))),
    ])
})



TimeNodeType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'nextEdge'), TimeEdgePropertyType, scope=TimeNodeType))

TimeNodeType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'previousEdge'), TimeEdgePropertyType, scope=TimeNodeType))

TimeNodeType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'position'), TimeInstantPropertyType, scope=TimeNodeType))
TimeNodeType._ContentModel = pyxb.binding.content.ContentModel(state_map = {
      1 : pyxb.binding.content.ContentModelState(state=1, is_final=True, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=TimeNodeType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'identifier'))),
        pyxb.binding.content.ContentModelTransition(next_state=5, element_use=TimeNodeType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'complex'))),
        pyxb.binding.content.ContentModelTransition(next_state=6, element_use=TimeNodeType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'descriptionReference'))),
        pyxb.binding.content.ContentModelTransition(next_state=1, element_use=TimeNodeType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'metaDataProperty'))),
        pyxb.binding.content.ContentModelTransition(next_state=5, element_use=TimeNodeType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'previousEdge'))),
        pyxb.binding.content.ContentModelTransition(next_state=4, element_use=TimeNodeType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'relatedTime'))),
        pyxb.binding.content.ContentModelTransition(next_state=5, element_use=TimeNodeType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'nextEdge'))),
        pyxb.binding.content.ContentModelTransition(next_state=7, element_use=TimeNodeType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'position'))),
        pyxb.binding.content.ContentModelTransition(next_state=3, element_use=TimeNodeType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'description'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=TimeNodeType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name'))),
    ])
    , 2 : pyxb.binding.content.ContentModelState(state=2, is_final=True, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=4, element_use=TimeNodeType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'relatedTime'))),
        pyxb.binding.content.ContentModelTransition(next_state=5, element_use=TimeNodeType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'previousEdge'))),
        pyxb.binding.content.ContentModelTransition(next_state=5, element_use=TimeNodeType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'complex'))),
        pyxb.binding.content.ContentModelTransition(next_state=5, element_use=TimeNodeType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'nextEdge'))),
        pyxb.binding.content.ContentModelTransition(next_state=7, element_use=TimeNodeType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'position'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=TimeNodeType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name'))),
    ])
    , 3 : pyxb.binding.content.ContentModelState(state=3, is_final=True, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=TimeNodeType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'identifier'))),
        pyxb.binding.content.ContentModelTransition(next_state=5, element_use=TimeNodeType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'complex'))),
        pyxb.binding.content.ContentModelTransition(next_state=6, element_use=TimeNodeType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'descriptionReference'))),
        pyxb.binding.content.ContentModelTransition(next_state=5, element_use=TimeNodeType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'previousEdge'))),
        pyxb.binding.content.ContentModelTransition(next_state=4, element_use=TimeNodeType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'relatedTime'))),
        pyxb.binding.content.ContentModelTransition(next_state=5, element_use=TimeNodeType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'nextEdge'))),
        pyxb.binding.content.ContentModelTransition(next_state=7, element_use=TimeNodeType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'position'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=TimeNodeType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name'))),
    ])
    , 4 : pyxb.binding.content.ContentModelState(state=4, is_final=True, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=4, element_use=TimeNodeType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'relatedTime'))),
        pyxb.binding.content.ContentModelTransition(next_state=5, element_use=TimeNodeType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'previousEdge'))),
        pyxb.binding.content.ContentModelTransition(next_state=5, element_use=TimeNodeType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'complex'))),
        pyxb.binding.content.ContentModelTransition(next_state=5, element_use=TimeNodeType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'nextEdge'))),
        pyxb.binding.content.ContentModelTransition(next_state=7, element_use=TimeNodeType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'position'))),
    ])
    , 5 : pyxb.binding.content.ContentModelState(state=5, is_final=True, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=5, element_use=TimeNodeType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'previousEdge'))),
        pyxb.binding.content.ContentModelTransition(next_state=5, element_use=TimeNodeType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'nextEdge'))),
        pyxb.binding.content.ContentModelTransition(next_state=7, element_use=TimeNodeType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'position'))),
    ])
    , 6 : pyxb.binding.content.ContentModelState(state=6, is_final=True, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=TimeNodeType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'identifier'))),
        pyxb.binding.content.ContentModelTransition(next_state=5, element_use=TimeNodeType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'complex'))),
        pyxb.binding.content.ContentModelTransition(next_state=5, element_use=TimeNodeType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'previousEdge'))),
        pyxb.binding.content.ContentModelTransition(next_state=4, element_use=TimeNodeType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'relatedTime'))),
        pyxb.binding.content.ContentModelTransition(next_state=5, element_use=TimeNodeType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'nextEdge'))),
        pyxb.binding.content.ContentModelTransition(next_state=7, element_use=TimeNodeType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'position'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=TimeNodeType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name'))),
    ])
    , 7 : pyxb.binding.content.ContentModelState(state=7, is_final=True, transitions=[
    ])
})



TimeOrdinalReferenceSystemType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'component'), TimeOrdinalEraPropertyType, scope=TimeOrdinalReferenceSystemType))
TimeOrdinalReferenceSystemType._ContentModel = pyxb.binding.content.ContentModel(state_map = {
      1 : pyxb.binding.content.ContentModelState(state=1, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=TimeOrdinalReferenceSystemType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'descriptionReference'))),
        pyxb.binding.content.ContentModelTransition(next_state=1, element_use=TimeOrdinalReferenceSystemType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'metaDataProperty'))),
        pyxb.binding.content.ContentModelTransition(next_state=4, element_use=TimeOrdinalReferenceSystemType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'description'))),
        pyxb.binding.content.ContentModelTransition(next_state=7, element_use=TimeOrdinalReferenceSystemType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'identifier'))),
    ])
    , 2 : pyxb.binding.content.ContentModelState(state=2, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=7, element_use=TimeOrdinalReferenceSystemType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'identifier'))),
    ])
    , 3 : pyxb.binding.content.ContentModelState(state=3, is_final=True, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=3, element_use=TimeOrdinalReferenceSystemType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'component'))),
    ])
    , 4 : pyxb.binding.content.ContentModelState(state=4, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=TimeOrdinalReferenceSystemType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'descriptionReference'))),
        pyxb.binding.content.ContentModelTransition(next_state=7, element_use=TimeOrdinalReferenceSystemType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'identifier'))),
    ])
    , 5 : pyxb.binding.content.ContentModelState(state=5, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=3, element_use=TimeOrdinalReferenceSystemType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'component'))),
    ])
    , 6 : pyxb.binding.content.ContentModelState(state=6, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=5, element_use=TimeOrdinalReferenceSystemType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'domainOfValidity'))),
    ])
    , 7 : pyxb.binding.content.ContentModelState(state=7, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=5, element_use=TimeOrdinalReferenceSystemType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'domainOfValidity'))),
        pyxb.binding.content.ContentModelTransition(next_state=6, element_use=TimeOrdinalReferenceSystemType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'remarks'))),
        pyxb.binding.content.ContentModelTransition(next_state=7, element_use=TimeOrdinalReferenceSystemType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name'))),
    ])
})



TimePeriodType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'endPosition'), TimePositionType, scope=TimePeriodType))

TimePeriodType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'end'), TimeInstantPropertyType, scope=TimePeriodType))

TimePeriodType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'beginPosition'), TimePositionType, scope=TimePeriodType))

TimePeriodType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'begin'), TimeInstantPropertyType, scope=TimePeriodType))

TimePeriodType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'timeInterval'), TimeIntervalLengthType, scope=TimePeriodType))

TimePeriodType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'duration'), pyxb.binding.datatypes.duration, scope=TimePeriodType))
TimePeriodType._ContentModel = pyxb.binding.content.ContentModel(state_map = {
      1 : pyxb.binding.content.ContentModelState(state=1, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=TimePeriodType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'begin'))),
        pyxb.binding.content.ContentModelTransition(next_state=1, element_use=TimePeriodType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'metaDataProperty'))),
        pyxb.binding.content.ContentModelTransition(next_state=3, element_use=TimePeriodType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'relatedTime'))),
        pyxb.binding.content.ContentModelTransition(next_state=8, element_use=TimePeriodType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'identifier'))),
        pyxb.binding.content.ContentModelTransition(next_state=8, element_use=TimePeriodType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name'))),
        pyxb.binding.content.ContentModelTransition(next_state=5, element_use=TimePeriodType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'description'))),
        pyxb.binding.content.ContentModelTransition(next_state=6, element_use=TimePeriodType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'descriptionReference'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=TimePeriodType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'beginPosition'))),
    ])
    , 2 : pyxb.binding.content.ContentModelState(state=2, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=4, element_use=TimePeriodType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'endPosition'))),
        pyxb.binding.content.ContentModelTransition(next_state=4, element_use=TimePeriodType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'end'))),
    ])
    , 3 : pyxb.binding.content.ContentModelState(state=3, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=TimePeriodType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'begin'))),
        pyxb.binding.content.ContentModelTransition(next_state=3, element_use=TimePeriodType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'relatedTime'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=TimePeriodType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'beginPosition'))),
    ])
    , 4 : pyxb.binding.content.ContentModelState(state=4, is_final=True, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=7, element_use=TimePeriodType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'duration'))),
        pyxb.binding.content.ContentModelTransition(next_state=7, element_use=TimePeriodType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'timeInterval'))),
    ])
    , 5 : pyxb.binding.content.ContentModelState(state=5, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=TimePeriodType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'begin'))),
        pyxb.binding.content.ContentModelTransition(next_state=8, element_use=TimePeriodType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name'))),
        pyxb.binding.content.ContentModelTransition(next_state=3, element_use=TimePeriodType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'relatedTime'))),
        pyxb.binding.content.ContentModelTransition(next_state=8, element_use=TimePeriodType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'identifier'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=TimePeriodType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'beginPosition'))),
        pyxb.binding.content.ContentModelTransition(next_state=6, element_use=TimePeriodType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'descriptionReference'))),
    ])
    , 6 : pyxb.binding.content.ContentModelState(state=6, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=TimePeriodType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'begin'))),
        pyxb.binding.content.ContentModelTransition(next_state=8, element_use=TimePeriodType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name'))),
        pyxb.binding.content.ContentModelTransition(next_state=8, element_use=TimePeriodType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'identifier'))),
        pyxb.binding.content.ContentModelTransition(next_state=3, element_use=TimePeriodType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'relatedTime'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=TimePeriodType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'beginPosition'))),
    ])
    , 7 : pyxb.binding.content.ContentModelState(state=7, is_final=True, transitions=[
    ])
    , 8 : pyxb.binding.content.ContentModelState(state=8, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=TimePeriodType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'begin'))),
        pyxb.binding.content.ContentModelTransition(next_state=8, element_use=TimePeriodType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name'))),
        pyxb.binding.content.ContentModelTransition(next_state=3, element_use=TimePeriodType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'relatedTime'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=TimePeriodType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'beginPosition'))),
    ])
})


AbstractGeneralConversionType._ContentModel = pyxb.binding.content.ContentModel(state_map = {
      1 : pyxb.binding.content.ContentModelState(state=1, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=1, element_use=AbstractGeneralConversionType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'metaDataProperty'))),
        pyxb.binding.content.ContentModelTransition(next_state=3, element_use=AbstractGeneralConversionType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'description'))),
        pyxb.binding.content.ContentModelTransition(next_state=5, element_use=AbstractGeneralConversionType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'descriptionReference'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=AbstractGeneralConversionType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'identifier'))),
    ])
    , 2 : pyxb.binding.content.ContentModelState(state=2, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=7, element_use=AbstractGeneralConversionType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'scope'))),
        pyxb.binding.content.ContentModelTransition(next_state=8, element_use=AbstractGeneralConversionType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'domainOfValidity'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=AbstractGeneralConversionType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name'))),
        pyxb.binding.content.ContentModelTransition(next_state=4, element_use=AbstractGeneralConversionType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'remarks'))),
    ])
    , 3 : pyxb.binding.content.ContentModelState(state=3, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=5, element_use=AbstractGeneralConversionType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'descriptionReference'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=AbstractGeneralConversionType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'identifier'))),
    ])
    , 4 : pyxb.binding.content.ContentModelState(state=4, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=7, element_use=AbstractGeneralConversionType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'scope'))),
        pyxb.binding.content.ContentModelTransition(next_state=8, element_use=AbstractGeneralConversionType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'domainOfValidity'))),
    ])
    , 5 : pyxb.binding.content.ContentModelState(state=5, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=AbstractGeneralConversionType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'identifier'))),
    ])
    , 6 : pyxb.binding.content.ContentModelState(state=6, is_final=True, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=6, element_use=AbstractGeneralConversionType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'coordinateOperationAccuracy'))),
    ])
    , 7 : pyxb.binding.content.ContentModelState(state=7, is_final=True, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=7, element_use=AbstractGeneralConversionType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'scope'))),
        pyxb.binding.content.ContentModelTransition(next_state=6, element_use=AbstractGeneralConversionType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'coordinateOperationAccuracy'))),
    ])
    , 8 : pyxb.binding.content.ContentModelState(state=8, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=7, element_use=AbstractGeneralConversionType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'scope'))),
    ])
})



AbstractGeneralDerivedCRSType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'conversion'), GeneralConversionPropertyType, scope=AbstractGeneralDerivedCRSType))
AbstractGeneralDerivedCRSType._ContentModel = pyxb.binding.content.ContentModel(state_map = {
      1 : pyxb.binding.content.ContentModelState(state=1, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=4, element_use=AbstractGeneralDerivedCRSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'descriptionReference'))),
        pyxb.binding.content.ContentModelTransition(next_state=1, element_use=AbstractGeneralDerivedCRSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'metaDataProperty'))),
        pyxb.binding.content.ContentModelTransition(next_state=6, element_use=AbstractGeneralDerivedCRSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'description'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=AbstractGeneralDerivedCRSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'identifier'))),
    ])
    , 2 : pyxb.binding.content.ContentModelState(state=2, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=7, element_use=AbstractGeneralDerivedCRSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'scope'))),
        pyxb.binding.content.ContentModelTransition(next_state=3, element_use=AbstractGeneralDerivedCRSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'remarks'))),
        pyxb.binding.content.ContentModelTransition(next_state=3, element_use=AbstractGeneralDerivedCRSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'domainOfValidity'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=AbstractGeneralDerivedCRSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name'))),
    ])
    , 3 : pyxb.binding.content.ContentModelState(state=3, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=7, element_use=AbstractGeneralDerivedCRSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'scope'))),
        pyxb.binding.content.ContentModelTransition(next_state=3, element_use=AbstractGeneralDerivedCRSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'domainOfValidity'))),
    ])
    , 4 : pyxb.binding.content.ContentModelState(state=4, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=AbstractGeneralDerivedCRSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'identifier'))),
    ])
    , 5 : pyxb.binding.content.ContentModelState(state=5, is_final=True, transitions=[
    ])
    , 6 : pyxb.binding.content.ContentModelState(state=6, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=4, element_use=AbstractGeneralDerivedCRSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'descriptionReference'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=AbstractGeneralDerivedCRSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'identifier'))),
    ])
    , 7 : pyxb.binding.content.ContentModelState(state=7, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=7, element_use=AbstractGeneralDerivedCRSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'scope'))),
        pyxb.binding.content.ContentModelTransition(next_state=5, element_use=AbstractGeneralDerivedCRSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'conversion'))),
        pyxb.binding.content.ContentModelTransition(next_state=3, element_use=AbstractGeneralDerivedCRSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'domainOfValidity'))),
    ])
})


AbstractGeneralTransformationType._ContentModel = pyxb.binding.content.ContentModel(state_map = {
      1 : pyxb.binding.content.ContentModelState(state=1, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=AbstractGeneralTransformationType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'descriptionReference'))),
        pyxb.binding.content.ContentModelTransition(next_state=10, element_use=AbstractGeneralTransformationType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'identifier'))),
        pyxb.binding.content.ContentModelTransition(next_state=1, element_use=AbstractGeneralTransformationType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'metaDataProperty'))),
        pyxb.binding.content.ContentModelTransition(next_state=4, element_use=AbstractGeneralTransformationType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'description'))),
    ])
    , 2 : pyxb.binding.content.ContentModelState(state=2, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=10, element_use=AbstractGeneralTransformationType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'identifier'))),
    ])
    , 3 : pyxb.binding.content.ContentModelState(state=3, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=9, element_use=AbstractGeneralTransformationType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'scope'))),
    ])
    , 4 : pyxb.binding.content.ContentModelState(state=4, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=AbstractGeneralTransformationType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'descriptionReference'))),
        pyxb.binding.content.ContentModelTransition(next_state=10, element_use=AbstractGeneralTransformationType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'identifier'))),
    ])
    , 5 : pyxb.binding.content.ContentModelState(state=5, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=8, element_use=AbstractGeneralTransformationType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'targetCRS'))),
    ])
    , 6 : pyxb.binding.content.ContentModelState(state=6, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=5, element_use=AbstractGeneralTransformationType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'sourceCRS'))),
        pyxb.binding.content.ContentModelTransition(next_state=6, element_use=AbstractGeneralTransformationType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'coordinateOperationAccuracy'))),
    ])
    , 7 : pyxb.binding.content.ContentModelState(state=7, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=9, element_use=AbstractGeneralTransformationType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'scope'))),
        pyxb.binding.content.ContentModelTransition(next_state=3, element_use=AbstractGeneralTransformationType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'domainOfValidity'))),
    ])
    , 8 : pyxb.binding.content.ContentModelState(state=8, is_final=True, transitions=[
    ])
    , 9 : pyxb.binding.content.ContentModelState(state=9, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=9, element_use=AbstractGeneralTransformationType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'scope'))),
        pyxb.binding.content.ContentModelTransition(next_state=6, element_use=AbstractGeneralTransformationType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'operationVersion'))),
    ])
    , 10 : pyxb.binding.content.ContentModelState(state=10, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=10, element_use=AbstractGeneralTransformationType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name'))),
        pyxb.binding.content.ContentModelTransition(next_state=7, element_use=AbstractGeneralTransformationType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'remarks'))),
        pyxb.binding.content.ContentModelTransition(next_state=3, element_use=AbstractGeneralTransformationType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'domainOfValidity'))),
        pyxb.binding.content.ContentModelTransition(next_state=9, element_use=AbstractGeneralTransformationType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'scope'))),
    ])
})


AffineCSType._ContentModel = pyxb.binding.content.ContentModel(state_map = {
      1 : pyxb.binding.content.ContentModelState(state=1, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=AffineCSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'descriptionReference'))),
        pyxb.binding.content.ContentModelTransition(next_state=1, element_use=AffineCSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'metaDataProperty'))),
        pyxb.binding.content.ContentModelTransition(next_state=3, element_use=AffineCSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'description'))),
        pyxb.binding.content.ContentModelTransition(next_state=6, element_use=AffineCSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'identifier'))),
    ])
    , 2 : pyxb.binding.content.ContentModelState(state=2, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=6, element_use=AffineCSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'identifier'))),
    ])
    , 3 : pyxb.binding.content.ContentModelState(state=3, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=AffineCSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'descriptionReference'))),
        pyxb.binding.content.ContentModelTransition(next_state=6, element_use=AffineCSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'identifier'))),
    ])
    , 4 : pyxb.binding.content.ContentModelState(state=4, is_final=True, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=4, element_use=AffineCSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'axis'))),
    ])
    , 5 : pyxb.binding.content.ContentModelState(state=5, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=4, element_use=AffineCSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'axis'))),
    ])
    , 6 : pyxb.binding.content.ContentModelState(state=6, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=4, element_use=AffineCSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'axis'))),
        pyxb.binding.content.ContentModelTransition(next_state=5, element_use=AffineCSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'remarks'))),
        pyxb.binding.content.ContentModelTransition(next_state=6, element_use=AffineCSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name'))),
    ])
})


CartesianCSType._ContentModel = pyxb.binding.content.ContentModel(state_map = {
      1 : pyxb.binding.content.ContentModelState(state=1, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=CartesianCSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'descriptionReference'))),
        pyxb.binding.content.ContentModelTransition(next_state=1, element_use=CartesianCSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'metaDataProperty'))),
        pyxb.binding.content.ContentModelTransition(next_state=3, element_use=CartesianCSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'description'))),
        pyxb.binding.content.ContentModelTransition(next_state=6, element_use=CartesianCSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'identifier'))),
    ])
    , 2 : pyxb.binding.content.ContentModelState(state=2, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=6, element_use=CartesianCSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'identifier'))),
    ])
    , 3 : pyxb.binding.content.ContentModelState(state=3, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=CartesianCSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'descriptionReference'))),
        pyxb.binding.content.ContentModelTransition(next_state=6, element_use=CartesianCSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'identifier'))),
    ])
    , 4 : pyxb.binding.content.ContentModelState(state=4, is_final=True, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=4, element_use=CartesianCSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'axis'))),
    ])
    , 5 : pyxb.binding.content.ContentModelState(state=5, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=4, element_use=CartesianCSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'axis'))),
    ])
    , 6 : pyxb.binding.content.ContentModelState(state=6, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=4, element_use=CartesianCSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'axis'))),
        pyxb.binding.content.ContentModelTransition(next_state=5, element_use=CartesianCSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'remarks'))),
        pyxb.binding.content.ContentModelTransition(next_state=6, element_use=CartesianCSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name'))),
    ])
})



CompoundCRSType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'componentReferenceSystem'), SingleCRSPropertyType, scope=CompoundCRSType))
CompoundCRSType._ContentModel = pyxb.binding.content.ContentModel(state_map = {
      1 : pyxb.binding.content.ContentModelState(state=1, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=3, element_use=CompoundCRSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'description'))),
        pyxb.binding.content.ContentModelTransition(next_state=4, element_use=CompoundCRSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'descriptionReference'))),
        pyxb.binding.content.ContentModelTransition(next_state=1, element_use=CompoundCRSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'metaDataProperty'))),
        pyxb.binding.content.ContentModelTransition(next_state=8, element_use=CompoundCRSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'identifier'))),
    ])
    , 2 : pyxb.binding.content.ContentModelState(state=2, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=7, element_use=CompoundCRSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'scope'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=CompoundCRSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'domainOfValidity'))),
    ])
    , 3 : pyxb.binding.content.ContentModelState(state=3, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=4, element_use=CompoundCRSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'descriptionReference'))),
        pyxb.binding.content.ContentModelTransition(next_state=8, element_use=CompoundCRSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'identifier'))),
    ])
    , 4 : pyxb.binding.content.ContentModelState(state=4, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=8, element_use=CompoundCRSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'identifier'))),
    ])
    , 5 : pyxb.binding.content.ContentModelState(state=5, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=6, element_use=CompoundCRSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'componentReferenceSystem'))),
    ])
    , 6 : pyxb.binding.content.ContentModelState(state=6, is_final=True, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=6, element_use=CompoundCRSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'componentReferenceSystem'))),
    ])
    , 7 : pyxb.binding.content.ContentModelState(state=7, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=5, element_use=CompoundCRSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'componentReferenceSystem'))),
        pyxb.binding.content.ContentModelTransition(next_state=7, element_use=CompoundCRSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'scope'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=CompoundCRSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'domainOfValidity'))),
    ])
    , 8 : pyxb.binding.content.ContentModelState(state=8, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=7, element_use=CompoundCRSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'scope'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=CompoundCRSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'remarks'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=CompoundCRSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'domainOfValidity'))),
        pyxb.binding.content.ContentModelTransition(next_state=8, element_use=CompoundCRSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name'))),
    ])
})



ConcatenatedOperationType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'coordOperation'), CoordinateOperationPropertyType, scope=ConcatenatedOperationType))
ConcatenatedOperationType._ContentModel = pyxb.binding.content.ContentModel(state_map = {
      1 : pyxb.binding.content.ContentModelState(state=1, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=1, element_use=ConcatenatedOperationType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'metaDataProperty'))),
        pyxb.binding.content.ContentModelTransition(next_state=4, element_use=ConcatenatedOperationType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'descriptionReference'))),
        pyxb.binding.content.ContentModelTransition(next_state=6, element_use=ConcatenatedOperationType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'description'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=ConcatenatedOperationType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'identifier'))),
    ])
    , 2 : pyxb.binding.content.ContentModelState(state=2, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=7, element_use=ConcatenatedOperationType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'domainOfValidity'))),
        pyxb.binding.content.ContentModelTransition(next_state=8, element_use=ConcatenatedOperationType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'scope'))),
        pyxb.binding.content.ContentModelTransition(next_state=10, element_use=ConcatenatedOperationType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'remarks'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=ConcatenatedOperationType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name'))),
    ])
    , 3 : pyxb.binding.content.ContentModelState(state=3, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=5, element_use=ConcatenatedOperationType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'coordOperation'))),
        pyxb.binding.content.ContentModelTransition(next_state=3, element_use=ConcatenatedOperationType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'coordinateOperationAccuracy'))),
        pyxb.binding.content.ContentModelTransition(next_state=9, element_use=ConcatenatedOperationType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'sourceCRS'))),
        pyxb.binding.content.ContentModelTransition(next_state=11, element_use=ConcatenatedOperationType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'targetCRS'))),
    ])
    , 4 : pyxb.binding.content.ContentModelState(state=4, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=ConcatenatedOperationType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'identifier'))),
    ])
    , 5 : pyxb.binding.content.ContentModelState(state=5, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=12, element_use=ConcatenatedOperationType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'coordOperation'))),
    ])
    , 6 : pyxb.binding.content.ContentModelState(state=6, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=4, element_use=ConcatenatedOperationType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'descriptionReference'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=ConcatenatedOperationType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'identifier'))),
    ])
    , 7 : pyxb.binding.content.ContentModelState(state=7, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=8, element_use=ConcatenatedOperationType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'scope'))),
    ])
    , 8 : pyxb.binding.content.ContentModelState(state=8, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=3, element_use=ConcatenatedOperationType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'operationVersion'))),
        pyxb.binding.content.ContentModelTransition(next_state=5, element_use=ConcatenatedOperationType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'coordOperation'))),
        pyxb.binding.content.ContentModelTransition(next_state=8, element_use=ConcatenatedOperationType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'scope'))),
        pyxb.binding.content.ContentModelTransition(next_state=3, element_use=ConcatenatedOperationType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'coordinateOperationAccuracy'))),
        pyxb.binding.content.ContentModelTransition(next_state=9, element_use=ConcatenatedOperationType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'sourceCRS'))),
        pyxb.binding.content.ContentModelTransition(next_state=11, element_use=ConcatenatedOperationType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'targetCRS'))),
    ])
    , 9 : pyxb.binding.content.ContentModelState(state=9, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=5, element_use=ConcatenatedOperationType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'coordOperation'))),
        pyxb.binding.content.ContentModelTransition(next_state=11, element_use=ConcatenatedOperationType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'targetCRS'))),
    ])
    , 10 : pyxb.binding.content.ContentModelState(state=10, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=7, element_use=ConcatenatedOperationType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'domainOfValidity'))),
        pyxb.binding.content.ContentModelTransition(next_state=8, element_use=ConcatenatedOperationType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'scope'))),
    ])
    , 11 : pyxb.binding.content.ContentModelState(state=11, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=5, element_use=ConcatenatedOperationType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'coordOperation'))),
    ])
    , 12 : pyxb.binding.content.ContentModelState(state=12, is_final=True, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=12, element_use=ConcatenatedOperationType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'coordOperation'))),
    ])
})


CylindricalCSType._ContentModel = pyxb.binding.content.ContentModel(state_map = {
      1 : pyxb.binding.content.ContentModelState(state=1, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=CylindricalCSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'descriptionReference'))),
        pyxb.binding.content.ContentModelTransition(next_state=1, element_use=CylindricalCSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'metaDataProperty'))),
        pyxb.binding.content.ContentModelTransition(next_state=3, element_use=CylindricalCSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'description'))),
        pyxb.binding.content.ContentModelTransition(next_state=6, element_use=CylindricalCSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'identifier'))),
    ])
    , 2 : pyxb.binding.content.ContentModelState(state=2, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=6, element_use=CylindricalCSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'identifier'))),
    ])
    , 3 : pyxb.binding.content.ContentModelState(state=3, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=CylindricalCSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'descriptionReference'))),
        pyxb.binding.content.ContentModelTransition(next_state=6, element_use=CylindricalCSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'identifier'))),
    ])
    , 4 : pyxb.binding.content.ContentModelState(state=4, is_final=True, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=4, element_use=CylindricalCSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'axis'))),
    ])
    , 5 : pyxb.binding.content.ContentModelState(state=5, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=4, element_use=CylindricalCSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'axis'))),
    ])
    , 6 : pyxb.binding.content.ContentModelState(state=6, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=4, element_use=CylindricalCSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'axis'))),
        pyxb.binding.content.ContentModelTransition(next_state=5, element_use=CylindricalCSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'remarks'))),
        pyxb.binding.content.ContentModelTransition(next_state=6, element_use=CylindricalCSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name'))),
    ])
})


EllipsoidalCSType._ContentModel = pyxb.binding.content.ContentModel(state_map = {
      1 : pyxb.binding.content.ContentModelState(state=1, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=EllipsoidalCSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'descriptionReference'))),
        pyxb.binding.content.ContentModelTransition(next_state=1, element_use=EllipsoidalCSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'metaDataProperty'))),
        pyxb.binding.content.ContentModelTransition(next_state=3, element_use=EllipsoidalCSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'description'))),
        pyxb.binding.content.ContentModelTransition(next_state=6, element_use=EllipsoidalCSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'identifier'))),
    ])
    , 2 : pyxb.binding.content.ContentModelState(state=2, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=6, element_use=EllipsoidalCSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'identifier'))),
    ])
    , 3 : pyxb.binding.content.ContentModelState(state=3, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=EllipsoidalCSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'descriptionReference'))),
        pyxb.binding.content.ContentModelTransition(next_state=6, element_use=EllipsoidalCSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'identifier'))),
    ])
    , 4 : pyxb.binding.content.ContentModelState(state=4, is_final=True, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=4, element_use=EllipsoidalCSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'axis'))),
    ])
    , 5 : pyxb.binding.content.ContentModelState(state=5, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=4, element_use=EllipsoidalCSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'axis'))),
    ])
    , 6 : pyxb.binding.content.ContentModelState(state=6, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=4, element_use=EllipsoidalCSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'axis'))),
        pyxb.binding.content.ContentModelTransition(next_state=5, element_use=EllipsoidalCSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'remarks'))),
        pyxb.binding.content.ContentModelTransition(next_state=6, element_use=EllipsoidalCSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name'))),
    ])
})



EngineeringCRSType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'coordinateSystem'), CoordinateSystemPropertyType, scope=EngineeringCRSType))

EngineeringCRSType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'engineeringDatum'), EngineeringDatumPropertyType, scope=EngineeringCRSType))
EngineeringCRSType._ContentModel = pyxb.binding.content.ContentModel(state_map = {
      1 : pyxb.binding.content.ContentModelState(state=1, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=3, element_use=EngineeringCRSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'descriptionReference'))),
        pyxb.binding.content.ContentModelTransition(next_state=1, element_use=EngineeringCRSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'metaDataProperty'))),
        pyxb.binding.content.ContentModelTransition(next_state=4, element_use=EngineeringCRSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'description'))),
        pyxb.binding.content.ContentModelTransition(next_state=8, element_use=EngineeringCRSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'identifier'))),
    ])
    , 2 : pyxb.binding.content.ContentModelState(state=2, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=7, element_use=EngineeringCRSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'scope'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=EngineeringCRSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'domainOfValidity'))),
    ])
    , 3 : pyxb.binding.content.ContentModelState(state=3, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=8, element_use=EngineeringCRSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'identifier'))),
    ])
    , 4 : pyxb.binding.content.ContentModelState(state=4, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=3, element_use=EngineeringCRSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'descriptionReference'))),
        pyxb.binding.content.ContentModelTransition(next_state=8, element_use=EngineeringCRSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'identifier'))),
    ])
    , 5 : pyxb.binding.content.ContentModelState(state=5, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=6, element_use=EngineeringCRSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'engineeringDatum'))),
    ])
    , 6 : pyxb.binding.content.ContentModelState(state=6, is_final=True, transitions=[
    ])
    , 7 : pyxb.binding.content.ContentModelState(state=7, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=7, element_use=EngineeringCRSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'scope'))),
        pyxb.binding.content.ContentModelTransition(next_state=5, element_use=EngineeringCRSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'coordinateSystem'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=EngineeringCRSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'domainOfValidity'))),
    ])
    , 8 : pyxb.binding.content.ContentModelState(state=8, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=7, element_use=EngineeringCRSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'scope'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=EngineeringCRSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'remarks'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=EngineeringCRSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'domainOfValidity'))),
        pyxb.binding.content.ContentModelTransition(next_state=8, element_use=EngineeringCRSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name'))),
    ])
})


EngineeringDatumType._ContentModel = pyxb.binding.content.ContentModel(state_map = {
      1 : pyxb.binding.content.ContentModelState(state=1, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=3, element_use=EngineeringDatumType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'descriptionReference'))),
        pyxb.binding.content.ContentModelTransition(next_state=1, element_use=EngineeringDatumType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'metaDataProperty'))),
        pyxb.binding.content.ContentModelTransition(next_state=5, element_use=EngineeringDatumType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'description'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=EngineeringDatumType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'identifier'))),
    ])
    , 2 : pyxb.binding.content.ContentModelState(state=2, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=7, element_use=EngineeringDatumType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'domainOfValidity'))),
        pyxb.binding.content.ContentModelTransition(next_state=8, element_use=EngineeringDatumType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'scope'))),
        pyxb.binding.content.ContentModelTransition(next_state=9, element_use=EngineeringDatumType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'remarks'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=EngineeringDatumType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name'))),
    ])
    , 3 : pyxb.binding.content.ContentModelState(state=3, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=EngineeringDatumType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'identifier'))),
    ])
    , 4 : pyxb.binding.content.ContentModelState(state=4, is_final=True, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=6, element_use=EngineeringDatumType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'realizationEpoch'))),
    ])
    , 5 : pyxb.binding.content.ContentModelState(state=5, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=3, element_use=EngineeringDatumType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'descriptionReference'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=EngineeringDatumType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'identifier'))),
    ])
    , 6 : pyxb.binding.content.ContentModelState(state=6, is_final=True, transitions=[
    ])
    , 7 : pyxb.binding.content.ContentModelState(state=7, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=8, element_use=EngineeringDatumType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'scope'))),
    ])
    , 8 : pyxb.binding.content.ContentModelState(state=8, is_final=True, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=4, element_use=EngineeringDatumType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'anchorDefinition'))),
        pyxb.binding.content.ContentModelTransition(next_state=8, element_use=EngineeringDatumType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'scope'))),
        pyxb.binding.content.ContentModelTransition(next_state=6, element_use=EngineeringDatumType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'realizationEpoch'))),
    ])
    , 9 : pyxb.binding.content.ContentModelState(state=9, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=7, element_use=EngineeringDatumType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'domainOfValidity'))),
        pyxb.binding.content.ContentModelTransition(next_state=8, element_use=EngineeringDatumType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'scope'))),
    ])
})



GeocentricCRSType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'usesGeodeticDatum'), GeodeticDatumPropertyType, scope=GeocentricCRSType))

GeocentricCRSType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'usesSphericalCS'), SphericalCSPropertyType, scope=GeocentricCRSType))

GeocentricCRSType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'usesCartesianCS'), CartesianCSPropertyType, scope=GeocentricCRSType))
GeocentricCRSType._ContentModel = pyxb.binding.content.ContentModel(state_map = {
      1 : pyxb.binding.content.ContentModelState(state=1, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=4, element_use=GeocentricCRSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'descriptionReference'))),
        pyxb.binding.content.ContentModelTransition(next_state=1, element_use=GeocentricCRSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'metaDataProperty'))),
        pyxb.binding.content.ContentModelTransition(next_state=5, element_use=GeocentricCRSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'description'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=GeocentricCRSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'identifier'))),
    ])
    , 2 : pyxb.binding.content.ContentModelState(state=2, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=7, element_use=GeocentricCRSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'scope'))),
        pyxb.binding.content.ContentModelTransition(next_state=3, element_use=GeocentricCRSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'remarks'))),
        pyxb.binding.content.ContentModelTransition(next_state=3, element_use=GeocentricCRSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'domainOfValidity'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=GeocentricCRSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name'))),
    ])
    , 3 : pyxb.binding.content.ContentModelState(state=3, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=7, element_use=GeocentricCRSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'scope'))),
        pyxb.binding.content.ContentModelTransition(next_state=3, element_use=GeocentricCRSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'domainOfValidity'))),
    ])
    , 4 : pyxb.binding.content.ContentModelState(state=4, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=GeocentricCRSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'identifier'))),
    ])
    , 5 : pyxb.binding.content.ContentModelState(state=5, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=4, element_use=GeocentricCRSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'descriptionReference'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=GeocentricCRSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'identifier'))),
    ])
    , 6 : pyxb.binding.content.ContentModelState(state=6, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=8, element_use=GeocentricCRSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'usesGeodeticDatum'))),
    ])
    , 7 : pyxb.binding.content.ContentModelState(state=7, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=7, element_use=GeocentricCRSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'scope'))),
        pyxb.binding.content.ContentModelTransition(next_state=6, element_use=GeocentricCRSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'usesSphericalCS'))),
        pyxb.binding.content.ContentModelTransition(next_state=6, element_use=GeocentricCRSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'usesCartesianCS'))),
        pyxb.binding.content.ContentModelTransition(next_state=3, element_use=GeocentricCRSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'domainOfValidity'))),
    ])
    , 8 : pyxb.binding.content.ContentModelState(state=8, is_final=True, transitions=[
    ])
})



GeodeticCRSType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'sphericalCS'), SphericalCSPropertyType, scope=GeodeticCRSType))

GeodeticCRSType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'geodeticDatum'), GeodeticDatumPropertyType, scope=GeodeticCRSType))

GeodeticCRSType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'ellipsoidalCS'), EllipsoidalCSPropertyType, scope=GeodeticCRSType))

GeodeticCRSType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'cartesianCS'), CartesianCSPropertyType, scope=GeodeticCRSType))
GeodeticCRSType._ContentModel = pyxb.binding.content.ContentModel(state_map = {
      1 : pyxb.binding.content.ContentModelState(state=1, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=4, element_use=GeodeticCRSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'description'))),
        pyxb.binding.content.ContentModelTransition(next_state=5, element_use=GeodeticCRSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'descriptionReference'))),
        pyxb.binding.content.ContentModelTransition(next_state=1, element_use=GeodeticCRSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'metaDataProperty'))),
        pyxb.binding.content.ContentModelTransition(next_state=8, element_use=GeodeticCRSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'identifier'))),
    ])
    , 2 : pyxb.binding.content.ContentModelState(state=2, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=6, element_use=GeodeticCRSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'scope'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=GeodeticCRSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'domainOfValidity'))),
    ])
    , 3 : pyxb.binding.content.ContentModelState(state=3, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=7, element_use=GeodeticCRSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'geodeticDatum'))),
    ])
    , 4 : pyxb.binding.content.ContentModelState(state=4, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=5, element_use=GeodeticCRSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'descriptionReference'))),
        pyxb.binding.content.ContentModelTransition(next_state=8, element_use=GeodeticCRSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'identifier'))),
    ])
    , 5 : pyxb.binding.content.ContentModelState(state=5, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=8, element_use=GeodeticCRSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'identifier'))),
    ])
    , 6 : pyxb.binding.content.ContentModelState(state=6, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=6, element_use=GeodeticCRSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'scope'))),
        pyxb.binding.content.ContentModelTransition(next_state=3, element_use=GeodeticCRSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'sphericalCS'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=GeodeticCRSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'domainOfValidity'))),
        pyxb.binding.content.ContentModelTransition(next_state=3, element_use=GeodeticCRSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'cartesianCS'))),
        pyxb.binding.content.ContentModelTransition(next_state=3, element_use=GeodeticCRSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'ellipsoidalCS'))),
    ])
    , 7 : pyxb.binding.content.ContentModelState(state=7, is_final=True, transitions=[
    ])
    , 8 : pyxb.binding.content.ContentModelState(state=8, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=6, element_use=GeodeticCRSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'scope'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=GeodeticCRSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'remarks'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=GeodeticCRSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'domainOfValidity'))),
        pyxb.binding.content.ContentModelTransition(next_state=8, element_use=GeodeticCRSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name'))),
    ])
})



GeodeticDatumType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'primeMeridian'), PrimeMeridianPropertyType, scope=GeodeticDatumType))

GeodeticDatumType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'ellipsoid'), EllipsoidPropertyType, scope=GeodeticDatumType))
GeodeticDatumType._ContentModel = pyxb.binding.content.ContentModel(state_map = {
      1 : pyxb.binding.content.ContentModelState(state=1, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=1, element_use=GeodeticDatumType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'metaDataProperty'))),
        pyxb.binding.content.ContentModelTransition(next_state=3, element_use=GeodeticDatumType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'descriptionReference'))),
        pyxb.binding.content.ContentModelTransition(next_state=5, element_use=GeodeticDatumType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'description'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=GeodeticDatumType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'identifier'))),
    ])
    , 2 : pyxb.binding.content.ContentModelState(state=2, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=7, element_use=GeodeticDatumType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'remarks'))),
        pyxb.binding.content.ContentModelTransition(next_state=9, element_use=GeodeticDatumType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'domainOfValidity'))),
        pyxb.binding.content.ContentModelTransition(next_state=11, element_use=GeodeticDatumType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'scope'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=GeodeticDatumType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name'))),
    ])
    , 3 : pyxb.binding.content.ContentModelState(state=3, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=GeodeticDatumType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'identifier'))),
    ])
    , 4 : pyxb.binding.content.ContentModelState(state=4, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=10, element_use=GeodeticDatumType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'ellipsoid'))),
    ])
    , 5 : pyxb.binding.content.ContentModelState(state=5, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=3, element_use=GeodeticDatumType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'descriptionReference'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=GeodeticDatumType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'identifier'))),
    ])
    , 6 : pyxb.binding.content.ContentModelState(state=6, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=4, element_use=GeodeticDatumType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'primeMeridian'))),
        pyxb.binding.content.ContentModelTransition(next_state=8, element_use=GeodeticDatumType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'realizationEpoch'))),
    ])
    , 7 : pyxb.binding.content.ContentModelState(state=7, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=9, element_use=GeodeticDatumType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'domainOfValidity'))),
        pyxb.binding.content.ContentModelTransition(next_state=11, element_use=GeodeticDatumType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'scope'))),
    ])
    , 8 : pyxb.binding.content.ContentModelState(state=8, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=4, element_use=GeodeticDatumType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'primeMeridian'))),
    ])
    , 9 : pyxb.binding.content.ContentModelState(state=9, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=11, element_use=GeodeticDatumType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'scope'))),
    ])
    , 10 : pyxb.binding.content.ContentModelState(state=10, is_final=True, transitions=[
    ])
    , 11 : pyxb.binding.content.ContentModelState(state=11, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=11, element_use=GeodeticDatumType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'scope'))),
        pyxb.binding.content.ContentModelTransition(next_state=4, element_use=GeodeticDatumType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'primeMeridian'))),
        pyxb.binding.content.ContentModelTransition(next_state=6, element_use=GeodeticDatumType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'anchorDefinition'))),
        pyxb.binding.content.ContentModelTransition(next_state=8, element_use=GeodeticDatumType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'realizationEpoch'))),
    ])
})



GeographicCRSType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'usesGeodeticDatum'), GeodeticDatumPropertyType, scope=GeographicCRSType))

GeographicCRSType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'usesEllipsoidalCS'), EllipsoidalCSPropertyType, scope=GeographicCRSType))
GeographicCRSType._ContentModel = pyxb.binding.content.ContentModel(state_map = {
      1 : pyxb.binding.content.ContentModelState(state=1, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=4, element_use=GeographicCRSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'descriptionReference'))),
        pyxb.binding.content.ContentModelTransition(next_state=1, element_use=GeographicCRSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'metaDataProperty'))),
        pyxb.binding.content.ContentModelTransition(next_state=6, element_use=GeographicCRSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'description'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=GeographicCRSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'identifier'))),
    ])
    , 2 : pyxb.binding.content.ContentModelState(state=2, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=8, element_use=GeographicCRSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'scope'))),
        pyxb.binding.content.ContentModelTransition(next_state=3, element_use=GeographicCRSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'remarks'))),
        pyxb.binding.content.ContentModelTransition(next_state=3, element_use=GeographicCRSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'domainOfValidity'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=GeographicCRSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name'))),
    ])
    , 3 : pyxb.binding.content.ContentModelState(state=3, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=8, element_use=GeographicCRSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'scope'))),
        pyxb.binding.content.ContentModelTransition(next_state=3, element_use=GeographicCRSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'domainOfValidity'))),
    ])
    , 4 : pyxb.binding.content.ContentModelState(state=4, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=GeographicCRSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'identifier'))),
    ])
    , 5 : pyxb.binding.content.ContentModelState(state=5, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=7, element_use=GeographicCRSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'usesGeodeticDatum'))),
    ])
    , 6 : pyxb.binding.content.ContentModelState(state=6, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=4, element_use=GeographicCRSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'descriptionReference'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=GeographicCRSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'identifier'))),
    ])
    , 7 : pyxb.binding.content.ContentModelState(state=7, is_final=True, transitions=[
    ])
    , 8 : pyxb.binding.content.ContentModelState(state=8, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=8, element_use=GeographicCRSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'scope'))),
        pyxb.binding.content.ContentModelTransition(next_state=5, element_use=GeographicCRSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'usesEllipsoidalCS'))),
        pyxb.binding.content.ContentModelTransition(next_state=3, element_use=GeographicCRSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'domainOfValidity'))),
    ])
})



ImageCRSType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'affineCS'), AffineCSPropertyType, scope=ImageCRSType))

ImageCRSType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'imageDatum'), ImageDatumPropertyType, scope=ImageCRSType))

ImageCRSType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'cartesianCS'), CartesianCSPropertyType, scope=ImageCRSType))

ImageCRSType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'usesObliqueCartesianCS'), ObliqueCartesianCSPropertyType, scope=ImageCRSType))
ImageCRSType._ContentModel = pyxb.binding.content.ContentModel(state_map = {
      1 : pyxb.binding.content.ContentModelState(state=1, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=1, element_use=ImageCRSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'metaDataProperty'))),
        pyxb.binding.content.ContentModelTransition(next_state=4, element_use=ImageCRSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'description'))),
        pyxb.binding.content.ContentModelTransition(next_state=5, element_use=ImageCRSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'descriptionReference'))),
        pyxb.binding.content.ContentModelTransition(next_state=8, element_use=ImageCRSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'identifier'))),
    ])
    , 2 : pyxb.binding.content.ContentModelState(state=2, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=6, element_use=ImageCRSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'scope'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=ImageCRSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'domainOfValidity'))),
    ])
    , 3 : pyxb.binding.content.ContentModelState(state=3, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=7, element_use=ImageCRSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'imageDatum'))),
    ])
    , 4 : pyxb.binding.content.ContentModelState(state=4, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=5, element_use=ImageCRSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'descriptionReference'))),
        pyxb.binding.content.ContentModelTransition(next_state=8, element_use=ImageCRSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'identifier'))),
    ])
    , 5 : pyxb.binding.content.ContentModelState(state=5, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=8, element_use=ImageCRSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'identifier'))),
    ])
    , 6 : pyxb.binding.content.ContentModelState(state=6, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=6, element_use=ImageCRSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'scope'))),
        pyxb.binding.content.ContentModelTransition(next_state=3, element_use=ImageCRSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'affineCS'))),
        pyxb.binding.content.ContentModelTransition(next_state=3, element_use=ImageCRSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'usesObliqueCartesianCS'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=ImageCRSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'domainOfValidity'))),
        pyxb.binding.content.ContentModelTransition(next_state=3, element_use=ImageCRSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'cartesianCS'))),
    ])
    , 7 : pyxb.binding.content.ContentModelState(state=7, is_final=True, transitions=[
    ])
    , 8 : pyxb.binding.content.ContentModelState(state=8, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=6, element_use=ImageCRSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'scope'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=ImageCRSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'remarks'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=ImageCRSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'domainOfValidity'))),
        pyxb.binding.content.ContentModelTransition(next_state=8, element_use=ImageCRSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name'))),
    ])
})



ImageDatumType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'pixelInCell'), CodeWithAuthorityType, scope=ImageDatumType))
ImageDatumType._ContentModel = pyxb.binding.content.ContentModel(state_map = {
      1 : pyxb.binding.content.ContentModelState(state=1, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=3, element_use=ImageDatumType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'descriptionReference'))),
        pyxb.binding.content.ContentModelTransition(next_state=1, element_use=ImageDatumType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'metaDataProperty'))),
        pyxb.binding.content.ContentModelTransition(next_state=5, element_use=ImageDatumType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'description'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=ImageDatumType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'identifier'))),
    ])
    , 2 : pyxb.binding.content.ContentModelState(state=2, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=7, element_use=ImageDatumType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'domainOfValidity'))),
        pyxb.binding.content.ContentModelTransition(next_state=9, element_use=ImageDatumType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'scope'))),
        pyxb.binding.content.ContentModelTransition(next_state=10, element_use=ImageDatumType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'remarks'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=ImageDatumType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name'))),
    ])
    , 3 : pyxb.binding.content.ContentModelState(state=3, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=ImageDatumType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'identifier'))),
    ])
    , 4 : pyxb.binding.content.ContentModelState(state=4, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=6, element_use=ImageDatumType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'pixelInCell'))),
        pyxb.binding.content.ContentModelTransition(next_state=8, element_use=ImageDatumType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'realizationEpoch'))),
    ])
    , 5 : pyxb.binding.content.ContentModelState(state=5, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=3, element_use=ImageDatumType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'descriptionReference'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=ImageDatumType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'identifier'))),
    ])
    , 6 : pyxb.binding.content.ContentModelState(state=6, is_final=True, transitions=[
    ])
    , 7 : pyxb.binding.content.ContentModelState(state=7, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=9, element_use=ImageDatumType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'scope'))),
    ])
    , 8 : pyxb.binding.content.ContentModelState(state=8, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=6, element_use=ImageDatumType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'pixelInCell'))),
    ])
    , 9 : pyxb.binding.content.ContentModelState(state=9, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=4, element_use=ImageDatumType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'anchorDefinition'))),
        pyxb.binding.content.ContentModelTransition(next_state=6, element_use=ImageDatumType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'pixelInCell'))),
        pyxb.binding.content.ContentModelTransition(next_state=9, element_use=ImageDatumType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'scope'))),
        pyxb.binding.content.ContentModelTransition(next_state=8, element_use=ImageDatumType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'realizationEpoch'))),
    ])
    , 10 : pyxb.binding.content.ContentModelState(state=10, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=7, element_use=ImageDatumType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'domainOfValidity'))),
        pyxb.binding.content.ContentModelTransition(next_state=9, element_use=ImageDatumType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'scope'))),
    ])
})


LinearCSType._ContentModel = pyxb.binding.content.ContentModel(state_map = {
      1 : pyxb.binding.content.ContentModelState(state=1, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=LinearCSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'descriptionReference'))),
        pyxb.binding.content.ContentModelTransition(next_state=1, element_use=LinearCSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'metaDataProperty'))),
        pyxb.binding.content.ContentModelTransition(next_state=3, element_use=LinearCSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'description'))),
        pyxb.binding.content.ContentModelTransition(next_state=6, element_use=LinearCSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'identifier'))),
    ])
    , 2 : pyxb.binding.content.ContentModelState(state=2, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=6, element_use=LinearCSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'identifier'))),
    ])
    , 3 : pyxb.binding.content.ContentModelState(state=3, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=LinearCSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'descriptionReference'))),
        pyxb.binding.content.ContentModelTransition(next_state=6, element_use=LinearCSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'identifier'))),
    ])
    , 4 : pyxb.binding.content.ContentModelState(state=4, is_final=True, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=4, element_use=LinearCSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'axis'))),
    ])
    , 5 : pyxb.binding.content.ContentModelState(state=5, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=4, element_use=LinearCSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'axis'))),
    ])
    , 6 : pyxb.binding.content.ContentModelState(state=6, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=4, element_use=LinearCSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'axis'))),
        pyxb.binding.content.ContentModelTransition(next_state=5, element_use=LinearCSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'remarks'))),
        pyxb.binding.content.ContentModelTransition(next_state=6, element_use=LinearCSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name'))),
    ])
})


ObliqueCartesianCSType._ContentModel = pyxb.binding.content.ContentModel(state_map = {
      1 : pyxb.binding.content.ContentModelState(state=1, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=ObliqueCartesianCSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'descriptionReference'))),
        pyxb.binding.content.ContentModelTransition(next_state=1, element_use=ObliqueCartesianCSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'metaDataProperty'))),
        pyxb.binding.content.ContentModelTransition(next_state=3, element_use=ObliqueCartesianCSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'description'))),
        pyxb.binding.content.ContentModelTransition(next_state=6, element_use=ObliqueCartesianCSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'identifier'))),
    ])
    , 2 : pyxb.binding.content.ContentModelState(state=2, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=6, element_use=ObliqueCartesianCSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'identifier'))),
    ])
    , 3 : pyxb.binding.content.ContentModelState(state=3, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=ObliqueCartesianCSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'descriptionReference'))),
        pyxb.binding.content.ContentModelTransition(next_state=6, element_use=ObliqueCartesianCSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'identifier'))),
    ])
    , 4 : pyxb.binding.content.ContentModelState(state=4, is_final=True, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=4, element_use=ObliqueCartesianCSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'axis'))),
    ])
    , 5 : pyxb.binding.content.ContentModelState(state=5, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=4, element_use=ObliqueCartesianCSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'axis'))),
    ])
    , 6 : pyxb.binding.content.ContentModelState(state=6, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=4, element_use=ObliqueCartesianCSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'axis'))),
        pyxb.binding.content.ContentModelTransition(next_state=5, element_use=ObliqueCartesianCSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'remarks'))),
        pyxb.binding.content.ContentModelTransition(next_state=6, element_use=ObliqueCartesianCSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name'))),
    ])
})



OperationParameterGroupType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'maximumOccurs'), pyxb.binding.datatypes.positiveInteger, scope=OperationParameterGroupType))

OperationParameterGroupType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'generalOperationParameter'), AbstractGeneralOperationParameterPropertyType, scope=OperationParameterGroupType))
OperationParameterGroupType._ContentModel = pyxb.binding.content.ContentModel(state_map = {
      1 : pyxb.binding.content.ContentModelState(state=1, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=1, element_use=OperationParameterGroupType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'metaDataProperty'))),
        pyxb.binding.content.ContentModelTransition(next_state=3, element_use=OperationParameterGroupType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'descriptionReference'))),
        pyxb.binding.content.ContentModelTransition(next_state=5, element_use=OperationParameterGroupType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'description'))),
        pyxb.binding.content.ContentModelTransition(next_state=4, element_use=OperationParameterGroupType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'identifier'))),
    ])
    , 2 : pyxb.binding.content.ContentModelState(state=2, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=7, element_use=OperationParameterGroupType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'generalOperationParameter'))),
        pyxb.binding.content.ContentModelTransition(next_state=8, element_use=OperationParameterGroupType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'maximumOccurs'))),
        pyxb.binding.content.ContentModelTransition(next_state=9, element_use=OperationParameterGroupType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'minimumOccurs'))),
    ])
    , 3 : pyxb.binding.content.ContentModelState(state=3, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=4, element_use=OperationParameterGroupType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'identifier'))),
    ])
    , 4 : pyxb.binding.content.ContentModelState(state=4, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=7, element_use=OperationParameterGroupType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'generalOperationParameter'))),
        pyxb.binding.content.ContentModelTransition(next_state=8, element_use=OperationParameterGroupType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'maximumOccurs'))),
        pyxb.binding.content.ContentModelTransition(next_state=9, element_use=OperationParameterGroupType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'minimumOccurs'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=OperationParameterGroupType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'remarks'))),
        pyxb.binding.content.ContentModelTransition(next_state=4, element_use=OperationParameterGroupType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name'))),
    ])
    , 5 : pyxb.binding.content.ContentModelState(state=5, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=3, element_use=OperationParameterGroupType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'descriptionReference'))),
        pyxb.binding.content.ContentModelTransition(next_state=4, element_use=OperationParameterGroupType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'identifier'))),
    ])
    , 6 : pyxb.binding.content.ContentModelState(state=6, is_final=True, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=6, element_use=OperationParameterGroupType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'generalOperationParameter'))),
    ])
    , 7 : pyxb.binding.content.ContentModelState(state=7, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=6, element_use=OperationParameterGroupType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'generalOperationParameter'))),
    ])
    , 8 : pyxb.binding.content.ContentModelState(state=8, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=7, element_use=OperationParameterGroupType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'generalOperationParameter'))),
    ])
    , 9 : pyxb.binding.content.ContentModelState(state=9, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=7, element_use=OperationParameterGroupType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'generalOperationParameter'))),
        pyxb.binding.content.ContentModelTransition(next_state=8, element_use=OperationParameterGroupType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'maximumOccurs'))),
    ])
})


OperationParameterType._ContentModel = pyxb.binding.content.ContentModel(state_map = {
      1 : pyxb.binding.content.ContentModelState(state=1, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=OperationParameterType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'descriptionReference'))),
        pyxb.binding.content.ContentModelTransition(next_state=1, element_use=OperationParameterType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'metaDataProperty'))),
        pyxb.binding.content.ContentModelTransition(next_state=3, element_use=OperationParameterType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'description'))),
        pyxb.binding.content.ContentModelTransition(next_state=6, element_use=OperationParameterType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'identifier'))),
    ])
    , 2 : pyxb.binding.content.ContentModelState(state=2, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=6, element_use=OperationParameterType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'identifier'))),
    ])
    , 3 : pyxb.binding.content.ContentModelState(state=3, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=OperationParameterType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'descriptionReference'))),
        pyxb.binding.content.ContentModelTransition(next_state=6, element_use=OperationParameterType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'identifier'))),
    ])
    , 4 : pyxb.binding.content.ContentModelState(state=4, is_final=True, transitions=[
    ])
    , 5 : pyxb.binding.content.ContentModelState(state=5, is_final=True, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=4, element_use=OperationParameterType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'minimumOccurs'))),
    ])
    , 6 : pyxb.binding.content.ContentModelState(state=6, is_final=True, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=4, element_use=OperationParameterType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'minimumOccurs'))),
        pyxb.binding.content.ContentModelTransition(next_state=5, element_use=OperationParameterType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'remarks'))),
        pyxb.binding.content.ContentModelTransition(next_state=6, element_use=OperationParameterType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name'))),
    ])
})



PassThroughOperationType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'coordOperation'), CoordinateOperationPropertyType, scope=PassThroughOperationType))

PassThroughOperationType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'modifiedCoordinate'), pyxb.binding.datatypes.positiveInteger, scope=PassThroughOperationType))
PassThroughOperationType._ContentModel = pyxb.binding.content.ContentModel(state_map = {
      1 : pyxb.binding.content.ContentModelState(state=1, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=1, element_use=PassThroughOperationType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'metaDataProperty'))),
        pyxb.binding.content.ContentModelTransition(next_state=3, element_use=PassThroughOperationType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'descriptionReference'))),
        pyxb.binding.content.ContentModelTransition(next_state=5, element_use=PassThroughOperationType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'description'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=PassThroughOperationType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'identifier'))),
    ])
    , 2 : pyxb.binding.content.ContentModelState(state=2, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=7, element_use=PassThroughOperationType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'scope'))),
        pyxb.binding.content.ContentModelTransition(next_state=8, element_use=PassThroughOperationType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'domainOfValidity'))),
        pyxb.binding.content.ContentModelTransition(next_state=9, element_use=PassThroughOperationType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'remarks'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=PassThroughOperationType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name'))),
    ])
    , 3 : pyxb.binding.content.ContentModelState(state=3, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=PassThroughOperationType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'identifier'))),
    ])
    , 4 : pyxb.binding.content.ContentModelState(state=4, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=4, element_use=PassThroughOperationType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'modifiedCoordinate'))),
        pyxb.binding.content.ContentModelTransition(next_state=12, element_use=PassThroughOperationType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'coordOperation'))),
    ])
    , 5 : pyxb.binding.content.ContentModelState(state=5, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=3, element_use=PassThroughOperationType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'descriptionReference'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=PassThroughOperationType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'identifier'))),
    ])
    , 6 : pyxb.binding.content.ContentModelState(state=6, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=4, element_use=PassThroughOperationType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'modifiedCoordinate'))),
        pyxb.binding.content.ContentModelTransition(next_state=10, element_use=PassThroughOperationType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'targetCRS'))),
    ])
    , 7 : pyxb.binding.content.ContentModelState(state=7, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=4, element_use=PassThroughOperationType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'modifiedCoordinate'))),
        pyxb.binding.content.ContentModelTransition(next_state=7, element_use=PassThroughOperationType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'scope'))),
        pyxb.binding.content.ContentModelTransition(next_state=11, element_use=PassThroughOperationType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'operationVersion'))),
        pyxb.binding.content.ContentModelTransition(next_state=6, element_use=PassThroughOperationType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'sourceCRS'))),
        pyxb.binding.content.ContentModelTransition(next_state=11, element_use=PassThroughOperationType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'coordinateOperationAccuracy'))),
        pyxb.binding.content.ContentModelTransition(next_state=10, element_use=PassThroughOperationType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'targetCRS'))),
    ])
    , 8 : pyxb.binding.content.ContentModelState(state=8, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=7, element_use=PassThroughOperationType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'scope'))),
    ])
    , 9 : pyxb.binding.content.ContentModelState(state=9, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=7, element_use=PassThroughOperationType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'scope'))),
        pyxb.binding.content.ContentModelTransition(next_state=8, element_use=PassThroughOperationType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'domainOfValidity'))),
    ])
    , 10 : pyxb.binding.content.ContentModelState(state=10, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=4, element_use=PassThroughOperationType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'modifiedCoordinate'))),
    ])
    , 11 : pyxb.binding.content.ContentModelState(state=11, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=4, element_use=PassThroughOperationType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'modifiedCoordinate'))),
        pyxb.binding.content.ContentModelTransition(next_state=6, element_use=PassThroughOperationType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'sourceCRS'))),
        pyxb.binding.content.ContentModelTransition(next_state=11, element_use=PassThroughOperationType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'coordinateOperationAccuracy'))),
        pyxb.binding.content.ContentModelTransition(next_state=10, element_use=PassThroughOperationType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'targetCRS'))),
    ])
    , 12 : pyxb.binding.content.ContentModelState(state=12, is_final=True, transitions=[
    ])
})


PolarCSType._ContentModel = pyxb.binding.content.ContentModel(state_map = {
      1 : pyxb.binding.content.ContentModelState(state=1, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=PolarCSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'descriptionReference'))),
        pyxb.binding.content.ContentModelTransition(next_state=1, element_use=PolarCSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'metaDataProperty'))),
        pyxb.binding.content.ContentModelTransition(next_state=3, element_use=PolarCSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'description'))),
        pyxb.binding.content.ContentModelTransition(next_state=6, element_use=PolarCSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'identifier'))),
    ])
    , 2 : pyxb.binding.content.ContentModelState(state=2, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=6, element_use=PolarCSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'identifier'))),
    ])
    , 3 : pyxb.binding.content.ContentModelState(state=3, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=PolarCSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'descriptionReference'))),
        pyxb.binding.content.ContentModelTransition(next_state=6, element_use=PolarCSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'identifier'))),
    ])
    , 4 : pyxb.binding.content.ContentModelState(state=4, is_final=True, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=4, element_use=PolarCSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'axis'))),
    ])
    , 5 : pyxb.binding.content.ContentModelState(state=5, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=4, element_use=PolarCSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'axis'))),
    ])
    , 6 : pyxb.binding.content.ContentModelState(state=6, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=4, element_use=PolarCSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'axis'))),
        pyxb.binding.content.ContentModelTransition(next_state=5, element_use=PolarCSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'remarks'))),
        pyxb.binding.content.ContentModelTransition(next_state=6, element_use=PolarCSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name'))),
    ])
})



PolyhedralSurfaceType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'polygonPatches'), PolygonPatchArrayPropertyType, scope=PolyhedralSurfaceType))
PolyhedralSurfaceType._ContentModel = pyxb.binding.content.ContentModel(state_map = {
      1 : pyxb.binding.content.ContentModelState(state=1, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=3, element_use=PolyhedralSurfaceType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'polygonPatches'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=PolyhedralSurfaceType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name'))),
        pyxb.binding.content.ContentModelTransition(next_state=1, element_use=PolyhedralSurfaceType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'metaDataProperty'))),
        pyxb.binding.content.ContentModelTransition(next_state=4, element_use=PolyhedralSurfaceType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'descriptionReference'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=PolyhedralSurfaceType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'identifier'))),
        pyxb.binding.content.ContentModelTransition(next_state=5, element_use=PolyhedralSurfaceType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'description'))),
    ])
    , 2 : pyxb.binding.content.ContentModelState(state=2, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=3, element_use=PolyhedralSurfaceType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'polygonPatches'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=PolyhedralSurfaceType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name'))),
    ])
    , 3 : pyxb.binding.content.ContentModelState(state=3, is_final=True, transitions=[
    ])
    , 4 : pyxb.binding.content.ContentModelState(state=4, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=3, element_use=PolyhedralSurfaceType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'polygonPatches'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=PolyhedralSurfaceType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'identifier'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=PolyhedralSurfaceType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name'))),
    ])
    , 5 : pyxb.binding.content.ContentModelState(state=5, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=3, element_use=PolyhedralSurfaceType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'polygonPatches'))),
        pyxb.binding.content.ContentModelTransition(next_state=4, element_use=PolyhedralSurfaceType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'descriptionReference'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=PolyhedralSurfaceType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'identifier'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=PolyhedralSurfaceType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name'))),
    ])
})


SphericalCSType._ContentModel = pyxb.binding.content.ContentModel(state_map = {
      1 : pyxb.binding.content.ContentModelState(state=1, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=SphericalCSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'descriptionReference'))),
        pyxb.binding.content.ContentModelTransition(next_state=1, element_use=SphericalCSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'metaDataProperty'))),
        pyxb.binding.content.ContentModelTransition(next_state=3, element_use=SphericalCSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'description'))),
        pyxb.binding.content.ContentModelTransition(next_state=6, element_use=SphericalCSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'identifier'))),
    ])
    , 2 : pyxb.binding.content.ContentModelState(state=2, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=6, element_use=SphericalCSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'identifier'))),
    ])
    , 3 : pyxb.binding.content.ContentModelState(state=3, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=SphericalCSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'descriptionReference'))),
        pyxb.binding.content.ContentModelTransition(next_state=6, element_use=SphericalCSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'identifier'))),
    ])
    , 4 : pyxb.binding.content.ContentModelState(state=4, is_final=True, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=4, element_use=SphericalCSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'axis'))),
    ])
    , 5 : pyxb.binding.content.ContentModelState(state=5, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=4, element_use=SphericalCSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'axis'))),
    ])
    , 6 : pyxb.binding.content.ContentModelState(state=6, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=4, element_use=SphericalCSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'axis'))),
        pyxb.binding.content.ContentModelTransition(next_state=5, element_use=SphericalCSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'remarks'))),
        pyxb.binding.content.ContentModelTransition(next_state=6, element_use=SphericalCSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name'))),
    ])
})



TemporalCRSType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'temporalDatum'), TemporalDatumPropertyType, scope=TemporalCRSType))

TemporalCRSType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'usesTemporalCS'), TemporalCSPropertyType, scope=TemporalCRSType))

TemporalCRSType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'timeCS'), TimeCSPropertyType, scope=TemporalCRSType))
TemporalCRSType._ContentModel = pyxb.binding.content.ContentModel(state_map = {
      1 : pyxb.binding.content.ContentModelState(state=1, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=1, element_use=TemporalCRSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'metaDataProperty'))),
        pyxb.binding.content.ContentModelTransition(next_state=3, element_use=TemporalCRSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'description'))),
        pyxb.binding.content.ContentModelTransition(next_state=4, element_use=TemporalCRSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'descriptionReference'))),
        pyxb.binding.content.ContentModelTransition(next_state=8, element_use=TemporalCRSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'identifier'))),
    ])
    , 2 : pyxb.binding.content.ContentModelState(state=2, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=6, element_use=TemporalCRSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'scope'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=TemporalCRSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'domainOfValidity'))),
    ])
    , 3 : pyxb.binding.content.ContentModelState(state=3, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=4, element_use=TemporalCRSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'descriptionReference'))),
        pyxb.binding.content.ContentModelTransition(next_state=8, element_use=TemporalCRSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'identifier'))),
    ])
    , 4 : pyxb.binding.content.ContentModelState(state=4, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=8, element_use=TemporalCRSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'identifier'))),
    ])
    , 5 : pyxb.binding.content.ContentModelState(state=5, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=7, element_use=TemporalCRSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'temporalDatum'))),
    ])
    , 6 : pyxb.binding.content.ContentModelState(state=6, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=5, element_use=TemporalCRSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'usesTemporalCS'))),
        pyxb.binding.content.ContentModelTransition(next_state=6, element_use=TemporalCRSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'scope'))),
        pyxb.binding.content.ContentModelTransition(next_state=5, element_use=TemporalCRSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'timeCS'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=TemporalCRSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'domainOfValidity'))),
    ])
    , 7 : pyxb.binding.content.ContentModelState(state=7, is_final=True, transitions=[
    ])
    , 8 : pyxb.binding.content.ContentModelState(state=8, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=6, element_use=TemporalCRSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'scope'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=TemporalCRSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'remarks'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=TemporalCRSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'domainOfValidity'))),
        pyxb.binding.content.ContentModelTransition(next_state=8, element_use=TemporalCRSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name'))),
    ])
})


TemporalCSType._ContentModel = pyxb.binding.content.ContentModel(state_map = {
      1 : pyxb.binding.content.ContentModelState(state=1, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=TemporalCSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'descriptionReference'))),
        pyxb.binding.content.ContentModelTransition(next_state=1, element_use=TemporalCSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'metaDataProperty'))),
        pyxb.binding.content.ContentModelTransition(next_state=3, element_use=TemporalCSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'description'))),
        pyxb.binding.content.ContentModelTransition(next_state=6, element_use=TemporalCSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'identifier'))),
    ])
    , 2 : pyxb.binding.content.ContentModelState(state=2, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=6, element_use=TemporalCSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'identifier'))),
    ])
    , 3 : pyxb.binding.content.ContentModelState(state=3, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=TemporalCSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'descriptionReference'))),
        pyxb.binding.content.ContentModelTransition(next_state=6, element_use=TemporalCSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'identifier'))),
    ])
    , 4 : pyxb.binding.content.ContentModelState(state=4, is_final=True, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=4, element_use=TemporalCSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'axis'))),
    ])
    , 5 : pyxb.binding.content.ContentModelState(state=5, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=4, element_use=TemporalCSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'axis'))),
    ])
    , 6 : pyxb.binding.content.ContentModelState(state=6, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=4, element_use=TemporalCSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'axis'))),
        pyxb.binding.content.ContentModelTransition(next_state=5, element_use=TemporalCSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'remarks'))),
        pyxb.binding.content.ContentModelTransition(next_state=6, element_use=TemporalCSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name'))),
    ])
})


TemporalDatumBaseType._ContentModel = pyxb.binding.content.ContentModel(state_map = {
      1 : pyxb.binding.content.ContentModelState(state=1, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=3, element_use=TemporalDatumBaseType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'descriptionReference'))),
        pyxb.binding.content.ContentModelTransition(next_state=1, element_use=TemporalDatumBaseType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'metaDataProperty'))),
        pyxb.binding.content.ContentModelTransition(next_state=5, element_use=TemporalDatumBaseType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'description'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=TemporalDatumBaseType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'identifier'))),
    ])
    , 2 : pyxb.binding.content.ContentModelState(state=2, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=6, element_use=TemporalDatumBaseType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'domainOfValidity'))),
        pyxb.binding.content.ContentModelTransition(next_state=7, element_use=TemporalDatumBaseType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'scope'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=TemporalDatumBaseType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name'))),
        pyxb.binding.content.ContentModelTransition(next_state=4, element_use=TemporalDatumBaseType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'remarks'))),
    ])
    , 3 : pyxb.binding.content.ContentModelState(state=3, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=TemporalDatumBaseType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'identifier'))),
    ])
    , 4 : pyxb.binding.content.ContentModelState(state=4, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=6, element_use=TemporalDatumBaseType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'domainOfValidity'))),
        pyxb.binding.content.ContentModelTransition(next_state=7, element_use=TemporalDatumBaseType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'scope'))),
    ])
    , 5 : pyxb.binding.content.ContentModelState(state=5, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=3, element_use=TemporalDatumBaseType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'descriptionReference'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=TemporalDatumBaseType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'identifier'))),
    ])
    , 6 : pyxb.binding.content.ContentModelState(state=6, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=7, element_use=TemporalDatumBaseType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'scope'))),
    ])
    , 7 : pyxb.binding.content.ContentModelState(state=7, is_final=True, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=7, element_use=TemporalDatumBaseType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'scope'))),
    ])
})


TimeCSType._ContentModel = pyxb.binding.content.ContentModel(state_map = {
      1 : pyxb.binding.content.ContentModelState(state=1, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=TimeCSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'descriptionReference'))),
        pyxb.binding.content.ContentModelTransition(next_state=1, element_use=TimeCSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'metaDataProperty'))),
        pyxb.binding.content.ContentModelTransition(next_state=3, element_use=TimeCSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'description'))),
        pyxb.binding.content.ContentModelTransition(next_state=6, element_use=TimeCSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'identifier'))),
    ])
    , 2 : pyxb.binding.content.ContentModelState(state=2, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=6, element_use=TimeCSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'identifier'))),
    ])
    , 3 : pyxb.binding.content.ContentModelState(state=3, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=TimeCSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'descriptionReference'))),
        pyxb.binding.content.ContentModelTransition(next_state=6, element_use=TimeCSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'identifier'))),
    ])
    , 4 : pyxb.binding.content.ContentModelState(state=4, is_final=True, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=4, element_use=TimeCSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'axis'))),
    ])
    , 5 : pyxb.binding.content.ContentModelState(state=5, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=4, element_use=TimeCSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'axis'))),
    ])
    , 6 : pyxb.binding.content.ContentModelState(state=6, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=4, element_use=TimeCSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'axis'))),
        pyxb.binding.content.ContentModelTransition(next_state=5, element_use=TimeCSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'remarks'))),
        pyxb.binding.content.ContentModelTransition(next_state=6, element_use=TimeCSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name'))),
    ])
})



TriangulatedSurfaceType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'trianglePatches'), TrianglePatchArrayPropertyType, scope=TriangulatedSurfaceType))
TriangulatedSurfaceType._ContentModel = pyxb.binding.content.ContentModel(state_map = {
      1 : pyxb.binding.content.ContentModelState(state=1, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=5, element_use=TriangulatedSurfaceType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name'))),
        pyxb.binding.content.ContentModelTransition(next_state=3, element_use=TriangulatedSurfaceType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'descriptionReference'))),
        pyxb.binding.content.ContentModelTransition(next_state=4, element_use=TriangulatedSurfaceType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'trianglePatches'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=TriangulatedSurfaceType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'description'))),
        pyxb.binding.content.ContentModelTransition(next_state=1, element_use=TriangulatedSurfaceType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'metaDataProperty'))),
        pyxb.binding.content.ContentModelTransition(next_state=5, element_use=TriangulatedSurfaceType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'identifier'))),
    ])
    , 2 : pyxb.binding.content.ContentModelState(state=2, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=5, element_use=TriangulatedSurfaceType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name'))),
        pyxb.binding.content.ContentModelTransition(next_state=3, element_use=TriangulatedSurfaceType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'descriptionReference'))),
        pyxb.binding.content.ContentModelTransition(next_state=5, element_use=TriangulatedSurfaceType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'identifier'))),
        pyxb.binding.content.ContentModelTransition(next_state=4, element_use=TriangulatedSurfaceType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'trianglePatches'))),
    ])
    , 3 : pyxb.binding.content.ContentModelState(state=3, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=5, element_use=TriangulatedSurfaceType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name'))),
        pyxb.binding.content.ContentModelTransition(next_state=5, element_use=TriangulatedSurfaceType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'identifier'))),
        pyxb.binding.content.ContentModelTransition(next_state=4, element_use=TriangulatedSurfaceType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'trianglePatches'))),
    ])
    , 4 : pyxb.binding.content.ContentModelState(state=4, is_final=True, transitions=[
    ])
    , 5 : pyxb.binding.content.ContentModelState(state=5, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=5, element_use=TriangulatedSurfaceType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name'))),
        pyxb.binding.content.ContentModelTransition(next_state=4, element_use=TriangulatedSurfaceType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'trianglePatches'))),
    ])
})


UserDefinedCSType._ContentModel = pyxb.binding.content.ContentModel(state_map = {
      1 : pyxb.binding.content.ContentModelState(state=1, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=UserDefinedCSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'descriptionReference'))),
        pyxb.binding.content.ContentModelTransition(next_state=1, element_use=UserDefinedCSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'metaDataProperty'))),
        pyxb.binding.content.ContentModelTransition(next_state=3, element_use=UserDefinedCSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'description'))),
        pyxb.binding.content.ContentModelTransition(next_state=6, element_use=UserDefinedCSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'identifier'))),
    ])
    , 2 : pyxb.binding.content.ContentModelState(state=2, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=6, element_use=UserDefinedCSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'identifier'))),
    ])
    , 3 : pyxb.binding.content.ContentModelState(state=3, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=UserDefinedCSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'descriptionReference'))),
        pyxb.binding.content.ContentModelTransition(next_state=6, element_use=UserDefinedCSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'identifier'))),
    ])
    , 4 : pyxb.binding.content.ContentModelState(state=4, is_final=True, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=4, element_use=UserDefinedCSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'axis'))),
    ])
    , 5 : pyxb.binding.content.ContentModelState(state=5, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=4, element_use=UserDefinedCSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'axis'))),
    ])
    , 6 : pyxb.binding.content.ContentModelState(state=6, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=4, element_use=UserDefinedCSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'axis'))),
        pyxb.binding.content.ContentModelTransition(next_state=5, element_use=UserDefinedCSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'remarks'))),
        pyxb.binding.content.ContentModelTransition(next_state=6, element_use=UserDefinedCSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name'))),
    ])
})



VerticalCRSType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'verticalDatum'), VerticalDatumPropertyType, scope=VerticalCRSType))

VerticalCRSType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'verticalCS'), VerticalCSPropertyType, scope=VerticalCRSType))
VerticalCRSType._ContentModel = pyxb.binding.content.ContentModel(state_map = {
      1 : pyxb.binding.content.ContentModelState(state=1, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=3, element_use=VerticalCRSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'descriptionReference'))),
        pyxb.binding.content.ContentModelTransition(next_state=1, element_use=VerticalCRSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'metaDataProperty'))),
        pyxb.binding.content.ContentModelTransition(next_state=4, element_use=VerticalCRSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'description'))),
        pyxb.binding.content.ContentModelTransition(next_state=8, element_use=VerticalCRSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'identifier'))),
    ])
    , 2 : pyxb.binding.content.ContentModelState(state=2, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=7, element_use=VerticalCRSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'scope'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=VerticalCRSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'domainOfValidity'))),
    ])
    , 3 : pyxb.binding.content.ContentModelState(state=3, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=8, element_use=VerticalCRSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'identifier'))),
    ])
    , 4 : pyxb.binding.content.ContentModelState(state=4, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=3, element_use=VerticalCRSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'descriptionReference'))),
        pyxb.binding.content.ContentModelTransition(next_state=8, element_use=VerticalCRSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'identifier'))),
    ])
    , 5 : pyxb.binding.content.ContentModelState(state=5, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=6, element_use=VerticalCRSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'verticalDatum'))),
    ])
    , 6 : pyxb.binding.content.ContentModelState(state=6, is_final=True, transitions=[
    ])
    , 7 : pyxb.binding.content.ContentModelState(state=7, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=7, element_use=VerticalCRSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'scope'))),
        pyxb.binding.content.ContentModelTransition(next_state=5, element_use=VerticalCRSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'verticalCS'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=VerticalCRSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'domainOfValidity'))),
    ])
    , 8 : pyxb.binding.content.ContentModelState(state=8, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=7, element_use=VerticalCRSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'scope'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=VerticalCRSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'domainOfValidity'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=VerticalCRSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'remarks'))),
        pyxb.binding.content.ContentModelTransition(next_state=8, element_use=VerticalCRSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name'))),
    ])
})


VerticalCSType._ContentModel = pyxb.binding.content.ContentModel(state_map = {
      1 : pyxb.binding.content.ContentModelState(state=1, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=VerticalCSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'descriptionReference'))),
        pyxb.binding.content.ContentModelTransition(next_state=1, element_use=VerticalCSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'metaDataProperty'))),
        pyxb.binding.content.ContentModelTransition(next_state=3, element_use=VerticalCSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'description'))),
        pyxb.binding.content.ContentModelTransition(next_state=6, element_use=VerticalCSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'identifier'))),
    ])
    , 2 : pyxb.binding.content.ContentModelState(state=2, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=6, element_use=VerticalCSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'identifier'))),
    ])
    , 3 : pyxb.binding.content.ContentModelState(state=3, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=VerticalCSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'descriptionReference'))),
        pyxb.binding.content.ContentModelTransition(next_state=6, element_use=VerticalCSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'identifier'))),
    ])
    , 4 : pyxb.binding.content.ContentModelState(state=4, is_final=True, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=4, element_use=VerticalCSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'axis'))),
    ])
    , 5 : pyxb.binding.content.ContentModelState(state=5, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=4, element_use=VerticalCSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'axis'))),
    ])
    , 6 : pyxb.binding.content.ContentModelState(state=6, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=4, element_use=VerticalCSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'axis'))),
        pyxb.binding.content.ContentModelTransition(next_state=5, element_use=VerticalCSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'remarks'))),
        pyxb.binding.content.ContentModelTransition(next_state=6, element_use=VerticalCSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name'))),
    ])
})


VerticalDatumType._ContentModel = pyxb.binding.content.ContentModel(state_map = {
      1 : pyxb.binding.content.ContentModelState(state=1, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=3, element_use=VerticalDatumType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'descriptionReference'))),
        pyxb.binding.content.ContentModelTransition(next_state=1, element_use=VerticalDatumType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'metaDataProperty'))),
        pyxb.binding.content.ContentModelTransition(next_state=5, element_use=VerticalDatumType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'description'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=VerticalDatumType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'identifier'))),
    ])
    , 2 : pyxb.binding.content.ContentModelState(state=2, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=7, element_use=VerticalDatumType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'domainOfValidity'))),
        pyxb.binding.content.ContentModelTransition(next_state=8, element_use=VerticalDatumType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'scope'))),
        pyxb.binding.content.ContentModelTransition(next_state=9, element_use=VerticalDatumType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'remarks'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=VerticalDatumType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name'))),
    ])
    , 3 : pyxb.binding.content.ContentModelState(state=3, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=VerticalDatumType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'identifier'))),
    ])
    , 4 : pyxb.binding.content.ContentModelState(state=4, is_final=True, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=6, element_use=VerticalDatumType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'realizationEpoch'))),
    ])
    , 5 : pyxb.binding.content.ContentModelState(state=5, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=3, element_use=VerticalDatumType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'descriptionReference'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=VerticalDatumType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'identifier'))),
    ])
    , 6 : pyxb.binding.content.ContentModelState(state=6, is_final=True, transitions=[
    ])
    , 7 : pyxb.binding.content.ContentModelState(state=7, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=8, element_use=VerticalDatumType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'scope'))),
    ])
    , 8 : pyxb.binding.content.ContentModelState(state=8, is_final=True, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=4, element_use=VerticalDatumType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'anchorDefinition'))),
        pyxb.binding.content.ContentModelTransition(next_state=8, element_use=VerticalDatumType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'scope'))),
        pyxb.binding.content.ContentModelTransition(next_state=6, element_use=VerticalDatumType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'realizationEpoch'))),
    ])
    , 9 : pyxb.binding.content.ContentModelState(state=9, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=7, element_use=VerticalDatumType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'domainOfValidity'))),
        pyxb.binding.content.ContentModelTransition(next_state=8, element_use=VerticalDatumType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'scope'))),
    ])
})



ConversionType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'method'), OperationMethodPropertyType, scope=ConversionType))

ConversionType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'parameterValue'), AbstractGeneralParameterValuePropertyType, scope=ConversionType))
ConversionType._ContentModel = pyxb.binding.content.ContentModel(state_map = {
      1 : pyxb.binding.content.ContentModelState(state=1, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=1, element_use=ConversionType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'metaDataProperty'))),
        pyxb.binding.content.ContentModelTransition(next_state=3, element_use=ConversionType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'description'))),
        pyxb.binding.content.ContentModelTransition(next_state=5, element_use=ConversionType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'descriptionReference'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=ConversionType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'identifier'))),
    ])
    , 2 : pyxb.binding.content.ContentModelState(state=2, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=7, element_use=ConversionType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'scope'))),
        pyxb.binding.content.ContentModelTransition(next_state=9, element_use=ConversionType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'domainOfValidity'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=ConversionType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name'))),
        pyxb.binding.content.ContentModelTransition(next_state=4, element_use=ConversionType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'remarks'))),
    ])
    , 3 : pyxb.binding.content.ContentModelState(state=3, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=5, element_use=ConversionType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'descriptionReference'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=ConversionType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'identifier'))),
    ])
    , 4 : pyxb.binding.content.ContentModelState(state=4, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=7, element_use=ConversionType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'scope'))),
        pyxb.binding.content.ContentModelTransition(next_state=9, element_use=ConversionType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'domainOfValidity'))),
    ])
    , 5 : pyxb.binding.content.ContentModelState(state=5, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=ConversionType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'identifier'))),
    ])
    , 6 : pyxb.binding.content.ContentModelState(state=6, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=8, element_use=ConversionType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'method'))),
        pyxb.binding.content.ContentModelTransition(next_state=6, element_use=ConversionType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'coordinateOperationAccuracy'))),
    ])
    , 7 : pyxb.binding.content.ContentModelState(state=7, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=7, element_use=ConversionType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'scope'))),
        pyxb.binding.content.ContentModelTransition(next_state=8, element_use=ConversionType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'method'))),
        pyxb.binding.content.ContentModelTransition(next_state=6, element_use=ConversionType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'coordinateOperationAccuracy'))),
    ])
    , 8 : pyxb.binding.content.ContentModelState(state=8, is_final=True, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=8, element_use=ConversionType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'parameterValue'))),
    ])
    , 9 : pyxb.binding.content.ContentModelState(state=9, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=7, element_use=ConversionType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'scope'))),
    ])
})



DerivedCRSType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'baseCRS'), SingleCRSPropertyType, scope=DerivedCRSType))

DerivedCRSType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'derivedCRSType'), CodeWithAuthorityType, scope=DerivedCRSType))

DerivedCRSType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'coordinateSystem'), CoordinateSystemPropertyType, scope=DerivedCRSType))
DerivedCRSType._ContentModel = pyxb.binding.content.ContentModel(state_map = {
      1 : pyxb.binding.content.ContentModelState(state=1, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=4, element_use=DerivedCRSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'descriptionReference'))),
        pyxb.binding.content.ContentModelTransition(next_state=1, element_use=DerivedCRSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'metaDataProperty'))),
        pyxb.binding.content.ContentModelTransition(next_state=6, element_use=DerivedCRSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'description'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=DerivedCRSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'identifier'))),
    ])
    , 2 : pyxb.binding.content.ContentModelState(state=2, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=8, element_use=DerivedCRSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'scope'))),
        pyxb.binding.content.ContentModelTransition(next_state=3, element_use=DerivedCRSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'remarks'))),
        pyxb.binding.content.ContentModelTransition(next_state=3, element_use=DerivedCRSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'domainOfValidity'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=DerivedCRSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name'))),
    ])
    , 3 : pyxb.binding.content.ContentModelState(state=3, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=8, element_use=DerivedCRSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'scope'))),
        pyxb.binding.content.ContentModelTransition(next_state=3, element_use=DerivedCRSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'domainOfValidity'))),
    ])
    , 4 : pyxb.binding.content.ContentModelState(state=4, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=DerivedCRSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'identifier'))),
    ])
    , 5 : pyxb.binding.content.ContentModelState(state=5, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=7, element_use=DerivedCRSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'baseCRS'))),
    ])
    , 6 : pyxb.binding.content.ContentModelState(state=6, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=4, element_use=DerivedCRSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'descriptionReference'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=DerivedCRSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'identifier'))),
    ])
    , 7 : pyxb.binding.content.ContentModelState(state=7, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=9, element_use=DerivedCRSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'derivedCRSType'))),
    ])
    , 8 : pyxb.binding.content.ContentModelState(state=8, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=8, element_use=DerivedCRSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'scope'))),
        pyxb.binding.content.ContentModelTransition(next_state=5, element_use=DerivedCRSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'conversion'))),
        pyxb.binding.content.ContentModelTransition(next_state=3, element_use=DerivedCRSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'domainOfValidity'))),
    ])
    , 9 : pyxb.binding.content.ContentModelState(state=9, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=10, element_use=DerivedCRSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'coordinateSystem'))),
    ])
    , 10 : pyxb.binding.content.ContentModelState(state=10, is_final=True, transitions=[
    ])
})



ProjectedCRSType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'baseGeodeticCRS'), GeodeticCRSPropertyType, scope=ProjectedCRSType))

ProjectedCRSType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'cartesianCS'), CartesianCSPropertyType, scope=ProjectedCRSType))

ProjectedCRSType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'baseGeographicCRS'), GeographicCRSPropertyType, scope=ProjectedCRSType))
ProjectedCRSType._ContentModel = pyxb.binding.content.ContentModel(state_map = {
      1 : pyxb.binding.content.ContentModelState(state=1, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=4, element_use=ProjectedCRSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'descriptionReference'))),
        pyxb.binding.content.ContentModelTransition(next_state=1, element_use=ProjectedCRSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'metaDataProperty'))),
        pyxb.binding.content.ContentModelTransition(next_state=6, element_use=ProjectedCRSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'description'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=ProjectedCRSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'identifier'))),
    ])
    , 2 : pyxb.binding.content.ContentModelState(state=2, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=7, element_use=ProjectedCRSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'scope'))),
        pyxb.binding.content.ContentModelTransition(next_state=3, element_use=ProjectedCRSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'remarks'))),
        pyxb.binding.content.ContentModelTransition(next_state=3, element_use=ProjectedCRSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'domainOfValidity'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=ProjectedCRSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name'))),
    ])
    , 3 : pyxb.binding.content.ContentModelState(state=3, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=7, element_use=ProjectedCRSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'scope'))),
        pyxb.binding.content.ContentModelTransition(next_state=3, element_use=ProjectedCRSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'domainOfValidity'))),
    ])
    , 4 : pyxb.binding.content.ContentModelState(state=4, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=ProjectedCRSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'identifier'))),
    ])
    , 5 : pyxb.binding.content.ContentModelState(state=5, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=9, element_use=ProjectedCRSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'baseGeodeticCRS'))),
        pyxb.binding.content.ContentModelTransition(next_state=9, element_use=ProjectedCRSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'baseGeographicCRS'))),
    ])
    , 6 : pyxb.binding.content.ContentModelState(state=6, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=4, element_use=ProjectedCRSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'descriptionReference'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=ProjectedCRSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'identifier'))),
    ])
    , 7 : pyxb.binding.content.ContentModelState(state=7, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=7, element_use=ProjectedCRSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'scope'))),
        pyxb.binding.content.ContentModelTransition(next_state=5, element_use=ProjectedCRSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'conversion'))),
        pyxb.binding.content.ContentModelTransition(next_state=3, element_use=ProjectedCRSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'domainOfValidity'))),
    ])
    , 8 : pyxb.binding.content.ContentModelState(state=8, is_final=True, transitions=[
    ])
    , 9 : pyxb.binding.content.ContentModelState(state=9, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=8, element_use=ProjectedCRSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'cartesianCS'))),
    ])
})



TemporalDatumType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'origin'), pyxb.binding.datatypes.dateTime, scope=TemporalDatumType))
TemporalDatumType._ContentModel = pyxb.binding.content.ContentModel(state_map = {
      1 : pyxb.binding.content.ContentModelState(state=1, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=TemporalDatumType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'descriptionReference'))),
        pyxb.binding.content.ContentModelTransition(next_state=1, element_use=TemporalDatumType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'metaDataProperty'))),
        pyxb.binding.content.ContentModelTransition(next_state=8, element_use=TemporalDatumType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'identifier'))),
        pyxb.binding.content.ContentModelTransition(next_state=5, element_use=TemporalDatumType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'description'))),
    ])
    , 2 : pyxb.binding.content.ContentModelState(state=2, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=8, element_use=TemporalDatumType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'identifier'))),
    ])
    , 3 : pyxb.binding.content.ContentModelState(state=3, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=6, element_use=TemporalDatumType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'scope'))),
        pyxb.binding.content.ContentModelTransition(next_state=7, element_use=TemporalDatumType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'domainOfValidity'))),
    ])
    , 4 : pyxb.binding.content.ContentModelState(state=4, is_final=True, transitions=[
    ])
    , 5 : pyxb.binding.content.ContentModelState(state=5, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=TemporalDatumType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'descriptionReference'))),
        pyxb.binding.content.ContentModelTransition(next_state=8, element_use=TemporalDatumType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'identifier'))),
    ])
    , 6 : pyxb.binding.content.ContentModelState(state=6, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=6, element_use=TemporalDatumType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'scope'))),
        pyxb.binding.content.ContentModelTransition(next_state=4, element_use=TemporalDatumType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'origin'))),
    ])
    , 7 : pyxb.binding.content.ContentModelState(state=7, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=6, element_use=TemporalDatumType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'scope'))),
    ])
    , 8 : pyxb.binding.content.ContentModelState(state=8, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=6, element_use=TemporalDatumType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'scope'))),
        pyxb.binding.content.ContentModelTransition(next_state=7, element_use=TemporalDatumType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'domainOfValidity'))),
        pyxb.binding.content.ContentModelTransition(next_state=8, element_use=TemporalDatumType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name'))),
        pyxb.binding.content.ContentModelTransition(next_state=3, element_use=TemporalDatumType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'remarks'))),
    ])
})



TinType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'stopLines'), LineStringSegmentArrayPropertyType, scope=TinType))

TinType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'breakLines'), LineStringSegmentArrayPropertyType, scope=TinType))

TinType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'maxLength'), LengthType, scope=TinType))

TinType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'controlPoint'), _CTD_ANON_21, scope=TinType))
TinType._ContentModel = pyxb.binding.content.ContentModel(state_map = {
      1 : pyxb.binding.content.ContentModelState(state=1, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=3, element_use=TinType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name'))),
        pyxb.binding.content.ContentModelTransition(next_state=4, element_use=TinType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'description'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=TinType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'trianglePatches'))),
        pyxb.binding.content.ContentModelTransition(next_state=6, element_use=TinType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'descriptionReference'))),
        pyxb.binding.content.ContentModelTransition(next_state=1, element_use=TinType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'metaDataProperty'))),
        pyxb.binding.content.ContentModelTransition(next_state=3, element_use=TinType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'identifier'))),
    ])
    , 2 : pyxb.binding.content.ContentModelState(state=2, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=TinType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'stopLines'))),
        pyxb.binding.content.ContentModelTransition(next_state=5, element_use=TinType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'maxLength'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=TinType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'breakLines'))),
    ])
    , 3 : pyxb.binding.content.ContentModelState(state=3, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=TinType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'trianglePatches'))),
        pyxb.binding.content.ContentModelTransition(next_state=3, element_use=TinType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name'))),
    ])
    , 4 : pyxb.binding.content.ContentModelState(state=4, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=6, element_use=TinType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'descriptionReference'))),
        pyxb.binding.content.ContentModelTransition(next_state=3, element_use=TinType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'identifier'))),
        pyxb.binding.content.ContentModelTransition(next_state=3, element_use=TinType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=TinType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'trianglePatches'))),
    ])
    , 5 : pyxb.binding.content.ContentModelState(state=5, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=7, element_use=TinType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'controlPoint'))),
    ])
    , 6 : pyxb.binding.content.ContentModelState(state=6, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=3, element_use=TinType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'identifier'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=TinType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'trianglePatches'))),
        pyxb.binding.content.ContentModelTransition(next_state=3, element_use=TinType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name'))),
    ])
    , 7 : pyxb.binding.content.ContentModelState(state=7, is_final=True, transitions=[
    ])
})



TransformationType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'method'), OperationMethodPropertyType, scope=TransformationType))

TransformationType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'parameterValue'), AbstractGeneralParameterValuePropertyType, scope=TransformationType))
TransformationType._ContentModel = pyxb.binding.content.ContentModel(state_map = {
      1 : pyxb.binding.content.ContentModelState(state=1, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=3, element_use=TransformationType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'descriptionReference'))),
        pyxb.binding.content.ContentModelTransition(next_state=1, element_use=TransformationType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'metaDataProperty'))),
        pyxb.binding.content.ContentModelTransition(next_state=5, element_use=TransformationType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'description'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=TransformationType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'identifier'))),
    ])
    , 2 : pyxb.binding.content.ContentModelState(state=2, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=TransformationType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name'))),
        pyxb.binding.content.ContentModelTransition(next_state=11, element_use=TransformationType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'remarks'))),
        pyxb.binding.content.ContentModelTransition(next_state=4, element_use=TransformationType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'domainOfValidity'))),
        pyxb.binding.content.ContentModelTransition(next_state=10, element_use=TransformationType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'scope'))),
    ])
    , 3 : pyxb.binding.content.ContentModelState(state=3, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=TransformationType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'identifier'))),
    ])
    , 4 : pyxb.binding.content.ContentModelState(state=4, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=10, element_use=TransformationType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'scope'))),
    ])
    , 5 : pyxb.binding.content.ContentModelState(state=5, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=3, element_use=TransformationType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'descriptionReference'))),
        pyxb.binding.content.ContentModelTransition(next_state=2, element_use=TransformationType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'identifier'))),
    ])
    , 6 : pyxb.binding.content.ContentModelState(state=6, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=9, element_use=TransformationType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'targetCRS'))),
    ])
    , 7 : pyxb.binding.content.ContentModelState(state=7, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=6, element_use=TransformationType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'sourceCRS'))),
        pyxb.binding.content.ContentModelTransition(next_state=7, element_use=TransformationType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'coordinateOperationAccuracy'))),
    ])
    , 8 : pyxb.binding.content.ContentModelState(state=8, is_final=True, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=8, element_use=TransformationType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'parameterValue'))),
    ])
    , 9 : pyxb.binding.content.ContentModelState(state=9, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=8, element_use=TransformationType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'method'))),
    ])
    , 10 : pyxb.binding.content.ContentModelState(state=10, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=7, element_use=TransformationType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'operationVersion'))),
        pyxb.binding.content.ContentModelTransition(next_state=10, element_use=TransformationType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'scope'))),
    ])
    , 11 : pyxb.binding.content.ContentModelState(state=11, is_final=False, transitions=[
        pyxb.binding.content.ContentModelTransition(next_state=10, element_use=TransformationType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'scope'))),
        pyxb.binding.content.ContentModelTransition(next_state=4, element_use=TransformationType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'domainOfValidity'))),
    ])
})

AbstractCRS._setSubstitutionGroup(Definition)

AbstractContinuousCoverage._setSubstitutionGroup(AbstractFeature)

AbstractCoordinateOperation._setSubstitutionGroup(Definition)

AbstractCoordinateSystem._setSubstitutionGroup(Definition)

AbstractCoverage._setSubstitutionGroup(AbstractFeature)

AbstractCurve._setSubstitutionGroup(AbstractGeometricPrimitive)

AbstractCurveSegment._setSubstitutionGroup(AbstractObject)

AbstractDatum._setSubstitutionGroup(Definition)

AbstractDiscreteCoverage._setSubstitutionGroup(AbstractCoverage)

AbstractFeature._setSubstitutionGroup(AbstractGML)

AbstractFeatureCollection._setSubstitutionGroup(AbstractFeature)

AbstractGML._setSubstitutionGroup(AbstractObject)

AbstractGeneralConversion._setSubstitutionGroup(AbstractOperation)

AbstractGeneralDerivedCRS._setSubstitutionGroup(AbstractSingleCRS)

AbstractGeneralOperationParameter._setSubstitutionGroup(Definition)

AbstractGeneralParameterValue._setSubstitutionGroup(AbstractObject)

AbstractGeneralTransformation._setSubstitutionGroup(AbstractOperation)

AbstractGeometricAggregate._setSubstitutionGroup(AbstractGeometry)

AbstractGeometricPrimitive._setSubstitutionGroup(AbstractGeometry)

AbstractGeometry._setSubstitutionGroup(AbstractGML)

AbstractGriddedSurface._setSubstitutionGroup(AbstractParametricCurveSurface)

AbstractImplicitGeometry._setSubstitutionGroup(AbstractGeometry)

AbstractMetaData._setSubstitutionGroup(AbstractObject)

AbstractOperation._setSubstitutionGroup(AbstractSingleOperation)

AbstractParametricCurveSurface._setSubstitutionGroup(AbstractSurfacePatch)

AbstractRing._setSubstitutionGroup(AbstractObject)

AbstractScalarValue._setSubstitutionGroup(AbstractValue)

AbstractScalarValueList._setSubstitutionGroup(AbstractValue)

AbstractSingleCRS._setSubstitutionGroup(AbstractCRS)

AbstractSingleOperation._setSubstitutionGroup(AbstractCoordinateOperation)

AbstractSolid._setSubstitutionGroup(AbstractGeometricPrimitive)

AbstractSurface._setSubstitutionGroup(AbstractGeometricPrimitive)

AbstractTimeComplex._setSubstitutionGroup(AbstractTimeObject)

AbstractTimeGeometricPrimitive._setSubstitutionGroup(AbstractTimePrimitive)

AbstractTimeObject._setSubstitutionGroup(AbstractGML)

AbstractTimePrimitive._setSubstitutionGroup(AbstractTimeObject)

AbstractTimeSlice._setSubstitutionGroup(AbstractGML)

AbstractTimeTopologyPrimitive._setSubstitutionGroup(AbstractTimePrimitive)

AbstractTopoPrimitive._setSubstitutionGroup(AbstractTopology)

AbstractTopology._setSubstitutionGroup(AbstractGML)

AbstractValue._setSubstitutionGroup(AbstractObject)

AffineCS._setSubstitutionGroup(AbstractCoordinateSystem)

AffinePlacement._setSubstitutionGroup(AbstractObject)

Arc._setSubstitutionGroup(ArcString)

ArcByBulge._setSubstitutionGroup(ArcStringByBulge)

ArcByCenterPoint._setSubstitutionGroup(AbstractCurveSegment)

ArcString._setSubstitutionGroup(AbstractCurveSegment)

ArcStringByBulge._setSubstitutionGroup(AbstractCurveSegment)

Array._setSubstitutionGroup(AbstractGML)

BSpline._setSubstitutionGroup(AbstractCurveSegment)

Bag._setSubstitutionGroup(AbstractGML)

BaseUnit._setSubstitutionGroup(UnitDefinition)

Bezier._setSubstitutionGroup(BSpline)

Boolean._setSubstitutionGroup(AbstractScalarValue)

BooleanList._setSubstitutionGroup(AbstractScalarValueList)

CartesianCS._setSubstitutionGroup(AbstractCoordinateSystem)

Category._setSubstitutionGroup(AbstractScalarValue)

CategoryExtent._setSubstitutionGroup(AbstractValue)

CategoryList._setSubstitutionGroup(AbstractScalarValueList)

Circle._setSubstitutionGroup(Arc)

CircleByCenterPoint._setSubstitutionGroup(ArcByCenterPoint)

Clothoid._setSubstitutionGroup(AbstractCurveSegment)

CompositeCurve._setSubstitutionGroup(AbstractCurve)

CompositeSolid._setSubstitutionGroup(AbstractSolid)

CompositeSurface._setSubstitutionGroup(AbstractSurface)

CompositeValue._setSubstitutionGroup(AbstractValue)

CompoundCRS._setSubstitutionGroup(AbstractCRS)

ConcatenatedOperation._setSubstitutionGroup(AbstractCoordinateOperation)

Cone._setSubstitutionGroup(AbstractGriddedSurface)

ConventionalUnit._setSubstitutionGroup(UnitDefinition)

Conversion._setSubstitutionGroup(AbstractGeneralConversion)

CoordinateSystemAxis._setSubstitutionGroup(Definition)

Count._setSubstitutionGroup(AbstractScalarValue)

CountExtent._setSubstitutionGroup(AbstractValue)

CountList._setSubstitutionGroup(AbstractScalarValueList)

CoverageMappingRule._setSubstitutionGroup(AbstractObject)

CubicSpline._setSubstitutionGroup(AbstractCurveSegment)

Curve._setSubstitutionGroup(AbstractCurve)

Cylinder._setSubstitutionGroup(AbstractGriddedSurface)

CylindricalCS._setSubstitutionGroup(AbstractCoordinateSystem)

DataBlock._setSubstitutionGroup(AbstractObject)

Definition._setSubstitutionGroup(AbstractGML)

DefinitionCollection._setSubstitutionGroup(Definition)

DefinitionProxy._setSubstitutionGroup(Definition)

DerivedCRS._setSubstitutionGroup(AbstractGeneralDerivedCRS)

DerivedUnit._setSubstitutionGroup(UnitDefinition)

Dictionary._setSubstitutionGroup(Definition)

DirectedObservation._setSubstitutionGroup(Observation)

DirectedObservationAtDistance._setSubstitutionGroup(DirectedObservation)

DynamicFeature._setSubstitutionGroup(AbstractFeature)

DynamicFeatureCollection._setSubstitutionGroup(DynamicFeature)

Edge._setSubstitutionGroup(AbstractTopoPrimitive)

Ellipsoid._setSubstitutionGroup(Definition)

EllipsoidalCS._setSubstitutionGroup(AbstractCoordinateSystem)

EngineeringCRS._setSubstitutionGroup(AbstractSingleCRS)

EngineeringDatum._setSubstitutionGroup(AbstractDatum)

Envelope._setSubstitutionGroup(AbstractObject)

EnvelopeWithTimePeriod._setSubstitutionGroup(Envelope)

Face._setSubstitutionGroup(AbstractTopoPrimitive)

FeatureCollection._setSubstitutionGroup(AbstractFeature)

File._setSubstitutionGroup(AbstractObject)

GenericMetaData._setSubstitutionGroup(AbstractMetaData)

GeocentricCRS._setSubstitutionGroup(AbstractSingleCRS)

Geodesic._setSubstitutionGroup(GeodesicString)

GeodesicString._setSubstitutionGroup(AbstractCurveSegment)

GeodeticCRS._setSubstitutionGroup(AbstractSingleCRS)

GeodeticDatum._setSubstitutionGroup(AbstractDatum)

GeographicCRS._setSubstitutionGroup(AbstractSingleCRS)

GeometricComplex._setSubstitutionGroup(AbstractGeometry)

Grid._setSubstitutionGroup(AbstractImplicitGeometry)

GridCoverage._setSubstitutionGroup(AbstractDiscreteCoverage)

GridFunction._setSubstitutionGroup(AbstractObject)

ImageCRS._setSubstitutionGroup(AbstractSingleCRS)

ImageDatum._setSubstitutionGroup(AbstractDatum)

LineString._setSubstitutionGroup(AbstractCurve)

LineStringSegment._setSubstitutionGroup(AbstractCurveSegment)

LinearCS._setSubstitutionGroup(AbstractCoordinateSystem)

LinearRing._setSubstitutionGroup(AbstractRing)

MovingObjectStatus._setSubstitutionGroup(AbstractTimeSlice)

MultiCurve._setSubstitutionGroup(AbstractGeometricAggregate)

MultiCurveCoverage._setSubstitutionGroup(AbstractDiscreteCoverage)

MultiGeometry._setSubstitutionGroup(AbstractGeometricAggregate)

MultiPoint._setSubstitutionGroup(AbstractGeometricAggregate)

MultiPointCoverage._setSubstitutionGroup(AbstractDiscreteCoverage)

MultiSolid._setSubstitutionGroup(AbstractGeometricAggregate)

MultiSolidCoverage._setSubstitutionGroup(AbstractDiscreteCoverage)

MultiSurface._setSubstitutionGroup(AbstractGeometricAggregate)

MultiSurfaceCoverage._setSubstitutionGroup(AbstractDiscreteCoverage)

Node._setSubstitutionGroup(AbstractTopoPrimitive)

ObliqueCartesianCS._setSubstitutionGroup(AbstractCoordinateSystem)

Observation._setSubstitutionGroup(AbstractFeature)

OffsetCurve._setSubstitutionGroup(AbstractCurveSegment)

OperationMethod._setSubstitutionGroup(Definition)

OperationParameter._setSubstitutionGroup(AbstractGeneralOperationParameter)

OperationParameterGroup._setSubstitutionGroup(AbstractGeneralOperationParameter)

OrientableCurve._setSubstitutionGroup(AbstractCurve)

OrientableSurface._setSubstitutionGroup(AbstractSurface)

ParameterValue._setSubstitutionGroup(AbstractGeneralParameterValue)

ParameterValueGroup._setSubstitutionGroup(AbstractGeneralParameterValue)

PassThroughOperation._setSubstitutionGroup(AbstractSingleOperation)

Point._setSubstitutionGroup(AbstractGeometricPrimitive)

PolarCS._setSubstitutionGroup(AbstractCoordinateSystem)

Polygon._setSubstitutionGroup(AbstractSurface)

PolygonPatch._setSubstitutionGroup(AbstractSurfacePatch)

PolyhedralSurface._setSubstitutionGroup(Surface)

PrimeMeridian._setSubstitutionGroup(Definition)

ProjectedCRS._setSubstitutionGroup(AbstractGeneralDerivedCRS)

Quantity._setSubstitutionGroup(AbstractScalarValue)

QuantityExtent._setSubstitutionGroup(AbstractValue)

QuantityList._setSubstitutionGroup(AbstractScalarValueList)

Rectangle._setSubstitutionGroup(AbstractSurfacePatch)

RectifiedGrid._setSubstitutionGroup(Grid)

RectifiedGridCoverage._setSubstitutionGroup(AbstractDiscreteCoverage)

Ring._setSubstitutionGroup(AbstractRing)

Shell._setSubstitutionGroup(AbstractObject)

Solid._setSubstitutionGroup(AbstractSolid)

Sphere._setSubstitutionGroup(AbstractGriddedSurface)

SphericalCS._setSubstitutionGroup(AbstractCoordinateSystem)

Surface._setSubstitutionGroup(AbstractSurface)

TemporalCRS._setSubstitutionGroup(AbstractSingleCRS)

TemporalCS._setSubstitutionGroup(AbstractCoordinateSystem)

TemporalDatum._setSubstitutionGroup(AbstractDatum)

TimeCS._setSubstitutionGroup(AbstractCoordinateSystem)

TimeCalendar._setSubstitutionGroup(TimeReferenceSystem)

TimeClock._setSubstitutionGroup(TimeReferenceSystem)

TimeCoordinateSystem._setSubstitutionGroup(TimeReferenceSystem)

TimeEdge._setSubstitutionGroup(AbstractTimeTopologyPrimitive)

TimeInstant._setSubstitutionGroup(AbstractTimeGeometricPrimitive)

TimeNode._setSubstitutionGroup(AbstractTimeTopologyPrimitive)

TimeOrdinalReferenceSystem._setSubstitutionGroup(TimeReferenceSystem)

TimePeriod._setSubstitutionGroup(AbstractTimeGeometricPrimitive)

TimeReferenceSystem._setSubstitutionGroup(Definition)

TimeTopologyComplex._setSubstitutionGroup(AbstractTimeComplex)

Tin._setSubstitutionGroup(TriangulatedSurface)

TopoComplex._setSubstitutionGroup(AbstractTopology)

TopoSolid._setSubstitutionGroup(AbstractTopoPrimitive)

Transformation._setSubstitutionGroup(AbstractGeneralTransformation)

Triangle._setSubstitutionGroup(AbstractSurfacePatch)

TriangulatedSurface._setSubstitutionGroup(Surface)

UnitDefinition._setSubstitutionGroup(Definition)

UserDefinedCS._setSubstitutionGroup(AbstractCoordinateSystem)

ValueArray._setSubstitutionGroup(CompositeValue)

VerticalCRS._setSubstitutionGroup(AbstractSingleCRS)

VerticalCS._setSubstitutionGroup(AbstractCoordinateSystem)

VerticalDatum._setSubstitutionGroup(AbstractDatum)

anchorPoint._setSubstitutionGroup(anchorDefinition)

coverageFunction._setSubstitutionGroup(AbstractObject)

definedByConversion._setSubstitutionGroup(conversion)

definitionMember._setSubstitutionGroup(dictionaryEntry)

gridDomain._setSubstitutionGroup(domainSet)

includesSingleCRS._setSubstitutionGroup(componentReferenceSystem)

includesValue._setSubstitutionGroup(parameterValue)

methodFormula._setSubstitutionGroup(formula)

multiCurveDomain._setSubstitutionGroup(domainSet)

multiPointDomain._setSubstitutionGroup(domainSet)

multiSolidDomain._setSubstitutionGroup(domainSet)

multiSurfaceDomain._setSubstitutionGroup(domainSet)

polygonPatches._setSubstitutionGroup(patches)

priorityLocation._setSubstitutionGroup(location)

rectifiedGridDomain._setSubstitutionGroup(domainSet)

subject._setSubstitutionGroup(target)

track._setSubstitutionGroup(history)

trianglePatches._setSubstitutionGroup(patches)

usesAffineCS._setSubstitutionGroup(affineCS)

usesAxis._setSubstitutionGroup(axis)

usesCS._setSubstitutionGroup(coordinateSystem)

usesCartesianCS._setSubstitutionGroup(cartesianCS)

usesEllipsoid._setSubstitutionGroup(ellipsoid)

usesEllipsoidalCS._setSubstitutionGroup(ellipsoidalCS)

usesEngineeringDatum._setSubstitutionGroup(engineeringDatum)

usesGeodeticDatum._setSubstitutionGroup(geodeticDatum)

usesImageDatum._setSubstitutionGroup(imageDatum)

usesMethod._setSubstitutionGroup(method)

usesOperation._setSubstitutionGroup(coordOperation)

usesParameter._setSubstitutionGroup(generalOperationParameter)

usesPrimeMeridian._setSubstitutionGroup(primeMeridian)

usesSingleOperation._setSubstitutionGroup(coordOperation)

usesSphericalCS._setSubstitutionGroup(sphericalCS)

usesTemporalDatum._setSubstitutionGroup(temporalDatum)

usesTimeCS._setSubstitutionGroup(timeCS)

usesValue._setSubstitutionGroup(parameterValue)

usesVerticalCS._setSubstitutionGroup(verticalCS)

usesVerticalDatum._setSubstitutionGroup(verticalDatum)

valueOfParameter._setSubstitutionGroup(operationParameter)

valuesOfGroup._setSubstitutionGroup(group)
