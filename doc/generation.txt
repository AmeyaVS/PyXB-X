This document describes the mapping between XML Schema components and Python
constructs as used in the default binding generation module.

Namespace Issues
================

In XML schema, the namespaces for element declarations, type definitions,
and attribute definitions are all distinct.  Python uses the same namespace
for everything.  So, if you have a schema that defines a simple type
"color", it can also have a complex type "color" with a child element named
"color" that has an attribute "color" with type "color".  Since the natural
representation of elements inside complex types is also by their schema
name, the chances of conflict are high.

PyWXSB resolves this by ensuring every identifiable object has a unique
identifier.  Identifiers are made unique by appending underscores, with a
sequence number if necessary.  See pywxsb.utils.utility.PrepareIdentifier
for details.

In addition to name conflicts directly in the schema, conflicts may also
result from Python keywords and public field or method names in the binding
classes.  The pywxsb.utils.utility._DeconflictSymbols_mixin is used to
refine the set of type-specific public names.  If you customize a generated
binding class by extending from it, you must specific your own class
variable _ReservedSymbols with a value that is the union of your symbols and
those of the superclass(es).

Identifiers are deconflicted in favor of higher items on this list:
* Python keywords
* Public class identifiers
* Element tags
* Complex or simple type definition tags
* Enumeration tags
* Attribute tags
although, of course, enumeration and attribute tags cannot conflict because
they occur in different component types.

Pythonic XML
============

How XML concepts should be represented in Python is a matter of taste.  For
a complex type, I expect to see its member elements as class members.  I
also expect attributes as class members.  As noted in Namespace Issues, this
can create ambiguities and errors since XML views these as different
namespaces.

Personal Python style also comes into play: some might want member variables
to be inspected and mutated only through accessor methods.  The generation
infrastructure permits you to customize this through the assignment of an
InterfaceGenerator instance.  This generator defines the mapping from the
XML name to the internal class variable name, and provides an opportunity to
define inspector and mutator methods.

Simple Types
------------

Simple types are classes which ultimately descend from a Python class, often
a built-in.  The binding classes incorporate the facets which constrain
the value space for the simple type.

The built-in datatypes described in XMLSchema are provided by the
infrastructure in pywxsb.binding.datatypes (or pywxsb.xmlschema.datatypes).

Complex Types
-------------

The binding corresponding to a complex type provides access to XML
attributes and child elements through inspector and mutator functions.  The
names of the Python value attributes are derived from the corresponding
names for elements that can appear within the schema, but may be modified to
be valid Python identifiers that do not conflict with infrastructure
attributes.

Each field name is paired with the XML tag from which its value is obtained.
Furthermore, the field is fixed to be either a single value or a collection,
depending on the model groups within the complex type.  Single value fields
are those for which at most one element with the field tag may appear in a
valid complex type instance.  The value of such a field is either None
(indicating no sub-element was found), or a reference to a binding instance.
Fields that hold sub-elements that might have multiple instances are
represented as lists.



Attributes of Complex Types
~~~~~~~~~~~~~~~~~~~~~~~~~~~

An attribute of a complex type is represented as an instance of the
content.AttributeUse class, and is stored as a private instance variable in
the class used for its owning CTD.  The code generator provides inspector
and mutator methods; the mutator method will validate the new value against
the attribute type.

A complex type definition that supports attribute wildcards does so by
overriding the base class _AttributeWildcard field with an instance of the
content.Wildcard class.  Absence of such an override means that unrecognized
attributes appearing in a DOM node will result in an
UnrecognizedAttributeError exception.  If wildcard attributes are allowed,
they can be accessed through the instance method wildcardAttributes(), which
returns a map from attribute tags to the string value of the attribute from
the DOM model.

When creating values from a DOM instance, the absence of an attribute with
use=requires in the schema will result in a MissingAttributeError.
Instances created through the class constructor are not checked for missing
attributes.  @todo This may change.

Attempts to read or set attributes with use=prohibited in the schema will
result in a ProhibitedAttributeError.  This validation is performed whether
the instance is created using CreateFromDOM or the class constructor.

Each class that allows attributes contains a class variable _AttributeMap
which maps from the **prefix-qualified** attribute name to the corresponding
AttributeUse instances.

Elements In Complex Types
~~~~~~~~~~~~~~~~~~~~~~~~~

Elements are represented, like attributes, as instance fields, nominally
private with public inspectors and mutators.  The field named is derived
from the tag of the schema element declaration.  Where multiple element
declarations have the same tag within a given complex type definition, all
those elements are accessed through the same variable.  The variable is an
instance reference if the maximum number of occurrences of elements with its
tag is one; otherwise it is a list.

The content model for a complex type definition is either a simple type or a
schema particle, which in turn can have element declarations, wildcards, or
model groups as their term.  PyWXSB translates the content model into a
deterministic finite automaton, which is executed at runtime over the child
nodes of the DOM element so that nodes are added to element in the correct
order.

States in the finite automaton are integers, with the value 1 being the
start state.  Edge transitions are made by successfully interpreting a DOM
node as an element instance, or by matching the node against a wildcard.  As
a special case, model groups with compositor "all" are handled as a special
transition, so that the state space does not grow exponentially; see below.

From a given state, the next child node is tested against all element
declarations first, followed by any "all" model groups, followed by wildcard
nodes.  If none of the transitions from the state can be taken, an
UnexpectedContentError is raised.  If, at the point where the child node
list is exhausted, the current state is a final state (has a None transition
to state zero), the content model is satisfied and the element is created.
If not, a MissingContentError is raised.

Handling of Model Groups with compositor "all"
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
The "all" compositor model group represents zero or one instances of a set
of terms, in arbitrary order.  A deterministic finite automaton to recognize
this pattern has 2^n nodes if there are n alternatives.  Some of the schema
PyWXSB must handle include model groups with nine or more alternatives.
Generating and attempting to minimize such a DFA is too time consuming.

For this reason, an "all" model group is represented as a special
transition.  When starting to test against this transition, the content
model interpreter will create a set containing all the alternatives.  It
will then attempt to match the head of the element list against each
alternative in turn.  When an alternative is successfully matched, it is
removed from the candidate list.  Element declaration alternatives are
checked first, followed by additional "all" model groups, followed by
wildcards.  If every remaining alternative has been checked and the head of
the node list does not match, or there are no more child nodes in the list,
processing of the model group is completed.  If any remaining alternative
has a minOccurs of 1, an UnrecognizedContentError or a MissingContentError
is raised, depending on the state of the node list.  Otherwise the optional
alternatives are interpreted as being absent, andthe element reduction
completes.

Content models are represented as maps from integers to ContentTransition
nodes.  A ContentTransition node comprises a term, a reference to an
ElementUse, and an integer value next state.  A term comprises a subclass of
pywxsb.binding.basis.element, an instance of pywxsb.binding.basis.Wildcard,
or an instance of pywxsb.binding.basis.ModelGroupAll.  A ModelGroupAll
instance comprises a set of pairs comprising a DFA that serves as the
content model for a term, and a boolean.  The boolean is true iff the
corresponding original alternative particle has a minOccurs of 1.

A reduction against a basis.element class is successful if an instance of
the class can be created from the DOM element node at the head of the
current child list.  If successful, the ElementUse is used to store it
within the parent element, and the content model interpreter continues at
the successor state.

A reduction against a Wildcard is successful if the wildcare namespace
constraints are met.  If so, the child node is stored in the
wildcardElements list, and the content model interpreter continues at the
successor state.

A reduction against a ModelGroupAll instance is successful following the
algorithm described above.  Execution of this instance results in the
storage of the elements and wildcards generated from the consumed prefix of
the child node list, in the normal course of processing alternative terms.

Representation of Schema Components
===================================

Attribute Declaration
---------------------

Attribute declarations are simply a binding of a name to a type.  They are
not themselves represented, but provide the name for an Attribute Use.

Attribute Use
-------------

See `Complex Type Attributes`_.

Attribute Groups
----------------

Attribute groups do not appear in the bindings.  The set of attribute uses,
and potential wildcards, that they enable are incorporated into the `Complex
Type Attributes`_ infrastructure.


Simple Type Definitions
-----------------------

(The material in this section applies both to SimpleTypeDefinitions and to
ComplexTypeDefinitions with simple content.)

STDs are represented by classes.  Classes are associated with facet
instances.  The classes themselves are either valueless or descend from a
Python built-in type.

Local STDs are assigned a protected-scope name that is unique within their
namespace.

Primitive STDs are the ones in the XMLSchema datatypes list, and are
built-in to PyWXSB.  The structure of a primitive STDs depends on its
variety.

Any facets defined for the given STD are created as class variables using a
name template [option].  The STD also contains a private class variable
__FacetMap which maps from facet classes to instances of that class.  A type
has an entry in the map for a facet class only if the facet is legal to
apply to that type.  Maps for subclasses are copies of the superclass map,
with additional constraints overwriting the parent ones.

Enumeration facets will add class variables corresponding to each
enumeration value.  [option] If a prefix is associated with the enumeration,
the enumeration value will also be promoted to the module (namespace) level,
using the prefix.  Both these options are configurable at the namespace and
named STD levels.

The constructor for an STD will check the resulting value against the
constraints that apply to that STD.  THis may be inconvenient in some cases;
for example, a subtype of NMTOKENS that requires a length of 5 must be
created with an iterable holding five elements; it cannot be built up
piece-by-piece.

Atomic STDs
~~~~~~~~~~~

Atomic simple type definitions inherit from the base type definition, which
is assumed to already have a Python type associated with it from its
primitive type.

List STDs
~~~~~~~~~

A list STD inherits from the datatypes._PST_list class, which combines
_PST_mixin with Python's list type and adds other stuff.  The class
associated with the item type is stored in a class variable _ItemType.

A BadTypeValue is raised when a list STD's constraints are checked and a
member of the list is not an instance of the _ItemType.

Union STDs
~~~~~~~~~~

A union STD does not have data associated with it; rather, it is a class
used to disambiguate the desired member type upon creation from an XML
string.  It inherits from _PST_union only.  Subclasses must include a
variable _MemberTypes which is a tuple of non-union STD classes, in the
order defined by the schema.

The class includes a public Factory class method which converts a string
into the appropriate instance of a member type, by attempting to create a
validated member instance of each member type in turn.

@todo Unions can be constrained by pattern or enumeration facets.

Enumerations
~~~~~~~~~~~~

A key purpose of PyWXSB is to support named constants to represent
enumeration values.  An STD has a class member variable _CF_enumeration if
it has an enumeration restriction.  This variable supports translation
between tag, value, and unicode representations of the enumeration.

The _CF_enumeration variable is an instance of the facets.CF_enumeration
class.  Each instance maintains a set of facets._EnumerationElement
instances which record enumeration values.  Note that because the instance
includes a reference to the class that owns the facet, the definition of the
instance has to follow the class proper.

Complex Type Definitions
------------------------

Complex type definitions are represented by Python classes.
pywxsb.binding.basis.complexTypeDefinition is a base class for all CTDs.
This in turn is subclassed for each of the four content types: empty,
simple, mixed, and element.  The content fields of a CTD are dependent on
its content type.

The base complexTypeDefinition class provides a CreateFromDOM method that is
like Factory but also sets the instance values.  Alternatively, the python
field names can be used as keywords to the class constructor.  DOM values
are validated against the content model; keyword initializers are only
validated against the field type.

CTDs that are defined by extension apply thusly:
* Any attribute or element that matches a corresponding attribute or element
  in the base class is inherited from the base class.
* New attributes and elements are introduced locally.

CTDs that are defined by restriction apply thusly:
* Any attribute or element that appears in the base type is inherited from
  the parent class, but retains a local constraint corresponding to the use
  and occurrence
* Attributes and elements in the base type that are not defined in the local
  type are excluded by defining throwing accessors.

* Any attribute that matches an attribute in the base type is inherited from
  the parent class.  If the attribute is prohibited in the local type,
  accessor methods that throw an exception may be generated.
* An element that matches an element in the base type is inherited from the
  parent class.  Changes in the particle occurence values are stored
  locally.  Note that this means that after initialization from a DOM node
  it may be necessary to convert an element field value from a collection to
  an instance.

class _CTD_mixin:
  _Particle = None
  _AttributeUses = None

Empty Content
~~~~~~~~~~~~~

Simple Content
~~~~~~~~~~~~~~

Simple content CTDs are represented by a Python class that inherits from the
base STD.  Facets are incorporated just as for STDs.  Attributes are
incorporated just as for element content CTDs.

Element Content
~~~~~~~~~~~~~~~

Element content CTDs are represented by a Python class that inherits
ultimately from _PST_CTD_mixin.  If the base type definition for the CTD is
the ur-type, this inheritance is direct; otherwise, the CTD inherits from
the Python class corresponding to its base type.

Mixed Content
~~~~~~~~~~~~~

Ick.  Don't know yet.


Element Declarations
--------------------

Element declarations are represented by classes.  They do not inherit from
the class corresponding to their type definition, primarily because that
type might be a union STD.  Instead, the content is represented as a field,
which is an instance of an STD or CTD class.

The class has a variable _XsdName corresponding to the name property of the
declaration component.  It also has a variable _ElementScope with value None
for global scope, and a reference to a subclass of _CTD_mixin for non-global
scope declarations.

Global scope element declarations are defined at the module level.
Non-global scope element declarations are also so-represented, but the class
name is generated to be unique within the namespace.

Particle
--------

A particle is a ModelGroup, Wildcard, or ElementDeclaration with an
associated cardinality range.  They are not themselves represented as data
objects in the Python bindings.  However, the structural information in them
is retained in the _Particle member of each non-empty CTD, or in class
members for particles internal to a model group.

The binding._Particle class contains minOccurs and maxOccurs and term
fields, just like the XML schema component does.  The term field is a
reference to a Python class that is a subclass of binding._ModelGroup_mixin,
binding._Wildcard, or _binding._ED_mixin.

Model Groups
------------

Model groups represent an all, sequence, or choice among a group of
particles.  They do not hold data objects in the Python bindings, but do
appear as objects to provide a way to parse incoming structures.

A named model group (from a Model Group Definition) has a module-level class
that holds the particles that comprise it.  There is a corresponding
module-level singleton object that is referenced wherever the model group is
needed.

Internal model groups define their particles within the containing CTD.

The binding._ModelGroup class includes the following variables and methods:

compositor -- all, sequence, or choice

particles -- a tuple of binding._Particle instances

reset -- Resets all state associated with an extraction sequence.  The input
should be a DOM node that validates against the model group.

nextMember -- Returns a tuple consisting of a name, a boolean isPlural, and
an instance of a _CTD_mixin [or _Wildcard_mixin] subclass. The containing
infrastructure should associate the instance to the member variable
associated with the name: by assignment if isPlural is false, and by append
if isPlural is true.  The name is None in the case of a _Wildcard_mixin, and
otherwise is the name property of the element declaration that was matched.

The CTD instance that interprets the model group also maintains a list of
the return values from nextMember, so that the original order from the XML
can be obtained.

At some point, the nextMember method should also validate the input.
nextMember should raise a SchemaValidationError exception if an ordering or
content property is violated.

Order of Generation
===================

* Annotation, IdentityConstraintDefinition, NotationDeclaration, and
  Wildcard all have no dependencies
* SimpleTypeDefinition
* AttributeDeclaration depends on SimpleTypeDefinition
* AttributeUse depends on AttributeDeclaration
* AttributeGroupDefinition depends on AttributeUse (but don't exist at
  generation time so nobody cares)
* ComplexTypeDefinition depends on SimpleTypeDefinition and AttributeUse
* ElementDeclaration depends on {Simple,Complex}TypeDefinition
* ModelGroup depends on ElementDeclaration and Wildcard
* ModelGroupDefinition depends on ModelGorup
* Particle depends on ModelGroup, Wildcard, ElementDeclaration


Customization Points
====================

The customization points must be configurable by namespace, since templates
used for one binding may be inappropriate for another, but cross-namespace
inheritance and reference are required.

A template consists of a character sequence in which the value %{name} is
replaced by a component name, and the value %{id} is replaced by a
context-specific non-negative serial number passed to the expansion
function.  For example, classes corresponding to local simple types may use
a template of "_STD_local_%{id}", where the serial number is global to the
namespace.  Classes corresponding to top-level elements may use a template
of "%{name}" while those for top-level types would use a template of
"%{name}_t".

* The mechanism by which element references in a complex type are generated:
  names, inspectors, mutators.

* The mechanism by which attributes in a type are generated: names,
  inspectors, mutators.

* The default enumeration value prefix

* Whether enumeration values are represented by numbers or by strings

* The mapping from STD ncName to enumeration values prefix.

* Whether an enumeration value is made visible at the namespace level.

* The template name for classes that represent named element declarations
* The template pattern for non-global element declaration classes

* The template name for classes that represent named type definitions
* The template pattern for unnamed type definitions

* The template name for classes that represent attribute groups

* The template name for classes that hold model group and particle objects
  for named model groups

* The template name for objects that represent named model groups

* The template pattern for local model group objects
* The template pattern for local particle objects
* The template pattern for local attribute use objects
* The template pattern for local facet objects

Base Classes
============

* xs.datatypes.*
* PyWXSB.binding defines mix-in classes
 - _STD_mixin
 - _CTD_mixin
 - _AG_mixin
 - _Union_mixin

Things To Generate

EnumerationElement:
 - python name : template expansion from tag.  Requires global support when
   used as default value cross-namespace
 - python value : string value, or id expansion.  Local only.
 - string value : literal from value.  Local only.

ConstrainingFacet:
 - python name : template expansion from Name.  Global support when inherited.
 - value : literal from value.  Local only.

TypeDefinition:
 - python type reference: template expansion from ncName and
 targetNamespace.  Optional module + class; or self/cls.


