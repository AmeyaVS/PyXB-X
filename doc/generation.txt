This document describes the mapping between XML Schema components and Python
constructs as used in the default generation module.

Pythonic XML
============

How XML concepts should be represented in Python is a matter of taste.  For
a complex type, I expect to see its member elements as class members.  I
also expect attributes as class members.  As noted in Namespace Issues
below, this can create ambiguities and errors since XML views these as
different namespaces.

Personal Python style also comes into play: some might want member variables
to be inspected and mutated only through accessor methods.  The generation
infrastructure permits you to customize this through the assignment of an
InterfaceGenerator instance.  This generator defines the mapping from the
XML name to the internal class variable name, and provides an opportunity to
define inspector and mutator methods.

name : component -> python identifier
inspect : component -> python identifier or method invocation
mutate : component + python expression -> python statement

Complex Type Field Representation
---------------------------------

The binding corresponding to a complex type provides access to XML
attributes through inspector and mutator functions, and to nested elements
through Python value attributes.  The names of the Python value attributes
are derived from the corresponding names for elements that can appear within
the schema, but may be modified to be valid Python identifiers that do not
conflict with infrastructure attributes.

Each field name is paired with the XML tag from which its value is obtained.
Furthermore, the field is fixed to be either a single value or a collection,
depending on the model groups within the complex type.  Single value fields
are those for which at most one element with the field tag may appear in a
valid complex type instance.  The value of such a field is either None
(indicating no sub-element was found), or a reference to a binding instance.
Fields that hold sub-elements that might have multiple instances are
represented as lists.

Namespace Issues
================

In XML schema, the namespaces for element declarations, type definitions,
and attribute definitions are all distinct.  Python uses the same namespace
for everything.  So, if you have a schema that defines a simple type
"color", you can then have an element named "color" that has an attribute
"color" with type "color".  Since the natural representation of elements
inside complex types is also by their schema name, the chances of conflict
are high.

Representation of Schema Components
===================================

Attribute Declaration
---------------------

Attribute declarations are simply a binding of a name to a type.  They are
not themselves represented, but provide the name for an Attribute Use.

Attribute Use
-------------

An attribute use is represented as an instance variable with accessor
methods in the class used for its owning CTD.  Each class that allows
attributes contains a class variable _AttributeUses which is a list of
instances that provide the name, Python class, and use restrictions for each
attribute.  In the case of classes defined by restriction, the variable
corresponding to the accessor remains in the parent class, but a new
instance is added to the local _AttributeUses list, and new accessors may be
defined to implement an updated use property.

class _AttributeUse:
  name = ncName
  pythonClass = SimpleTypeDefinitionClass (None for inherited uses)
  inheritedUse = _AttributeUse (parent class use reference)
  use = USE_prohibited | USE_required (0 = USE_optional)

Attribute Groups
----------------

An attribute group is represented as a mix-in class that contains a set of
one or more attribute uses, structured in the same way as for
element-content complex type definitions.  The mix-in class inherits from
PyWXSB.binding._AG_mixin.

Simple Type Definitions
-----------------------

(The material in this section applies both to SimpleTypeDefinitions and to
ComplexTypeDefinitions with simple content.)

STDs are represented by classes.  Classes are associated with facet
instances.  The classes themselves are either valueless or descend from a
Python built-in type.

Local STDs are assigned a protected-scope name that is unique within their
namespace.

Primitive STDs are the ones in the XMLSchema datatypes list, and are
built-in to PyWXSB.  The structure of a primitive STDs depends on its
variety.

Any facets defined for the given STD are created as class variables using a
name template [option].  The STD also contains a private class variable
__FacetMap which maps from facet classes to instances of that class.  A type
has an entry in the map for a facet class only if the facet is legal to
apply to that type.  Maps for subclasses are copies of the superclass map,
with additional constraints overwriting the parent ones.

Enumeration facets will add class variables corresponding to each
enumeration value.  [option] If a prefix is associated with the enumeration,
the enumeration value will also be promoted to the module (namespace) level,
using the prefix.  Both these options are configurable at the namespace and
named STD levels.

The constructor for an STD will check the resulting value against the
constraints that apply to that STD.  THis may be inconvenient in some cases;
for example, a subtype of NMTOKENS that requires a length of 5 must be
created with an iterable holding five elements; it cannot be built up
piece-by-piece.

Atomic STDs
~~~~~~~~~~~

Atomic simple type definitions inherit from the base type definition, which
is assumed to already have a Python type associated with it from its
primitive type.

List STDs
~~~~~~~~~

A list STD inherits from the datatypes._PST_list class, which combines
_PST_mixin with Python's list type and adds other stuff.  The class
associated with the item type is stored in a class variable _ItemType.

A BadTypeValue is raised when a list STD's constraints are checked and a
member of the list is not an instance of the _ItemType.

Union STDs
~~~~~~~~~~

A union STD does not have data associated with it; rather, it is a class
used to disambiguate the desired member type upon creation from an XML
string.  It inherits from _PST_union only.  Subclasses must include a
variable _MemberTypes which is a tuple of non-union STD classes, in the
order defined by the schema.

The class includes a public Factory class method which converts a string
into the appropriate instance of a member type, by attempting to create a
validated member instance of each member type in turn.

@todo Unions can be constrained by pattern or enumeration facets.

Enumerations
~~~~~~~~~~~~

A key purpose of PyWXSB is to support named constants to represent
enumeration values.  An STD has a class member variable _CF_enumeration if
it has an enumeration restriction.  This variable supports translation
between tag, value, and unicode representations of the enumeration.

The _CF_enumeration variable is an instance of the facets.CF_enumeration
class.  Each instance maintains a set of facets._EnumerationElement
instances which record enumeration values.  Note that because the instance
includes a reference to the class that owns the facet, the definition of the
instance has to follow the class proper.

Complex Type Definitions
------------------------

Complex type definitions are represented by Python classes.
bindings.PyWXSB_complexTypeDefinition is a base class for all CTDs.  This in
turn is subclassed for each of the four content types: empty, simple, mixed,
and element.  The content fields of a CTD are dependent on its content type.

The base PyWXSB_complexTypeDefinition class provides an InitializeFromDOM
method that walks the class hierarchy to assign attribute values, and the
_Particle hierarchy to extract element values.

CTDs that are defined by extension apply thusly:
* Any attribute or element that matches a corresponding attribute or element
  in the base class is inherited from the base class.
* New attributes and elements are introduced locally.

CTDs that are defined by restriction apply thusly:
* Any attribute or element that appears in the base type is inherited from
  the parent class, but retains a local constraint corresponding to the use
  and occurrence
* Attributes and elements in the base type that are not defined in the local
  type are excluded by defining throwing accessors.

* Any attribute that matches an attribute in the base type is inherited from
  the parent class.  If the attribute is prohibited in the local type,
  accessor methods that throw an exception may be generated.
* An element that matches an element in the base type is inherited from the
  parent class.  Changes in the particle occurence values are stored
  locally.  Note that this means that after initialization from a DOM node
  it may be necessary to convert an element field value from a collection to
  an instance.

class _CTD_mixin:
  _Particle = None
  _AttributeUses = None

Empty Content
~~~~~~~~~~~~~

Simple Content
~~~~~~~~~~~~~~

Simple content CTDs are represented by a Python class that inherits from the
base STD.  Facets are incorporated just as for STDs.  Attributes are
incorporated just as for element content CTDs.

Element Content
~~~~~~~~~~~~~~~

Element content CTDs are represented by a Python class that inherits
ultimately from _PST_CTD_mixin.  If the base type definition for the CTD is
the ur-type, this inheritance is direct; otherwise, the CTD inherits from
the Python class corresponding to its base type.

Mixed Content
~~~~~~~~~~~~~

Ick.  Don't know yet.


Element Declarations
--------------------

Element declarations are represented by classes.  They do not inherit from
the class corresponding to their type definition, primarily because that
type might be a union STD.  Instead, the content is represented as a field,
which is an instance of an STD or CTD class.

The class has a variable _XsdName corresponding to the name property of the
declaration component.  It also has a variable _ElementScope with value None
for global scope, and a reference to a subclass of _CTD_mixin for non-global
scope declarations.

Global scope element declarations are defined at the module level.
Non-global scope element declarations are also so-represented, but the class
name is generated to be unique within the namespace.

Particle
--------

A particle is a ModelGroup, Wildcard, or ElementDeclaration with an
associated cardinality range.  They are not themselves represented as data
objects in the Python bindings.  However, the structural information in them
is retained in the _Particle member of each non-empty CTD, or in class
members for particles internal to a model group.

The binding._Particle class contains minOccurs and maxOccurs and term
fields, just like the XML schema component does.  The term field is a
reference to a Python class that is a subclass of binding._ModelGroup_mixin,
binding._Wildcard, or _binding._ED_mixin.

Model Groups
------------

Model groups represent an all, sequence, or choice among a group of
particles.  They do not hold data objects in the Python bindings, but do
appear as objects to provide a way to parse incoming structures.

A named model group (from a Model Group Definition) has a module-level class
that holds the particles that comprise it.  There is a corresponding
module-level singleton object that is referenced wherever the model group is
needed.

Internal model groups define their particles within the containing CTD.

The binding._ModelGroup class includes the following variables and methods:

compositor -- all, sequence, or choice

particles -- a tuple of binding._Particle instances

reset -- Resets all state associated with an extraction sequence.  The input
should be a DOM node that validates against the model group.

nextMember -- Returns a tuple consisting of a name, a boolean isPlural, and
an instance of a _CTD_mixin [or _Wildcard_mixin] subclass. The containing
infrastructure should associate the instance to the member variable
associated with the name: by assignment if isPlural is false, and by append
if isPlural is true.  The name is None in the case of a _Wildcard_mixin, and
otherwise is the name property of the element declaration that was matched.

The CTD instance that interprets the model group also maintains a list of
the return values from nextMember, so that the original order from the XML
can be obtained.

At some point, the nextMember method should also validate the input.
nextMember should raise a SchemaValidationError exception if an ordering or
content property is violated.

Order of Generation
===================

* Annotation, IdentityConstraintDefinition, NotationDeclaration, and
  Wildcard all have no dependencies
* SimpleTypeDefinition
* AttributeDeclaration depends on SimpleTypeDefinition
* AttributeUse depends on AttributeDeclaration
* AttributeGroupDefinition depends on AttributeUse (but don't exist at
  generation time so nobody cares)
* ComplexTypeDefinition depends on SimpleTypeDefinition and AttributeUse
* ElementDeclaration depends on {Simple,Complex}TypeDefinition
* ModelGroup depends on ElementDeclaration and Wildcard
* ModelGroupDefinition depends on ModelGorup
* Particle depends on ModelGroup, Wildcard, ElementDeclaration


Customization Points
====================

The customization points must be configurable by namespace, since templates
used for one binding may be inappropriate for another, but cross-namespace
inheritance and reference are required.

A template consists of a character sequence in which the value %{name} is
replaced by a component name, and the value %{id} is replaced by a
context-specific non-negative serial number passed to the expansion
function.  For example, classes corresponding to local simple types may use
a template of "_STD_local_%{id}", where the serial number is global to the
namespace.  Classes corresponding to top-level elements may use a template
of "%{name}" while those for top-level types would use a template of
"%{name}_t".

* The mechanism by which element references in a complex type are generated:
  names, inspectors, mutators.

* The mechanism by which attributes in a type are generated: names,
  inspectors, mutators.

* The default enumeration value prefix

* Whether enumeration values are represented by numbers or by strings

* The mapping from STD ncName to enumeration values prefix.

* Whether an enumeration value is made visible at the namespace level.

* The template name for classes that represent named element declarations
* The template pattern for non-global element declaration classes

* The template name for classes that represent named type definitions
* The template pattern for unnamed type definitions

* The template name for classes that represent attribute groups

* The template name for classes that hold model group and particle objects
  for named model groups

* The template name for objects that represent named model groups

* The template pattern for local model group objects
* The template pattern for local particle objects
* The template pattern for local attribute use objects
* The template pattern for local facet objects

Base Classes
============

* xs.datatypes.*
* PyWXSB.binding defines mix-in classes
 - _STD_mixin
 - _CTD_mixin
 - _AG_mixin
 - _Union_mixin

Things To Generate

EnumerationElement:
 - python name : template expansion from tag.  Requires global support when
   used as default value cross-namespace
 - python value : string value, or id expansion.  Local only.
 - string value : literal from value.  Local only.

ConstrainingFacet:
 - python name : template expansion from Name.  Global support when inherited.
 - value : literal from value.  Local only.

TypeDefinition:
 - python type reference: template expansion from ncName and
 targetNamespace.  Optional module + class; or self/cls.


