This document describes the mapping between XML Schema components and Python
constructs as used in the default generation module.

Pythonic XML
============

How XML concepts should be represented in Python is a matter of taste.  For
a complex type, I expect to see its member elements as class members.  I
also expect attributes as class members.  As noted in Namespace Issues
below, this can create ambiguities and errors since XML views these as
different namespaces.

Personal Python style also comes into play: some might want member variables
to be inspected and mutated only through accessor methods.  The generation
infrastructure permits you to customize this through the assignment of an
InterfaceGenerator instance.  This generator defines the mapping from the
XML name to the internal class variable name, and provides an opportunity to
define inspector and mutator methods.

name : component -> python identifier
inspect : component -> python identifier or method invocation
mutate : component + python expression -> python statement

Namespace Issues
================

In XML schema, the namespaces for element declarations, type definitions,
and attribute definitions are all distinct.  Python uses the same namespace
for everything.  So, if you have a schema that defines a simple type
"color", you can then have an element named "color" that has an attribute
"color" with type "color".  Since the natural representation of elements
inside complex types is also by their schema name, the chances of conflict
are high.

Attribute Use
=============

An attribute use is represented as a local variable with accessor methods.
Each class that allows attributes contains a class variable _AttributeUses
which is a list of instances that provide the name, Python class, and use
restrictions for each attribute.  In the case of classes defined by
restriction, the variable corresponding to the accessor remains in the
parent class, but a new instance is added to the local _AttributeUses list,
and new accessors may be defined to implement an updated use property.

class _AttributeUse:
  name = ncName
  pythonClass = SimpleTypeDefinitionClass (None for inherited uses)
  inheritedUse = _AttributeUse (parent class use reference)
  use = USE_prohibited | USE_required (0 = USE_optional)

Attribute Groups
================

An attribute group is represented as a mix-in class that contains a set of
one or more attribute declarations, structured in the same way as for
element-content complex type definitions.  The mix-in class inherits from
PyWXSB.binding._AG_mixin.

Simple Type Definitions
=======================

The material in this section applies both to SimpleTypeDefinitions and to
ComplexTypeDefinitions with simple content.

STDs are represented by classes.  Classes are associated with facet
instances.  The classes themselves are either valueless or descend from a
Python built-in type.

Local STDs are assigned a protected-scope name that is unique within their
namespace.

Primitive STDs are the ones in the XMLSchema datatypes list, and are
built-in to PyWXSB.  The structure of a primitive STDs depends on its
variety.

Any facets defined for the given STD are created as class variables using a
name template [option].  The STD also contains a class variable _Facets
incorporating a list of all facets that affect it; some of these may be in
the STD, and some in superclasses.

class _Facet:
  name = a string
  valueType = a reference to an STD in the XMLSchema datatypes
  fixed = a boolean, or None
  ownerClass = a reference to the STD in which the facet instance is defined

Enumeration facets will add class variables corresponding to each
enumeration value.  [option] The prefix for the class variable corresponding
to an enumeration may be configured at code-generation time.  [option]
Enumeration values may also be made visible in the namespace.  Both these
options are configurable at the namespace and named STD levels.

Atomic STDs
-----------

Atomic simple type definitions inherit from the base type definition, which
is assumed to already have a Python type associated with it from its
primitive type.

List STDs
---------

A list STD inherits from Python's list type.  The class associated with the
item type is stored in a class variable _ItemType.


Union STDs
----------

A union STD does not have data associated with it; rather, it is a class
used to disambiguate the desired member type upon creation from an XML
string.  The class includes a variable _MemberTypes which is a list of
non-union STD classes, in the order defined by the schema.  Union STDs do
not inherit from _STD_mixin; instead they inherit from _Union_mixin.

The class includes a public XsdFromString class method which converts a
string into the appropriate instance of a member type, by attempting to
create a validated member instance of each member type in turn.

Complex Type Definitions
========================

Complex type definitions are represented by Python classes.  The _CTD_mixin
is a base class for all CTDs.

Each CTD includes a class variable _Particle which is None for empty and
simple content, and is an instance of binding._Particle for element and
mixed content.

The base _CTD_mixin class provides an XsdCreateFromDOM method that walks the
class hierarchy to assign attribute values, and the _Particle hierarchy to
extract element values.

CTDs that are defined by extension apply thusly:
* Any attribute or element that matches a corresponding attribute or element
  in the base class is inherited from the base class.
* New attributes and elements are introduced locally.

CTDs that are defined by restriction apply thusly:
* Any attribute or element that appears in the base type is inherited from
  the parent class, but retains a local constraint corresponding to the use
  and occurrence
* Attributes and elements in the base type that are not defined in the local
  type are excluded by defining throwing accessors.

* Any attribute that matches an attribute in the base type is inherited from
  the parent class.  If the attribute is prohibited in the local type,
  accessor methods that throw an exception may be generated.
* An element that matches an element in the base type is inherited from the
  parent class.  Changes in the particle occurence values are stored
  locally.  Note that this means that after initialization from a DOM node
  it may be necessary to convert an element field value from a collection to
  an instance.


Empty Content
-------------

Simple Content
--------------

Simple content CTDs are represented by a Python class that inherits from the
base STD.  Facets are incorporated just as for STDs.  Attributes are
incorporated just as for element content CTDs.

Element Content
---------------

Element content CTDs are represented by a Python class that inherits
ultimately from _PST_CTD_mixin.  If the base type definition for the CTD is
the ur-type, this inheritance is direct; otherwise, the CTD inherits from
the Python class corresponding to its base type.

Mixed Content
-------------

Element Declarations
====================

Element declarations are represented by classes that inherit from
binding._ED_mixin and the class corresponding to the declaration's type
definition.

The class has a variable _ElementName corresponding to the name property of
the declaration component.  It also has a variable _ElementScope with value
None for global scope, and a reference to a subclass of _CTD_mixin for
non-global scope declarations.

Global scope element declarations are defined at the module level.
Non-global scope element declarations are also so-represented, but the class
name is generated to be unique within the namespace.

Particle
========

A particle is a ModelGroup, Wildcard, or ElementDeclaration with an
associated cardinality range.  They are not themselves represented as data
objects in the Python bindings.  However, the structural information in them
is retained in the _Particle member of each non-empty CTD, or in class
members for particles internal to a model group.

The binding._Particle class contains minOccurs and maxOccurs and term
fields, just like the XML schema component does.  The term field is a
reference to a Python class that is a subclass of binding._ModelGroup_mixin,
binding._Wildcard, or _binding._ED_mixin.

Model Groups
============

Model groups represent an all, sequence, or choice among a group of
particles.  They do not hold data objects in the Python bindings, but do
appear as objects to provide a way to parse incoming structures.

A named model group (from a Model Group Definition) has a module-level class
that holds the particles that comprise it.  There is a corresponding
module-level singleton object that is referenced wherever the model group is
needed.

Internal model groups define their particles within the containing CTD.

The binding._ModelGroup class includes the following variables and methods:

compositor -- all, sequence, or choice

particles -- a tuple of binding._Particle instances

reset -- Resets all state associated with an extraction sequence.  The input
should be a DOM node that validates against the model group.

nextMember -- Returns a pair consisting of a name, a boolean isPlural, and
an instance of a _CTD_mixin [or _Wildcard_mixin] subclass. The containing
infrastructure should associate the instance to the member variable
associated with the name: by assignment if isPlural is false, and by append
if isPlural is true.  The name is None in the case of a _Wildcard_mixin, and
otherwise is the name property of the element declaration that was matched.

The CTD instance that interprets the model group also maintains a list of
the return values from nextMember, so that the original order from the XML
can be obtained.

At some point, the nextMember method should also validate the input.
nextMember should raise a SchemaValidationError exception if an ordering or
content property is violated.

Customization Points
====================

The customization points must be configurable by namespace, since templates
used for one binding may be inappropriate for another, but cross-namespace
inheritance and reference are required.

A template consists of a character sequence in which the value %{name} is
replaced by a component name, and the value %{id} is replaced by a
context-specific non-negative serial number passed to the expansion
function.  For example, classes corresponding to local simple types may use
a template of "_STD_local_%{id}", where the serial number is global to the
namespace.  Classes corresponding to top-level elements may use a template
of "%{name}" while those for top-level types would use a template of
"%{name}_t".

* The mechanism by which element references in a complex type are generated:
  names, inspectors, mutators.

* The mechanism by which attributes in a type are generated: names,
  inspectors, mutators.

* The default enumeration value prefix

* Whether enumeration values are represented by numbers or by strings

* The mapping from STD ncName to enumeration values prefix.

* Whether an enumeration value is made visible at the namespace level.

* The template name for classes that represent named element declarations
* The template pattern for non-global element declaration classes

* The template name for classes that represent named type definitions
* The template pattern for unnamed type definitions

* The template name for classes that represent attribute groups

* The template name for classes that hold model group and particle objects
  for named model groups

* The template name for objects that represent named model groups

* The template pattern for local model group objects
* The template pattern for local particle objects
* The template pattern for local attribute use objects
* The template pattern for local facet objects

Base Classes
============

* xs.datatypes.*
* PyWXSB.binding defines mix-in classes
 - _STD_mixin
 - _CTD_mixin
 - _AG_mixin
 - _Union_mixin

Things To Generate

EnumerationElement:
 - python name : template expansion from tag.  Requires global support when
   used as default value cross-namespace
 - python value : string value, or id expansion.  Local only.
 - string value : literal from value.  Local only.

ConstrainingFacet:
 - python name : template expansion from Name.  Global support when inherited.
 - value : literal from value.  Local only.

TypeDefinition:
 - python type reference: template expansion from ncName and
 targetNamespace.  Optional module + class; or self/cls.


