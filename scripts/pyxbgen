#!/usr/bin/env python

import getopt
import sys
import pyxb.xmlschema
from pyxb.binding.generate import GeneratePython, AltGenerate
import os.path

# module path prefix
# schema uri
# prefix to use for schema
# whether generated bindings should be marked as raw
# whether component model should be saved
# map for imported namespaces

module_path = None              # -m
schema_uri = None               # -u
generate_raw_binding = False    # -r
save_component_model = False    # -C
uri_is_wsdl = False             # -W
write_schema_path = None        # -s

options = [
    ('m', 'module-path', True, 'The Python module path for the generated bindings', 'pyxb.standard.bindings.wsdl'),
    ('u', 'schema-uri', True, 'The URI for the schema from which bindings are to be generated', 'http://schemas.xmlsoap.org/wsdl/'),
    ('r', 'generate-raw-binding', False, 'Generate the bindings in a subdirectory "raw" so that customized wrappers can be written', None),
    ('s', 'write-schema-path', True, 'Write the retrieved schema to the path/uri.xsd', 'pyxb/standard/schemas'),
    ('C', 'save-component-model', False, 'Save the XMLSchema component model in a serialized format', None),
    ('W', 'uri-is-wsdl', False, 'The schema-uri refers to a WSDL definition', None)
]
    
short_opt = ''
long_opt = []
for (flag, long_flag, has_arg, description, example) in options:
    if has_arg:
        short_opt += flag + ':'
        long_opt.append('%s=' % (long_flag,))
    else:
        short_opt += flag
        long_opt.append(long_flag)

def usage ():
    global options
    print 'Usage: %s options' % (sys.argv[0],)
    for (flag, long_flag, has_arg, description, example) in options:
        arg = ""
        if has_arg:
            arg = " arg"
        print "  --%s%s\n      %s" % (long_flag, arg, description)
        if example is not None:
            print "      Example: --%s %s" % (long_flag, example)
        if flag is not None:
            print "      Alternative: -%s%s" % (flag, arg)

try:
    (opts, args) = getopt.getopt(sys.argv[1:], short_opt, long_opt)
except getopt.GetoptError:
    usage()
    sys.exit(1)
for (o, a) in opts:
    if o in ('-m', '--module-path'):
        module_path = a
    elif o in ('-u', '--schema-uri'):
        schema_uri = a
    elif o in ('-s', '--write-schema-path'):
        write_schema_path = a
    elif o in ('-r', '--generate-raw-binding'):
        generate_raw_binding = True
    elif o in ('-C', '--save-component-model'):
        save_component_model = True
    elif o in ('-W', '--uri-is-wsdl'):
        uri_is_wsdl = True
    else:
        print 'Unrecognized option %s' % (o,)
        usage()
        sys.exit(1)

if module_path is None:
    print 'Require --module-path'
    sys.exit(1)

if 0 <= module_path.find('.'):
    (module_path_prefix, schema_prefix) = module_path.rsplit('.', 1)
else:
    module_path_prefix = ''
    schema_prefix = module_path

if not schema_prefix:
    print 'Require --schema-prefix'
    sys.exit(1)

module_path_elts = module_path_prefix.split('.')
if not module_path_elts:
    module_path_elts.append('.')
if generate_raw_binding:
    module_path_elts.append('raw')
binding_path = os.path.join(*module_path_elts)
if save_component_model:
    component_model_file = os.path.join(binding_path, '%s.wxs' % (schema_prefix,))
binding_file = os.path.join(binding_path,'%s.py' % (schema_prefix,))

if module_path_prefix:
    module_path_prefix += '.'

import sys
import traceback
from xml.dom import minidom
from xml.dom import Node
import urllib2
     
if schema_uri is None:
    print 'Require --schema-uri'
    sys.exit(1)

schema_reader = None
try:
    schema_reader = open(schema_uri, 'r')
except IOError, e:
    pass
if schema_reader is None:
    try:
        schema_reader = urllib2.urlopen(schema_uri)
    except Exception, e:
        print 'Unable to read schema URI: %s' % (e,)
        sys.exit(1)

schema = schema_reader.read()

if write_schema_path is not None:
    ext = 'xsd'
    if uri_is_wsdl:
        ext = 'wsdl'
    file('%s/%s.%s' % (write_schema_path, schema_prefix, ext), 'w').write(schema)

#print schema

doc = minidom.parseString(schema)
dom = doc.documentElement

if uri_is_wsdl:
    import pyxb.standard.bindings.wsdl as wsdl
    spec = wsdl.definitions.createFromDOM(dom, process_schema=True, wsdl_location=schema_uri)
    wxs = spec.schema()
else:
    wxs = pyxb.xmlschema.schema.CreateFromDOM(dom, schema_location=schema_uri)

tns = wxs.targetNamespace()

# Save binding source first, so name-in-binding is stored in the
# parsed schema file
try:
    #AltGenerate(namespace=tns, module_path_prefix=module_path_prefix)

    tns.setModulePath(module_path)
    resolved_ns = set()

    nslist = set([ wxs.targetNamespace() ])
    while nslist:
        new_nslist = set()
        while nslist:
            ns = nslist.pop()
            if not ns.needsResolution():
                continue
            for ins in ns.referencedNamespaces():
                print '%s imports %s' % (ns.uri(), ins.uri())
                if ins.needsResolution():
                    print 'Adding imported namespace %s' % (ins.uri(),)
                    new_nslist.add(ins)
            print 'Attempting resolution %s' % (ns.uri(),)
            if not ns.resolveDefinitions(allow_unresolved=True):
                print 'Holding incomplete resolution %s' % (ns.uri(),)
                new_nslist.add(ns)
            else:
                resolved_ns.add(ns)
        nslist = new_nslist

    for ns in resolved_ns:
        ns.validateComponentModel()

    print "Imported:\n%s\nEnd of imports" % ("\n".join([ _ins.uri() for _ins in tns.importedNamespaces() ]),)
    print "Identified:"
    for ns in resolved_ns:
        print '%s %s' % (ns.prefix(), ns.uri())
        for ins in ns.importedNamespaces():
            print "\timp %s %s" % (ins.prefix(), ins.uri())
        for ins in ns.referencedNamespaces():
            print "\tref %s %s" % (ins.prefix(), ins.uri())
    print "Sibling:\n%s\nEnd of siblings" % ("\n".join([ str(_ins.uri(),) for _ins in tns.siblingNamespaces() ]),)

    for ins in tns.importedNamespaces():
        if ns.isAbsentNamespace():
            print 'WARNING Unable to save generated bindings for imported %s' % (ns,)
            continue
        if ns.isLoadable():
            print 'NOTE: %s available in pre-load format' % (ns,)
            continue
        if ns.modulePath() is None:
            print 'WARNING: No module path available for imported %s' % (ns,)
            continue
        print 'Need to generate binding for imported %s as %s' % (ns.uri(), ns.modulePath())
        binding_source = GeneratePython(namespace=ins)
        ns.saveToFile('%s/%s.wxs' % (binding_path, ns.modulePath()))
    binding_source = GeneratePython(namespace=tns)
    if binding_source is not None:
        print 'Binding source is %d long to %s' % (len(binding_source), binding_file)
        file(binding_file, "w").write(binding_source)
        print 'Saved binding source to %s' % (binding_file,)
except Exception, e:
    print 'Exception generating bindings to %s: %s' % (binding_file, e)
    traceback.print_exception(*sys.exc_info())
    sys.exit(3)

if save_component_model:
    assert 'typeDefinition' in tns.categories()
    try:
        tns.saveToFile(component_model_file)
        print 'Saved parsed schema to %s URI %s' % (component_model_file, tns.uri())
    except Exception, e:
        print 'Exception saving preprocessed schema to %s: %s' % (component_model_file, e)
        traceback.print_exception(*sys.exc_info())
        try:
            os.unlink(component_model_file)
        except:
            pass
        sys.exit(2)

# LocalVariables:
# mode:python
# End:

