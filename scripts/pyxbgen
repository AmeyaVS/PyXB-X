#!/usr/bin/env python

import pyxb.xmlschema
import pyxb.binding.generate
import pyxb.utils.utility
import pyxb.utils.domutils
import os.path

generator = pyxb.binding.generate.Generator()
parser = generator.optionParser()
parser.add_option('--wsdl-location', metavar='FILE_or_URL',
                  action='append',
                  help=\
'''Generate bindings for the C{types} stanza of the WSDL at this
location.  This option is equivalent to retrieving the WSDL,
extracting the schema part of its C{types} block to a file, and using
that file as a --schema-location.''')

(options, args) = parser.parse_args()

if options.wsdl_location is not None:
    import pyxb.standard.bindings.wsdl as wsdl
    for wsdl_uri in options.wsdl_location:
        wsdl_uri = pyxb.utils.utility.NormalizeLocation(wsdl_uri)
        print 'Retrieving WSDL from %s' % (wsdl_uri,)
        xmlns = pyxb.utils.utility.TextFromURI(wsdl_uri)
        spec = wsdl.definitions.createFromDOM(pyxb.utils.domutils.StringToDOM(xmlns), process_schema=True, wsdl_location=wsdl_uri)
        generator.addSchema(spec.schema())
generator.applyOptionValues(options, args)
print generator.getCommandLineArgs()

generator.resolveExternalSchema()

import sys
import traceback

# Save binding source first, so name-in-binding is stored in the
# parsed schema file
try:
    tns = generator.namespaces().pop()
    modules = generator.bindingModules()
    print 'Python for %s requires %d modules' % (tns, len(modules))

    top_module = None
    path_dirs = set()
    for m in modules:
        m.writeToModuleFile()
        '''
        if isinstance(m, pyxb.binding.generate.NamespaceModule):
            sns = m.namespace()
            if sns == tns:
                top_module = m
        assert m.modulePath() is not None, 'Module %s has no module path' % (m,)
        binding_path_elts = m.modulePath().split('.')

        try:
            print binding_path
            path_dirs.add(binding_path)
            os.makedirs(binding_path)
        except Exception, e:
            #print 'Exception creating directory %s: %s' % (binding_path, e)
            pass
        use_binding_file = os.path.join(binding_path, '%s.py' % (binding_file,))
        if top_module == m:
            component_model_file = os.path.join(binding_path, '%s.wxs' % (binding_file,))
        file(use_binding_file, 'w').write(m.moduleContents())
        print 'Saved binding source to %s' % (use_binding_file,)

    done_path = set()
    for path in path_dirs:
        path_elts = path.split(os.sep)
        for n in range(len(path_elts)):
            sub_path = os.path.join(*path_elts[:1+n])
            if not (sub_path in done_path):
                init_path = os.path.join(sub_path, '__init__.py')
                if not os.path.exists(init_path):
                    file(init_path, 'w')
                    '''

except Exception, e:
    print 'Exception generating bindings: %s' % (e,)
    traceback.print_exception(*sys.exc_info())
    sys.exit(3)

'''
if ns_archive is not None:
    try:
        ns_archive.writeNamespaces(component_model_file)
        print 'Saved parsed schema to %s URI %s' % (component_model_file, tns.uri())
    except Exception, e:
        print 'Exception saving preprocessed schema to %s: %s' % (component_model_file, e)
        traceback.print_exception(*sys.exc_info())
        try:
            os.unlink(component_model_file)
        except:
            pass
        sys.exit(2)
'''
# LocalVariables:
# mode:python
# End:

